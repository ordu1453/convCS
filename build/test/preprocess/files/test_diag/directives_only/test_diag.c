# 0 "test/test_diag.c"
# 0 "<built-in>"
#define __STDC__ 1
# 0 "<built-in>"
#define __STDC_VERSION__ 202311L
# 0 "<built-in>"
#define __STDC_UTF_16__ 1
# 0 "<built-in>"
#define __STDC_UTF_32__ 1
# 0 "<built-in>"
#define __STDC_HOSTED__ 1
# 0 "<built-in>"
#define __STDC_EMBED_NOT_FOUND__ 0
# 0 "<built-in>"
#define __STDC_EMBED_FOUND__ 1
# 0 "<built-in>"
#define __STDC_EMBED_EMPTY__ 2
# 0 "<built-in>"
#define __GNUC__ 15
# 0 "<built-in>"
#define __GNUC_MINOR__ 2
# 0 "<built-in>"
#define __GNUC_PATCHLEVEL__ 0
# 0 "<built-in>"
#define __VERSION__ "15.2.0"
# 0 "<built-in>"
#define __ATOMIC_RELAXED 0
# 0 "<built-in>"
#define __ATOMIC_SEQ_CST 5
# 0 "<built-in>"
#define __ATOMIC_ACQUIRE 2
# 0 "<built-in>"
#define __ATOMIC_RELEASE 3
# 0 "<built-in>"
#define __ATOMIC_ACQ_REL 4
# 0 "<built-in>"
#define __ATOMIC_CONSUME 1
# 0 "<built-in>"
#define __pic__ 1
# 0 "<built-in>"
#define __PIC__ 1
# 0 "<built-in>"
#define __FINITE_MATH_ONLY__ 0
# 0 "<built-in>"
#define __SIZEOF_INT__ 4
# 0 "<built-in>"
#define __SIZEOF_LONG__ 4
# 0 "<built-in>"
#define __SIZEOF_LONG_LONG__ 8
# 0 "<built-in>"
#define __SIZEOF_SHORT__ 2
# 0 "<built-in>"
#define __SIZEOF_FLOAT__ 4
# 0 "<built-in>"
#define __SIZEOF_DOUBLE__ 8
# 0 "<built-in>"
#define __SIZEOF_LONG_DOUBLE__ 16
# 0 "<built-in>"
#define __SIZEOF_SIZE_T__ 8
# 0 "<built-in>"
#define __CHAR_BIT__ 8
# 0 "<built-in>"
#define __BIGGEST_ALIGNMENT__ 16
# 0 "<built-in>"
#define __ORDER_LITTLE_ENDIAN__ 1234
# 0 "<built-in>"
#define __ORDER_BIG_ENDIAN__ 4321
# 0 "<built-in>"
#define __ORDER_PDP_ENDIAN__ 3412
# 0 "<built-in>"
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
# 0 "<built-in>"
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
# 0 "<built-in>"
#define __SIZEOF_POINTER__ 8
# 0 "<built-in>"
#define __GNUC_EXECUTION_CHARSET_NAME "UTF-8"
# 0 "<built-in>"
#define __GNUC_WIDE_EXECUTION_CHARSET_NAME "UTF-16LE"
# 0 "<built-in>"
#define __SIZE_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __PTRDIFF_TYPE__ long long int
# 0 "<built-in>"
#define __WCHAR_TYPE__ short unsigned int
# 0 "<built-in>"
#define __WINT_TYPE__ short unsigned int
# 0 "<built-in>"
#define __INTMAX_TYPE__ long long int
# 0 "<built-in>"
#define __UINTMAX_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __CHAR8_TYPE__ unsigned char
# 0 "<built-in>"
#define __CHAR16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __CHAR32_TYPE__ unsigned int
# 0 "<built-in>"
#define __SIG_ATOMIC_TYPE__ int
# 0 "<built-in>"
#define __INT8_TYPE__ signed char
# 0 "<built-in>"
#define __INT16_TYPE__ short int
# 0 "<built-in>"
#define __INT32_TYPE__ int
# 0 "<built-in>"
#define __INT64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INT_LEAST8_TYPE__ signed char
# 0 "<built-in>"
#define __INT_LEAST16_TYPE__ short int
# 0 "<built-in>"
#define __INT_LEAST32_TYPE__ int
# 0 "<built-in>"
#define __INT_LEAST64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT_LEAST8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT_LEAST16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT_LEAST32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT_LEAST64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INT_FAST8_TYPE__ signed char
# 0 "<built-in>"
#define __INT_FAST16_TYPE__ short int
# 0 "<built-in>"
#define __INT_FAST32_TYPE__ int
# 0 "<built-in>"
#define __INT_FAST64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT_FAST8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT_FAST16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT_FAST32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT_FAST64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INTPTR_TYPE__ long long int
# 0 "<built-in>"
#define __UINTPTR_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __GXX_ABI_VERSION 1020
# 0 "<built-in>"
#define __SCHAR_MAX__ 0x7f
# 0 "<built-in>"
#define __SHRT_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __LONG_MAX__ 0x7fffffffL
# 0 "<built-in>"
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __WCHAR_MAX__ 0xffff
# 0 "<built-in>"
#define __WCHAR_MIN__ 0
# 0 "<built-in>"
#define __WINT_MAX__ 0xffff
# 0 "<built-in>"
#define __WINT_MIN__ 0
# 0 "<built-in>"
#define __PTRDIFF_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __SIZE_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __SCHAR_WIDTH__ 8
# 0 "<built-in>"
#define __SHRT_WIDTH__ 16
# 0 "<built-in>"
#define __INT_WIDTH__ 32
# 0 "<built-in>"
#define __LONG_WIDTH__ 32
# 0 "<built-in>"
#define __LONG_LONG_WIDTH__ 64
# 0 "<built-in>"
#define __WCHAR_WIDTH__ 16
# 0 "<built-in>"
#define __WINT_WIDTH__ 16
# 0 "<built-in>"
#define __PTRDIFF_WIDTH__ 64
# 0 "<built-in>"
#define __SIZE_WIDTH__ 64
# 0 "<built-in>"
#define __BITINT_MAXWIDTH__ 65535
# 0 "<built-in>"
#define __INTMAX_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INTMAX_C(c) c ## LL
# 0 "<built-in>"
#define __UINTMAX_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __UINTMAX_C(c) c ## ULL
# 0 "<built-in>"
#define __INTMAX_WIDTH__ 64
# 0 "<built-in>"
#define __SIG_ATOMIC_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
# 0 "<built-in>"
#define __SIG_ATOMIC_WIDTH__ 32
# 0 "<built-in>"
#define __INT8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __UINT8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __INT_LEAST8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT8_C(c) c
# 0 "<built-in>"
#define __INT_LEAST8_WIDTH__ 8
# 0 "<built-in>"
#define __INT_LEAST16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT16_C(c) c
# 0 "<built-in>"
#define __INT_LEAST16_WIDTH__ 16
# 0 "<built-in>"
#define __INT_LEAST32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT32_C(c) c
# 0 "<built-in>"
#define __INT_LEAST32_WIDTH__ 32
# 0 "<built-in>"
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INT64_C(c) c ## LL
# 0 "<built-in>"
#define __INT_LEAST64_WIDTH__ 64
# 0 "<built-in>"
#define __UINT_LEAST8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT8_C(c) c
# 0 "<built-in>"
#define __UINT_LEAST16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT16_C(c) c
# 0 "<built-in>"
#define __UINT_LEAST32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT32_C(c) c ## U
# 0 "<built-in>"
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __UINT64_C(c) c ## ULL
# 0 "<built-in>"
#define __INT_FAST8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT_FAST8_WIDTH__ 8
# 0 "<built-in>"
#define __INT_FAST16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT_FAST16_WIDTH__ 16
# 0 "<built-in>"
#define __INT_FAST32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT_FAST32_WIDTH__ 32
# 0 "<built-in>"
#define __INT_FAST64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INT_FAST64_WIDTH__ 64
# 0 "<built-in>"
#define __UINT_FAST8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT_FAST16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT_FAST32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT_FAST64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __INTPTR_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INTPTR_WIDTH__ 64
# 0 "<built-in>"
#define __UINTPTR_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __GCC_IEC_559 2
# 0 "<built-in>"
#define __GCC_IEC_559_COMPLEX 2
# 0 "<built-in>"
#define __FLT_EVAL_METHOD__ 0
# 0 "<built-in>"
#define __FLT_EVAL_METHOD_TS_18661_3__ 0
# 0 "<built-in>"
#define __DEC_EVAL_METHOD__ 2
# 0 "<built-in>"
#define __FLT_RADIX__ 2
# 0 "<built-in>"
#define __FLT_MANT_DIG__ 24
# 0 "<built-in>"
#define __FLT_DIG__ 6
# 0 "<built-in>"
#define __FLT_MIN_EXP__ (-125)
# 0 "<built-in>"
#define __FLT_MIN_10_EXP__ (-37)
# 0 "<built-in>"
#define __FLT_MAX_EXP__ 128
# 0 "<built-in>"
#define __FLT_MAX_10_EXP__ 38
# 0 "<built-in>"
#define __FLT_DECIMAL_DIG__ 9
# 0 "<built-in>"
#define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F
# 0 "<built-in>"
#define __FLT_NORM_MAX__ 3.40282346638528859811704183484516925e+38F
# 0 "<built-in>"
#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
# 0 "<built-in>"
#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
# 0 "<built-in>"
#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
# 0 "<built-in>"
#define __FLT_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __DBL_MANT_DIG__ 53
# 0 "<built-in>"
#define __DBL_DIG__ 15
# 0 "<built-in>"
#define __DBL_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __DBL_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __DBL_MAX_EXP__ 1024
# 0 "<built-in>"
#define __DBL_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __DBL_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __DBL_MAX__ ((double)1.79769313486231570814527423731704357e+308L)
# 0 "<built-in>"
#define __DBL_NORM_MAX__ ((double)1.79769313486231570814527423731704357e+308L)
# 0 "<built-in>"
#define __DBL_MIN__ ((double)2.22507385850720138309023271733240406e-308L)
# 0 "<built-in>"
#define __DBL_EPSILON__ ((double)2.22044604925031308084726333618164062e-16L)
# 0 "<built-in>"
#define __DBL_DENORM_MIN__ ((double)4.94065645841246544176568792868221372e-324L)
# 0 "<built-in>"
#define __DBL_HAS_DENORM__ 1
# 0 "<built-in>"
#define __DBL_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __DBL_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __DBL_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __LDBL_MANT_DIG__ 64
# 0 "<built-in>"
#define __LDBL_DIG__ 18
# 0 "<built-in>"
#define __LDBL_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __LDBL_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __LDBL_MAX_EXP__ 16384
# 0 "<built-in>"
#define __LDBL_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __DECIMAL_DIG__ 21
# 0 "<built-in>"
#define __LDBL_DECIMAL_DIG__ 21
# 0 "<built-in>"
#define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L
# 0 "<built-in>"
#define __LDBL_NORM_MAX__ 1.18973149535723176502126385303097021e+4932L
# 0 "<built-in>"
#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
# 0 "<built-in>"
#define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L
# 0 "<built-in>"
#define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L
# 0 "<built-in>"
#define __LDBL_HAS_DENORM__ 1
# 0 "<built-in>"
#define __LDBL_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __LDBL_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __LDBL_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __FLT16_MANT_DIG__ 11
# 0 "<built-in>"
#define __FLT16_DIG__ 3
# 0 "<built-in>"
#define __FLT16_MIN_EXP__ (-13)
# 0 "<built-in>"
#define __FLT16_MIN_10_EXP__ (-4)
# 0 "<built-in>"
#define __FLT16_MAX_EXP__ 16
# 0 "<built-in>"
#define __FLT16_MAX_10_EXP__ 4
# 0 "<built-in>"
#define __FLT16_DECIMAL_DIG__ 5
# 0 "<built-in>"
#define __FLT16_MAX__ 6.55040000000000000000000000000000000e+4F16
# 0 "<built-in>"
#define __FLT16_NORM_MAX__ 6.55040000000000000000000000000000000e+4F16
# 0 "<built-in>"
#define __FLT16_MIN__ 6.10351562500000000000000000000000000e-5F16
# 0 "<built-in>"
#define __FLT16_EPSILON__ 9.76562500000000000000000000000000000e-4F16
# 0 "<built-in>"
#define __FLT16_DENORM_MIN__ 5.96046447753906250000000000000000000e-8F16
# 0 "<built-in>"
#define __FLT16_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT16_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT16_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT16_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __FLT32_MANT_DIG__ 24
# 0 "<built-in>"
#define __FLT32_DIG__ 6
# 0 "<built-in>"
#define __FLT32_MIN_EXP__ (-125)
# 0 "<built-in>"
#define __FLT32_MIN_10_EXP__ (-37)
# 0 "<built-in>"
#define __FLT32_MAX_EXP__ 128
# 0 "<built-in>"
#define __FLT32_MAX_10_EXP__ 38
# 0 "<built-in>"
#define __FLT32_DECIMAL_DIG__ 9
# 0 "<built-in>"
#define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32
# 0 "<built-in>"
#define __FLT32_NORM_MAX__ 3.40282346638528859811704183484516925e+38F32
# 0 "<built-in>"
#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
# 0 "<built-in>"
#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
# 0 "<built-in>"
#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
# 0 "<built-in>"
#define __FLT32_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT32_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT32_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT32_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __FLT64_MANT_DIG__ 53
# 0 "<built-in>"
#define __FLT64_DIG__ 15
# 0 "<built-in>"
#define __FLT64_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __FLT64_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __FLT64_MAX_EXP__ 1024
# 0 "<built-in>"
#define __FLT64_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __FLT64_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64
# 0 "<built-in>"
#define __FLT64_NORM_MAX__ 1.79769313486231570814527423731704357e+308F64
# 0 "<built-in>"
#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
# 0 "<built-in>"
#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
# 0 "<built-in>"
#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
# 0 "<built-in>"
#define __FLT64_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT64_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT64_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT64_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __FLT128_MANT_DIG__ 113
# 0 "<built-in>"
#define __FLT128_DIG__ 33
# 0 "<built-in>"
#define __FLT128_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __FLT128_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __FLT128_MAX_EXP__ 16384
# 0 "<built-in>"
#define __FLT128_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __FLT128_DECIMAL_DIG__ 36
# 0 "<built-in>"
#define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128
# 0 "<built-in>"
#define __FLT128_NORM_MAX__ 1.18973149535723176508575932662800702e+4932F128
# 0 "<built-in>"
#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
# 0 "<built-in>"
#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
# 0 "<built-in>"
#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
# 0 "<built-in>"
#define __FLT128_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT128_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT128_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT128_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __FLT32X_MANT_DIG__ 53
# 0 "<built-in>"
#define __FLT32X_DIG__ 15
# 0 "<built-in>"
#define __FLT32X_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __FLT32X_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __FLT32X_MAX_EXP__ 1024
# 0 "<built-in>"
#define __FLT32X_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __FLT32X_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x
# 0 "<built-in>"
#define __FLT32X_NORM_MAX__ 1.79769313486231570814527423731704357e+308F32x
# 0 "<built-in>"
#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
# 0 "<built-in>"
#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
# 0 "<built-in>"
#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
# 0 "<built-in>"
#define __FLT32X_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT32X_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT32X_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT32X_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __FLT64X_MANT_DIG__ 64
# 0 "<built-in>"
#define __FLT64X_DIG__ 18
# 0 "<built-in>"
#define __FLT64X_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __FLT64X_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __FLT64X_MAX_EXP__ 16384
# 0 "<built-in>"
#define __FLT64X_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __FLT64X_DECIMAL_DIG__ 21
# 0 "<built-in>"
#define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x
# 0 "<built-in>"
#define __FLT64X_NORM_MAX__ 1.18973149535723176502126385303097021e+4932F64x
# 0 "<built-in>"
#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
# 0 "<built-in>"
#define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x
# 0 "<built-in>"
#define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x
# 0 "<built-in>"
#define __FLT64X_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT64X_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT64X_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT64X_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __BFLT16_MANT_DIG__ 8
# 0 "<built-in>"
#define __BFLT16_DIG__ 2
# 0 "<built-in>"
#define __BFLT16_MIN_EXP__ (-125)
# 0 "<built-in>"
#define __BFLT16_MIN_10_EXP__ (-37)
# 0 "<built-in>"
#define __BFLT16_MAX_EXP__ 128
# 0 "<built-in>"
#define __BFLT16_MAX_10_EXP__ 38
# 0 "<built-in>"
#define __BFLT16_DECIMAL_DIG__ 4
# 0 "<built-in>"
#define __BFLT16_MAX__ 3.38953138925153547590470800371487867e+38BF16
# 0 "<built-in>"
#define __BFLT16_NORM_MAX__ 3.38953138925153547590470800371487867e+38BF16
# 0 "<built-in>"
#define __BFLT16_MIN__ 1.17549435082228750796873653722224568e-38BF16
# 0 "<built-in>"
#define __BFLT16_EPSILON__ 7.81250000000000000000000000000000000e-3BF16
# 0 "<built-in>"
#define __BFLT16_DENORM_MIN__ 9.18354961579912115600575419704879436e-41BF16
# 0 "<built-in>"
#define __BFLT16_HAS_DENORM__ 1
# 0 "<built-in>"
#define __BFLT16_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __BFLT16_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __BFLT16_IS_IEC_60559__ 0
# 0 "<built-in>"
#define __DEC32_MANT_DIG__ 7
# 0 "<built-in>"
#define __DEC32_MIN_EXP__ (-94)
# 0 "<built-in>"
#define __DEC32_MAX_EXP__ 97
# 0 "<built-in>"
#define __DEC32_MIN__ 1E-95DF
# 0 "<built-in>"
#define __DEC32_MAX__ 9.999999E96DF
# 0 "<built-in>"
#define __DEC32_EPSILON__ 1E-6DF
# 0 "<built-in>"
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
# 0 "<built-in>"
#define __DEC64_MANT_DIG__ 16
# 0 "<built-in>"
#define __DEC64_MIN_EXP__ (-382)
# 0 "<built-in>"
#define __DEC64_MAX_EXP__ 385
# 0 "<built-in>"
#define __DEC64_MIN__ 1E-383DD
# 0 "<built-in>"
#define __DEC64_MAX__ 9.999999999999999E384DD
# 0 "<built-in>"
#define __DEC64_EPSILON__ 1E-15DD
# 0 "<built-in>"
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
# 0 "<built-in>"
#define __DEC128_MANT_DIG__ 34
# 0 "<built-in>"
#define __DEC128_MIN_EXP__ (-6142)
# 0 "<built-in>"
#define __DEC128_MAX_EXP__ 6145
# 0 "<built-in>"
#define __DEC128_MIN__ 1E-6143DL
# 0 "<built-in>"
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
# 0 "<built-in>"
#define __DEC128_EPSILON__ 1E-33DL
# 0 "<built-in>"
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
# 0 "<built-in>"
#define __DEC64X_MANT_DIG__ 34
# 0 "<built-in>"
#define __DEC64X_MIN_EXP__ (-6142)
# 0 "<built-in>"
#define __DEC64X_MAX_EXP__ 6145
# 0 "<built-in>"
#define __DEC64X_MIN__ 1E-6143D64x
# 0 "<built-in>"
#define __DEC64X_MAX__ 9.999999999999999999999999999999999E6144D64x
# 0 "<built-in>"
#define __DEC64X_EPSILON__ 1E-33D64x
# 0 "<built-in>"
#define __DEC64X_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143D64x
# 0 "<built-in>"
#define __REGISTER_PREFIX__ 
# 0 "<built-in>"
#define __USER_LABEL_PREFIX__ 
# 0 "<built-in>"
#define __GNUC_STDC_INLINE__ 1
# 0 "<built-in>"
#define __NO_INLINE__ 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 1
# 0 "<built-in>"
#define __GCC_ATOMIC_BOOL_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR8_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_SHORT_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_INT_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_LLONG_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
# 0 "<built-in>"
#define __GCC_DESTRUCTIVE_SIZE 64
# 0 "<built-in>"
#define __GCC_CONSTRUCTIVE_SIZE 64
# 0 "<built-in>"
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
# 0 "<built-in>"
#define __HAVE_SPECULATION_SAFE_VALUE 1
# 0 "<built-in>"
#define __PRAGMA_REDEFINE_EXTNAME 1
# 0 "<built-in>"
#define __SIZEOF_INT128__ 16
# 0 "<built-in>"
#define __SIZEOF_WCHAR_T__ 2
# 0 "<built-in>"
#define __SIZEOF_WINT_T__ 2
# 0 "<built-in>"
#define __SIZEOF_PTRDIFF_T__ 8
# 0 "<built-in>"
#define __amd64 1
# 0 "<built-in>"
#define __amd64__ 1
# 0 "<built-in>"
#define __x86_64 1
# 0 "<built-in>"
#define __x86_64__ 1
# 0 "<built-in>"
#define __SIZEOF_FLOAT80__ 16
# 0 "<built-in>"
#define __SIZEOF_FLOAT128__ 16
# 0 "<built-in>"
#define __ATOMIC_HLE_ACQUIRE 65536
# 0 "<built-in>"
#define __ATOMIC_HLE_RELEASE 131072
# 0 "<built-in>"
#define __GCC_ASM_FLAG_OUTPUTS__ 1
# 0 "<built-in>"
#define __nocona 1
# 0 "<built-in>"
#define __nocona__ 1
# 0 "<built-in>"
#define __tune_core2__ 1
# 0 "<built-in>"
#define __code_model_medium__ 1
# 0 "<built-in>"
#define __MMX__ 1
# 0 "<built-in>"
#define __SSE__ 1
# 0 "<built-in>"
#define __SSE2__ 1
# 0 "<built-in>"
#define __SSE3__ 1
# 0 "<built-in>"
#define __FXSR__ 1
# 0 "<built-in>"
#define __SSE_MATH__ 1
# 0 "<built-in>"
#define __SSE2_MATH__ 1
# 0 "<built-in>"
#define __MMX_WITH_SSE__ 1
# 0 "<built-in>"
#define __SEG_FS 1
# 0 "<built-in>"
#define __SEG_GS 1
# 0 "<built-in>"
#define __SEH__ 1
# 0 "<built-in>"
#define __stdcall __attribute__((__stdcall__))
# 0 "<built-in>"
#define __fastcall __attribute__((__fastcall__))
# 0 "<built-in>"
#define __thiscall __attribute__((__thiscall__))
# 0 "<built-in>"
#define __cdecl __attribute__((__cdecl__))
# 0 "<built-in>"
#define _stdcall __attribute__((__stdcall__))
# 0 "<built-in>"
#define _fastcall __attribute__((__fastcall__))
# 0 "<built-in>"
#define _thiscall __attribute__((__thiscall__))
# 0 "<built-in>"
#define _cdecl __attribute__((__cdecl__))
# 0 "<built-in>"
#define __GXX_MERGED_TYPEINFO_NAMES 0
# 0 "<built-in>"
#define __GXX_TYPEINFO_EQUALITY_INLINE 0
# 0 "<built-in>"
#define __MSVCRT__ 1
# 0 "<built-in>"
#define __MINGW32__ 1
# 0 "<built-in>"
#define _WIN32 1
# 0 "<built-in>"
#define __WIN32 1
# 0 "<built-in>"
#define __WIN32__ 1
# 0 "<built-in>"
#define WIN32 1
# 0 "<built-in>"
#define __WINNT 1
# 0 "<built-in>"
#define __WINNT__ 1
# 0 "<built-in>"
#define WINNT 1
# 0 "<built-in>"
#define _INTEGRAL_MAX_BITS 64
# 0 "<built-in>"
#define __MINGW64__ 1
# 0 "<built-in>"
#define __WIN64 1
# 0 "<built-in>"
#define __WIN64__ 1
# 0 "<built-in>"
#define WIN64 1
# 0 "<built-in>"
#define _WIN64 1
# 0 "<built-in>"
#define __USING_POSIXTHREAD__ 1
# 0 "<built-in>"
#define __declspec(x) __attribute__((x))
# 0 "<built-in>"
#define __DECIMAL_BID_FORMAT__ 1
# 0 "<command-line>"
#define _REENTRANT 1
# 0 "<command-line>"
#define TEST_UNITY 1
# 0 "<command-line>"
#define STM32G473xx 1
# 0 "<command-line>"
#define USE_HAL_DRIVER 1
# 0 "<command-line>"
#define GNU_COMPILER 1
# 1 "test/test_diag.c"



# 1 "build/vendor/unity/src/unity.h" 1
/* =========================================================================
    Unity - A Test Framework for C
    ThrowTheSwitch.org
    Copyright (c) 2007-25 Mike Karlesky, Mark VanderVoord, & Greg Williams
    SPDX-License-Identifier: MIT
========================================================================= */


#define UNITY_FRAMEWORK_H 
#define UNITY 

#define UNITY_VERSION_MAJOR 2
#define UNITY_VERSION_MINOR 6
#define UNITY_VERSION_BUILD 1
#define UNITY_VERSION ((UNITY_VERSION_MAJOR << 16) | (UNITY_VERSION_MINOR << 8) | UNITY_VERSION_BUILD)






# 1 "build/vendor/unity/src/unity_internals.h" 1
/* =========================================================================
    Unity - A Test Framework for C
    ThrowTheSwitch.org
    Copyright (c) 2007-25 Mike Karlesky, Mark VanderVoord, & Greg Williams
    SPDX-License-Identifier: MIT
========================================================================= */


#define UNITY_INTERNALS_H 






# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/setjmp.h" 1 3
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */

#define _INC_SETJMP 

# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 1 3
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */


#define _INC_CRTDEFS 

# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/corecrt.h" 1 3
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */


#define _INC_CORECRT 

# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 1 3
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */


#define _INC__MINGW_H 

# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 1 3
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */


#define _INC_CRTDEFS_MACRO 

#define __MINGW64_PASTE2(x,y) x ## y
#define __MINGW64_PASTE(x,y) __MINGW64_PASTE2(x, y)

#define __STRINGIFY(x) #x
#define __MINGW64_STRINGIFY(x) __STRINGIFY(x)


#define __MINGW64_VERSION_MAJOR 13
#define __MINGW64_VERSION_MINOR 0
#define __MINGW64_VERSION_BUGFIX 0

/* This macro holds an monotonic increasing value, which indicates
   a specific fix/patch is present on trunk.  This value isn't related to
   minor/major version-macros.  It is increased on demand, if a big
   fix was applied to trunk.  This macro gets just increased on trunk.  For
   other branches its value won't be modified.  */

#define __MINGW64_VERSION_RC 0

#define __MINGW64_VERSION_STR __MINGW64_STRINGIFY(__MINGW64_VERSION_MAJOR) "." __MINGW64_STRINGIFY(__MINGW64_VERSION_MINOR) "." __MINGW64_STRINGIFY(__MINGW64_VERSION_BUGFIX)






#define __MINGW64_VERSION_STATE "alpha"

/* mingw.org's version macros: these make gcc to define
   MINGW32_SUPPORTS_MT_EH and to use the _CRT_MT global
   and the __mingwthr_key_dtor() function from the MinGW
   CRT in its private gthr-win32.h header. */
#define __MINGW32_MAJOR_VERSION 3
#define __MINGW32_MINOR_VERSION 11

/* Set VC specific compiler target macros.  */




# 62 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 3



#define _M_AMD64 100
#define _M_X64 100







# 86 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 3
















   /* MS does not prefix symbols by underscores for 64-bit.  */

     /* As we have to support older gcc version, which are using underscores
      as symbol prefix for x64, we have to check here for the user label
      prefix defined by gcc. */

             
#undef _
#define _ 1



#define __MINGW_USE_UNDERSCORE_PREFIX 0

#undef _
             











#define __MINGW_IMP_SYMBOL(sym) __MINGW64_PASTE(__imp_,sym)
#define __MINGW_IMP_LSYMBOL(sym) __MINGW64_PASTE(__imp_,sym)
#define __MINGW_USYMBOL(sym) sym
#define __MINGW_LSYMBOL(sym) __MINGW64_PASTE(_,sym)







#define __MINGW_ASM_CALL(func) __asm__(__MINGW64_STRINGIFY(__MINGW_USYMBOL(func)))
#define __MINGW_ASM_CRT_CALL(func) __asm__(__STRINGIFY(func))

























#undef __MINGW_EXTENSION





#define __MINGW_EXTENSION __extension__





/* Special case nameless struct/union.  */

#define __C89_NAMELESS __MINGW_EXTENSION
#define __C89_NAMELESSSTRUCTNAME 
#define __C89_NAMELESSSTRUCTNAME1 
#define __C89_NAMELESSSTRUCTNAME2 
#define __C89_NAMELESSSTRUCTNAME3 
#define __C89_NAMELESSSTRUCTNAME4 
#define __C89_NAMELESSSTRUCTNAME5 
#define __C89_NAMELESSUNIONNAME 
#define __C89_NAMELESSUNIONNAME1 
#define __C89_NAMELESSUNIONNAME2 
#define __C89_NAMELESSUNIONNAME3 
#define __C89_NAMELESSUNIONNAME4 
#define __C89_NAMELESSUNIONNAME5 
#define __C89_NAMELESSUNIONNAME6 
#define __C89_NAMELESSUNIONNAME7 
#define __C89_NAMELESSUNIONNAME8 



#define __GNU_EXTENSION __MINGW_EXTENSION


/* MinGW-w64 has some additional C99 printf/scanf feature support.
   So we add some helper macros to ease recognition of them.  */
#define __MINGW_HAVE_ANSI_C99_PRINTF 1
#define __MINGW_HAVE_WIDE_C99_PRINTF 1
#define __MINGW_HAVE_ANSI_C99_SCANF 1
#define __MINGW_HAVE_WIDE_C99_SCANF 1




#define __MINGW_POISON_NAME(__IFACE) __IFACE ##_layout_has_not_been_verified_and_its_declaration_is_most_likely_incorrect





#define __MSABI_LONG(x) x ## l






#define __MINGW_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)







#define __MINGW_GNUC_PREREQ(major,minor) (__GNUC__ > (major) || (__GNUC__ == (major) && __GNUC_MINOR__ >= (minor)))










#define __MINGW_MSC_PREREQ(major,minor) 0


# 257 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 3
#define __MINGW_ATTRIB_DEPRECATED_STR(X) 


#define __MINGW_SEC_WARN_STR "This function or variable may be unsafe, use _CRT_SECURE_NO_WARNINGS to disable deprecation"


#define __MINGW_MSVC2005_DEPREC_STR "This POSIX function is deprecated beginning in Visual C++ 2005, use _CRT_NONSTDC_NO_DEPRECATE to disable deprecation"



#define __MINGW_ATTRIB_DEPRECATED_MSVC2005 __MINGW_ATTRIB_DEPRECATED_STR(__MINGW_MSVC2005_DEPREC_STR)






#define __MINGW_ATTRIB_DEPRECATED_SEC_WARN __MINGW_ATTRIB_DEPRECATED_STR(__MINGW_SEC_WARN_STR)





# 293 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 3
#define __MINGW_MS_PRINTF(__format,__args) __attribute__((__format__(__ms_printf__, __format,__args)))


#define __MINGW_MS_SCANF(__format,__args) __attribute__((__format__(__ms_scanf__, __format,__args)))


#define __MINGW_GNU_PRINTF(__format,__args) __attribute__((__format__(__gnu_printf__,__format,__args)))


#define __MINGW_GNU_SCANF(__format,__args) __attribute__((__format__(__gnu_scanf__, __format,__args)))



#undef __mingw_ovr




#define __mingw_ovr static __attribute__ ((__unused__)) __inline__ __cdecl






#define __mingw_attribute_artificial __attribute__((__artificial__))





#define __MINGW_SELECTANY __attribute__((__selectany__))

       




# 349 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 3
#define __MINGW_FORTIFY_LEVEL 0


# 389 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 3
#define __mingw_bos_ovr __mingw_ovr


/* If _FORTIFY_SOURCE is enabled, some inline functions may use
   __builtin_va_arg_pack().  GCC may report an error if the address
   of such a function is used.  Set _FORTIFY_VA_ARG=0 in this case.
   Clang doesn't, as of version 15, yet implement __builtin_va_arg_pack().  */






#define __MINGW_FORTIFY_VA_ARG 0


       
# 405 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 3
#undef __has_builtin

/* Enable workaround for ABI incompatibility on affected platforms */






# 11 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw_secapi.h" 1 3
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
 

#define _INC_MINGW_SECAPI 

/* http://msdn.microsoft.com/en-us/library/ms175759%28v=VS.100%29.aspx */
# 28 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw_secapi.h" 3
/* Templates won't work in C, will break if secure API is not enabled, disabled */
#undef _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES
#undef _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY
#undef _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
#undef _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT
#undef _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY
#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 0
#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0


#define __MINGW_CRT_NAME_CONCAT2(sym) ::sym ##_s

# 53 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw_secapi.h" 3

/* https://blogs.msdn.com/b/sdl/archive/2010/02/16/vc-2010-and-memcpy.aspx?Redirected=true */
/* fallback on default implementation if we can't know the size of the destination */
# 69 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw_secapi.h" 3
#define __CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY_0_3_(__ret,__func,__type1,__attrib1,__arg1,__type2,__attrib2,__arg2,__type3,__attrib3,__arg3) _CRTIMP __ret __cdecl __func(__type1 * __attrib1 __arg1, __type2 __attrib2 __arg2, __type3 __attrib3 __arg3) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;



# 12 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3

/* Include _cygwin.h if we're building a Cygwin application. */




/* Target specific macro replacement for type "long".  In the Windows API,
   the type long is always 32 bit, even if the target is 64 bit (LLP64).
   On 64 bit Cygwin, the type long is 64 bit (LP64).  So, to get the right
   sized definitions and declarations, all usage of type long in the Windows
   headers have to be replaced by the below defined macro __LONG32. */

#define __LONG32 long




/* C/C++ specific language defines.  */
# 40 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3


/* Note the extern. This is needed to work around GCC's
limitations in handling dllimport attribute.  */
#define __MINGW_IMPORT extern __attribute__ ((__dllimport__))


#undef __USE_CRTIMP

#define __USE_CRTIMP 1


#define _CRTIMP __attribute__ ((__dllimport__))




#define __DECLSPEC_SUPPORTED 












#define USE___UUIDOF 0



#define _inline __inline








#define __CRT_INLINE extern inline __attribute__((__gnu_inline__))






#define __MINGW_INTRIN_INLINE extern __inline__ __attribute__((__always_inline__,__gnu_inline__))




#undef __CRT__NO_INLINE
#define __CRT__NO_INLINE 1



/* Recent MSVC supports C++14 but it doesn't define __cplusplus accordingly.  */
#define __MINGW_CXX11_CONSTEXPR 
#define __MINGW_CXX14_CONSTEXPR 
# 113 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3





#define __UNUSED_PARAM(x) x __attribute__ ((__unused__))














#define __restrict_arr __restrict
# 147 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3


#define __MINGW_ATTRIB_NORETURN __attribute__ ((__noreturn__))
#define __MINGW_ATTRIB_CONST __attribute__ ((__const__))









#define __MINGW_ATTRIB_MALLOC __attribute__ ((__malloc__))
#define __MINGW_ATTRIB_PURE __attribute__ ((__pure__))








/* Attribute `nonnull' was valid as of gcc 3.3.  We don't use GCC's
   variadiac macro facility, because variadic macros cause syntax
   errors with  --traditional-cpp.  */

#define __MINGW_ATTRIB_NONNULL(arg) __attribute__ ((__nonnull__ (arg)))





#define __MINGW_ATTRIB_UNUSED __attribute__ ((__unused__))





#define __MINGW_ATTRIB_USED __attribute__ ((__used__))
#define __MINGW_ATTRIB_DEPRECATED __attribute__ ((__deprecated__))

#define __MINGW_ATTRIB_DEPRECATED_MSG(x) __attribute__ ((__deprecated__(x)))














#define __MINGW_NOTHROW __attribute__ ((__nothrow__))







#define __MINGW_ATTRIB_NO_OPTIMIZE __attribute__((__optimize__ ("0")))





#define __MINGW_PRAGMA_PARAM(x) _Pragma (#x)






#define __MINGW_BROKEN_INTERFACE(x) __MINGW_PRAGMA_PARAM(message ("Interface " _CRT_STRINGIZE(x) " has unverified layout."))




/*  High byte is the major version, low byte is the minor. */





#define __MSVCRT_VERSION__ 0xE00








/* Allow both 0x1400 and 0xE00 to identify UCRT */
#define _UCRT 



#define __MINGW_UCRT_ASM_CALL(func) __MINGW_ASM_CALL(func)





#define _WIN32_WINNT 0xa00



#define _INT128_DEFINED 

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long













#define __ptr32 
#define __ptr64 

#define __unaligned 


#define __w64 




#define __forceinline extern __inline__ __attribute__((__always_inline__,__gnu_inline__))











#define __nothrow 



# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 1 3
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */

#define _INC_VADEFS 

# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 1 3
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */

# 672 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3


#define MINGW_SDK_INIT 

/* for backward compatibility */

#define MINGW_HAS_SECURE_API 1


#define __STDC_SECURE_LIB__ 200411L
#define __GOT_SECURE_LIB__ __STDC_SECURE_LIB__


# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/sdks/_mingw_ddk.h" 1 3

#define MINGW_DDK_H 

#define MINGW_HAS_DDK_H 1

# 686 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3


# 10 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 2 3


#undef _CRT_PACKING
#define _CRT_PACKING 8
#pragma pack(push,_CRT_PACKING)








#define __GNUC_VA_LIST 
  typedef __builtin_va_list __gnuc_va_list;




#define _VA_LIST_DEFINED 

  typedef __gnuc_va_list va_list;










#define _ADDRESSOF(v) (&(v))



/* Use GCC builtins */

#define _crt_va_start(v,l) __builtin_va_start(v,l)
#define _crt_va_arg(v,l) __builtin_va_arg(v,l)
#define _crt_va_end(v) __builtin_va_end(v)
#define _crt_va_copy(d,s) __builtin_va_copy(d,s)

# 97 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 3






#pragma pack(pop)




# 307 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3


#define __CRT_STRINGIZE(_Value) #_Value
#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)



#define __CRT_WIDE(_String) L ## _String
#define _CRT_WIDE(_String) __CRT_WIDE(_String)



#define _W64 






#define _CRTIMP_NOIA64 _CRTIMP




#define _CRTIMP2 _CRTIMP



#define _CRTIMP_ALTERNATIVE _CRTIMP
#define _CRT_ALTERNATIVE_IMPORTED 



#define _MRTIMP2 _CRTIMP


/* We have to define _DLL for gcc based mingw version. This define is set
   by VC, when DLL-based runtime is used. So, gcc based runtime just have
   DLL-base runtime, therefore this define has to be set.
   As our headers are possibly used by windows compiler having a static
   C-runtime, we make this definition gnu compiler specific here.  */

#define _DLL 



#define _MT 



#define _MCRTIMP _CRTIMP



#define _CRTIMP_PURE _CRTIMP



#define _PGLOBAL 



#define _AGLOBAL 


#define _SECURECRT_FILL_BUFFER_PATTERN 0xFD
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated)


#define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement) 



#define _CRT_INSECURE_DEPRECATE_GLOBALS(_Replacement) 



#define _CRT_MANAGED_HEAP_DEPRECATE 



#define _CRT_OBSOLETE(_NewItem) 











#define _CONST_RETURN 




#define UNALIGNED __unaligned









#define _CRT_ALIGN(x) __attribute__ ((__aligned__ (x)))






#define __CRTDECL __cdecl


#define _ARGMAX 100


#define _TRUNCATE ((size_t)-1)



#define _CRT_UNUSED(x) (void)x


/* MSVC defines _NATIVE_NULLPTR_SUPPORTED when nullptr is supported. We emulate it here for GCC. */






/* We are activating __USE_MINGW_ANSI_STDIO for various define indicators.
 * printf ll modifier (unsupported by msvcrt.dll) is required by C99 and C++11 standards. */
# 455 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3

/* We are defining __USE_MINGW_ANSI_STDIO as 0 or 1 */

#define __USE_MINGW_ANSI_STDIO 0






/* _dowildcard is an int that controls the globbing of the command line.
 * The MinGW32 (mingw.org) runtime calls it _CRT_glob, so we are adding
 * a compatibility definition here:  you can use either of _CRT_glob or
 * _dowildcard .
 * If _dowildcard is non-zero, the command line will be globbed:  *.*
 * will be expanded to be all files in the startup directory.
 * In the mingw-w64 library a _dowildcard variable is defined as being
 * 0, therefore command line globbing is DISABLED by default. To turn it
 * on and to leave wildcard command line processing MS's globbing code,
 * include a line in one of your source modules defining _dowildcard and
 * setting it to -1, like so:
 * int _dowildcard = -1;
 */
#undef _CRT_glob
#define _CRT_glob _dowildcard















#define __ANONYMOUS_DEFINED 
#define _ANONYMOUS_UNION __MINGW_EXTENSION
#define _ANONYMOUS_STRUCT __MINGW_EXTENSION

#define _UNION_NAME(x) 
#define _STRUCT_NAME(x) 







# 520 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3
#define DUMMYUNIONNAME 
#define DUMMYUNIONNAME1 
#define DUMMYUNIONNAME2 
#define DUMMYUNIONNAME3 
#define DUMMYUNIONNAME4 
#define DUMMYUNIONNAME5 
#define DUMMYUNIONNAME6 
#define DUMMYUNIONNAME7 
#define DUMMYUNIONNAME8 
#define DUMMYUNIONNAME9 




# 542 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3
#define DUMMYSTRUCTNAME 
#define DUMMYSTRUCTNAME1 
#define DUMMYSTRUCTNAME2 
#define DUMMYSTRUCTNAME3 
#define DUMMYSTRUCTNAME4 
#define DUMMYSTRUCTNAME5 




/* Macros for __uuidof template-based emulation */
# 586 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3

#define __CRT_UUID_DECL(type,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) 











#define __MINGW_DEBUGBREAK_IMPL !__has_builtin(__debugbreak)




void __cdecl __debugbreak(void);
__MINGW_INTRIN_INLINE void __cdecl __debugbreak(void)
{



  __asm__ __volatile__("int {$}3":);





}



#define __MINGW_FASTFAIL_IMPL !__has_builtin(__fastfail)




void __cdecl __MINGW_ATTRIB_NORETURN __fastfail(unsigned int code);
__MINGW_INTRIN_INLINE void __cdecl __MINGW_ATTRIB_NORETURN __fastfail(unsigned int code)
{




  __asm__ __volatile__("int {$}0x29"::"c"(code));






  __builtin_unreachable();
}



#define __MINGW_PREFETCH_IMPL !__has_builtin(__prefetch)




# 660 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3




/* mingw-w64 specific functions: */
const char *__mingw_get_crt_info (void);







# 11 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/corecrt.h" 2 3


#undef _CRT_PACKING
#define _CRT_PACKING 8
#pragma pack(push,_CRT_PACKING)








#define _CRTNOALIAS 



#define _CRTRESTRICT 



#define _SIZE_T_DEFINED 
#undef size_t

__MINGW_EXTENSION typedef unsigned __int64 size_t;






#define _SSIZE_T_DEFINED 
#undef ssize_t

__MINGW_EXTENSION typedef __int64 ssize_t;






typedef size_t rsize_t;
#define _RSIZE_T_DEFINED 



#define _INTPTR_T_DEFINED 

#define __intptr_t_defined 
#undef intptr_t

__MINGW_EXTENSION typedef __int64 intptr_t;







#define _UINTPTR_T_DEFINED 

#define __uintptr_t_defined 
#undef uintptr_t

__MINGW_EXTENSION typedef unsigned __int64 uintptr_t;







#define _PTRDIFF_T_DEFINED 

#define _PTRDIFF_T_ 
#undef ptrdiff_t

__MINGW_EXTENSION typedef __int64 ptrdiff_t;







#define _WCHAR_T_DEFINED 

typedef unsigned short wchar_t;




#define _WCTYPE_T_DEFINED 

#define _WINT_T 
typedef unsigned short wint_t;
typedef unsigned short wctype_t;




#define _ERRCODE_DEFINED 
typedef int errno_t;



#define _TIME32_T_DEFINED 
typedef long __time32_t;



#define _TIME64_T_DEFINED 
__MINGW_EXTENSION typedef __int64 __time64_t;










#define _TIME_T_DEFINED 



typedef __time64_t time_t;




#define _CRT_SECURE_CPP_NOTHROW throw()










# 261 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/corecrt.h" 3

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(__ret,__func,__dsttype,__dst) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(__ret,__func,__dsttype,__dst,__type1,__arg1) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(__ret,__func,__dsttype,__dst,__type1,__arg1,__type2,__arg2) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(__ret,__func,__dsttype,__dst,__type1,__arg1,__type2,__arg2,__type3,__arg3) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(__ret,__func,__dsttype,__dst,__type1,__arg1,__type2,__arg2,__type3,__arg3,__type4,__arg4) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(__ret,__func,__type0,__arg0,__dsttype,__dst,__type1,__arg1) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(__ret,__func,__type0,__arg0,__dsttype,__dst,__type1,__arg1,__type2,__arg2) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(__ret,__func,__type0,__arg0,__dsttype,__dst,__type1,__arg1,__type2,__arg2,__type3,__arg3) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(__ret,__func,__type1,__arg1,__type2,__arg2,__dsttype,__dst) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(__ret,__func,__vfunc,__dsttype,__dst,__type1,__arg1) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(__ret,__func,__vfunc,__dsttype,__dst,__type1,__arg1,__type2,__arg2) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(__ret,__func,__dsttype,__src) 



#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst, __arg1_type, __arg1, __arg2_type, __arg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst, __arg1_type, __arg1, __arg2_type, __arg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2,__arg3_type,__arg3) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst, __arg1_type, __arg1, __arg2_type, __arg2, __arg3_type, __arg3)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(__ret_type,__ret_policy,__decl_spec,__name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2,__arg3_type,__arg3,__arg4_type,__arg4) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(__ret_type, __ret_policy, __decl_spec, __func_name, __func_name ##_s, __dst_attr, __dst_type, __dst, __arg1_type, __arg1, __arg2_type, __arg2, __arg3_type, __arg3, __arg4_type, __arg4)


# 421 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/corecrt.h" 3

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst) 
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1) 
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2) 
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2,__arg3_type,__arg3) 
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(__ret_type,__ret_policy,__decl_spec,__name,__sec_name,__dst_attr,__dst_type,__dst,__arg1_type,__arg1,__arg2_type,__arg2,__arg3_type,__arg3,__arg4_type,__arg4) 



struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct *pthreadlocinfo;
typedef struct threadmbcinfostruct *pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct {
  pthreadlocinfo locinfo;
  pthreadmbcinfo mbcinfo;
} _locale_tstruct,*_locale_t;


#define _TAGLC_ID_DEFINED 
typedef struct tagLC_ID {
  unsigned short wLanguage;
  unsigned short wCountry;
  unsigned short wCodePage;
} LC_ID,*LPLC_ID;



#define _THREADLOCALEINFO 
typedef struct threadlocaleinfostruct {

  const unsigned short *_locale_pctype;
  int _locale_mb_cur_max;
  unsigned int _locale_lc_codepage;
# 482 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/corecrt.h" 3
} threadlocinfo;



#define __crt_typefix(ctype) 









#define _CRT_USE_WINAPI_FAMILY_DESKTOP_APP 




#pragma pack(pop)


# 11 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 2 3

# 10 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/setjmp.h" 2 3

#pragma pack(push,_CRT_PACKING)









#define NULL ((void *)0)







# 111 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/setjmp.h" 3

  typedef _CRT_ALIGN(16) struct _SETJMP_FLOAT128 {
    __MINGW_EXTENSION unsigned __int64 Part[2];
  } SETJMP_FLOAT128;

#define _JBLEN 16
  typedef SETJMP_FLOAT128 _JBTYPE;

  typedef struct _JUMP_BUFFER {
    __MINGW_EXTENSION unsigned __int64 Frame;
    __MINGW_EXTENSION unsigned __int64 Rbx;
    __MINGW_EXTENSION unsigned __int64 Rsp;
    __MINGW_EXTENSION unsigned __int64 Rbp;
    __MINGW_EXTENSION unsigned __int64 Rsi;
    __MINGW_EXTENSION unsigned __int64 Rdi;
    __MINGW_EXTENSION unsigned __int64 R12;
    __MINGW_EXTENSION unsigned __int64 R13;
    __MINGW_EXTENSION unsigned __int64 R14;
    __MINGW_EXTENSION unsigned __int64 R15;
    __MINGW_EXTENSION unsigned __int64 Rip;
    unsigned long MxCsr;
    unsigned short FpCsr;
    unsigned short Spare;
    SETJMP_FLOAT128 Xmm6;
    SETJMP_FLOAT128 Xmm7;
    SETJMP_FLOAT128 Xmm8;
    SETJMP_FLOAT128 Xmm9;
    SETJMP_FLOAT128 Xmm10;
    SETJMP_FLOAT128 Xmm11;
    SETJMP_FLOAT128 Xmm12;
    SETJMP_FLOAT128 Xmm13;
    SETJMP_FLOAT128 Xmm14;
    SETJMP_FLOAT128 Xmm15;
  } _JUMP_BUFFER;

# 199 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/setjmp.h" 3


  typedef _JBTYPE jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED 


_CRTIMP __MINGW_ATTRIB_NORETURN __attribute__ ((__nothrow__)) void __cdecl longjmp(jmp_buf _Buf,int _Value);

void * __cdecl __attribute__ ((__nothrow__)) mingw_getsp (void);

       






#define _setjmp __intrinsic_setjmpex








# 241 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/setjmp.h" 3
#define setjmp(BUF) _setjmp((BUF), __builtin_frame_address (0))

  int __cdecl __attribute__ ((__nothrow__,__returns_twice__)) _setjmp(jmp_buf _Buf, void *_Ctx);
  int __cdecl __attribute__ ((__nothrow__,__returns_twice__)) _setjmp3(jmp_buf _Buf, void *_Ctx);
# 261 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/setjmp.h" 3

       
# 262 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/setjmp.h" 3
#undef __has_builtin





#pragma pack(pop)
# 17 "build/vendor/unity/src/unity_internals.h" 2



# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 1 3
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */

#define _MATH_H_ 


       
# 11 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 3




struct _exception;

#pragma pack(push,_CRT_PACKING)

#define _DOMAIN 1
#define _SING 2
#define _OVERFLOW 3
#define _UNDERFLOW 4
#define _TLOSS 5
#define _PLOSS 6




#define DOMAIN _DOMAIN
#define SING _SING
#define OVERFLOW _OVERFLOW
#define UNDERFLOW _UNDERFLOW
#define TLOSS _TLOSS
#define PLOSS _PLOSS





#define M_E 2.7182818284590452354
#define M_LOG2E 1.4426950408889634074
#define M_LOG10E 0.43429448190325182765
#define M_LN2 0.69314718055994530942
#define M_LN10 2.30258509299404568402
#define M_PI 3.14159265358979323846
#define M_PI_2 1.57079632679489661923
#define M_PI_4 0.78539816339744830962
#define M_1_PI 0.31830988618379067154
#define M_2_PI 0.63661977236758134308
#define M_2_SQRTPI 1.12837916709551257390
#define M_SQRT2 1.41421356237309504880
#define M_SQRT1_2 0.70710678118654752440


/* See also float.h  */

#define __MINGW_FPCLASS_DEFINED 1
/* IEEE 754 classication */
#define _FPCLASS_SNAN 0x0001
#define _FPCLASS_QNAN 0x0002
#define _FPCLASS_NINF 0x0004
#define _FPCLASS_NN 0x0008
#define _FPCLASS_ND 0x0010
#define _FPCLASS_NZ 0x0020
#define _FPCLASS_PZ 0x0040
#define _FPCLASS_PD 0x0080
#define _FPCLASS_PN 0x0100
#define _FPCLASS_PINF 0x0200





# 95 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 3
#define __mingw_types_compatible_p(type1,type2) __builtin_types_compatible_p (type1, type2)







#define __mingw_choose_expr __builtin_choose_expr









#define __MINGW_SOFTMATH 

/* IEEE float/double type shapes.  */

  typedef union __mingw_dbl_type_t {
    double x;
    unsigned long long val;
    __C89_NAMELESS struct {
      unsigned int low, high;
    } lh;
  } __mingw_dbl_type_t;

  typedef union __mingw_flt_type_t {
    float x;
    unsigned int val;
  } __mingw_flt_type_t;

  typedef union __mingw_ldbl_type_t
  {
    long double x;
    __C89_NAMELESS struct {
      unsigned int low, high;
      int sign_exponent : 16;
      int res1 : 16;
      int res0 : 32;
    } lh;
  } __mingw_ldbl_type_t;




  extern double * __MINGW_IMP_SYMBOL(_HUGE);
#define _HUGE (* __MINGW_IMP_SYMBOL(_HUGE))



#define HUGE_VAL __builtin_huge_val()





#define _EXCEPTION_DEFINED 
  struct _exception {
    int type;
    const char *name;
    double arg1;
    double arg2;
    double retval;
  };

  void __mingw_raise_matherr (int typ, const char *name, double a1, double a2,
			      double rslt);
  void __mingw_setusermatherr (int (__cdecl *)(struct _exception *));
  _CRTIMP void __setusermatherr(int (__cdecl *)(struct _exception *));
  #define __setusermatherr __mingw_setusermatherr


  double __cdecl sin(double _X);
  double __cdecl cos(double _X);
  double __cdecl tan(double _X);
  double __cdecl sinh(double _X);
  double __cdecl cosh(double _X);
  double __cdecl tanh(double _X);
  double __cdecl asin(double _X);
  double __cdecl acos(double _X);
  double __cdecl atan(double _X);
  double __cdecl atan2(double _Y,double _X);
  double __cdecl exp(double _X);
  double __cdecl log(double _X);
  double __cdecl log10(double _X);
  double __cdecl pow(double _X,double _Y);
  double __cdecl sqrt(double _X);
  double __cdecl ceil(double _X);
  double __cdecl floor(double _X);

/* 7.12.7.2 The fabs functions: Double in C89 */
  extern  float __cdecl fabsf (float x);
  extern long double __cdecl fabsl (long double);
  extern double __cdecl fabs (double _X);

# 230 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 3

  double __cdecl ldexp(double _X,int _Y);
  double __cdecl frexp(double _X,int *_Y);
  double __cdecl modf(double _X,double *_Y);
  double __cdecl fmod(double _X,double _Y);

  void __cdecl sincos (double __x, double *p_sin, double *p_cos);
  void __cdecl sincosl (long double __x, long double *p_sin, long double *p_cos);
  void __cdecl sincosf (float __x, float *p_sin, float *p_cos);


#define _CRT_ABS_DEFINED 
  int __cdecl abs(int _X);
  long __cdecl labs(long _X);


#define _CRT_ATOF_DEFINED 
  double __cdecl atof(const char *_String);
  double __cdecl _atof_l(const char *_String,_locale_t _Locale);


#define EDOM 33
#define ERANGE 34


#define _COMPLEX_DEFINED 
  struct _complex {
    double x;
    double y;
  };


  double __cdecl _cabs(struct _complex _ComplexA); /* Overridden to use our cabs.  */
  double __cdecl _hypot(double _X,double _Y);
  _CRTIMP double __cdecl _j0(double _X);
  _CRTIMP double __cdecl _j1(double _X);
  _CRTIMP double __cdecl _jn(int _X,double _Y);
  _CRTIMP double __cdecl _y0(double _X);
  _CRTIMP double __cdecl _y1(double _X);
  _CRTIMP double __cdecl _yn(int _X,double _Y);

#define _CRT_MATHERR_DEFINED 
  _CRTIMP int __cdecl _matherr (struct _exception *);


/* These are also declared in Mingw float.h; needed here as well to work 
   around GCC build issues.  */
/* BEGIN FLOAT.H COPY */
/*
 * IEEE recommended functions
 */

#define _SIGN_DEFINED 
  _CRTIMP double __cdecl _chgsign (double _X);
  _CRTIMP double __cdecl _copysign (double _Number,double _Sign);
  _CRTIMP double __cdecl _logb (double);
  _CRTIMP double __cdecl _nextafter (double, double);
  _CRTIMP double __cdecl _scalb (double, long);
  _CRTIMP int __cdecl _finite (double);
  _CRTIMP int __cdecl _fpclass (double);
  _CRTIMP int __cdecl _isnan (double);


/* END FLOAT.H COPY */



_CRTIMP double __cdecl j0 (double) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
_CRTIMP double __cdecl j1 (double) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
_CRTIMP double __cdecl jn (int, double) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
_CRTIMP double __cdecl y0 (double) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
_CRTIMP double __cdecl y1 (double) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
_CRTIMP double __cdecl yn (int, double) __MINGW_ATTRIB_DEPRECATED_MSVC2005;



_CRTIMP double __cdecl chgsign (double);
/*
 * scalb() is a GCC built-in.
 * Exclude this _scalb() stub; the semantics are incompatible
 * with the built-in implementation.
 *
_CRTIMP double __cdecl scalb (double, long);
 *
 */
  _CRTIMP int __cdecl finite (double);
  _CRTIMP int __cdecl fpclass (double);

#define FP_SNAN _FPCLASS_SNAN
#define FP_QNAN _FPCLASS_QNAN
#define FP_NINF _FPCLASS_NINF
#define FP_PINF _FPCLASS_PINF
#define FP_NDENORM _FPCLASS_ND
#define FP_PDENORM _FPCLASS_PD
#define FP_NZERO _FPCLASS_NZ
#define FP_PZERO _FPCLASS_PZ
#define FP_NNORM _FPCLASS_NN
#define FP_PNORM _FPCLASS_PN













#define HUGE_VALF __builtin_huge_valf()
#define HUGE_VALL __builtin_huge_vall()
#define INFINITY __builtin_inff()
#define NAN __builtin_nanf("")
# 354 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 3

/* Use the compiler's builtin define for FLT_EVAL_METHOD to
   set float_t and double_t.  */


typedef float float_t;
typedef double double_t;












/* 7.12.3.1 */
/*
   Return values for fpclassify.
   These are based on Intel x87 fpu condition codes
   in the high byte of status word and differ from
   the return values for MS IEEE 754 extension _fpclass()
*/
#define FP_NAN 0x0100
#define FP_NORMAL 0x0400
#define FP_INFINITE (FP_NAN | FP_NORMAL)
#define FP_ZERO 0x4000
#define FP_SUBNORMAL (FP_NORMAL | FP_ZERO)
/* 0x0200 is signbit mask */

/*
  We can't inline float or double, because we want to ensure truncation
  to semantic type before classification. 
  (A normal long double value might become subnormal when 
  converted to double, and zero when converted to float.)
*/

  extern int __cdecl __fpclassifyl (long double);
  extern int __cdecl __fpclassifyf (float);
  extern int __cdecl __fpclassify (double);

# 467 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 3

# 481 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 3
#define __dfp_expansion(__call,__fin,x) __fin


#define fpclassify(x) __mingw_choose_expr ( __mingw_types_compatible_p (__typeof__ (x), double), __fpclassify(x), __mingw_choose_expr ( __mingw_types_compatible_p (__typeof__ (x), float), __fpclassifyf(x), __mingw_choose_expr ( __mingw_types_compatible_p (__typeof__ (x), long double), __fpclassifyl(x), __dfp_expansion(__fpclassify,(__builtin_trap(),0),x))))
# 495 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 3


/* 7.12.3.2 */
#define isfinite(x) ((fpclassify(x) & FP_NAN) == 0)

/* 7.12.3.3 */
#define isinf(x) (fpclassify(x) == FP_INFINITE)

/* 7.12.3.4 */
/* We don't need to worry about truncation here:
   A NaN stays a NaN. */

  extern int __cdecl __isnan (double);
  extern int __cdecl __isnanf (float);
  extern int __cdecl __isnanl (long double);

# 575 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 3



#define isnan(x) __mingw_choose_expr ( __mingw_types_compatible_p (__typeof__ (x), double), __isnan((double)(x)), __mingw_choose_expr ( __mingw_types_compatible_p (__typeof__ (x), float), __isnanf((float)(x)), __mingw_choose_expr ( __mingw_types_compatible_p (__typeof__ (x), long double), __isnanl((long double)(x)), __dfp_expansion(__isnan,(__builtin_trap(),(int)0),x))))
# 589 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 3

/* 7.12.3.5 */
#define isnormal(x) (fpclassify(x) == FP_NORMAL)

/* 7.12.3.6 The signbit macro */
  extern int __cdecl __signbit (double);
  extern int __cdecl __signbitf (float);
  extern int __cdecl __signbitl (long double);
# 637 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 3

#define signbit(x) __mingw_choose_expr ( __mingw_types_compatible_p (__typeof__ (x), double), __signbit(x), __mingw_choose_expr ( __mingw_types_compatible_p (__typeof__ (x), float), __signbitf(x), __mingw_choose_expr ( __mingw_types_compatible_p (__typeof__ (x), long double), __signbitl(x), __dfp_expansion(__signbit,(__builtin_trap(),x),x))))
# 649 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 3

/* 7.12.4 Trigonometric functions: Double in C89 */
  extern float __cdecl sinf(float _X);
  extern long double __cdecl sinl(long double);

  extern float __cdecl cosf(float _X);
  extern long double __cdecl cosl(long double);

  extern float __cdecl tanf(float _X);
  extern long double __cdecl tanl(long double);
  extern float __cdecl asinf(float _X);
  extern long double __cdecl asinl(long double);

  extern float __cdecl acosf (float);
  extern long double __cdecl acosl (long double);

  extern float __cdecl atanf (float);
  extern long double __cdecl atanl (long double);

  extern float __cdecl atan2f (float, float);
  extern long double __cdecl atan2l (long double, long double);

/* 7.12.5 Hyperbolic functions: Double in C89  */
  extern float __cdecl sinhf(float _X);



  extern long double __cdecl sinhl(long double);

  extern float __cdecl coshf(float _X);



  extern long double __cdecl coshl(long double);

  extern float __cdecl tanhf(float _X);



  extern long double __cdecl tanhl(long double);

/* Inverse hyperbolic trig functions  */ 
/* 7.12.5.1 */
  extern double __cdecl acosh (double);
  extern float __cdecl acoshf (float);
  extern long double __cdecl acoshl (long double);

/* 7.12.5.2 */
  extern double __cdecl asinh (double);
  extern float __cdecl asinhf (float);
  extern long double __cdecl asinhl (long double);

/* 7.12.5.3 */
  extern double __cdecl atanh (double);
  extern float __cdecl atanhf  (float);
  extern long double __cdecl atanhl (long double);

/* Exponentials and logarithms  */
/* 7.12.6.1 Double in C89 */
  extern float __cdecl expf(float _X);



  extern long double __cdecl expl(long double);

/* 7.12.6.2 */
  extern double __cdecl exp2(double);
  extern float __cdecl exp2f(float);
  extern long double __cdecl exp2l(long double);

/* 7.12.6.3 The expm1 functions */
/* TODO: These could be inlined */
  extern double __cdecl expm1(double);
  extern float __cdecl expm1f(float);
  extern long double __cdecl expm1l(long double);

/* 7.12.6.4 Double in C89 */
  extern float frexpf(float _X,int *_Y);



  extern long double __cdecl frexpl(long double,int *);

/* 7.12.6.5 */
#define FP_ILOGB0 ((int)0x80000000)
#define FP_ILOGBNAN ((int)0x7fffffff)
  extern int __cdecl ilogb (double);
  extern int __cdecl ilogbf (float);
  extern int __cdecl ilogbl (long double);

/* 7.12.6.6  Double in C89 */
  extern float __cdecl ldexpf(float _X,int _Y);



  extern long double __cdecl ldexpl (long double, int);

/* 7.12.6.7 Double in C89 */
  extern float __cdecl logf (float);
  extern long double __cdecl logl(long double);

/* 7.12.6.8 Double in C89 */
  extern float __cdecl log10f (float);
  extern long double __cdecl log10l(long double);

/* 7.12.6.9 */
  extern double __cdecl log1p(double);
  extern float __cdecl log1pf(float);
  extern long double __cdecl log1pl(long double);

/* 7.12.6.10 */
  extern double __cdecl log2 (double);
  extern float __cdecl log2f (float);
  extern long double __cdecl log2l (long double);

/* 7.12.6.11 */
  extern double __cdecl logb (double);
  extern float __cdecl logbf (float);
  extern long double __cdecl logbl (long double);

/* 7.12.6.12  Double in C89 */
  extern float __cdecl modff (float, float*);
  extern long double __cdecl modfl (long double, long double*);

/* 7.12.6.13 */
  extern double __cdecl scalbn (double, int);
  extern float __cdecl scalbnf (float, int);
  extern long double __cdecl scalbnl (long double, int);

  extern double __cdecl scalbln (double, long);
  extern float __cdecl scalblnf (float, long);
  extern long double __cdecl scalblnl (long double, long);

/* 7.12.7.1 */
/* Implementations adapted from Cephes versions */ 
  extern double __cdecl cbrt (double);
  extern float __cdecl cbrtf (float);
  extern long double __cdecl cbrtl (long double);

/* 7.12.7.3  */
  extern double __cdecl hypot (double, double) __MINGW_ATTRIB_DEPRECATED_MSVC2005; /* in libmoldname.a */
  extern float __cdecl hypotf (float x, float y);



  extern long double __cdecl hypotl (long double, long double);

/* 7.12.7.4 The pow functions. Double in C89 */
  extern float __cdecl powf(float _X,float _Y);



  extern long double __cdecl powl (long double, long double);

/* 7.12.7.5 The sqrt functions. Double in C89. */
  extern float __cdecl sqrtf (float);
  extern long double sqrtl(long double);

/* 7.12.8.1 The erf functions  */
  extern double __cdecl erf (double);
  extern float __cdecl erff (float);
  extern long double __cdecl erfl (long double);

/* 7.12.8.2 The erfc functions  */
  extern double __cdecl erfc (double);
  extern float __cdecl erfcf (float);
  extern long double __cdecl erfcl (long double);

/* 7.12.8.3 The lgamma functions */
  extern double __cdecl lgamma (double);
  extern float __cdecl lgammaf (float);
  extern long double __cdecl lgammal (long double);

  extern int signgam;

/* 7.12.8.4 The tgamma functions */
  extern double __cdecl tgamma (double);
  extern float __cdecl tgammaf (float);
  extern long double __cdecl tgammal (long double);

/* 7.12.9.1 Double in C89 */
  extern float __cdecl ceilf (float);
  extern long double __cdecl ceill (long double);

/* 7.12.9.2 Double in C89 */
  extern float __cdecl floorf (float);
  extern long double __cdecl floorl (long double);

/* 7.12.9.3 */
  extern double __cdecl nearbyint ( double);
  extern float __cdecl nearbyintf (float);
  extern long double __cdecl nearbyintl (long double);

/* 7.12.9.4 */
/* round, using fpu control word settings */
extern double __cdecl rint (double);
extern float __cdecl rintf (float);
extern long double __cdecl rintl (long double);

/* 7.12.9.5 */
extern long __cdecl lrint (double);
extern long __cdecl lrintf (float);
extern long __cdecl lrintl (long double);

__MINGW_EXTENSION long long __cdecl llrint (double);
__MINGW_EXTENSION long long __cdecl llrintf (float);
__MINGW_EXTENSION long long __cdecl llrintl (long double);

/* 7.12.9.6 */
/* round away from zero, regardless of fpu control word settings */
  extern double __cdecl round (double);
  extern float __cdecl roundf (float);
  extern long double __cdecl roundl (long double);

/* 7.12.9.7  */
  extern long __cdecl lround (double);
  extern long __cdecl lroundf (float);
  extern long __cdecl lroundl (long double);
  __MINGW_EXTENSION long long __cdecl llround (double);
  __MINGW_EXTENSION long long __cdecl llroundf (float);
  __MINGW_EXTENSION long long __cdecl llroundl (long double);
  
/* 7.12.9.8 */
/* round towards zero, regardless of fpu control word settings */
  extern double __cdecl trunc (double);
  extern float __cdecl truncf (float);
  extern long double __cdecl truncl (long double);

/* 7.12.10.1 Double in C89 */
  extern float __cdecl fmodf (float, float);
  extern long double __cdecl fmodl (long double, long double);

/* 7.12.10.2 */ 
  extern double __cdecl remainder (double, double);
  extern float __cdecl remainderf (float, float);
  extern long double __cdecl remainderl (long double, long double);

/* 7.12.10.3 */
  extern double __cdecl remquo(double, double, int *);
  extern float __cdecl remquof(float, float, int *);
  extern long double __cdecl remquol(long double, long double, int *);

/* 7.12.11.1 */
  extern double __cdecl copysign (double, double); /* in libmoldname.a */
  extern float __cdecl copysignf (float, float);
  extern long double __cdecl copysignl (long double, long double);

# 914 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 3

/* 7.12.11.2 Return a NaN */
  extern double __cdecl nan(const char *tagp);
  extern float __cdecl nanf(const char *tagp);
  extern long double __cdecl nanl(const char *tagp);


#define _nan() nan("")
#define _nanf() nanf("")
#define _nanl() nanl("")


/* 7.12.11.3 */
  extern double __cdecl nextafter (double, double); /* in libmoldname.a */
  extern float __cdecl nextafterf (float, float);
  extern long double __cdecl nextafterl (long double, long double);

/* 7.12.11.4 The nexttoward functions */
  extern double __cdecl nexttoward (double,  long double);
  extern float __cdecl nexttowardf (float,  long double);
  extern long double __cdecl nexttowardl (long double, long double);

/* 7.12.12.1 */
/*  x > y ? (x - y) : 0.0  */
  extern double __cdecl fdim (double x, double y);
  extern float __cdecl fdimf (float x, float y);
  extern long double __cdecl fdiml (long double x, long double y);

/* fmax and fmin.
   NaN arguments are treated as missing data: if one argument is a NaN
   and the other numeric, then these functions choose the numeric
   value. */

/* 7.12.12.2 */
  extern double __cdecl fmax  (double, double);
  extern float __cdecl fmaxf (float, float);
  extern long double __cdecl fmaxl (long double, long double);

/* 7.12.12.3 */
  extern double __cdecl fmin (double, double);
  extern float __cdecl fminf (float, float);
  extern long double __cdecl fminl (long double, long double);

/* 7.12.13.1 */
/* return x * y + z as a ternary op */ 
  extern double __cdecl fma (double, double, double);
  extern float __cdecl fmaf (float, float, float);
  extern long double __cdecl fmal (long double, long double, long double);

/* 7.12.14 */
/* 
 *  With these functions, comparisons involving quiet NaNs set the FP
 *  condition code to "unordered".  The IEEE floating-point spec
 *  dictates that the result of floating-point comparisons should be
 *  false whenever a NaN is involved, with the exception of the != op, 
 *  which always returns true: yes, (NaN != NaN) is true).
 */



#define isgreater(x,y) __builtin_isgreater(x, y)
#define isgreaterequal(x,y) __builtin_isgreaterequal(x, y)
#define isless(x,y) __builtin_isless(x, y)
#define islessequal(x,y) __builtin_islessequal(x, y)
#define islessgreater(x,y) __builtin_islessgreater(x, y)
#define isunordered(x,y) __builtin_isunordered(x, y)

# 1001 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 3









   _CRTIMP float __cdecl _copysignf (float _Number,float _Sign);
   _CRTIMP float __cdecl _chgsignf (float _X);
   _CRTIMP float __cdecl _logbf(float _X);
   _CRTIMP float __cdecl _nextafterf(float _X,float _Y);
   _CRTIMP int __cdecl _finitef(float _X);
   _CRTIMP int __cdecl _isnanf(float _X);
   _CRTIMP int __cdecl _fpclassf(float _X);



   extern long double __cdecl _chgsignl (long double);
#define _copysignl copysignl


#define _hypotl hypotl


#define matherr _matherr
#define HUGE _HUGE


/* Documentation on decimal float math
   http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=8cf166fedd1aa110VgnVCM100000a360ea10RCRD 
 */
# 1403 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/math.h" 3







#pragma pack(pop)



# 21 "build/vendor/unity/src/unity_internals.h" 2



# 1 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/stddef.h" 1 3 4
# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 1 3 4
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */




#define _INC_STDDEF 






#define _CRT_ERRNO_DEFINED 
  _CRTIMP extern int *__cdecl _errno(void);
#define errno (*_errno())
  errno_t __cdecl _set_errno(int _Value);
  errno_t __cdecl _get_errno(int *_Value);


  _CRTIMP extern unsigned long __cdecl __threadid(void);
#define _threadid (__threadid())
  _CRTIMP extern uintptr_t __cdecl __threadhandle(void);







/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */



#define _STDDEF_H 
#define _STDDEF_H_ 
/* snaroff@next.com says the NeXT needs this.  */
#define _ANSI_STDDEF_H 
/* Irix 5.1 needs this.  */
#define __STDDEF_H__ 



/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
# 89 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4

/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */













/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */





# 157 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4





/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */











# 230 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4










#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */













# 325 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4












#undef __need_wchar_t


# 355 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4

/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
# 388 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4



/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)









#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)




#define _GCC_MAX_ALIGN_T 
#define __CLANG_MAX_ALIGN_T_DEFINED 
/* Type whose alignment is supported in every context and is at least
   as great as that of any standard type not using alignment
   specifiers.  */
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;








# 2 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/stddef.h" 2 3 4
/* Copyright (C) 1989-2025 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 25 "build/vendor/unity/src/unity_internals.h" 2






/* Unity Attempts to Auto-Detect Integer Types
 * Attempt 1: UINT_MAX, ULONG_MAX in <limits.h>, or default to 32 bits
 * Attempt 2: UINTPTR_MAX in <stdint.h>, or default to same size as long
 * The user may override any of these derived constants:
 * UNITY_INT_WIDTH, UNITY_LONG_WIDTH, UNITY_POINTER_WIDTH */

# 1 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/stdint.h" 1 3 4








#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdint.h" 1 3 4
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
/* ISO C9x  7.18  Integer types <stdint.h>
 * Based on ISO/IEC SC22/WG14 9899 Committee draft (SC22 N2794)
 *
 *  THIS SOFTWARE IS NOT COPYRIGHTED
 *
 *  Contributor: Danny Smith <danny_r_smith_2001@yahoo.co.nz>
 *
 *  This source code is offered for use in the public domain. You may
 *  use, modify or distribute it freely.
 *
 *  This code is distributed in the hope that it will be useful but
 *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 *  DISCLAIMED. This includes but is not limited to warranties of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  Date: 2000-12-02
 */



#define _STDINT_H 



#define __need_wint_t 
#define __need_wchar_t 
# 1 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/stddef.h" 1 3 4
# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 1 3 4
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */



# 33 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 56 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4


/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
# 89 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4

/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */













/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */





# 157 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4





/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */











# 230 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4










#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */













# 325 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4












#undef __need_wchar_t



# 353 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4
#undef __need_wint_t


/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
# 388 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4



/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)









#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)



# 429 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4







# 2 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/stddef.h" 2 3 4
/* Copyright (C) 1989-2025 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 33 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdint.h" 2 3 4

/* 7.18.1.1  Exact-width integer types */
typedef signed char int8_t;
typedef unsigned char   uint8_t;
typedef short  int16_t;
typedef unsigned short  uint16_t;
typedef int  int32_t;
typedef unsigned   uint32_t;
__MINGW_EXTENSION typedef long long  int64_t;
__MINGW_EXTENSION typedef unsigned long long   uint64_t;

/* 7.18.1.2  Minimum-width integer types */
typedef signed char int_least8_t;
typedef unsigned char   uint_least8_t;
typedef short  int_least16_t;
typedef unsigned short  uint_least16_t;
typedef int  int_least32_t;
typedef unsigned   uint_least32_t;
__MINGW_EXTENSION typedef long long  int_least64_t;
__MINGW_EXTENSION typedef unsigned long long   uint_least64_t;

/*  7.18.1.3  Fastest minimum-width integer types
 *  Not actually guaranteed to be fastest for all purposes
 *  Here we use the exact-width types for 8 and 16-bit ints.
 */
typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short  int_fast16_t;
typedef unsigned short  uint_fast16_t;
typedef int  int_fast32_t;
typedef unsigned  int  uint_fast32_t;
__MINGW_EXTENSION typedef long long  int_fast64_t;
__MINGW_EXTENSION typedef unsigned long long   uint_fast64_t;

/* 7.18.1.5  Greatest-width integer types */
__MINGW_EXTENSION typedef long long  intmax_t;
__MINGW_EXTENSION typedef unsigned long long   uintmax_t;

/* 7.18.2  Limits of specified-width integer types */



/* 7.18.2.1  Limits of exact-width integer types */
#define INT8_MIN (-128)
#define INT16_MIN (-32768)
#define INT32_MIN (-2147483647 - 1)
#define INT64_MIN (-9223372036854775807LL - 1)

#define INT8_MAX 127
#define INT16_MAX 32767
#define INT32_MAX 2147483647
#define INT64_MAX 9223372036854775807LL

#define UINT8_MAX 255
#define UINT16_MAX 65535
#define UINT32_MAX 0xffffffffU
#define UINT64_MAX 0xffffffffffffffffULL

/* 7.18.2.2  Limits of minimum-width integer types */
#define INT_LEAST8_MIN INT8_MIN
#define INT_LEAST16_MIN INT16_MIN
#define INT_LEAST32_MIN INT32_MIN
#define INT_LEAST64_MIN INT64_MIN

#define INT_LEAST8_MAX INT8_MAX
#define INT_LEAST16_MAX INT16_MAX
#define INT_LEAST32_MAX INT32_MAX
#define INT_LEAST64_MAX INT64_MAX

#define UINT_LEAST8_MAX UINT8_MAX
#define UINT_LEAST16_MAX UINT16_MAX
#define UINT_LEAST32_MAX UINT32_MAX
#define UINT_LEAST64_MAX UINT64_MAX

/* 7.18.2.3  Limits of fastest minimum-width integer types */
#define INT_FAST8_MIN INT8_MIN
#define INT_FAST16_MIN INT16_MIN
#define INT_FAST32_MIN INT32_MIN
#define INT_FAST64_MIN INT64_MIN

#define INT_FAST8_MAX INT8_MAX
#define INT_FAST16_MAX INT16_MAX
#define INT_FAST32_MAX INT32_MAX
#define INT_FAST64_MAX INT64_MAX

#define UINT_FAST8_MAX UINT8_MAX
#define UINT_FAST16_MAX UINT16_MAX
#define UINT_FAST32_MAX UINT32_MAX
#define UINT_FAST64_MAX UINT64_MAX

/* 7.18.2.4  Limits of integer types capable of holding
    object pointers */

#define INTPTR_MIN INT64_MIN
#define INTPTR_MAX INT64_MAX
#define UINTPTR_MAX UINT64_MAX






/* 7.18.2.5  Limits of greatest-width integer types */
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#define UINTMAX_MAX UINT64_MAX

/* 7.18.3  Limits of other integer types */

#define PTRDIFF_MIN INT64_MIN
#define PTRDIFF_MAX INT64_MAX





#define SIG_ATOMIC_MIN INT32_MIN
#define SIG_ATOMIC_MAX INT32_MAX



#define SIZE_MAX UINT64_MAX






#define WCHAR_MIN 0U
#define WCHAR_MAX 0xffffU


/*
 * wint_t is unsigned short for compatibility with MS runtime
 */
#define WINT_MIN 0U
#define WINT_MAX 0xffffU




/* 7.18.4  Macros for integer constants */



/* 7.18.4.1  Macros for minimum-width integer constants

    Accoding to Douglas Gwyn <gwyn@arl.mil>:
	"This spec was changed in ISO/IEC 9899:1999 TC1; in ISO/IEC
	9899:1999 as initially published, the expansion was required
	to be an integer constant of precisely matching type, which
	is impossible to accomplish for the shorter types on most
	platforms, because C99 provides no standard way to designate
	an integer constant with width less than that of type int.
	TC1 changed this to require just an integer constant
	*expression* with *promoted* type."

	The trick used here is from Clive D W Feather.
*/

#define INT8_C(val) (INT_LEAST8_MAX-INT_LEAST8_MAX+(val))
#define INT16_C(val) (INT_LEAST16_MAX-INT_LEAST16_MAX+(val))
#define INT32_C(val) (INT_LEAST32_MAX-INT_LEAST32_MAX+(val))
/*  The 'trick' doesn't work in C89 for long long because, without
    suffix, (val) will be evaluated as int, not intmax_t */
#define INT64_C(val) val ##LL

#define UINT8_C(val) (val)
#define UINT16_C(val) (val)
#define UINT32_C(val) (val ##U)
#define UINT64_C(val) val ##ULL

/* 7.18.4.2  Macros for greatest-width integer constants */
#define INTMAX_C(val) val ##LL
#define UINTMAX_C(val) val ##ULL



# 12 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/stdint.h" 2 3 4
#pragma GCC diagnostic pop



#define _GCC_WRAP_STDINT_H 
# 38 "build/vendor/unity/src/unity_internals.h" 2



# 1 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/limits.h" 1 3 4
/* Copyright (C) 1992-2025 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */

#define _GCC_LIMITS_H_ 


/* Use "..." so that we find syslimits.h only in this same directory.  */
# 1 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/syslimits.h" 1 3 4
/* syslimits.h stands for the system's own limits.h file.
   If we can use it ok unmodified, then we install this text.
   If fixincludes fixes it, then the fixed version is installed
   instead of this text.  */

#define _GCC_NEXT_LIMITS_H 
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 1 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/limits.h" 1 3 4
/* Copyright (C) 1992-2025 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
# 208 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/limits.h" 3 4


# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/limits.h" 1 3 4
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */



#define _INC_LIMITS 

/*
 * File system limits
 *
 * NOTE: Apparently the actual size of PATH_MAX is 260, but a space is
 *       required for the NUL. TODO: Test?
 * NOTE: PATH_MAX is the POSIX equivalent for Microsoft's MAX_PATH; the two
 *       are semantically identical, with a limit of 259 characters for the
 *       path name, plus one for a terminating NUL, for a total of 260.
 */
#define PATH_MAX 260

#define CHAR_BIT 8
#define SCHAR_MIN (-128)
#define SCHAR_MAX 127
#define UCHAR_MAX 0xff





#define CHAR_MIN SCHAR_MIN
#define CHAR_MAX SCHAR_MAX


#define MB_LEN_MAX 5
#define SHRT_MIN (-32768)
#define SHRT_MAX 32767
#define USHRT_MAX 0xffffU
#define INT_MIN (-2147483647 - 1)
#define INT_MAX 2147483647
#define UINT_MAX 0xffffffffU
#define LONG_MIN (-2147483647L - 1)
#define LONG_MAX 2147483647L
#define ULONG_MAX 0xffffffffUL
#define LLONG_MAX 9223372036854775807ll
#define LLONG_MIN (-9223372036854775807ll - 1)
#define ULLONG_MAX 0xffffffffffffffffull

#define _I8_MIN (-127 - 1)
#define _I8_MAX 127
#define _UI8_MAX 0xffu

#define _I16_MIN (-32767 - 1)
#define _I16_MAX 32767
#define _UI16_MAX 0xffffu

#define _I32_MIN (-2147483647 - 1)
#define _I32_MAX 2147483647
#define _UI32_MAX 0xffffffffu


#undef LONG_LONG_MAX
#define LONG_LONG_MAX 9223372036854775807ll
#undef LONG_LONG_MIN
#define LONG_LONG_MIN (-LONG_LONG_MAX-1)
#undef ULONG_LONG_MAX
#define ULONG_LONG_MAX (2ull * LONG_LONG_MAX + 1ull)


#define _I64_MIN (-9223372036854775807ll - 1)
#define _I64_MAX 9223372036854775807ll
#define _UI64_MAX 0xffffffffffffffffull











#define SSIZE_MAX _I64_MAX





# 118 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/limits.h" 3 4

# 211 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/limits.h" 2 3 4


# 10 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/syslimits.h" 2 3 4
#pragma GCC diagnostic pop
#undef _GCC_NEXT_LIMITS_H
# 35 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/limits.h" 2 3 4

/* Copyright (C) 1991-2025 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */


#define _LIMITS_H___ 

/* Number of bits in a `char'.  */
#undef CHAR_BIT
#define CHAR_BIT __CHAR_BIT__

/* Maximum length of a multibyte character.  */




/* Minimum and maximum values a `signed char' can hold.  */
#undef SCHAR_MIN
#define SCHAR_MIN (-SCHAR_MAX - 1)
#undef SCHAR_MAX
#define SCHAR_MAX __SCHAR_MAX__

/* Maximum value an `unsigned char' can hold.  (Minimum is 0).  */
#undef UCHAR_MAX



#define UCHAR_MAX (SCHAR_MAX * 2 + 1)


/* Minimum and maximum values a `char' can hold.  */
# 96 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/limits.h" 3 4
#undef CHAR_MIN
#define CHAR_MIN SCHAR_MIN
#undef CHAR_MAX
#define CHAR_MAX SCHAR_MAX


/* Minimum and maximum values a `signed short int' can hold.  */
#undef SHRT_MIN
#define SHRT_MIN (-SHRT_MAX - 1)
#undef SHRT_MAX
#define SHRT_MAX __SHRT_MAX__

/* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  */
#undef USHRT_MAX



#define USHRT_MAX (SHRT_MAX * 2 + 1)


/* Minimum and maximum values a `signed int' can hold.  */
#undef INT_MIN
#define INT_MIN (-INT_MAX - 1)
#undef INT_MAX
#define INT_MAX __INT_MAX__

/* Maximum value an `unsigned int' can hold.  (Minimum is 0).  */
#undef UINT_MAX
#define UINT_MAX (INT_MAX * 2U + 1U)

/* Minimum and maximum values a `signed long int' can hold.
   (Same as `int').  */
#undef LONG_MIN
#define LONG_MIN (-LONG_MAX - 1L)
#undef LONG_MAX
#define LONG_MAX __LONG_MAX__

/* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  */
#undef ULONG_MAX
#define ULONG_MAX (LONG_MAX * 2UL + 1UL)


/* Minimum and maximum values a `signed long long int' can hold.  */
#undef LLONG_MIN
#define LLONG_MIN (-LLONG_MAX - 1LL)
#undef LLONG_MAX
#define LLONG_MAX __LONG_LONG_MAX__

/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */
#undef ULLONG_MAX
#define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)



/* Minimum and maximum values a `signed long long int' can hold.  */
#undef LONG_LONG_MIN
#define LONG_LONG_MIN (-LONG_LONG_MAX - 1LL)
#undef LONG_LONG_MAX
#define LONG_LONG_MAX __LONG_LONG_MAX__

/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */
#undef ULONG_LONG_MAX
#define ULONG_LONG_MAX (LONG_LONG_MAX * 2ULL + 1ULL)




/* TS 18661-1 / C23 widths of integer types.  */
#undef CHAR_WIDTH
#define CHAR_WIDTH __SCHAR_WIDTH__
#undef SCHAR_WIDTH
#define SCHAR_WIDTH __SCHAR_WIDTH__
#undef UCHAR_WIDTH
#define UCHAR_WIDTH __SCHAR_WIDTH__
#undef SHRT_WIDTH
#define SHRT_WIDTH __SHRT_WIDTH__
#undef USHRT_WIDTH
#define USHRT_WIDTH __SHRT_WIDTH__
#undef INT_WIDTH
#define INT_WIDTH __INT_WIDTH__
#undef UINT_WIDTH
#define UINT_WIDTH __INT_WIDTH__
#undef LONG_WIDTH
#define LONG_WIDTH __LONG_WIDTH__
#undef ULONG_WIDTH
#define ULONG_WIDTH __LONG_WIDTH__
#undef LLONG_WIDTH
#define LLONG_WIDTH __LONG_LONG_WIDTH__
#undef ULLONG_WIDTH
#define ULLONG_WIDTH __LONG_LONG_WIDTH__



/* C23 width and limit of _Bool.  */
#undef BOOL_MAX
#define BOOL_MAX 1
#undef BOOL_WIDTH
#define BOOL_WIDTH 1


#undef BITINT_MAXWIDTH
#define BITINT_MAXWIDTH __BITINT_MAXWIDTH__


#define __STDC_VERSION_LIMITS_H__ 202311L



/* This administrivia gets added to the end of limits.h
   if the system has its own version of limits.h.  */

# 42 "build/vendor/unity/src/unity_internals.h" 2



  #define UNITY_FUNCTION_ATTR(a) __attribute__((a))




/* UNITY_NORETURN is only required if we have setjmp.h. */

  
    # 87 "build/vendor/unity/src/unity_internals.h"
      /* Since C23, the keyword _Noreturn has been replaced by the attribute noreturn, based on: */
      /* https://en.cppreference.com/w/c/language/attributes/noreturn */
      #define UNITY_NORETURN [[ noreturn ]]
    
  
  




/*-------------------------------------------------------
 * Guess Widths If Not Specified
 *-------------------------------------------------------*/

/* Determine the size of an int, if not already specified.
 * We cannot use sizeof(int), because it is not yet defined
 * at this stage in the translation of the C program.
 * Also sizeof(int) does return the size in addressable units on all platforms,
 * which may not necessarily be the size in bytes.
 * Therefore, infer it from UINT_MAX if possible. */

  
    


      #define UNITY_INT_WIDTH (32)
    


  




/* Determine the size of a long, if not already specified. */

  
    


      #define UNITY_LONG_WIDTH (32)
    


  




/* Determine the size of a pointer, if not already specified. */

  
    




      #define UNITY_POINTER_WIDTH (64)
    
  




/*-------------------------------------------------------
 * Int Support (Define types based on detected sizes)
 *-------------------------------------------------------*/


    typedef unsigned char   UNITY_UINT8;
    typedef unsigned short  UNITY_UINT16;
    typedef unsigned int    UNITY_UINT32;
    typedef signed char     UNITY_INT8;
    typedef signed short    UNITY_INT16;
    typedef signed int      UNITY_INT32;
# 172 "build/vendor/unity/src/unity_internals.h"

/*-------------------------------------------------------
 * 64-bit Support
 *-------------------------------------------------------*/

/* Auto-detect 64 Bit Support */

  
    #define UNITY_SUPPORT_64 
  


/* 64-Bit Support Dependent Configuration */






  /* 64-bit Support */
  
    typedef unsigned long long UNITY_UINT64;
    typedef signed long long   UNITY_INT64;
  





    typedef UNITY_UINT64 UNITY_UINT;
    typedef UNITY_INT64  UNITY_INT;
    #define UNITY_MAX_NIBBLES (16)


/*-------------------------------------------------------
 * Pointer Support
 *-------------------------------------------------------*/





  #define UNITY_PTR_TO_INT UNITY_INT64
  #define UNITY_DISPLAY_STYLE_POINTER UNITY_DISPLAY_STYLE_HEX64








  #define UNITY_PTR_ATTRIBUTE 



  #define UNITY_INTERNAL_PTR UNITY_PTR_ATTRIBUTE const void*


/* optionally define UNITY_COMPARE_PTRS_ON_ZERO_ARRAY */

/*-------------------------------------------------------
 * Float Support
 *-------------------------------------------------------*/

# 248 "build/vendor/unity/src/unity_internals.h"

/* Floating Point Support */

#define UNITY_FLOAT_PRECISION (0.00001f)


#define UNITY_FLOAT_TYPE float

typedef UNITY_FLOAT_TYPE UNITY_FLOAT;

/* isnan macro should be provided by math.h. Override if not macro */






#define UNITY_IS_NAN(n) isnan(n)



/* isinf macro should be provided by math.h. Override if not macro */





#define UNITY_IS_INF(n) isinf(n)





/*-------------------------------------------------------
 * Double Float Support
 *-------------------------------------------------------*/

/* unlike float, we DON'T include by default */


  /* No Floating Point Support */
  
  #define UNITY_EXCLUDE_DOUBLE 
  



  
    
    #define UNITY_DOUBLE_TYPE double
    
  typedef UNITY_FLOAT UNITY_DOUBLE;
  /* For parameter in UnityPrintFloat(UNITY_DOUBLE), which aliases to double or float */
  

# 316 "build/vendor/unity/src/unity_internals.h"

/*-------------------------------------------------------
 * Output Method: stdout (DEFAULT)
 *-------------------------------------------------------*/

  /* Default to using putchar, which is defined in stdio.h */
  # 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 1 3
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */

#define _INC_STDIO 

# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/corecrt_stdio_config.h" 1 3
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the Wine project.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */


#define _STDIO_CONFIG_DEFINED 







unsigned __int64* __cdecl __local_stdio_printf_options(void);
unsigned __int64* __cdecl __local_stdio_scanf_options(void);

#define _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION 0x0001ULL
#define _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR 0x0002ULL
#define _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS 0x0004ULL
#define _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY 0x0008ULL
#define _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS 0x0010ULL
#define _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING 0x0020ULL

#define _CRT_INTERNAL_SCANF_SECURECRT 0x0001ULL
#define _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS 0x0002ULL
#define _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY 0x0004ULL


#define _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS (*__local_stdio_printf_options())



#define _CRT_INTERNAL_LOCAL_SCANF_OPTIONS (*__local_stdio_scanf_options())





# 10 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3

#pragma pack(push,_CRT_PACKING)

       
#undef snprintf
       
#undef vsnprintf
       
#undef snwprintf
       
#undef vsnwprintf





#define BUFSIZ 512
#define _NFILE _NSTREAM_
#define _NSTREAM_ 512
#define _IOB_ENTRIES 20
#define EOF (-1)


  struct _iobuf {

    void *_Placeholder;
# 46 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  };
  typedef struct _iobuf FILE;
#define _FILE_DEFINED 






#define _P_tmpdir "\\"
#define _wP_tmpdir L"\\"



#define L_tmpnam 260









#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0

#define STDIN_FILENO 0
#define STDOUT_FILENO 1
#define STDERR_FILENO 2

#define FILENAME_MAX 260
#define FOPEN_MAX 20
#define _SYS_OPEN 20

#define TMP_MAX 2147483647




# 98 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3

# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/_mingw_off_t.h" 1 3

#define _OFF_T_DEFINED 

#define _OFF_T_ 
  typedef long _off_t;

  typedef long off32_t;




#define _OFF64_T_DEFINED 
  __MINGW_EXTENSION typedef long long _off64_t;

  __MINGW_EXTENSION typedef long long off64_t;





#define _FILE_OFFSET_BITS_SET_OFFT 




typedef off32_t off_t;





# 100 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3

_CRTIMP FILE *__cdecl __acrt_iob_func(unsigned index);

  _CRTIMP FILE *__cdecl __iob_func(void);
#define _iob __iob_func()



#define _FPOS_T_DEFINED 
#undef _FPOSOFF


  __MINGW_EXTENSION typedef __int64 fpos_t;
#define _FPOSOFF(fp) ((long)(fp))








#define _STDSTREAM_DEFINED 

#define stdin (__acrt_iob_func(0))
#define stdout (__acrt_iob_func(1))
#define stderr (__acrt_iob_func(2))


#define _IOFBF 0x0000
#define _IOLBF 0x0040
#define _IONBF 0x0004

# 145 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3

/* used with _set_output_format which is not present in ucrt */









extern
  __MINGW_GNU_SCANF(2, 3) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __mingw_sscanf(const char * __restrict__ _Src,const char * __restrict__ _Format,...);
extern
  __MINGW_GNU_SCANF(2, 0) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __mingw_vsscanf (const char * __restrict__ _Str,const char * __restrict__ Format,va_list argp);
extern
  __MINGW_GNU_SCANF(1, 2) __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __mingw_scanf(const char * __restrict__ _Format,...);
extern
  __MINGW_GNU_SCANF(1, 0) __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __mingw_vscanf(const char * __restrict__ Format, va_list argp);
extern
  __MINGW_GNU_SCANF(2, 3) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __mingw_fscanf(FILE * __restrict__ _File,const char * __restrict__ _Format,...);
extern
  __MINGW_GNU_SCANF(2, 0) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __mingw_vfscanf (FILE * __restrict__ fp, const char * __restrict__ Format,va_list argp);

extern
  __MINGW_GNU_PRINTF(3, 0) __MINGW_ATTRIB_NONNULL(3)
  int __cdecl __mingw_vsnprintf(char * __restrict__ _DstBuf,size_t _MaxCount,const char * __restrict__ _Format,
                               va_list _ArgList);
extern
  __MINGW_GNU_PRINTF(3, 4) __MINGW_ATTRIB_NONNULL(3)
  int __cdecl __mingw_snprintf(char * __restrict__ s, size_t n, const char * __restrict__  format, ...);
extern
  __MINGW_GNU_PRINTF(1, 2) __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __mingw_printf(const char * __restrict__ , ... ) __MINGW_NOTHROW;
extern
  __MINGW_GNU_PRINTF(1, 0) __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __mingw_vprintf (const char * __restrict__ , va_list) __MINGW_NOTHROW;
extern
  __MINGW_GNU_PRINTF(2, 3) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __mingw_fprintf (FILE * __restrict__ , const char * __restrict__ , ...) __MINGW_NOTHROW;
extern
  __MINGW_GNU_PRINTF(2, 0) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __mingw_vfprintf (FILE * __restrict__ , const char * __restrict__ , va_list) __MINGW_NOTHROW;
extern
  __MINGW_GNU_PRINTF(2, 3) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __mingw_sprintf (char * __restrict__ , const char * __restrict__ , ...) __MINGW_NOTHROW;
extern
  __MINGW_GNU_PRINTF(2, 0) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __mingw_vsprintf (char * __restrict__ , const char * __restrict__ , va_list) __MINGW_NOTHROW;
extern
  __MINGW_GNU_PRINTF(2, 3) __attribute__((nonnull (1,2)))
  int __cdecl __mingw_asprintf(char ** __restrict__ , const char * __restrict__ , ...) __MINGW_NOTHROW;
extern
  __MINGW_GNU_PRINTF(2, 0) __attribute__((nonnull (1,2)))
  int __cdecl __mingw_vasprintf(char ** __restrict__ , const char * __restrict__ , va_list) __MINGW_NOTHROW;

extern
  __MINGW_MS_SCANF(2, 3) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __ms_sscanf(const char * __restrict__ _Src,const char * __restrict__ _Format,...)
  __MINGW_UCRT_ASM_CALL(sscanf);
extern
  __MINGW_MS_SCANF(2, 0) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __ms_vsscanf(const char * __restrict__ _Str,const char * __restrict__ _Format,va_list argp)
  __MINGW_ASM_CALL(vsscanf);
extern
  __MINGW_MS_SCANF(1, 2) __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __ms_scanf(const char * __restrict__ _Format,...)
  __MINGW_UCRT_ASM_CALL(scanf);
extern
  __MINGW_MS_SCANF(1, 0) __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __ms_vscanf(const char * __restrict__ _Format,va_list argp)
  __MINGW_ASM_CALL(vscanf);
extern
  __MINGW_MS_SCANF(2, 3) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __ms_fscanf(FILE * __restrict__ _File,const char * __restrict__ _Format,...)
  __MINGW_UCRT_ASM_CALL(fscanf);
extern
  __MINGW_MS_SCANF(2, 0) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __ms_vfscanf(FILE * __restrict__ _File,const char * __restrict__ _Format,va_list argp)
  __MINGW_ASM_CALL(vfscanf);

extern
  __MINGW_MS_PRINTF(1, 2) __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __ms_printf(const char * __restrict__ , ... )
  __MINGW_UCRT_ASM_CALL(printf) __MINGW_NOTHROW;
extern
  __MINGW_MS_PRINTF(1, 0) __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __ms_vprintf (const char * __restrict__ , va_list)
  __MINGW_UCRT_ASM_CALL(vprintf) __MINGW_NOTHROW;
extern
  __MINGW_MS_PRINTF(2, 3) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __ms_fprintf (FILE * __restrict__ , const char * __restrict__ , ...)
  __MINGW_UCRT_ASM_CALL(fprintf) __MINGW_NOTHROW;
extern
  __MINGW_MS_PRINTF(2, 0) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __ms_vfprintf (FILE * __restrict__ , const char * __restrict__ , va_list)
  __MINGW_UCRT_ASM_CALL(vfprintf) __MINGW_NOTHROW
;
extern
  __MINGW_MS_PRINTF(2, 3) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __ms_sprintf (char * __restrict__ , const char * __restrict__ , ...)
  __MINGW_UCRT_ASM_CALL(sprintf) __MINGW_NOTHROW;
extern
  __MINGW_MS_PRINTF(2, 0) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __ms_vsprintf (char * __restrict__ , const char * __restrict__ , va_list)
  __MINGW_UCRT_ASM_CALL(vsprintf) __MINGW_NOTHROW;
extern
  __MINGW_MS_PRINTF(3, 4) __MINGW_ATTRIB_NONNULL(3)
  int __cdecl __ms_snprintf (char * __restrict__ , size_t , const char * __restrict__ , ...)
  __MINGW_UCRT_ASM_CALL(snprintf) __MINGW_NOTHROW;
extern
  __MINGW_MS_PRINTF(3, 0) __MINGW_ATTRIB_NONNULL(3)
  int __cdecl __ms_vsnprintf (char * __restrict__ , size_t , const char * __restrict__ , va_list)
  __MINGW_UCRT_ASM_CALL(vsnprintf) __MINGW_NOTHROW;


  int __cdecl __stdio_common_vsprintf(unsigned __int64 options, char *str, size_t len, const char *format, _locale_t locale, va_list valist);
  int __cdecl __stdio_common_vfprintf(unsigned __int64 options, FILE *file, const char *format, _locale_t locale, va_list valist);
  int __cdecl __stdio_common_vsscanf(unsigned __int64 options, const char *input, size_t length, const char *format, _locale_t locale, va_list valist);
  int __cdecl __stdio_common_vfscanf(unsigned __int64 options, FILE *file, const char *format, _locale_t locale, va_list valist);


#undef __MINGW_PRINTF_FORMAT
#undef __MINGW_SCANF_FORMAT





#define __MINGW_PRINTF_FORMAT __gnu_printf__
#define __MINGW_SCANF_FORMAT __gnu_scanf__





# 435 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3

#undef __builtin_vsnprintf
#undef __builtin_vsprintf

/*
 * Default configuration: simply direct all calls to MSVCRT...
 */


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wshadow"

  __attribute__((__format__ (__MINGW_PRINTF_FORMAT, 2, 3))) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl fprintf(FILE * __restrict__ _File,const char * __restrict__ _Format,...);
  __attribute__((__format__ (__MINGW_PRINTF_FORMAT, 1, 2))) __MINGW_ATTRIB_NONNULL(1)
  int __cdecl printf(const char * __restrict__ _Format,...);
  __attribute__((__format__ (__MINGW_PRINTF_FORMAT, 2, 3))) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl sprintf(char * __restrict__ _Dest,const char * __restrict__ _Format,...) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;

  __attribute__((__format__ (__MINGW_PRINTF_FORMAT, 2, 0))) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl vfprintf(FILE * __restrict__ _File,const char * __restrict__ _Format,va_list _ArgList);
  __attribute__((__format__ (__MINGW_PRINTF_FORMAT, 1, 0))) __MINGW_ATTRIB_NONNULL(1)
  int __cdecl vprintf(const char * __restrict__ _Format,va_list _ArgList);
  __attribute__((__format__ (__MINGW_PRINTF_FORMAT, 2, 0))) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl vsprintf(char * __restrict__ _Dest,const char * __restrict__ _Format,va_list _Args) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;

  __MINGW_ATTRIB_DEPRECATED_SEC_WARN
  __attribute__((__format__ (__MINGW_SCANF_FORMAT, 2, 3))) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl fscanf(FILE * __restrict__ _File,const char * __restrict__ _Format,...);
  __MINGW_ATTRIB_DEPRECATED_SEC_WARN
  __attribute__((__format__ (__MINGW_SCANF_FORMAT, 1, 2))) __MINGW_ATTRIB_NONNULL(1)
  int __cdecl scanf(const char * __restrict__ _Format,...);
  __MINGW_ATTRIB_DEPRECATED_SEC_WARN
  __attribute__((__format__ (__MINGW_SCANF_FORMAT, 2, 3))) __MINGW_ATTRIB_NONNULL(2)
  int __cdecl sscanf(const char * __restrict__ _Src,const char * __restrict__ _Format,...);







  __attribute__((__format__ (__MINGW_SCANF_FORMAT, 2, 0))) __MINGW_ATTRIB_NONNULL(2)
  int vfscanf (FILE *__stream,  const char *__format, __builtin_va_list __local_argv);

  __attribute__((__format__ (__MINGW_SCANF_FORMAT, 2, 0))) __MINGW_ATTRIB_NONNULL(2)
  int vsscanf (const char * __restrict__ __source, const char * __restrict__ __format, __builtin_va_list __local_argv);
  __attribute__((__format__ (__MINGW_SCANF_FORMAT, 1, 0))) __MINGW_ATTRIB_NONNULL(1)
  int vscanf(const char *__format,  __builtin_va_list __local_argv);


#pragma GCC diagnostic pop


# 533 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3


  _CRTIMP int __cdecl _filbuf(FILE *_File);
  _CRTIMP int __cdecl _flsbuf(int _Ch,FILE *_File);



  _CRTIMP FILE *__cdecl _fsopen(const char *_Filename,const char *_Mode,int _ShFlag);

  void __cdecl clearerr(FILE *_File);
  int __cdecl fclose(FILE *_File);
  _CRTIMP int __cdecl _fcloseall(void);



  _CRTIMP FILE *__cdecl _fdopen(int _FileHandle,const char *_Mode);

  int __cdecl feof(FILE *_File);
  int __cdecl ferror(FILE *_File);
  int __cdecl fflush(FILE *_File);
  int __cdecl fgetc(FILE *_File);
  _CRTIMP int __cdecl _fgetchar(void);
  int __cdecl fgetpos(FILE * __restrict__ _File ,fpos_t * __restrict__ _Pos); /* 64bit only, no 32bit version */
  int __cdecl fgetpos64(FILE * __restrict__ _File ,fpos_t * __restrict__ _Pos); /* fgetpos already 64bit */
  char *__cdecl fgets(char * __restrict__ _Buf,int _MaxCount,FILE * __restrict__ _File);
  _CRTIMP int __cdecl _fileno(FILE *_File);







  _CRTIMP char *__cdecl _tempnam(const char *_DirName,const char *_FilePrefix);



  _CRTIMP int __cdecl _flushall(void);
  FILE *__cdecl fopen(const char * __restrict__ _Filename,const char * __restrict__ _Mode) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;
  FILE *fopen64(const char * __restrict__ filename,const char * __restrict__  mode);
  int __cdecl fputc(int _Ch,FILE *_File);
  _CRTIMP int __cdecl _fputchar(int _Ch);
  int __cdecl fputs(const char * __restrict__ _Str,FILE * __restrict__ _File);
  size_t __cdecl fread(void * __restrict__ _DstBuf,size_t _ElementSize,size_t _Count,FILE * __restrict__ _File);
  FILE *__cdecl freopen(const char * __restrict__ _Filename,const char * __restrict__ _Mode,FILE * __restrict__ _File) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;
  int __cdecl fsetpos(FILE *_File,const fpos_t *_Pos);
  int __cdecl fsetpos64(FILE *_File,const fpos_t *_Pos); /* fsetpos already 64bit */
  int __cdecl fseek(FILE *_File,long _Offset,int _Origin);
  long __cdecl ftell(FILE *_File);

  /* Shouldn't be any fseeko32 in glibc, 32bit to 64bit casting should be fine */
  /* int fseeko32(FILE* stream, _off_t offset, int whence);*/ /* fseeko32 redirects to fseeko64 */
  _CRTIMP int __cdecl _fseeki64(FILE *_File,__int64 _Offset,int _Origin);
  _CRTIMP __int64 __cdecl _ftelli64(FILE *_File);

  __mingw_ovr int fseeko(FILE *_File, _off_t _Offset, int _Origin) {
    return fseek(_File, _Offset, _Origin);
  }
  __mingw_ovr int fseeko64(FILE *_File, _off64_t _Offset, int _Origin) {
    return _fseeki64(_File, _Offset, _Origin);
  }
  __mingw_ovr _off_t ftello(FILE *_File) {
    return ftell(_File);
  }
  __mingw_ovr _off64_t ftello64(FILE *_File) {
    return _ftelli64(_File);
  }









#define _FILE_OFFSET_BITS_SET_FSEEKO 






#define _FILE_OFFSET_BITS_SET_FTELLO 





  size_t __cdecl fwrite(const void * __restrict__ _Str,size_t _Size,size_t _Count,FILE * __restrict__ _File);
  int __cdecl getc(FILE *_File);
  int __cdecl getchar(void);
  _CRTIMP int __cdecl _getmaxstdio(void);
  char *__cdecl gets(char *_Buffer)
    __attribute__((__warning__("Using gets() is always unsafe - use fgets() instead")));
  int __cdecl _getw(FILE *_File);

#define _CRT_PERROR_DEFINED 
  void __cdecl perror(const char *_ErrMsg);


  _CRTIMP int __cdecl _pclose(FILE *_File);
  _CRTIMP FILE *__cdecl _popen(const char *_Command,const char *_Mode);

#define popen _popen
#define pclose _pclose


  int __cdecl putc(int _Ch,FILE *_File);
  int __cdecl putchar(int _Ch);
  int __cdecl puts(const char *_Str);
  _CRTIMP int __cdecl _putw(int _Word,FILE *_File);

#define _CRT_DIRECTORY_DEFINED 
  int __cdecl remove(const char *_Filename);
  int __cdecl rename(const char *_OldFilename,const char *_NewFilename);
  _CRTIMP int __cdecl _unlink(const char *_Filename);

  int __cdecl unlink(const char *_Filename) __MINGW_ATTRIB_DEPRECATED_MSVC2005;


  void __cdecl rewind(FILE *_File);
  _CRTIMP int __cdecl _rmtmp(void);
  void __cdecl setbuf(FILE * __restrict__ _File,char * __restrict__ _Buffer) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;
  _CRTIMP int __cdecl _setmaxstdio(int _Max);
  _CRTIMP unsigned int __cdecl _set_output_format(unsigned int _Format);
  _CRTIMP unsigned int __cdecl _get_output_format(void);
  int __cdecl setvbuf(FILE * __restrict__ _File,char * __restrict__ _Buf,int _Mode,size_t _Size);

  __MINGW_ATTRIB_PURE
  __attribute__((__format__ (__MINGW_PRINTF_FORMAT, 1, 2))) __MINGW_ATTRIB_NONNULL(1)
  int __cdecl _scprintf(const char * __restrict__ _Format,...);
  __attribute__((__format__ (__MINGW_SCANF_FORMAT, 3, 4))) __MINGW_ATTRIB_NONNULL(3)
  int __cdecl _snscanf(const char * __restrict__ _Src,size_t _MaxCount,const char * __restrict__ _Format,...) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;







  __MINGW_ATTRIB_PURE
  __MINGW_MS_PRINTF(1, 0) __MINGW_ATTRIB_NONNULL(1)
  _CRTIMP int __cdecl _vscprintf(const char * __restrict__ _Format,va_list _ArgList);
  FILE *__cdecl tmpfile(void) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;
  char *__cdecl tmpnam(char *_Buffer);
  int __cdecl ungetc(int _Ch,FILE *_File);


  __attribute__((__format__ (__MINGW_PRINTF_FORMAT, 3, 0))) __MINGW_ATTRIB_NONNULL(3)
  int __cdecl _vsnprintf(char * __restrict__ _Dest,size_t _Count,const char * __restrict__ _Format,va_list _Args) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;
  __attribute__((__format__ (__MINGW_PRINTF_FORMAT, 3, 4))) __MINGW_ATTRIB_NONNULL(3)
  int __cdecl _snprintf(char * __restrict__ _Dest,size_t _Count,const char * __restrict__ _Format,...) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;







# 732 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wshadow"

  __attribute__((__format__ (__MINGW_PRINTF_FORMAT, 3, 0))) __MINGW_ATTRIB_NONNULL(3)
  int vsnprintf (char * __restrict__ __stream, size_t __n, const char * __restrict__ __format, va_list __local_argv);

  __attribute__((__format__ (__MINGW_PRINTF_FORMAT, 3, 4))) __MINGW_ATTRIB_NONNULL(3)
  int snprintf (char * __restrict__ __stream, size_t __n, const char * __restrict__ __format, ...);

# 773 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3

# 801 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3


#pragma GCC diagnostic pop

# 903 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3


  _CRTIMP int __cdecl _set_printf_count_output(int _Value);
  _CRTIMP int __cdecl _get_printf_count_output(void);


#define _WSTDIO_DEFINED 

/* __attribute__((__format__ (gnu_wscanf, 2, 3))) */ __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __mingw_swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...);
/* __attribute__((__format__ (gnu_wscanf, 2, 0))) */ __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __mingw_vswscanf (const wchar_t * __restrict__ _Str,const wchar_t * __restrict__ Format,va_list argp);
/* __attribute__((__format__ (gnu_wscanf, 1, 2))) */ __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __mingw_wscanf(const wchar_t * __restrict__ _Format,...);
/* __attribute__((__format__ (gnu_wscanf, 1, 0))) */ __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __mingw_vwscanf(const wchar_t * __restrict__ Format, va_list argp);
/* __attribute__((__format__ (gnu_wscanf, 2, 3))) */ __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __mingw_fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
/* __attribute__((__format__ (gnu_wscanf, 2, 0))) */ __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __mingw_vfwscanf (FILE * __restrict__ fp, const wchar_t * __restrict__ Format,va_list argp);

/* __attribute__((__format__ (gnu_wprintf, 2, 3))) */ __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __mingw_fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
/* __attribute__((__format__ (gnu_wprintf, 1, 2))) */ __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __mingw_wprintf(const wchar_t * __restrict__ _Format,...);
/* __attribute__((__format__ (gnu_wprintf, 2, 0))) */__MINGW_ATTRIB_NONNULL(2)
  int __cdecl __mingw_vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
/*__attribute__((__format__ (gnu_wprintf, 1, 0))) */ __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __mingw_vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
/* __attribute__((__format__ (gnu_wprintf, 3, 4))) */ __MINGW_ATTRIB_NONNULL(3)
  int __cdecl __mingw_snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...);
/* __attribute__((__format__ (gnu_wprintf, 3, 0))) */ __MINGW_ATTRIB_NONNULL(3)
  int __cdecl __mingw_vsnwprintf (wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , va_list);
/* __attribute__((__format__ (gnu_wprintf, 3, 4))) */ __MINGW_ATTRIB_NONNULL(3)
  int __cdecl __mingw_swprintf(wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , ...);
/* __attribute__((__format__ (gnu_wprintf, 3, 0))) */ __MINGW_ATTRIB_NONNULL(3)
  int __cdecl __mingw_vswprintf(wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ ,va_list);

/* __attribute__((__format__ (ms_wscanf, 2, 3))) */ __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __ms_swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...)
  __MINGW_UCRT_ASM_CALL(swscanf);
/* __attribute__((__format__ (ms_wscanf, 2, 0))) */ __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __ms_vswscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,va_list)
  __MINGW_ASM_CALL(vswscanf);
/* __attribute__((__format__ (ms_wscanf, 1, 2))) */ __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __ms_wscanf(const wchar_t * __restrict__ _Format,...)
  __MINGW_UCRT_ASM_CALL(wscanf);
/* __attribute__((__format__ (ms_wscanf, 1, 0))) */ __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __ms_vwscanf(const wchar_t * __restrict__ _Format, va_list)
  __MINGW_ASM_CALL(vwscanf);
/* __attribute__((__format__ (ms_wscanf, 2, 3))) */ __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __ms_fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...)
  __MINGW_UCRT_ASM_CALL(fwscanf);
/* __attribute__((__format__ (ms_wscanf, 2, 0))) */ __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __ms_vfwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list)
  __MINGW_ASM_CALL(vfwscanf);

/* __attribute__((__format__ (ms_wprintf, 2, 3))) */ __MINGW_ATTRIB_NONNULL(2)
  int __cdecl __ms_fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
  /* No __MINGW_UCRT_ASM_CALL for __ms_fwprintf; this is provided as an
   * actual function in the ucrt import libraries. */
/* __attribute__((__format__ (ms_wprintf, 1, 2))) */ __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __ms_wprintf(const wchar_t * __restrict__ _Format,...)
  __MINGW_UCRT_ASM_CALL(wprintf);
/* __attribute__((__format__ (ms_wprintf, 2, 0))) */__MINGW_ATTRIB_NONNULL(2)
  int __cdecl __ms_vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList)
  __MINGW_UCRT_ASM_CALL(vfwprintf);
/*__attribute__((__format__ (ms_wprintf, 1, 0))) */ __MINGW_ATTRIB_NONNULL(1)
  int __cdecl __ms_vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList)
  __MINGW_UCRT_ASM_CALL(vwprintf);
/* __attribute__((__format__ (ms_wprintf, 3, 4))) */ __MINGW_ATTRIB_NONNULL(3)
  int __cdecl __ms_swprintf(wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , ...)
  __MINGW_UCRT_ASM_CALL(swprintf);
/* __attribute__((__format__ (ms_wprintf, 3, 0))) */ __MINGW_ATTRIB_NONNULL(3)
  int __cdecl __ms_vswprintf(wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ ,va_list)
  __MINGW_UCRT_ASM_CALL(vswprintf);
/* __attribute__((__format__ (ms_wprintf, 3, 4))) */ __MINGW_ATTRIB_NONNULL(3)
  int __cdecl __ms_snwprintf(wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , ...)
  __MINGW_UCRT_ASM_CALL(snwprintf);
/* __attribute__((__format__ (ms_wprintf, 3, 0))) */ __MINGW_ATTRIB_NONNULL(3)
  int __cdecl __ms_vsnwprintf(wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , va_list)
  __MINGW_UCRT_ASM_CALL(vsnwprintf);


  int __cdecl __stdio_common_vswprintf(unsigned __int64 options, wchar_t *str, size_t len, const wchar_t *format, _locale_t locale, va_list valist);
  int __cdecl __stdio_common_vfwprintf(unsigned __int64 options, FILE *file, const wchar_t *format, _locale_t locale, va_list valist);
  int __cdecl __stdio_common_vswscanf(unsigned __int64 options, const wchar_t *input, size_t length, const wchar_t *format, _locale_t locale, va_list valist);
  int __cdecl __stdio_common_vfwscanf(unsigned __int64 options, FILE *file, const wchar_t *format, _locale_t locale, va_list valist);


# 1099 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3


  __MINGW_ATTRIB_DEPRECATED_SEC_WARN
  int __cdecl fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);

  __MINGW_ATTRIB_DEPRECATED_SEC_WARN
  int __cdecl swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...);

  __MINGW_ATTRIB_DEPRECATED_SEC_WARN
  int __cdecl wscanf(const wchar_t * __restrict__ _Format,...);

  __MINGW_ATTRIB_NONNULL(2)
  int __cdecl vfwscanf(FILE *__stream,  const wchar_t *__format, va_list __local_argv);

  __MINGW_ATTRIB_NONNULL(2)
  int __cdecl vswscanf(const wchar_t * __restrict__ __source, const wchar_t * __restrict__ __format, va_list __local_argv);

  __MINGW_ATTRIB_NONNULL(1)
  int __cdecl vwscanf(const wchar_t *__format, va_list __local_argv);

  int __cdecl fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
  int __cdecl wprintf(const wchar_t * __restrict__ _Format,...);
  int __cdecl vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
  int __cdecl vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
# 1144 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3

  int __cdecl swprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,...);
  int __cdecl vswprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,va_list _Args);
  int __cdecl snwprintf(wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...);
  int __cdecl vsnwprintf(wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, va_list arg);



#define WEOF (wint_t)(0xFFFF)





  _CRTIMP FILE *__cdecl _wfsopen(const wchar_t *_Filename,const wchar_t *_Mode,int _ShFlag);


  wint_t __cdecl fgetwc(FILE *_File);
  _CRTIMP wint_t __cdecl _fgetwchar(void);
  wint_t __cdecl fputwc(wchar_t _Ch,FILE *_File);
  _CRTIMP wint_t __cdecl _fputwchar(wchar_t _Ch);
  wint_t __cdecl getwc(FILE *_File);
  wint_t __cdecl getwchar(void);
  wint_t __cdecl putwc(wchar_t _Ch,FILE *_File);
  wint_t __cdecl putwchar(wchar_t _Ch);
  wint_t __cdecl ungetwc(wint_t _Ch,FILE *_File);
  wchar_t *__cdecl fgetws(wchar_t * __restrict__ _Dst,int _SizeInWords,FILE * __restrict__ _File);
  int __cdecl fputws(const wchar_t * __restrict__ _Str,FILE * __restrict__ _File);
  _CRTIMP wchar_t *__cdecl _getws(wchar_t *_String) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;
  _CRTIMP int __cdecl _putws(const wchar_t *_Str);

  _CRTIMP int __cdecl _scwprintf(const wchar_t * __restrict__ _Format,...);




  _CRTIMP int __cdecl _snwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,...) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;
  _CRTIMP int __cdecl _vsnwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,va_list _Args) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;
  _CRTIMP int __cdecl _vscwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
  _CRTIMP int __cdecl _swprintf(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,...);
  _CRTIMP int __cdecl _vswprintf(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,va_list _Args);


# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/swprintf.inl" 1 3
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */


#define _INC_SWPRINTF_INL 

# 28 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/swprintf.inl" 3

# 1188 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3













  _CRTIMP wchar_t *__cdecl _wtempnam(const wchar_t *_Directory,const wchar_t *_FilePrefix);



  _CRTIMP int __cdecl _snwscanf(const wchar_t * __restrict__ _Src,size_t _MaxCount,const wchar_t * __restrict__ _Format,...);
  _CRTIMP FILE *__cdecl _wfdopen(int _FileHandle ,const wchar_t *_Mode);
  _CRTIMP FILE *__cdecl _wfopen(const wchar_t * __restrict__ _Filename,const wchar_t *__restrict__  _Mode) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;
  _CRTIMP FILE *__cdecl _wfreopen(const wchar_t * __restrict__ _Filename,const wchar_t * __restrict__ _Mode,FILE * __restrict__ _OldFile) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;


#define _CRT_WPERROR_DEFINED 
  _CRTIMP void __cdecl _wperror(const wchar_t *_ErrMsg);

  _CRTIMP FILE *__cdecl _wpopen(const wchar_t *_Command,const wchar_t *_Mode);

#define wpopen _wpopen


  _CRTIMP int __cdecl _wremove(const wchar_t *_Filename);
  _CRTIMP wchar_t *__cdecl _wtmpnam(wchar_t *_Buffer);

  _CRTIMP wint_t __cdecl _fgetwc_nolock(FILE *_File);
  _CRTIMP wint_t __cdecl _fputwc_nolock(wchar_t _Ch,FILE *_File);
  _CRTIMP wint_t __cdecl _ungetwc_nolock(wint_t _Ch,FILE *_File);


#undef _CRT_GETPUTWCHAR_NOINLINE


#define getwchar() fgetwc(stdin)
#define putwchar(_c) fputwc((_c),stdout)





#define getwc(_stm) fgetwc(_stm)
#define putwc(_c,_stm) fputwc(_c,_stm)

#define _putwc_nolock(_c,_stm) _fputwc_nolock(_c,_stm)
#define _getwc_nolock(_c) _fgetwc_nolock(_c)



#define _STDIO_DEFINED 



  _CRTIMP int __cdecl _fgetc_nolock(FILE *_File);
  _CRTIMP int __cdecl _fputc_nolock(int _Char, FILE *_File);
  _CRTIMP int __cdecl _getc_nolock(FILE *_File);
  _CRTIMP int __cdecl _putc_nolock(int _Char, FILE *_File);






#define _getchar_nolock() _getc_nolock(stdin)
#define _putchar_nolock(_c) _putc_nolock((_c),stdout)
#define _getwchar_nolock() _getwc_nolock(stdin)
#define _putwchar_nolock(_c) _putwc_nolock((_c),stdout)

  _CRTIMP void __cdecl _lock_file(FILE *_File);
  _CRTIMP void __cdecl _unlock_file(FILE *_File);

  _CRTIMP int __cdecl _fclose_nolock(FILE *_File);
  _CRTIMP int __cdecl _fflush_nolock(FILE *_File);
  _CRTIMP size_t __cdecl _fread_nolock(void * __restrict__ _DstBuf,size_t _ElementSize,size_t _Count,FILE * __restrict__ _File);
  _CRTIMP int __cdecl _fseek_nolock(FILE *_File,long _Offset,int _Origin);
  _CRTIMP long __cdecl _ftell_nolock(FILE *_File);
  __MINGW_EXTENSION _CRTIMP int __cdecl _fseeki64_nolock(FILE *_File,__int64 _Offset,int _Origin);
  __MINGW_EXTENSION _CRTIMP __int64 __cdecl _ftelli64_nolock(FILE *_File);
  _CRTIMP size_t __cdecl _fwrite_nolock(const void * __restrict__ _DstBuf,size_t _Size,size_t _Count,FILE * __restrict__ _File);
  _CRTIMP int __cdecl _ungetc_nolock(int _Ch,FILE *_File);



#define P_tmpdir _P_tmpdir
#define SYS_OPEN _SYS_OPEN





  char *__cdecl tempnam(const char *_Directory,const char *_FilePrefix) __MINGW_ATTRIB_DEPRECATED_MSVC2005;



  int __cdecl fcloseall(void) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
  FILE *__cdecl fdopen(int _FileHandle,const char *_Format) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
  int __cdecl fgetchar(void) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
  int __cdecl fileno(FILE *_File) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
  int __cdecl flushall(void) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
  int __cdecl fputchar(int _Ch) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
  int __cdecl getw(FILE *_File) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
  int __cdecl putw(int _Ch,FILE *_File) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
  int __cdecl rmtmp(void) __MINGW_ATTRIB_DEPRECATED_MSVC2005;



#define __MINGW_MBWC_CONVERT_DEFINED 

/**
 * __mingw_str_wide_utf8
 * Converts a null terminated UCS-2 string to a multibyte (UTF-8) equivalent.
 * Caller is supposed to free allocated buffer with __mingw_str_free().
 * @param[in] wptr Pointer to wide string.
 * @param[out] mbptr Pointer to multibyte string.
 * @param[out] buflen Optional parameter for length of allocated buffer.
 * @return Number of characters converted, 0 for failure.
 *
 * WideCharToMultiByte - http://msdn.microsoft.com/en-us/library/dd374130(VS.85).aspx
 */
int __cdecl __mingw_str_wide_utf8 (const wchar_t * const wptr, char **mbptr, size_t * buflen);

/**
 * __mingw_str_utf8_wide
 * Converts a null terminated UTF-8 string to a UCS-2 equivalent.
 * Caller is supposed to free allocated buffer with __mingw_str_free().
 * @param[out] mbptr Pointer to multibyte string.
 * @param[in] wptr Pointer to wide string.
 * @param[out] buflen Optional parameter for length of allocated buffer.
 * @return Number of characters converted, 0 for failure.
 *
 * MultiByteToWideChar - http://msdn.microsoft.com/en-us/library/dd319072(VS.85).aspx
 */

int __cdecl __mingw_str_utf8_wide (const char *const mbptr, wchar_t ** wptr, size_t * buflen);

/**
 * __mingw_str_free
 * Frees buffer create by __mingw_str_wide_utf8 and __mingw_str_utf8_wide.
 * @param[in] ptr memory block to free.
 *
 */

void __cdecl __mingw_str_free(void *ptr);





#define _WSPAWN_DEFINED 
  _CRTIMP intptr_t __cdecl _wspawnl(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  _CRTIMP intptr_t __cdecl _wspawnle(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  _CRTIMP intptr_t __cdecl _wspawnlp(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  _CRTIMP intptr_t __cdecl _wspawnlpe(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  _CRTIMP intptr_t __cdecl _wspawnv(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList);
  _CRTIMP intptr_t __cdecl _wspawnve(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
  _CRTIMP intptr_t __cdecl _wspawnvp(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList);
  _CRTIMP intptr_t __cdecl _wspawnvpe(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);



#define _P_WAIT 0
#define _P_NOWAIT 1
#define _OLD_P_OVERLAY 2
#define _P_NOWAITO 3
#define _P_DETACH 4
#define _P_OVERLAY 2

#define _WAIT_CHILD 0
#define _WAIT_GRANDCHILD 1



#define _SPAWNV_DEFINED 
  _CRTIMP intptr_t __cdecl _spawnv(int _Mode,const char *_Filename,const char *const *_ArgList);
  _CRTIMP intptr_t __cdecl _spawnve(int _Mode,const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  _CRTIMP intptr_t __cdecl _spawnvp(int _Mode,const char *_Filename,const char *const *_ArgList);
  _CRTIMP intptr_t __cdecl _spawnvpe(int _Mode,const char *_Filename,const char *const *_ArgList,const char *const *_Env);







       
       
       
       

#pragma pack(pop)

# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 1 3
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */

#define _INC_STDIO_S 

# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 1 3
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
# 10 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 2 3






#define _SECIMP __declspec(dllimport)








#define _STDIO_S_DEFINED 
  #define L_tmpnam_s L_tmpnam
  #define TMP_MAX_S TMP_MAX

  _CRTIMP errno_t __cdecl clearerr_s(FILE *_File);

  size_t __cdecl fread_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File);


  int __cdecl __stdio_common_vsprintf_s(unsigned __int64 _Options, char *_Str, size_t _Len, const char *_Format, _locale_t _Locale, va_list _ArgList);
  int __cdecl __stdio_common_vsprintf_p(unsigned __int64 _Options, char *_Str, size_t _Len, const char *_Format, _locale_t _Locale, va_list _ArgList);
  int __cdecl __stdio_common_vsnprintf_s(unsigned __int64 _Options, char *_Str, size_t _Len, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList);
  int __cdecl __stdio_common_vfprintf_s(unsigned __int64 _Options, FILE *_File, const char *_Format, _locale_t _Locale, va_list _ArgList);
  int __cdecl __stdio_common_vfprintf_p(unsigned __int64 _Options, FILE *_File, const char *_Format, _locale_t _Locale, va_list _ArgList);

  __mingw_ovr int __cdecl _vfscanf_s_l(FILE *_File, const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vfscanf(_CRT_INTERNAL_SCANF_SECURECRT, _File, _Format, _Locale, _ArgList);
  }

  __mingw_ovr int __cdecl vfscanf_s(FILE *_File, const char *_Format, va_list _ArgList)
  {
    return _vfscanf_s_l(_File, _Format, NULL, _ArgList);
  }

  __mingw_ovr int __cdecl _vscanf_s_l(const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vfscanf_s_l(stdin, _Format, _Locale, _ArgList);
  }

  __mingw_ovr int __cdecl vscanf_s(const char *_Format, va_list _ArgList)
  {
    return _vfscanf_s_l(stdin, _Format, NULL, _ArgList);
  }

  __mingw_ovr int __cdecl _fscanf_s_l(FILE *_File, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfscanf_s_l(_File, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl fscanf_s(FILE *_File, const char *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfscanf_s_l(_File, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _scanf_s_l(const char *_Format, _locale_t _Locale ,...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfscanf_s_l(stdin, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl scanf_s(const char *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfscanf_s_l(stdin, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vfscanf_l(FILE *_File, const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vfscanf(0, _File, _Format, _Locale, _ArgList);
  }

  __mingw_ovr int __cdecl _vscanf_l(const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vfscanf_l(stdin, _Format, _Locale, _ArgList);
  }

  __mingw_ovr int __cdecl _fscanf_l(FILE *_File, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfscanf_l(_File, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _scanf_l(const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfscanf_l(stdin, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vsscanf_s_l(const char *_Src, const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vsscanf(_CRT_INTERNAL_SCANF_SECURECRT, _Src, (size_t)-1, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl vsscanf_s(const char *_Src, const char *_Format, va_list _ArgList)
  {
    return _vsscanf_s_l(_Src, _Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl _sscanf_s_l(const char *_Src, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vsscanf_s_l(_Src, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl sscanf_s(const char *_Src, const char *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vsscanf_s_l(_Src, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vsscanf_l(const char *_Src, const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vsscanf(0, _Src, (size_t)-1, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl _sscanf_l(const char *_Src, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vsscanf_l(_Src, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  /* There is no _vsnscanf_s_l nor _vsnscanf_s */
  __mingw_ovr int __cdecl _snscanf_s_l(const char *_Src, size_t _MaxCount, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = __stdio_common_vsscanf(_CRT_INTERNAL_SCANF_SECURECRT, _Src, _MaxCount, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _snscanf_s(const char *_Src, size_t _MaxCount, const char *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = __stdio_common_vsscanf(_CRT_INTERNAL_SCANF_SECURECRT, _Src, _MaxCount, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  /* There is no _vsnscanf_l */
  __mingw_ovr int __cdecl _snscanf_l(const char *_Src, size_t _MaxCount, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = __stdio_common_vsscanf(0, _Src, _MaxCount, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }


  __mingw_ovr int __cdecl _vfprintf_s_l(FILE *_File, const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vfprintf_s(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _File, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl vfprintf_s(FILE *_File, const char *_Format, va_list _ArgList)
  {
    return _vfprintf_s_l(_File, _Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl _vprintf_s_l(const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vfprintf_s_l(stdout, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl vprintf_s(const char *_Format, va_list _ArgList)
  {
    return _vfprintf_s_l(stdout, _Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl _fprintf_s_l(FILE *_File, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfprintf_s_l(_File, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _printf_s_l(const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfprintf_s_l(stdout, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl fprintf_s(FILE *_File, const char *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfprintf_s_l(_File, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl printf_s(const char *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfprintf_s_l(stdout, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vsnprintf_c_l(char *_DstBuf, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vsprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _DstBuf, _MaxCount, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl _vsnprintf_c(char *_DstBuf, size_t _MaxCount, const char *_Format, va_list _ArgList)
  {
    return _vsnprintf_c_l(_DstBuf, _MaxCount, _Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl _snprintf_c_l(char *_DstBuf, size_t _MaxCount, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vsnprintf_c_l(_DstBuf, _MaxCount, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _snprintf_c(char *_DstBuf, size_t _MaxCount, const char *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vsnprintf_c_l(_DstBuf, _MaxCount, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vsnprintf_s_l(char *_DstBuf, size_t _DstSize, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vsnprintf_s(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _DstBuf, _DstSize, _MaxCount, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl vsnprintf_s(char *_DstBuf, size_t _DstSize, size_t _MaxCount, const char *_Format, va_list _ArgList)
  {
    return _vsnprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl _vsnprintf_s(char *_DstBuf, size_t _DstSize, size_t _MaxCount, const char *_Format, va_list _ArgList)
  {
    return _vsnprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl _snprintf_s_l(char *_DstBuf, size_t _DstSize, size_t _MaxCount, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vsnprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _snprintf_s(char *_DstBuf, size_t _DstSize, size_t _MaxCount, const char *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vsnprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vsprintf_s_l(char *_DstBuf, size_t _DstSize, const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vsprintf_s(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _DstBuf, _DstSize, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl vsprintf_s(char *_DstBuf, size_t _Size, const char *_Format, va_list _ArgList)
  {
    return _vsprintf_s_l(_DstBuf, _Size, _Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl _sprintf_s_l(char *_DstBuf, size_t _DstSize, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vsprintf_s_l(_DstBuf, _DstSize, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl sprintf_s(char *_DstBuf, size_t _DstSize, const char *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vsprintf_s_l(_DstBuf, _DstSize, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vfprintf_p_l(FILE *_File, const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vfprintf_p(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _File, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl _vfprintf_p(FILE *_File, const char *_Format, va_list _ArgList)
  {
    return _vfprintf_p_l(_File, _Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl _vprintf_p_l(const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vfprintf_p_l(stdout, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl _vprintf_p(const char *_Format, va_list _ArgList)
  {
    return _vfprintf_p_l(stdout, _Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl _fprintf_p_l(FILE *_File, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = __stdio_common_vfprintf_p(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _File, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _fprintf_p(FILE *_File, const char *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfprintf_p_l(_File, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _printf_p_l(const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfprintf_p_l(stdout, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _printf_p(const char *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfprintf_p_l(stdout, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vsprintf_p_l(char *_DstBuf, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vsprintf_p(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _DstBuf, _MaxCount, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl _vsprintf_p(char *_Dst, size_t _MaxCount, const char *_Format, va_list _ArgList)
  {
    return _vsprintf_p_l(_Dst, _MaxCount, _Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl _sprintf_p_l(char *_DstBuf, size_t _MaxCount, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vsprintf_p_l(_DstBuf, _MaxCount, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _sprintf_p(char *_Dst, size_t _MaxCount, const char *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vsprintf_p_l(_Dst, _MaxCount, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vscprintf_p_l(const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vsprintf_p(_CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR, NULL, 0, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl _vscprintf_p(const char *_Format, va_list _ArgList)
  {
    return _vscprintf_p_l(_Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl _scprintf_p_l(const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vscprintf_p_l(_Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _scprintf_p(const char *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vscprintf_p_l(_Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vfprintf_l(FILE *_File, const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _File, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl _vprintf_l(const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vfprintf_l(stdout, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl _fprintf_l(FILE *_File, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfprintf_l(_File, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _printf_l(const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfprintf_l(stdout, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vsnprintf_l(char *_DstBuf, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vsprintf(_CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION, _DstBuf, _MaxCount, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl _snprintf_l(char *_DstBuf, size_t _MaxCount, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vsnprintf_l(_DstBuf, _MaxCount, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _vsprintf_l(char *_DstBuf, const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vsnprintf_l(_DstBuf, (size_t)-1, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl _sprintf_l(char *_DstBuf, const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vsprintf_l(_DstBuf, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vscprintf_l(const char *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vsprintf(_CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR, NULL, 0, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl _scprintf_l(const char *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vscprintf_l(_Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
# 582 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 3

  __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(int,vsnprintf_s,char,_DstBuf,size_t,_MaxCount,const char*,_Format,va_list,_ArgList)
  __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(int,_vsnprintf_s,char,_DstBuf,size_t,_MaxCount,const char*,_Format,va_list,_ArgList)
  __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(int, vsprintf_s, char, _DstBuf, const char*, _Format, va_list, _ArgList)
  __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int,sprintf_s,vsprintf_s,char,_DstBuf,const char*,_Format)
  __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(int,_snprintf_s,_vsnprintf_s,char,_DstBuf,size_t,_MaxCount,const char*,_Format)

  _CRTIMP errno_t __cdecl fopen_s(FILE **_File,const char *_Filename,const char *_Mode);
  _CRTIMP errno_t __cdecl freopen_s(FILE** _File, const char *_Filename, const char *_Mode, FILE *_Stream);

  _CRTIMP char* __cdecl gets_s(char*,rsize_t);
  __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(char*,get_s,char,_DstBuf)

  _CRTIMP errno_t __cdecl tmpfile_s(FILE **_File);

  _CRTIMP errno_t __cdecl tmpnam_s(char*,rsize_t);
  __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t,tmpnam_s,char,_DstBuf)



#define _WSTDIO_S_DEFINED 
  _CRTIMP wchar_t *__cdecl _getws_s(wchar_t *_Str,size_t _SizeInWords);
  __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(wchar_t*,_getws_s,wchar_t,_DstBuf)


  int __cdecl __stdio_common_vswprintf_s(unsigned __int64 _Options, wchar_t *_Str, size_t _Len, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
  int __cdecl __stdio_common_vsnwprintf_s(unsigned __int64 _Options, wchar_t *_Str, size_t _Len, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
  int __cdecl __stdio_common_vfwprintf_s(unsigned __int64 _Options, FILE *_File, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);

  __mingw_ovr int __cdecl _vfwscanf_s_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vfwscanf(_CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT, _File, _Format, _Locale, _ArgList);
  }

  __mingw_ovr int __cdecl vfwscanf_s(FILE* _File, const wchar_t *_Format, va_list _ArgList)
  {
    return _vfwscanf_s_l(_File, _Format, NULL, _ArgList);
  }

  __mingw_ovr int __cdecl _vwscanf_s_l(const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vfwscanf_s_l(stdin, _Format, _Locale, _ArgList);
  }

  __mingw_ovr int __cdecl vwscanf_s(const wchar_t *_Format, va_list _ArgList)
  {
    return _vfwscanf_s_l(stdin, _Format, NULL, _ArgList);
  }

  __mingw_ovr int __cdecl _fwscanf_s_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfwscanf_s_l(_File, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl fwscanf_s(FILE *_File, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfwscanf_s_l(_File, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _wscanf_s_l(const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfwscanf_s_l(stdin, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl wscanf_s(const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfwscanf_s_l(stdin, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vswscanf_s_l(const wchar_t *_Src, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vswscanf(_CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT, _Src, (size_t)-1, _Format, _Locale, _ArgList);
  }

  __mingw_ovr int __cdecl vswscanf_s(const wchar_t *_Src, const wchar_t *_Format, va_list _ArgList)
  {
    return _vswscanf_s_l(_Src, _Format, NULL, _ArgList);
  }

  __mingw_ovr int __cdecl _swscanf_s_l(const wchar_t *_Src, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vswscanf_s_l(_Src, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl swscanf_s(const wchar_t *_Src, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vswscanf_s_l(_Src, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vsnwscanf_s_l(const wchar_t *_Src, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vswscanf(_CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT, _Src, _MaxCount, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl _snwscanf_s_l(const wchar_t *_Src, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vsnwscanf_s_l(_Src, _MaxCount, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _snwscanf_s(const wchar_t *_Src, size_t _MaxCount, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vsnwscanf_s_l(_Src, _MaxCount, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vfwprintf_s_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vfwprintf_s(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _File, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl _vwprintf_s_l(const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vfwprintf_s_l(stdout, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl vfwprintf_s(FILE *_File, const wchar_t *_Format, va_list _ArgList)
  {
    return _vfwprintf_s_l(_File, _Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl vwprintf_s(const wchar_t *_Format, va_list _ArgList)
  {
    return _vfwprintf_s_l(stdout, _Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl _fwprintf_s_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfwprintf_s_l(_File, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _wprintf_s_l(const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfwprintf_s_l(stdout, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl fwprintf_s(FILE *_File, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfwprintf_s_l(_File, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl wprintf_s(const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfwprintf_s_l(stdout, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vswprintf_s_l(wchar_t *_DstBuf, size_t _DstSize, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vswprintf_s(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _DstBuf, _DstSize, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl vswprintf_s(wchar_t *_DstBuf, size_t _DstSize, const wchar_t *_Format, va_list _ArgList)
  {
    return _vswprintf_s_l(_DstBuf, _DstSize, _Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl _swprintf_s_l(wchar_t *_DstBuf, size_t _DstSize, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vswprintf_s_l(_DstBuf, _DstSize, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl swprintf_s(wchar_t *_DstBuf, size_t _DstSize, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vswprintf_s_l(_DstBuf, _DstSize, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  __mingw_ovr int __cdecl _vsnwprintf_s_l(wchar_t *_DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vsnwprintf_s(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _DstBuf, _DstSize, _MaxCount, _Format, _Locale, _ArgList);
  }
  __mingw_ovr int __cdecl _vsnwprintf_s(wchar_t *_DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t *_Format, va_list _ArgList)
  {
    return _vsnwprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, NULL, _ArgList);
  }
  __mingw_ovr int __cdecl _snwprintf_s_l(wchar_t *_DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vsnwprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  __mingw_ovr int __cdecl _snwprintf_s(wchar_t *_DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vsnwprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, NULL, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
# 861 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 3

  __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(int, vswprintf_s, wchar_t, _Dst, const wchar_t*, _Format, va_list, _ArgList)
  __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int,swprintf_s,vswprintf_s,wchar_t,_Dst,const wchar_t*,_Format)
  __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(int,_vsnwprintf_s,wchar_t,_DstBuf,size_t,_MaxCount,const wchar_t*,_Format,va_list,_ArgList)
  __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(int,_snwprintf_s,_vsnwprintf_s,wchar_t,_DstBuf,size_t,_MaxCount,const wchar_t*,_Format)

  _CRTIMP errno_t __cdecl _wfopen_s(FILE **_File,const wchar_t *_Filename,const wchar_t *_Mode);
  _CRTIMP errno_t __cdecl _wfreopen_s(FILE **_File,const wchar_t *_Filename,const wchar_t *_Mode,FILE *_OldFile);

  _CRTIMP errno_t __cdecl _wtmpnam_s(wchar_t *_DstBuf,size_t _SizeInWords);
  __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t,_wtmpnam_s,wchar_t,_DstBuf)

# 907 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 3





  _CRTIMP size_t __cdecl _fread_nolock_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File);





# 1388 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3

# 323 "build/vendor/unity/src/unity_internals.h" 2
  #define UNITY_OUTPUT_CHAR(a) (void)putchar(a)








  




    /* We've specified nothing, therefore flush should just be ignored */
    #define UNITY_OUTPUT_FLUSH() (void)0
  










#define UNITY_FLUSH_CALL() UNITY_OUTPUT_FLUSH()



#define UNITY_PRINT_EOL() UNITY_OUTPUT_CHAR('\n')



#define UNITY_OUTPUT_START() 



#define UNITY_OUTPUT_COMPLETE() 


# 411 "build/vendor/unity/src/unity_internals.h"


#define UNITY_EXEC_TIME_START() do { } while (0)



#define UNITY_EXEC_TIME_STOP() do { } while (0)



#define UNITY_TIME_TYPE UNITY_UINT



#define UNITY_PRINT_EXEC_TIME() do { } while (0)


/*-------------------------------------------------------
 * Footprint
 *-------------------------------------------------------*/


#define UNITY_LINE_TYPE UNITY_UINT



#define UNITY_COUNTER_TYPE UNITY_UINT


/*-------------------------------------------------------
 * Internal Structs Needed
 *-------------------------------------------------------*/

typedef void (*UnityTestFunction)(void);

#define UNITY_DISPLAY_RANGE_INT (0x10)
#define UNITY_DISPLAY_RANGE_UINT (0x20)
#define UNITY_DISPLAY_RANGE_HEX (0x40)
#define UNITY_DISPLAY_RANGE_CHAR (0x80)

typedef enum
{
    UNITY_DISPLAY_STYLE_INT      = (UNITY_INT_WIDTH / 8) + UNITY_DISPLAY_RANGE_INT,
    UNITY_DISPLAY_STYLE_INT8     = 1 + UNITY_DISPLAY_RANGE_INT,
    UNITY_DISPLAY_STYLE_INT16    = 2 + UNITY_DISPLAY_RANGE_INT,
    UNITY_DISPLAY_STYLE_INT32    = 4 + UNITY_DISPLAY_RANGE_INT,

    UNITY_DISPLAY_STYLE_INT64    = 8 + UNITY_DISPLAY_RANGE_INT,


    UNITY_DISPLAY_STYLE_UINT     = (UNITY_INT_WIDTH / 8) + UNITY_DISPLAY_RANGE_UINT,
    UNITY_DISPLAY_STYLE_UINT8    = 1 + UNITY_DISPLAY_RANGE_UINT,
    UNITY_DISPLAY_STYLE_UINT16   = 2 + UNITY_DISPLAY_RANGE_UINT,
    UNITY_DISPLAY_STYLE_UINT32   = 4 + UNITY_DISPLAY_RANGE_UINT,

    UNITY_DISPLAY_STYLE_UINT64   = 8 + UNITY_DISPLAY_RANGE_UINT,


    UNITY_DISPLAY_STYLE_HEX8     = 1 + UNITY_DISPLAY_RANGE_HEX,
    UNITY_DISPLAY_STYLE_HEX16    = 2 + UNITY_DISPLAY_RANGE_HEX,
    UNITY_DISPLAY_STYLE_HEX32    = 4 + UNITY_DISPLAY_RANGE_HEX,

    UNITY_DISPLAY_STYLE_HEX64    = 8 + UNITY_DISPLAY_RANGE_HEX,


    UNITY_DISPLAY_STYLE_CHAR     = 1 + UNITY_DISPLAY_RANGE_CHAR + UNITY_DISPLAY_RANGE_INT,

    UNITY_DISPLAY_STYLE_UNKNOWN
} UNITY_DISPLAY_STYLE_T;

typedef enum
{
    UNITY_WITHIN           = 0x0,
    UNITY_EQUAL_TO         = 0x1,
    UNITY_GREATER_THAN     = 0x2,
    UNITY_GREATER_OR_EQUAL = 0x2 + UNITY_EQUAL_TO,
    UNITY_SMALLER_THAN     = 0x4,
    UNITY_SMALLER_OR_EQUAL = 0x4 + UNITY_EQUAL_TO,
    UNITY_NOT_EQUAL        = 0x0,
    UNITY_UNKNOWN
} UNITY_COMPARISON_T;


typedef enum UNITY_FLOAT_TRAIT
{
    UNITY_FLOAT_IS_NOT_INF       = 0,
    UNITY_FLOAT_IS_INF,
    UNITY_FLOAT_IS_NOT_NEG_INF,
    UNITY_FLOAT_IS_NEG_INF,
    UNITY_FLOAT_IS_NOT_NAN,
    UNITY_FLOAT_IS_NAN,
    UNITY_FLOAT_IS_NOT_DET,
    UNITY_FLOAT_IS_DET,
    UNITY_FLOAT_INVALID_TRAIT
} UNITY_FLOAT_TRAIT_T;


typedef enum
{
    UNITY_ARRAY_TO_VAL = 0,
    UNITY_ARRAY_TO_ARRAY,
    UNITY_ARRAY_UNKNOWN
} UNITY_FLAGS_T;

struct UNITY_STORAGE_T
{
    const char* TestFile;
    const char* CurrentTestName;

    const char* CurrentDetail1;
    const char* CurrentDetail2;

    UNITY_LINE_TYPE CurrentTestLineNumber;
    UNITY_COUNTER_TYPE NumberOfTests;
    UNITY_COUNTER_TYPE TestFailures;
    UNITY_COUNTER_TYPE TestIgnores;
    UNITY_COUNTER_TYPE CurrentTestFailed;
    UNITY_COUNTER_TYPE CurrentTestIgnored;





    jmp_buf AbortFrame;

};

extern struct UNITY_STORAGE_T Unity;

/*-------------------------------------------------------
 * Test Suite Management
 *-------------------------------------------------------*/

void UnityBegin(const char* filename);
int  UnityEnd(void);
void UnitySetTestFile(const char* filename);
void UnityConcludeTest(void);


void UnityDefaultTestRun(UnityTestFunction Func, const char* FuncName, const int FuncLineNum);




/*-------------------------------------------------------
 * Details Support
 *-------------------------------------------------------*/






#define UNITY_CLR_DETAILS() do { Unity.CurrentDetail1 = 0; Unity.CurrentDetail2 = 0; } while (0)
#define UNITY_SET_DETAIL(d1) do { Unity.CurrentDetail1 = (d1); Unity.CurrentDetail2 = 0; } while (0)
#define UNITY_SET_DETAILS(d1,d2) do { Unity.CurrentDetail1 = (d1); Unity.CurrentDetail2 = (d2); } while (0)


#define UNITY_DETAIL1_NAME "Function"



#define UNITY_DETAIL2_NAME "Argument"







/*-------------------------------------------------------
 * Test Output
 *-------------------------------------------------------*/

void UnityPrint(const char* string);





void UnityPrintLen(const char* string, const UNITY_UINT32 length);
void UnityPrintMask(const UNITY_UINT mask, const UNITY_UINT number);
void UnityPrintNumberByStyle(const UNITY_INT number, const UNITY_DISPLAY_STYLE_T style);
void UnityPrintNumber(const UNITY_INT number_to_print);
void UnityPrintNumberUnsigned(const UNITY_UINT number);
void UnityPrintNumberHex(const UNITY_UINT number, const char nibbles_to_print);


void UnityPrintFloat(const UNITY_DOUBLE input_number);


/*-------------------------------------------------------
 * Test Assertion Functions
 *-------------------------------------------------------
 *  Use the macros below this section instead of calling
 *  these directly. The macros have a consistent naming
 *  convention and will pull in file and line information
 *  for you. */

void UnityAssertEqualNumber(const UNITY_INT expected,
                            const UNITY_INT actual,
                            const char* msg,
                            const UNITY_LINE_TYPE lineNumber,
                            const UNITY_DISPLAY_STYLE_T style);

void UnityAssertGreaterOrLessOrEqualNumber(const UNITY_INT threshold,
                                           const UNITY_INT actual,
                                           const UNITY_COMPARISON_T compare,
                                           const char *msg,
                                           const UNITY_LINE_TYPE lineNumber,
                                           const UNITY_DISPLAY_STYLE_T style);

void UnityAssertEqualIntArray(UNITY_INTERNAL_PTR expected,
                              UNITY_INTERNAL_PTR actual,
                              const UNITY_UINT32 num_elements,
                              const char* msg,
                              const UNITY_LINE_TYPE lineNumber,
                              const UNITY_DISPLAY_STYLE_T style,
                              const UNITY_FLAGS_T flags);

void UnityAssertBits(const UNITY_INT mask,
                     const UNITY_INT expected,
                     const UNITY_INT actual,
                     const char* msg,
                     const UNITY_LINE_TYPE lineNumber);

void UnityAssertEqualString(const char* expected,
                            const char* actual,
                            const char* msg,
                            const UNITY_LINE_TYPE lineNumber);

void UnityAssertEqualStringLen(const char* expected,
                            const char* actual,
                            const UNITY_UINT32 length,
                            const char* msg,
                            const UNITY_LINE_TYPE lineNumber);

void UnityAssertEqualStringArray( UNITY_INTERNAL_PTR expected,
                                  const char** actual,
                                  const UNITY_UINT32 num_elements,
                                  const char* msg,
                                  const UNITY_LINE_TYPE lineNumber,
                                  const UNITY_FLAGS_T flags);

void UnityAssertEqualMemory( UNITY_INTERNAL_PTR expected,
                             UNITY_INTERNAL_PTR actual,
                             const UNITY_UINT32 length,
                             const UNITY_UINT32 num_elements,
                             const char* msg,
                             const UNITY_LINE_TYPE lineNumber,
                             const UNITY_FLAGS_T flags);

void UnityAssertNumbersWithin(const UNITY_UINT delta,
                              const UNITY_INT expected,
                              const UNITY_INT actual,
                              const char* msg,
                              const UNITY_LINE_TYPE lineNumber,
                              const UNITY_DISPLAY_STYLE_T style);

void UnityAssertNumbersArrayWithin(const UNITY_UINT delta,
                                   UNITY_INTERNAL_PTR expected,
                                   UNITY_INTERNAL_PTR actual,
                                   const UNITY_UINT32 num_elements,
                                   const char* msg,
                                   const UNITY_LINE_TYPE lineNumber,
                                   const UNITY_DISPLAY_STYLE_T style,
                                   const UNITY_FLAGS_T flags);


UNITY_NORETURN void UnityFail(const char* message, const UNITY_LINE_TYPE line);
UNITY_NORETURN void UnityIgnore(const char* message, const UNITY_LINE_TYPE line);





void UnityMessage(const char* message, const UNITY_LINE_TYPE line);


void UnityAssertFloatsWithin(const UNITY_FLOAT delta,
                             const UNITY_FLOAT expected,
                             const UNITY_FLOAT actual,
                             const char* msg,
                             const UNITY_LINE_TYPE lineNumber);

void UnityAssertFloatsNotWithin(const UNITY_FLOAT delta,
                                const UNITY_FLOAT expected,
                                const UNITY_FLOAT actual,
                                const char* msg,
                                const UNITY_LINE_TYPE lineNumber);

void UnityAssertGreaterOrLessFloat(const UNITY_FLOAT threshold,
                                   const UNITY_FLOAT actual,
                                   const UNITY_COMPARISON_T compare,
                                   const char* msg,
                                   const UNITY_LINE_TYPE linenumber);

void UnityAssertWithinFloatArray(const UNITY_FLOAT delta,
                                 UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* expected,
                                 UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* actual,
                                 const UNITY_UINT32 num_elements,
                                 const char* msg,
                                 const UNITY_LINE_TYPE lineNumber,
                                 const UNITY_FLAGS_T flags);

void UnityAssertFloatSpecial(const UNITY_FLOAT actual,
                             const char* msg,
                             const UNITY_LINE_TYPE lineNumber,
                             const UNITY_FLOAT_TRAIT_T style);


# 754 "build/vendor/unity/src/unity_internals.h"

/*-------------------------------------------------------
 * Helpers
 *-------------------------------------------------------*/

UNITY_INTERNAL_PTR UnityNumToPtr(const UNITY_INT num, const UNITY_UINT8 size);

UNITY_INTERNAL_PTR UnityFloatToPtr(const float num);





/*-------------------------------------------------------
 * Error Strings We Might Need
 *-------------------------------------------------------*/

extern const char UnityStrOk[];
extern const char UnityStrPass[];
extern const char UnityStrFail[];
extern const char UnityStrIgnore[];

extern const char UnityStrErrFloat[];
extern const char UnityStrErrDouble[];
extern const char UnityStrErr64[];
extern const char UnityStrErrShorthand[];

/*-------------------------------------------------------
 * Test Running Macros
 *-------------------------------------------------------*/





#define TEST_PROTECT() (setjmp(Unity.AbortFrame) == 0)









#define TEST_ABORT() longjmp(Unity.AbortFrame, 1)





/* Automatically enable variadic macros support, if it not enabled before */

  
    
      #define UNITY_SUPPORT_VARIADIC_MACROS 
    
  


/* This tricky series of macros gives us an optional line argument to treat it as RUN_TEST(func, num=__LINE__) */


#define RUN_TEST(...) RUN_TEST_AT_LINE(__VA_ARGS__, __LINE__, throwaway)
#define RUN_TEST_AT_LINE(func,line,...) UnityDefaultTestRun(func, #func, line)



/* Enable default macros for masking param tests test cases */
# 836 "build/vendor/unity/src/unity_internals.h"

/* If we can't do the tricky version, we'll just have to require them to always include the line number */








#define TEST_LINE_NUM (Unity.CurrentTestLineNumber)
#define TEST_IS_IGNORED (Unity.CurrentTestIgnored)
#define UNITY_NEW_TEST(a) Unity.CurrentTestName = (a); Unity.CurrentTestLineNumber = (UNITY_LINE_TYPE)(__LINE__); Unity.NumberOfTests++;





#define UNITY_BEGIN() UnityBegin(__FILE__)



#define UNITY_END() UnityEnd()






#define UNITY_SHORTHAND_AS_OLD 





/*-----------------------------------------------
 * Command Line Argument Support
 *-----------------------------------------------*/






/*-------------------------------------------------------
 * Basic Fail and Ignore
 *-------------------------------------------------------*/

#define UNITY_TEST_FAIL(line,message) UnityFail( (message), (UNITY_LINE_TYPE)(line))
#define UNITY_TEST_IGNORE(line,message) UnityIgnore( (message), (UNITY_LINE_TYPE)(line))

/*-------------------------------------------------------
 * Test Asserts
 *-------------------------------------------------------*/

#define UNITY_TEST_ASSERT(condition,line,message) do { if (condition) { } else { UNITY_TEST_FAIL((line), (message)); } } while (0)
#define UNITY_TEST_ASSERT_NULL(pointer,line,message) UNITY_TEST_ASSERT(((pointer) == NULL), (line), (message))
#define UNITY_TEST_ASSERT_NOT_NULL(pointer,line,message) UNITY_TEST_ASSERT(((pointer) != NULL), (line), (message))
#define UNITY_TEST_ASSERT_EMPTY(pointer,line,message) UNITY_TEST_ASSERT(((pointer[0]) == 0), (line), (message))
#define UNITY_TEST_ASSERT_NOT_EMPTY(pointer,line,message) UNITY_TEST_ASSERT(((pointer[0]) != 0), (line), (message))

#define UNITY_TEST_ASSERT_EQUAL_INT(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(expected), (UNITY_INT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT)
#define UNITY_TEST_ASSERT_EQUAL_INT8(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(UNITY_INT8 )(expected), (UNITY_INT)(UNITY_INT8 )(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT8)
#define UNITY_TEST_ASSERT_EQUAL_INT16(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(UNITY_INT16)(expected), (UNITY_INT)(UNITY_INT16)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT16)
#define UNITY_TEST_ASSERT_EQUAL_INT32(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(UNITY_INT32)(expected), (UNITY_INT)(UNITY_INT32)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT32)
#define UNITY_TEST_ASSERT_EQUAL_UINT(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(expected), (UNITY_INT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT)
#define UNITY_TEST_ASSERT_EQUAL_UINT8(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(UNITY_UINT8 )(expected), (UNITY_INT)(UNITY_UINT8 )(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT8)
#define UNITY_TEST_ASSERT_EQUAL_UINT16(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(UNITY_UINT16)(expected), (UNITY_INT)(UNITY_UINT16)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT16)
#define UNITY_TEST_ASSERT_EQUAL_UINT32(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(UNITY_UINT32)(expected), (UNITY_INT)(UNITY_UINT32)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT32)
#define UNITY_TEST_ASSERT_EQUAL_HEX8(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(UNITY_INT8 )(expected), (UNITY_INT)(UNITY_INT8 )(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX8)
#define UNITY_TEST_ASSERT_EQUAL_HEX16(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(UNITY_INT16)(expected), (UNITY_INT)(UNITY_INT16)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX16)
#define UNITY_TEST_ASSERT_EQUAL_HEX32(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(UNITY_INT32)(expected), (UNITY_INT)(UNITY_INT32)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX32)
#define UNITY_TEST_ASSERT_EQUAL_CHAR(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(UNITY_INT8 )(expected), (UNITY_INT)(UNITY_INT8 )(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_CHAR)
#define UNITY_TEST_ASSERT_BITS(mask,expected,actual,line,message) UnityAssertBits((UNITY_INT)(mask), (UNITY_INT)(expected), (UNITY_INT)(actual), (message), (UNITY_LINE_TYPE)(line))

#define UNITY_TEST_ASSERT_NOT_EQUAL_INT(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT)
#define UNITY_TEST_ASSERT_NOT_EQUAL_INT8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT8 )(threshold), (UNITY_INT)(UNITY_INT8 )(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT8)
#define UNITY_TEST_ASSERT_NOT_EQUAL_INT16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT16)(threshold), (UNITY_INT)(UNITY_INT16)(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT16)
#define UNITY_TEST_ASSERT_NOT_EQUAL_INT32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT32)(threshold), (UNITY_INT)(UNITY_INT32)(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT32)
#define UNITY_TEST_ASSERT_NOT_EQUAL_UINT(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT)
#define UNITY_TEST_ASSERT_NOT_EQUAL_UINT8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT8 )(threshold), (UNITY_INT)(UNITY_UINT8 )(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT8)
#define UNITY_TEST_ASSERT_NOT_EQUAL_UINT16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT16)(threshold), (UNITY_INT)(UNITY_UINT16)(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT16)
#define UNITY_TEST_ASSERT_NOT_EQUAL_UINT32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT32)(threshold), (UNITY_INT)(UNITY_UINT32)(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT32)
#define UNITY_TEST_ASSERT_NOT_EQUAL_HEX8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT8 )(threshold), (UNITY_INT)(UNITY_UINT8 )(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX8)
#define UNITY_TEST_ASSERT_NOT_EQUAL_HEX16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT16)(threshold), (UNITY_INT)(UNITY_UINT16)(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX16)
#define UNITY_TEST_ASSERT_NOT_EQUAL_HEX32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT32)(threshold), (UNITY_INT)(UNITY_UINT32)(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX32)
#define UNITY_TEST_ASSERT_NOT_EQUAL_CHAR(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT8 )(threshold), (UNITY_INT)(UNITY_INT8 )(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_CHAR)

#define UNITY_TEST_ASSERT_GREATER_THAN_INT(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT)
#define UNITY_TEST_ASSERT_GREATER_THAN_INT8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT8 )(threshold), (UNITY_INT)(UNITY_INT8 )(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT8)
#define UNITY_TEST_ASSERT_GREATER_THAN_INT16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT16)(threshold), (UNITY_INT)(UNITY_INT16)(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT16)
#define UNITY_TEST_ASSERT_GREATER_THAN_INT32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT32)(threshold), (UNITY_INT)(UNITY_INT32)(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT32)
#define UNITY_TEST_ASSERT_GREATER_THAN_UINT(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT)
#define UNITY_TEST_ASSERT_GREATER_THAN_UINT8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT8 )(threshold), (UNITY_INT)(UNITY_UINT8 )(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT8)
#define UNITY_TEST_ASSERT_GREATER_THAN_UINT16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT16)(threshold), (UNITY_INT)(UNITY_UINT16)(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT16)
#define UNITY_TEST_ASSERT_GREATER_THAN_UINT32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT32)(threshold), (UNITY_INT)(UNITY_UINT32)(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT32)
#define UNITY_TEST_ASSERT_GREATER_THAN_HEX8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT8 )(threshold), (UNITY_INT)(UNITY_UINT8 )(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX8)
#define UNITY_TEST_ASSERT_GREATER_THAN_HEX16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT16)(threshold), (UNITY_INT)(UNITY_UINT16)(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX16)
#define UNITY_TEST_ASSERT_GREATER_THAN_HEX32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT32)(threshold), (UNITY_INT)(UNITY_UINT32)(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX32)
#define UNITY_TEST_ASSERT_GREATER_THAN_CHAR(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT8 )(threshold), (UNITY_INT)(UNITY_INT8 )(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_CHAR)

#define UNITY_TEST_ASSERT_SMALLER_THAN_INT(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT)
#define UNITY_TEST_ASSERT_SMALLER_THAN_INT8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT8 )(threshold), (UNITY_INT)(UNITY_INT8 )(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT8)
#define UNITY_TEST_ASSERT_SMALLER_THAN_INT16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT16)(threshold), (UNITY_INT)(UNITY_INT16)(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT16)
#define UNITY_TEST_ASSERT_SMALLER_THAN_INT32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT32)(threshold), (UNITY_INT)(UNITY_INT32)(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT32)
#define UNITY_TEST_ASSERT_SMALLER_THAN_UINT(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT)
#define UNITY_TEST_ASSERT_SMALLER_THAN_UINT8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT8 )(threshold), (UNITY_INT)(UNITY_UINT8 )(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT8)
#define UNITY_TEST_ASSERT_SMALLER_THAN_UINT16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT16)(threshold), (UNITY_INT)(UNITY_UINT16)(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT16)
#define UNITY_TEST_ASSERT_SMALLER_THAN_UINT32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT32)(threshold), (UNITY_INT)(UNITY_UINT32)(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT32)
#define UNITY_TEST_ASSERT_SMALLER_THAN_HEX8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT8 )(threshold), (UNITY_INT)(UNITY_UINT8 )(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX8)
#define UNITY_TEST_ASSERT_SMALLER_THAN_HEX16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT16)(threshold), (UNITY_INT)(UNITY_UINT16)(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX16)
#define UNITY_TEST_ASSERT_SMALLER_THAN_HEX32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT32)(threshold), (UNITY_INT)(UNITY_UINT32)(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX32)
#define UNITY_TEST_ASSERT_SMALLER_THAN_CHAR(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT8 )(threshold), (UNITY_INT)(UNITY_INT8 )(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_CHAR)

#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT) (threshold), (UNITY_INT) (actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT8 ) (threshold), (UNITY_INT)(UNITY_INT8 ) (actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT8)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT16) (threshold), (UNITY_INT)(UNITY_INT16) (actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT16)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT32) (threshold), (UNITY_INT)(UNITY_INT32) (actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT32)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT) (threshold), (UNITY_INT) (actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT8 )(threshold), (UNITY_INT)(UNITY_UINT8 )(actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT8)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT16)(threshold), (UNITY_INT)(UNITY_UINT16)(actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT16)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT32)(threshold), (UNITY_INT)(UNITY_UINT32)(actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT32)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT8 )(threshold), (UNITY_INT)(UNITY_UINT8 )(actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX8)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT16)(threshold), (UNITY_INT)(UNITY_UINT16)(actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX16)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT32)(threshold), (UNITY_INT)(UNITY_UINT32)(actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX32)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_CHAR(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT8 ) (threshold), (UNITY_INT)(UNITY_INT8 ) (actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_CHAR)

#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT) (threshold), (UNITY_INT) (actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT)
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT8 )(threshold), (UNITY_INT)(UNITY_INT8 ) (actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT8)
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT16)(threshold), (UNITY_INT)(UNITY_INT16) (actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT16)
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT32)(threshold), (UNITY_INT)(UNITY_INT32) (actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT32)
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT) (threshold), (UNITY_INT) (actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT)
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT8 )(threshold), (UNITY_INT)(UNITY_UINT8 )(actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT8)
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT16)(threshold), (UNITY_INT)(UNITY_UINT16)(actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT16)
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT32)(threshold), (UNITY_INT)(UNITY_UINT32)(actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT32)
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX8(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT8 )(threshold), (UNITY_INT)(UNITY_UINT8 )(actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX8)
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX16(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT16)(threshold), (UNITY_INT)(UNITY_UINT16)(actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX16)
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX32(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_UINT32)(threshold), (UNITY_INT)(UNITY_UINT32)(actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX32)
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_CHAR(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(UNITY_INT8 )(threshold), (UNITY_INT)(UNITY_INT8 ) (actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_CHAR)

#define UNITY_TEST_ASSERT_INT_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin( (delta), (UNITY_INT) (expected), (UNITY_INT) (actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT)
#define UNITY_TEST_ASSERT_INT8_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin((UNITY_UINT8 )(delta), (UNITY_INT)(UNITY_INT8 ) (expected), (UNITY_INT)(UNITY_INT8 ) (actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT8)
#define UNITY_TEST_ASSERT_INT16_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin((UNITY_UINT16)(delta), (UNITY_INT)(UNITY_INT16) (expected), (UNITY_INT)(UNITY_INT16) (actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT16)
#define UNITY_TEST_ASSERT_INT32_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin((UNITY_UINT32)(delta), (UNITY_INT)(UNITY_INT32) (expected), (UNITY_INT)(UNITY_INT32) (actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT32)
#define UNITY_TEST_ASSERT_UINT_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin( (delta), (UNITY_INT) (expected), (UNITY_INT) (actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT)
#define UNITY_TEST_ASSERT_UINT8_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin((UNITY_UINT8 )(delta), (UNITY_INT)(UNITY_UINT)(UNITY_UINT8 )(expected), (UNITY_INT)(UNITY_UINT)(UNITY_UINT8 )(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT8)
#define UNITY_TEST_ASSERT_UINT16_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin((UNITY_UINT16)(delta), (UNITY_INT)(UNITY_UINT)(UNITY_UINT16)(expected), (UNITY_INT)(UNITY_UINT)(UNITY_UINT16)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT16)
#define UNITY_TEST_ASSERT_UINT32_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin((UNITY_UINT32)(delta), (UNITY_INT)(UNITY_UINT)(UNITY_UINT32)(expected), (UNITY_INT)(UNITY_UINT)(UNITY_UINT32)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT32)
#define UNITY_TEST_ASSERT_HEX8_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin((UNITY_UINT8 )(delta), (UNITY_INT)(UNITY_UINT)(UNITY_UINT8 )(expected), (UNITY_INT)(UNITY_UINT)(UNITY_UINT8 )(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX8)
#define UNITY_TEST_ASSERT_HEX16_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin((UNITY_UINT16)(delta), (UNITY_INT)(UNITY_UINT)(UNITY_UINT16)(expected), (UNITY_INT)(UNITY_UINT)(UNITY_UINT16)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX16)
#define UNITY_TEST_ASSERT_HEX32_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin((UNITY_UINT32)(delta), (UNITY_INT)(UNITY_UINT)(UNITY_UINT32)(expected), (UNITY_INT)(UNITY_UINT)(UNITY_UINT32)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX32)
#define UNITY_TEST_ASSERT_CHAR_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin((UNITY_UINT8 )(delta), (UNITY_INT)(UNITY_INT8 ) (expected), (UNITY_INT)(UNITY_INT8 ) (actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_CHAR)

#define UNITY_TEST_ASSERT_INT_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin( (delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), ((UNITY_UINT32)(num_elements)), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_INT8_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin((UNITY_UINT8 )(delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), ((UNITY_UINT32)(num_elements)), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT8, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_INT16_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin((UNITY_UINT16)(delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), ((UNITY_UINT32)(num_elements)), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT16, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_INT32_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin((UNITY_UINT32)(delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), ((UNITY_UINT32)(num_elements)), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT32, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin( (delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), ((UNITY_UINT32)(num_elements)), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_UINT8_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin((UNITY_UINT8 )(delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), ((UNITY_UINT32)(num_elements)), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT8, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_UINT16_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin((UNITY_UINT16)(delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), ((UNITY_UINT32)(num_elements)), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT16, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_UINT32_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin((UNITY_UINT32)(delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), ((UNITY_UINT32)(num_elements)), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT32, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_HEX8_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin((UNITY_UINT8 )(delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), ((UNITY_UINT32)(num_elements)), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX8, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_HEX16_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin((UNITY_UINT16)(delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), ((UNITY_UINT32)(num_elements)), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX16, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin((UNITY_UINT32)(delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), ((UNITY_UINT32)(num_elements)), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX32, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_CHAR_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin((UNITY_UINT8 )(delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), ((UNITY_UINT32)(num_elements)), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_CHAR, UNITY_ARRAY_TO_ARRAY)


#define UNITY_TEST_ASSERT_EQUAL_PTR(expected,actual,line,message) UnityAssertEqualNumber((UNITY_PTR_TO_INT)(expected), (UNITY_PTR_TO_INT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_POINTER)
#define UNITY_TEST_ASSERT_EQUAL_STRING(expected,actual,line,message) UnityAssertEqualString((const char*)(expected), (const char*)(actual), (message), (UNITY_LINE_TYPE)(line))
#define UNITY_TEST_ASSERT_EQUAL_STRING_LEN(expected,actual,len,line,message) UnityAssertEqualStringLen((const char*)(expected), (const char*)(actual), (UNITY_UINT32)(len), (message), (UNITY_LINE_TYPE)(line))
#define UNITY_TEST_ASSERT_EQUAL_MEMORY(expected,actual,len,line,message) UnityAssertEqualMemory((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(len), 1, (message), (UNITY_LINE_TYPE)(line), UNITY_ARRAY_TO_ARRAY)

#define UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_INT8_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT8, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_INT16_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT16, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_INT32_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT32, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_UINT8_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT8, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_UINT16_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT16, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT32, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX8, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX16, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX32, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_PTR_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_POINTER, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_STRING_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualStringArray((UNITY_INTERNAL_PTR)(expected), (const char**)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY(expected,actual,len,num_elements,line,message) UnityAssertEqualMemory((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(len), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_CHAR_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_CHAR, UNITY_ARRAY_TO_ARRAY)

#define UNITY_TEST_ASSERT_EACH_EQUAL_INT(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT) (expected), (UNITY_INT_WIDTH / 8)), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_INT8(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT)(UNITY_INT8 )(expected), 1), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT8, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_INT16(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT)(UNITY_INT16 )(expected), 2), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT16, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_INT32(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT)(UNITY_INT32 )(expected), 4), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT32, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_UINT(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT) (expected), (UNITY_INT_WIDTH / 8)), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_UINT8(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT)(UNITY_UINT8 )(expected), 1), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT8, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_UINT16(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT)(UNITY_UINT16)(expected), 2), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT16, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_UINT32(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT)(UNITY_UINT32)(expected), 4), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT32, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_HEX8(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT)(UNITY_INT8 )(expected), 1), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX8, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_HEX16(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT)(UNITY_INT16 )(expected), 2), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX16, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_HEX32(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT)(UNITY_INT32 )(expected), 4), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX32, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_PTR(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_PTR_TO_INT) (expected), (UNITY_POINTER_WIDTH / 8)), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_POINTER, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_STRING(expected,actual,num_elements,line,message) UnityAssertEqualStringArray((UNITY_INTERNAL_PTR)(expected), (const char**)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_MEMORY(expected,actual,len,num_elements,line,message) UnityAssertEqualMemory((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(len), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_CHAR(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT)(UNITY_INT8 )(expected), 1), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_CHAR, UNITY_ARRAY_TO_VAL)


#define UNITY_TEST_ASSERT_EQUAL_INT64(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(expected), (UNITY_INT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT64)
#define UNITY_TEST_ASSERT_EQUAL_UINT64(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(expected), (UNITY_INT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT64)
#define UNITY_TEST_ASSERT_EQUAL_HEX64(expected,actual,line,message) UnityAssertEqualNumber((UNITY_INT)(expected), (UNITY_INT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX64)
#define UNITY_TEST_ASSERT_EQUAL_INT64_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT64, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_UINT64_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT64, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_HEX64_ARRAY(expected,actual,num_elements,line,message) UnityAssertEqualIntArray((UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX64, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EACH_EQUAL_INT64(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT)(UNITY_INT64)(expected), 8), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT64, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_UINT64(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT)(UNITY_UINT64)(expected), 8), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT64, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_EACH_EQUAL_HEX64(expected,actual,num_elements,line,message) UnityAssertEqualIntArray(UnityNumToPtr((UNITY_INT)(UNITY_INT64)(expected), 8), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX64, UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_INT64_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin((delta), (UNITY_INT)(expected), (UNITY_INT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT64)
#define UNITY_TEST_ASSERT_UINT64_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin((delta), (UNITY_INT)(expected), (UNITY_INT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT64)
#define UNITY_TEST_ASSERT_HEX64_WITHIN(delta,expected,actual,line,message) UnityAssertNumbersWithin((delta), (UNITY_INT)(expected), (UNITY_INT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX64)
#define UNITY_TEST_ASSERT_NOT_EQUAL_INT64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT64)
#define UNITY_TEST_ASSERT_NOT_EQUAL_UINT64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT64)
#define UNITY_TEST_ASSERT_NOT_EQUAL_HEX64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_NOT_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX64)
#define UNITY_TEST_ASSERT_GREATER_THAN_INT64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT64)
#define UNITY_TEST_ASSERT_GREATER_THAN_UINT64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT64)
#define UNITY_TEST_ASSERT_GREATER_THAN_HEX64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX64)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT64)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT64)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX64)
#define UNITY_TEST_ASSERT_SMALLER_THAN_INT64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT64)
#define UNITY_TEST_ASSERT_SMALLER_THAN_UINT64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT64)
#define UNITY_TEST_ASSERT_SMALLER_THAN_HEX64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX64)
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT64)
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT64)
#define UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX64(threshold,actual,line,message) UnityAssertGreaterOrLessOrEqualNumber((UNITY_INT)(threshold), (UNITY_INT)(actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX64)
#define UNITY_TEST_ASSERT_INT64_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin((UNITY_UINT64)(delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_INT64, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_UINT64_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin((UNITY_UINT64)(delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_UINT64, UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_HEX64_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertNumbersArrayWithin((UNITY_UINT64)(delta), (UNITY_INTERNAL_PTR)(expected), (UNITY_INTERNAL_PTR)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_DISPLAY_STYLE_HEX64, UNITY_ARRAY_TO_ARRAY)
# 1097 "build/vendor/unity/src/unity_internals.h"

# 1119 "build/vendor/unity/src/unity_internals.h"
#define UNITY_TEST_ASSERT_FLOAT_WITHIN(delta,expected,actual,line,message) UnityAssertFloatsWithin((UNITY_FLOAT)(delta), (UNITY_FLOAT)(expected), (UNITY_FLOAT)(actual), (message), (UNITY_LINE_TYPE)(line))
#define UNITY_TEST_ASSERT_FLOAT_NOT_WITHIN(delta,expected,actual,line,message) UnityAssertFloatsNotWithin((UNITY_FLOAT)(delta), (UNITY_FLOAT)(expected), (UNITY_FLOAT)(actual), (message), (UNITY_LINE_TYPE)(line))
#define UNITY_TEST_ASSERT_EQUAL_FLOAT(expected,actual,line,message) UNITY_TEST_ASSERT_FLOAT_WITHIN((UNITY_FLOAT)(expected) * (UNITY_FLOAT)UNITY_FLOAT_PRECISION, (UNITY_FLOAT)(expected), (UNITY_FLOAT)(actual), (UNITY_LINE_TYPE)(line), (message))
#define UNITY_TEST_ASSERT_NOT_EQUAL_FLOAT(expected,actual,line,message) UNITY_TEST_ASSERT_FLOAT_NOT_WITHIN((UNITY_FLOAT)(expected) * (UNITY_FLOAT)UNITY_FLOAT_PRECISION, (UNITY_FLOAT)(expected), (UNITY_FLOAT)(actual), (UNITY_LINE_TYPE)(line), (message))
#define UNITY_TEST_ASSERT_FLOAT_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UnityAssertWithinFloatArray((UNITY_FLOAT)(delta), (const UNITY_FLOAT*)(expected), (const UNITY_FLOAT*)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(expected,actual,num_elements,line,message) UnityAssertWithinFloatArray((UNITY_FLOAT)0, (const UNITY_FLOAT*)(expected), (const UNITY_FLOAT*)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_ARRAY_TO_ARRAY)
#define UNITY_TEST_ASSERT_EACH_EQUAL_FLOAT(expected,actual,num_elements,line,message) UnityAssertWithinFloatArray((UNITY_FLOAT)0, UnityFloatToPtr(expected), (const UNITY_FLOAT*)(actual), (UNITY_UINT32)(num_elements), (message), (UNITY_LINE_TYPE)(line), UNITY_ARRAY_TO_VAL)
#define UNITY_TEST_ASSERT_GREATER_THAN_FLOAT(threshold,actual,line,message) UnityAssertGreaterOrLessFloat((UNITY_FLOAT)(threshold), (UNITY_FLOAT)(actual), UNITY_GREATER_THAN, (message), (UNITY_LINE_TYPE)(line))
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_FLOAT(threshold,actual,line,message) UnityAssertGreaterOrLessFloat((UNITY_FLOAT)(threshold), (UNITY_FLOAT)(actual), UNITY_GREATER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line))
#define UNITY_TEST_ASSERT_LESS_THAN_FLOAT(threshold,actual,line,message) UnityAssertGreaterOrLessFloat((UNITY_FLOAT)(threshold), (UNITY_FLOAT)(actual), UNITY_SMALLER_THAN, (message), (UNITY_LINE_TYPE)(line))
#define UNITY_TEST_ASSERT_LESS_OR_EQUAL_FLOAT(threshold,actual,line,message) UnityAssertGreaterOrLessFloat((UNITY_FLOAT)(threshold), (UNITY_FLOAT)(actual), UNITY_SMALLER_OR_EQUAL, (message), (UNITY_LINE_TYPE)(line))
#define UNITY_TEST_ASSERT_FLOAT_IS_INF(actual,line,message) UnityAssertFloatSpecial((UNITY_FLOAT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_FLOAT_IS_INF)
#define UNITY_TEST_ASSERT_FLOAT_IS_NEG_INF(actual,line,message) UnityAssertFloatSpecial((UNITY_FLOAT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_FLOAT_IS_NEG_INF)
#define UNITY_TEST_ASSERT_FLOAT_IS_NAN(actual,line,message) UnityAssertFloatSpecial((UNITY_FLOAT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_FLOAT_IS_NAN)
#define UNITY_TEST_ASSERT_FLOAT_IS_DETERMINATE(actual,line,message) UnityAssertFloatSpecial((UNITY_FLOAT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_FLOAT_IS_DET)
#define UNITY_TEST_ASSERT_FLOAT_IS_NOT_INF(actual,line,message) UnityAssertFloatSpecial((UNITY_FLOAT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_FLOAT_IS_NOT_INF)
#define UNITY_TEST_ASSERT_FLOAT_IS_NOT_NEG_INF(actual,line,message) UnityAssertFloatSpecial((UNITY_FLOAT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_FLOAT_IS_NOT_NEG_INF)
#define UNITY_TEST_ASSERT_FLOAT_IS_NOT_NAN(actual,line,message) UnityAssertFloatSpecial((UNITY_FLOAT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_FLOAT_IS_NOT_NAN)
#define UNITY_TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE(actual,line,message) UnityAssertFloatSpecial((UNITY_FLOAT)(actual), (message), (UNITY_LINE_TYPE)(line), UNITY_FLOAT_IS_NOT_DET)



#define UNITY_TEST_ASSERT_DOUBLE_WITHIN(delta,expected,actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_DOUBLE_NOT_WITHIN(delta,expected,actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_EQUAL_DOUBLE(expected,actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_NOT_EQUAL_DOUBLE(expected,actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_DOUBLE_ARRAY_WITHIN(delta,expected,actual,num_elements,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_EQUAL_DOUBLE_ARRAY(expected,actual,num_elements,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_EACH_EQUAL_DOUBLE(expected,actual,num_elements,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_GREATER_THAN_DOUBLE(threshold,actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE(threshold,actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_LESS_THAN_DOUBLE(threshold,actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_LESS_OR_EQUAL_DOUBLE(threshold,actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_DOUBLE_IS_INF(actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_DOUBLE_IS_NEG_INF(actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_DOUBLE_IS_NAN(actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_DOUBLE_IS_DETERMINATE(actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_DOUBLE_IS_NOT_INF(actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF(actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NAN(actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
#define UNITY_TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE(actual,line,message) UNITY_TEST_FAIL((UNITY_LINE_TYPE)(line), UnityStrErrDouble)
# 1181 "build/vendor/unity/src/unity_internals.h"

/* End of UNITY_INTERNALS_H */
# 23 "build/vendor/unity/src/unity.h" 2

/*-------------------------------------------------------
 * Test Setup / Teardown
 *-------------------------------------------------------*/

/* These functions are intended to be called before and after each test.
 * If using unity directly, these will need to be provided for each test
 * executable built. If you are using the test runner generator and/or
 * Ceedling, these are optional. */
void setUp(void);
void tearDown(void);

/* These functions are intended to be called at the beginning and end of an
 * entire test suite.  suiteTearDown() is passed the number of tests that
 * failed, and its return value becomes the exit code of main(). If using
 * Unity directly, you're in charge of calling these if they are desired.
 * If using Ceedling or the test runner generator, these will be called
 * automatically if they exist. */
void suiteSetUp(void);
int suiteTearDown(int num_failures);

/*-------------------------------------------------------
 * Test Reset and Verify
 *-------------------------------------------------------*/

/* These functions are intended to be called before during tests in order
 * to support complex test loops, etc. Both are NOT built into Unity. Instead
 * the test runner generator will create them. resetTest will run teardown and
 * setup again, verifying any end-of-test needs between. verifyTest will only
 * run the verification. */
void resetTest(void);
void verifyTest(void);

/*-------------------------------------------------------
 * Configuration Options
 *-------------------------------------------------------
 * All options described below should be passed as a compiler flag to all files using Unity. If you must add #defines, place them BEFORE the #include above.

 * Integers/longs/pointers
 *     - Unity attempts to automatically discover your integer sizes
 *       - define UNITY_EXCLUDE_STDINT_H to stop attempting to look in <stdint.h>
 *       - define UNITY_EXCLUDE_LIMITS_H to stop attempting to look in <limits.h>
 *     - If you cannot use the automatic methods above, you can force Unity by using these options:
 *       - define UNITY_SUPPORT_64
 *       - set UNITY_INT_WIDTH
 *       - set UNITY_LONG_WIDTH
 *       - set UNITY_POINTER_WIDTH

 * Floats
 *     - define UNITY_EXCLUDE_FLOAT to disallow floating point comparisons
 *     - define UNITY_FLOAT_PRECISION to specify the precision to use when doing TEST_ASSERT_EQUAL_FLOAT
 *     - define UNITY_FLOAT_TYPE to specify doubles instead of single precision floats
 *     - define UNITY_INCLUDE_DOUBLE to allow double floating point comparisons
 *     - define UNITY_EXCLUDE_DOUBLE to disallow double floating point comparisons (default)
 *     - define UNITY_DOUBLE_PRECISION to specify the precision to use when doing TEST_ASSERT_EQUAL_DOUBLE
 *     - define UNITY_DOUBLE_TYPE to specify something other than double
 *     - define UNITY_EXCLUDE_FLOAT_PRINT to trim binary size, won't print floating point values in errors

 * Output
 *     - by default, Unity prints to standard out with putchar.  define UNITY_OUTPUT_CHAR(a) with a different function if desired
 *     - define UNITY_DIFFERENTIATE_FINAL_FAIL to print FAILED (vs. FAIL) at test end summary - for automated search for failure

 * Optimization
 *     - by default, line numbers are stored in unsigned shorts.  Define UNITY_LINE_TYPE with a different type if your files are huge
 *     - by default, test and failure counters are unsigned shorts.  Define UNITY_COUNTER_TYPE with a different type if you want to save space or have more than 65535 Tests.

 * Test Cases
 *     - define UNITY_SUPPORT_TEST_CASES to include the TEST_CASE macro, though really it's mostly about the runner generator script

 * Parameterized Tests
 *     - you'll want to create a define of TEST_CASE(...), TEST_RANGE(...) and/or TEST_MATRIX(...) which basically evaluates to nothing

 * Tests with Arguments
 *     - you'll want to define UNITY_USE_COMMAND_LINE_ARGS if you have the test runner passing arguments to Unity

 *-------------------------------------------------------
 * Basic Fail and Ignore
 *-------------------------------------------------------*/

#define TEST_FAIL_MESSAGE(message) UNITY_TEST_FAIL(__LINE__, (message))
#define TEST_FAIL() UNITY_TEST_FAIL(__LINE__, NULL)
#define TEST_IGNORE_MESSAGE(message) UNITY_TEST_IGNORE(__LINE__, (message))
#define TEST_IGNORE() UNITY_TEST_IGNORE(__LINE__, NULL)
#define TEST_MESSAGE(message) UnityMessage((message), __LINE__)
#define TEST_ONLY() 




/* It is not necessary for you to call PASS. A PASS condition is assumed if nothing fails.
 * This method allows you to abort a test immediately with a PASS state, ignoring the remainder of the test. */
#define TEST_PASS() TEST_ABORT()
#define TEST_PASS_MESSAGE(message) do { UnityMessage((message), __LINE__); TEST_ABORT(); } while (0)

/*-------------------------------------------------------
 * Build Directives
 *-------------------------------------------------------

 * These macros do nothing, but they are useful for additional build context.
 * Tools (like Ceedling) can scan for these directives and make use of them for 
 * per-test-executable #include search paths and linking. */

/* Add source files to a test executable's compilation and linking. Ex: TEST_SOURCE_FILE("sandwiches.c") */
#define TEST_SOURCE_FILE(a) 

/* Customize #include search paths for a test executable's compilation. Ex: TEST_INCLUDE_PATH("src/module_a/inc") */
#define TEST_INCLUDE_PATH(a) 

/*-------------------------------------------------------
 * Test Asserts (simple)
 *-------------------------------------------------------*/

/* Boolean */
#define TEST_ASSERT(condition) UNITY_TEST_ASSERT( (condition), __LINE__, " Expression Evaluated To FALSE")
#define TEST_ASSERT_TRUE(condition) UNITY_TEST_ASSERT( (condition), __LINE__, " Expected TRUE Was FALSE")
#define TEST_ASSERT_UNLESS(condition) UNITY_TEST_ASSERT( !(condition), __LINE__, " Expression Evaluated To TRUE")
#define TEST_ASSERT_FALSE(condition) UNITY_TEST_ASSERT( !(condition), __LINE__, " Expected FALSE Was TRUE")
#define TEST_ASSERT_NULL(pointer) UNITY_TEST_ASSERT_NULL( (pointer), __LINE__, " Expected NULL")
#define TEST_ASSERT_NOT_NULL(pointer) UNITY_TEST_ASSERT_NOT_NULL((pointer), __LINE__, " Expected Non-NULL")
#define TEST_ASSERT_EMPTY(pointer) UNITY_TEST_ASSERT_EMPTY( (pointer), __LINE__, " Expected Empty")
#define TEST_ASSERT_NOT_EMPTY(pointer) UNITY_TEST_ASSERT_NOT_EMPTY((pointer), __LINE__, " Expected Non-Empty")

/* Integers (of all sizes) */
#define TEST_ASSERT_EQUAL_INT(expected,actual) UNITY_TEST_ASSERT_EQUAL_INT((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_INT8(expected,actual) UNITY_TEST_ASSERT_EQUAL_INT8((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_INT16(expected,actual) UNITY_TEST_ASSERT_EQUAL_INT16((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_INT32(expected,actual) UNITY_TEST_ASSERT_EQUAL_INT32((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_INT64(expected,actual) UNITY_TEST_ASSERT_EQUAL_INT64((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_UINT(expected,actual) UNITY_TEST_ASSERT_EQUAL_UINT( (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_UINT8(expected,actual) UNITY_TEST_ASSERT_EQUAL_UINT8( (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_UINT16(expected,actual) UNITY_TEST_ASSERT_EQUAL_UINT16( (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_UINT32(expected,actual) UNITY_TEST_ASSERT_EQUAL_UINT32( (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_UINT64(expected,actual) UNITY_TEST_ASSERT_EQUAL_UINT64( (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_size_t(expected,actual) UNITY_TEST_ASSERT_EQUAL_UINT((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_HEX(expected,actual) UNITY_TEST_ASSERT_EQUAL_HEX32((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_HEX8(expected,actual) UNITY_TEST_ASSERT_EQUAL_HEX8( (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_HEX16(expected,actual) UNITY_TEST_ASSERT_EQUAL_HEX16((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_HEX32(expected,actual) UNITY_TEST_ASSERT_EQUAL_HEX32((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_HEX64(expected,actual) UNITY_TEST_ASSERT_EQUAL_HEX64((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_CHAR(expected,actual) UNITY_TEST_ASSERT_EQUAL_CHAR((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_BITS(mask,expected,actual) UNITY_TEST_ASSERT_BITS((mask), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_BITS_HIGH(mask,actual) UNITY_TEST_ASSERT_BITS((mask), (UNITY_UINT)(-1), (actual), __LINE__, NULL)
#define TEST_ASSERT_BITS_LOW(mask,actual) UNITY_TEST_ASSERT_BITS((mask), (UNITY_UINT)(0), (actual), __LINE__, NULL)
#define TEST_ASSERT_BIT_HIGH(bit,actual) UNITY_TEST_ASSERT_BITS(((UNITY_UINT)1 << (bit)), (UNITY_UINT)(-1), (actual), __LINE__, NULL)
#define TEST_ASSERT_BIT_LOW(bit,actual) UNITY_TEST_ASSERT_BITS(((UNITY_UINT)1 << (bit)), (UNITY_UINT)(0), (actual), __LINE__, NULL)

/* Integer Not Equal To (of all sizes) */
#define TEST_ASSERT_NOT_EQUAL_INT(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_INT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_INT8(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_INT8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_INT16(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_INT16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_INT32(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_INT32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_INT64(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_INT64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_UINT(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_UINT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_UINT8(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_UINT8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_UINT16(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_UINT16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_UINT32(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_UINT32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_UINT64(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_UINT64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_size_t(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_UINT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_HEX8(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_HEX8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_HEX16(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_HEX16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_HEX32(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_HEX32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_HEX64(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_HEX64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_CHAR(threshold,actual) UNITY_TEST_ASSERT_NOT_EQUAL_CHAR((threshold), (actual), __LINE__, NULL)

/* Integer Greater Than/ Less Than (of all sizes) */
#define TEST_ASSERT_GREATER_THAN(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_INT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_INT(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_INT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_INT8(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_INT8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_INT16(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_INT16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_INT32(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_INT32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_INT64(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_INT64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_UINT(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_UINT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_UINT8(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_UINT8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_UINT16(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_UINT16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_UINT32(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_UINT32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_UINT64(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_UINT64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_size_t(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_UINT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_HEX8(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_HEX8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_HEX16(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_HEX16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_HEX32(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_HEX32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_HEX64(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_HEX64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_CHAR(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_CHAR((threshold), (actual), __LINE__, NULL)

#define TEST_ASSERT_LESS_THAN(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_INT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_INT(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_INT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_INT8(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_INT8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_INT16(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_INT16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_INT32(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_INT32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_INT64(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_INT64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_UINT(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_UINT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_UINT8(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_UINT8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_UINT16(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_UINT16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_UINT32(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_UINT32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_UINT64(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_UINT64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_size_t(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_UINT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_HEX8(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_HEX8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_HEX16(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_HEX16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_HEX32(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_HEX32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_HEX64(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_HEX64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_CHAR(threshold,actual) UNITY_TEST_ASSERT_SMALLER_THAN_CHAR((threshold), (actual), __LINE__, NULL)

#define TEST_ASSERT_GREATER_OR_EQUAL(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_INT(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_INT8(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_INT16(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_INT32(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_INT64(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT8(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT16(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT32(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT64(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_size_t(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX8(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX16(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX32(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX64(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_CHAR(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_CHAR((threshold), (actual), __LINE__, NULL)

#define TEST_ASSERT_LESS_OR_EQUAL(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_INT(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_INT8(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_INT16(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_INT32(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_INT64(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_UINT(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_UINT8(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_UINT16(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_UINT32(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_UINT64(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_size_t(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_HEX8(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX8((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_HEX16(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX16((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_HEX32(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX32((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_HEX64(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX64((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_CHAR(threshold,actual) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_CHAR((threshold), (actual), __LINE__, NULL)

/* Integer Ranges (of all sizes) */
#define TEST_ASSERT_INT_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_INT_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_INT8_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_INT8_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_INT16_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_INT16_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_INT32_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_INT32_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_INT64_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_INT64_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_UINT_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_UINT_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_UINT8_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_UINT8_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_UINT16_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_UINT16_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_UINT32_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_UINT32_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_UINT64_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_UINT64_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_size_t_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_UINT_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_HEX_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_HEX32_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_HEX8_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_HEX8_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_HEX16_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_HEX16_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_HEX32_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_HEX32_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_HEX64_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_HEX64_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_CHAR_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_CHAR_WITHIN((delta), (expected), (actual), __LINE__, NULL)

/* Integer Array Ranges (of all sizes) */
#define TEST_ASSERT_INT_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_INT_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_INT8_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_INT8_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_INT16_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_INT16_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_INT32_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_INT32_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_INT64_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_INT64_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_UINT_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_UINT8_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_UINT8_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_UINT16_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_UINT16_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_UINT32_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_UINT32_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_UINT64_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_UINT64_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_size_t_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_HEX_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_HEX8_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_HEX8_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_HEX16_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_HEX16_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_HEX32_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_HEX64_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_HEX64_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)
#define TEST_ASSERT_CHAR_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_CHAR_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, NULL)


/* Structs and Strings */
#define TEST_ASSERT_EQUAL_PTR(expected,actual) UNITY_TEST_ASSERT_EQUAL_PTR((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_STRING(expected,actual) UNITY_TEST_ASSERT_EQUAL_STRING((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_STRING_LEN(expected,actual,len) UNITY_TEST_ASSERT_EQUAL_STRING_LEN((expected), (actual), (len), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_MEMORY(expected,actual,len) UNITY_TEST_ASSERT_EQUAL_MEMORY((expected), (actual), (len), __LINE__, NULL)

/* Arrays */
#define TEST_ASSERT_EQUAL_INT_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_INT_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_INT8_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_INT8_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_INT16_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_INT16_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_INT32_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_INT32_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_INT64_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_INT64_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_UINT_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_UINT8_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_UINT8_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_UINT16_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_UINT16_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_UINT32_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_UINT64_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_UINT64_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_size_t_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_HEX_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_HEX8_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_HEX16_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_HEX32_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_HEX64_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_HEX64_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_PTR_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_PTR_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_STRING_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_STRING_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_MEMORY_ARRAY(expected,actual,len,num_elements) UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((expected), (actual), (len), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_CHAR_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_CHAR_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)

/* Arrays Compared To Single Value */
#define TEST_ASSERT_EACH_EQUAL_INT(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_INT((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_INT8(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_INT8((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_INT16(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_INT16((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_INT32(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_INT32((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_INT64(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_INT64((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_UINT(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_UINT((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_UINT8(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_UINT8((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_UINT16(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_UINT16((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_UINT32(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_UINT32((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_UINT64(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_UINT64((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_size_t(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_UINT((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_HEX(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_HEX32((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_HEX8(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_HEX8((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_HEX16(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_HEX16((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_HEX32(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_HEX32((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_HEX64(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_HEX64((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_PTR(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_PTR((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_STRING(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_STRING((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_MEMORY(expected,actual,len,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_MEMORY((expected), (actual), (len), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_CHAR(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_CHAR((expected), (actual), (num_elements), __LINE__, NULL)

/* Floating Point (If Enabled) */
#define TEST_ASSERT_FLOAT_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_FLOAT_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_FLOAT_NOT_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_FLOAT_NOT_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_FLOAT(expected,actual) UNITY_TEST_ASSERT_EQUAL_FLOAT((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_FLOAT(expected,actual) UNITY_TEST_ASSERT_NOT_EQUAL_FLOAT((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_FLOAT_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_FLOAT_ARRAY_WITHIN((delta), (expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_FLOAT_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_FLOAT(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_FLOAT((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_FLOAT(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_FLOAT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_FLOAT(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_FLOAT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_FLOAT(threshold,actual) UNITY_TEST_ASSERT_LESS_THAN_FLOAT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_FLOAT(threshold,actual) UNITY_TEST_ASSERT_LESS_OR_EQUAL_FLOAT((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_FLOAT_IS_INF(actual) UNITY_TEST_ASSERT_FLOAT_IS_INF((actual), __LINE__, NULL)
#define TEST_ASSERT_FLOAT_IS_NEG_INF(actual) UNITY_TEST_ASSERT_FLOAT_IS_NEG_INF((actual), __LINE__, NULL)
#define TEST_ASSERT_FLOAT_IS_NAN(actual) UNITY_TEST_ASSERT_FLOAT_IS_NAN((actual), __LINE__, NULL)
#define TEST_ASSERT_FLOAT_IS_DETERMINATE(actual) UNITY_TEST_ASSERT_FLOAT_IS_DETERMINATE((actual), __LINE__, NULL)
#define TEST_ASSERT_FLOAT_IS_NOT_INF(actual) UNITY_TEST_ASSERT_FLOAT_IS_NOT_INF((actual), __LINE__, NULL)
#define TEST_ASSERT_FLOAT_IS_NOT_NEG_INF(actual) UNITY_TEST_ASSERT_FLOAT_IS_NOT_NEG_INF((actual), __LINE__, NULL)
#define TEST_ASSERT_FLOAT_IS_NOT_NAN(actual) UNITY_TEST_ASSERT_FLOAT_IS_NOT_NAN((actual), __LINE__, NULL)
#define TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE(actual) UNITY_TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE((actual), __LINE__, NULL)

/* Double (If Enabled) */
#define TEST_ASSERT_DOUBLE_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_DOUBLE_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_DOUBLE_NOT_WITHIN(delta,expected,actual) UNITY_TEST_ASSERT_DOUBLE_NOT_WITHIN((delta), (expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_DOUBLE(expected,actual) UNITY_TEST_ASSERT_EQUAL_DOUBLE((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL_DOUBLE(expected,actual) UNITY_TEST_ASSERT_NOT_EQUAL_DOUBLE((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_DOUBLE_ARRAY_WITHIN(delta,expected,actual,num_elements) UNITY_TEST_ASSERT_DOUBLE_ARRAY_WITHIN((delta), (expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EQUAL_DOUBLE_ARRAY(expected,actual,num_elements) UNITY_TEST_ASSERT_EQUAL_DOUBLE_ARRAY((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_EACH_EQUAL_DOUBLE(expected,actual,num_elements) UNITY_TEST_ASSERT_EACH_EQUAL_DOUBLE((expected), (actual), (num_elements), __LINE__, NULL)
#define TEST_ASSERT_GREATER_THAN_DOUBLE(threshold,actual) UNITY_TEST_ASSERT_GREATER_THAN_DOUBLE((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE(threshold,actual) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_THAN_DOUBLE(threshold,actual) UNITY_TEST_ASSERT_LESS_THAN_DOUBLE((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_LESS_OR_EQUAL_DOUBLE(threshold,actual) UNITY_TEST_ASSERT_LESS_OR_EQUAL_DOUBLE((threshold), (actual), __LINE__, NULL)
#define TEST_ASSERT_DOUBLE_IS_INF(actual) UNITY_TEST_ASSERT_DOUBLE_IS_INF((actual), __LINE__, NULL)
#define TEST_ASSERT_DOUBLE_IS_NEG_INF(actual) UNITY_TEST_ASSERT_DOUBLE_IS_NEG_INF((actual), __LINE__, NULL)
#define TEST_ASSERT_DOUBLE_IS_NAN(actual) UNITY_TEST_ASSERT_DOUBLE_IS_NAN((actual), __LINE__, NULL)
#define TEST_ASSERT_DOUBLE_IS_DETERMINATE(actual) UNITY_TEST_ASSERT_DOUBLE_IS_DETERMINATE((actual), __LINE__, NULL)
#define TEST_ASSERT_DOUBLE_IS_NOT_INF(actual) UNITY_TEST_ASSERT_DOUBLE_IS_NOT_INF((actual), __LINE__, NULL)
#define TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF(actual) UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF((actual), __LINE__, NULL)
#define TEST_ASSERT_DOUBLE_IS_NOT_NAN(actual) UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NAN((actual), __LINE__, NULL)
#define TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE(actual) UNITY_TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE((actual), __LINE__, NULL)

/* Shorthand */

#define TEST_ASSERT_EQUAL(expected,actual) UNITY_TEST_ASSERT_EQUAL_INT((expected), (actual), __LINE__, NULL)
#define TEST_ASSERT_NOT_EQUAL(expected,actual) UNITY_TEST_ASSERT(((expected) != (actual)), __LINE__, " Expected Not-Equal")


















/*-------------------------------------------------------
 * Test Asserts (with additional messages)
 *-------------------------------------------------------*/

/* Boolean */
#define TEST_ASSERT_MESSAGE(condition,message) UNITY_TEST_ASSERT( (condition), __LINE__, (message))
#define TEST_ASSERT_TRUE_MESSAGE(condition,message) UNITY_TEST_ASSERT( (condition), __LINE__, (message))
#define TEST_ASSERT_UNLESS_MESSAGE(condition,message) UNITY_TEST_ASSERT( !(condition), __LINE__, (message))
#define TEST_ASSERT_FALSE_MESSAGE(condition,message) UNITY_TEST_ASSERT( !(condition), __LINE__, (message))
#define TEST_ASSERT_NULL_MESSAGE(pointer,message) UNITY_TEST_ASSERT_NULL( (pointer), __LINE__, (message))
#define TEST_ASSERT_NOT_NULL_MESSAGE(pointer,message) UNITY_TEST_ASSERT_NOT_NULL((pointer), __LINE__, (message))
#define TEST_ASSERT_EMPTY_MESSAGE(pointer,message) UNITY_TEST_ASSERT_EMPTY( (pointer), __LINE__, (message))
#define TEST_ASSERT_NOT_EMPTY_MESSAGE(pointer,message) UNITY_TEST_ASSERT_NOT_EMPTY((pointer), __LINE__, (message))

/* Integers (of all sizes) */
#define TEST_ASSERT_EQUAL_INT_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_INT((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_INT8_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_INT8((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_INT16_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_INT16((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_INT32_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_INT32((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_INT64_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_INT64((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_UINT_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_UINT( (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_UINT8_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_UINT8( (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_UINT16_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_UINT16( (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_UINT32_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_UINT32( (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_UINT64_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_UINT64( (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_size_t_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_UINT( (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_HEX_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_HEX32((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_HEX8_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_HEX8( (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_HEX16_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_HEX16((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_HEX32_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_HEX32((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_HEX64_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_HEX64((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_BITS_MESSAGE(mask,expected,actual,message) UNITY_TEST_ASSERT_BITS((mask), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_BITS_HIGH_MESSAGE(mask,actual,message) UNITY_TEST_ASSERT_BITS((mask), (UNITY_UINT32)(-1), (actual), __LINE__, (message))
#define TEST_ASSERT_BITS_LOW_MESSAGE(mask,actual,message) UNITY_TEST_ASSERT_BITS((mask), (UNITY_UINT32)(0), (actual), __LINE__, (message))
#define TEST_ASSERT_BIT_HIGH_MESSAGE(bit,actual,message) UNITY_TEST_ASSERT_BITS(((UNITY_UINT32)1 << (bit)), (UNITY_UINT32)(-1), (actual), __LINE__, (message))
#define TEST_ASSERT_BIT_LOW_MESSAGE(bit,actual,message) UNITY_TEST_ASSERT_BITS(((UNITY_UINT32)1 << (bit)), (UNITY_UINT32)(0), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_CHAR_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_CHAR((expected), (actual), __LINE__, (message))

/* Integer Not Equal To (of all sizes) */
#define TEST_ASSERT_NOT_EQUAL_INT_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_INT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_INT8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_INT8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_INT16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_INT16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_INT32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_INT32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_INT64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_INT64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_UINT_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_UINT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_UINT8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_UINT8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_UINT16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_UINT16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_UINT32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_UINT32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_UINT64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_UINT64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_size_t_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_UINT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_HEX8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_HEX8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_HEX16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_HEX16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_HEX32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_HEX32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_HEX64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_HEX64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_CHAR_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_CHAR((threshold), (actual), __LINE__, (message))


/* Integer Greater Than/ Less Than (of all sizes) */
#define TEST_ASSERT_GREATER_THAN_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_INT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_INT_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_INT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_INT8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_INT8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_INT16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_INT16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_INT32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_INT32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_INT64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_INT64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_UINT_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_UINT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_UINT8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_UINT8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_UINT16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_UINT16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_UINT32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_UINT32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_UINT64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_UINT64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_size_t_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_UINT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_HEX8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_HEX8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_HEX16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_HEX16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_HEX32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_HEX32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_HEX64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_HEX64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_CHAR_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_CHAR((threshold), (actual), __LINE__, (message))

#define TEST_ASSERT_LESS_THAN_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_INT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_INT_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_INT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_INT8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_INT8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_INT16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_INT16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_INT32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_INT32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_INT64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_INT64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_UINT_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_UINT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_UINT8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_UINT8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_UINT16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_UINT16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_UINT32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_UINT32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_UINT64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_UINT64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_size_t_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_UINT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_HEX8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_HEX8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_HEX16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_HEX16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_HEX32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_HEX32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_HEX64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_HEX64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_CHAR_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_THAN_CHAR((threshold), (actual), __LINE__, (message))

#define TEST_ASSERT_GREATER_OR_EQUAL_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_INT_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_INT8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_INT16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_INT32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_INT64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_INT64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_UINT64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_size_t_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_UINT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_HEX64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_HEX64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_CHAR_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_CHAR((threshold), (actual), __LINE__, (message))

#define TEST_ASSERT_LESS_OR_EQUAL_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_INT_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_INT8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_INT16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_INT32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_INT64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_INT64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_UINT_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_UINT8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_UINT16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_UINT32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_UINT64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_size_t_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_UINT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_HEX8_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX8((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_HEX16_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX16((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_HEX32_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX32((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_HEX64_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_HEX64((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_CHAR_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_SMALLER_OR_EQUAL_CHAR((threshold), (actual), __LINE__, (message))

/* Integer Ranges (of all sizes) */
#define TEST_ASSERT_INT_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_INT_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_INT8_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_INT8_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_INT16_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_INT16_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_INT32_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_INT32_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_INT64_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_INT64_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_UINT_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_UINT_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_UINT8_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_UINT8_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_UINT16_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_UINT16_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_UINT32_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_UINT32_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_UINT64_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_UINT64_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_size_t_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_UINT_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_HEX_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_HEX32_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_HEX8_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_HEX8_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_HEX16_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_HEX16_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_HEX32_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_HEX32_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_HEX64_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_HEX64_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_CHAR_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_CHAR_WITHIN((delta), (expected), (actual), __LINE__, (message))

/* Integer Array Ranges (of all sizes) */
#define TEST_ASSERT_INT_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_INT_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_INT8_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_INT8_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_INT16_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_INT16_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_INT32_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_INT32_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_INT64_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_INT64_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_UINT_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_UINT8_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_UINT8_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_UINT16_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_UINT16_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_UINT32_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_UINT32_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_UINT64_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_UINT64_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_size_t_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_UINT_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_HEX_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_HEX8_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_HEX8_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_HEX16_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_HEX16_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_HEX32_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_HEX32_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_HEX64_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_HEX64_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))
#define TEST_ASSERT_CHAR_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_CHAR_ARRAY_WITHIN((delta), (expected), (actual), num_elements, __LINE__, (message))


/* Structs and Strings */
#define TEST_ASSERT_EQUAL_PTR_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_PTR((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_STRING_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_STRING((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_STRING_LEN_MESSAGE(expected,actual,len,message) UNITY_TEST_ASSERT_EQUAL_STRING_LEN((expected), (actual), (len), __LINE__, (message))
#define TEST_ASSERT_EQUAL_MEMORY_MESSAGE(expected,actual,len,message) UNITY_TEST_ASSERT_EQUAL_MEMORY((expected), (actual), (len), __LINE__, (message))

/* Arrays */
#define TEST_ASSERT_EQUAL_INT_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_INT_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_INT8_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_INT8_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_INT16_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_INT16_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_INT32_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_INT32_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_INT64_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_INT64_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_UINT_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_UINT8_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_UINT8_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_UINT16_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_UINT16_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_UINT32_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_UINT64_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_UINT64_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_size_t_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_UINT_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_HEX_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_HEX8_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_HEX16_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_HEX32_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_HEX64_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_HEX64_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_PTR_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_PTR_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_STRING_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_STRING_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_MEMORY_ARRAY_MESSAGE(expected,actual,len,num_elements,message) UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((expected), (actual), (len), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_CHAR_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_CHAR_ARRAY((expected), (actual), (num_elements), __LINE__, (message))

/* Arrays Compared To Single Value*/
#define TEST_ASSERT_EACH_EQUAL_INT_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_INT((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_INT8_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_INT8((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_INT16_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_INT16((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_INT32_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_INT32((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_INT64_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_INT64((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_UINT_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_UINT((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_UINT8_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_UINT8((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_UINT16_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_UINT16((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_UINT32_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_UINT32((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_UINT64_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_UINT64((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_size_t_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_UINT((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_HEX_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_HEX32((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_HEX8_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_HEX8((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_HEX16_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_HEX16((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_HEX32_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_HEX32((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_HEX64_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_HEX64((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_PTR_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_PTR((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_STRING_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_STRING((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_MEMORY_MESSAGE(expected,actual,len,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_MEMORY((expected), (actual), (len), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_CHAR_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_CHAR((expected), (actual), (num_elements), __LINE__, (message))

/* Floating Point (If Enabled) */
#define TEST_ASSERT_FLOAT_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_FLOAT_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_FLOAT_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_FLOAT((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_FLOAT_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_FLOAT((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_FLOAT_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_FLOAT_ARRAY_WITHIN((delta), (expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_FLOAT_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_FLOAT_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_FLOAT((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_FLOAT_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_FLOAT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_FLOAT_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_FLOAT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_FLOAT_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_LESS_THAN_FLOAT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_FLOAT_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_LESS_OR_EQUAL_FLOAT((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_FLOAT_IS_INF_MESSAGE(actual,message) UNITY_TEST_ASSERT_FLOAT_IS_INF((actual), __LINE__, (message))
#define TEST_ASSERT_FLOAT_IS_NEG_INF_MESSAGE(actual,message) UNITY_TEST_ASSERT_FLOAT_IS_NEG_INF((actual), __LINE__, (message))
#define TEST_ASSERT_FLOAT_IS_NAN_MESSAGE(actual,message) UNITY_TEST_ASSERT_FLOAT_IS_NAN((actual), __LINE__, (message))
#define TEST_ASSERT_FLOAT_IS_DETERMINATE_MESSAGE(actual,message) UNITY_TEST_ASSERT_FLOAT_IS_DETERMINATE((actual), __LINE__, (message))
#define TEST_ASSERT_FLOAT_IS_NOT_INF_MESSAGE(actual,message) UNITY_TEST_ASSERT_FLOAT_IS_NOT_INF((actual), __LINE__, (message))
#define TEST_ASSERT_FLOAT_IS_NOT_NEG_INF_MESSAGE(actual,message) UNITY_TEST_ASSERT_FLOAT_IS_NOT_NEG_INF((actual), __LINE__, (message))
#define TEST_ASSERT_FLOAT_IS_NOT_NAN_MESSAGE(actual,message) UNITY_TEST_ASSERT_FLOAT_IS_NOT_NAN((actual), __LINE__, (message))
#define TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE_MESSAGE(actual,message) UNITY_TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE((actual), __LINE__, (message))

/* Double (If Enabled) */
#define TEST_ASSERT_DOUBLE_WITHIN_MESSAGE(delta,expected,actual,message) UNITY_TEST_ASSERT_DOUBLE_WITHIN((delta), (expected), (actual), __LINE__, (message))
#define TEST_ASSERT_EQUAL_DOUBLE_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_DOUBLE((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_DOUBLE_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_NOT_EQUAL_DOUBLE((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_DOUBLE_ARRAY_WITHIN_MESSAGE(delta,expected,actual,num_elements,message) UNITY_TEST_ASSERT_DOUBLE_ARRAY_WITHIN((delta), (expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EQUAL_DOUBLE_ARRAY_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EQUAL_DOUBLE_ARRAY((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_EACH_EQUAL_DOUBLE_MESSAGE(expected,actual,num_elements,message) UNITY_TEST_ASSERT_EACH_EQUAL_DOUBLE((expected), (actual), (num_elements), __LINE__, (message))
#define TEST_ASSERT_GREATER_THAN_DOUBLE_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_THAN_DOUBLE((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_THAN_DOUBLE_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_LESS_THAN_DOUBLE((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_LESS_OR_EQUAL_DOUBLE_MESSAGE(threshold,actual,message) UNITY_TEST_ASSERT_LESS_OR_EQUAL_DOUBLE((threshold), (actual), __LINE__, (message))
#define TEST_ASSERT_DOUBLE_IS_INF_MESSAGE(actual,message) UNITY_TEST_ASSERT_DOUBLE_IS_INF((actual), __LINE__, (message))
#define TEST_ASSERT_DOUBLE_IS_NEG_INF_MESSAGE(actual,message) UNITY_TEST_ASSERT_DOUBLE_IS_NEG_INF((actual), __LINE__, (message))
#define TEST_ASSERT_DOUBLE_IS_NAN_MESSAGE(actual,message) UNITY_TEST_ASSERT_DOUBLE_IS_NAN((actual), __LINE__, (message))
#define TEST_ASSERT_DOUBLE_IS_DETERMINATE_MESSAGE(actual,message) UNITY_TEST_ASSERT_DOUBLE_IS_DETERMINATE((actual), __LINE__, (message))
#define TEST_ASSERT_DOUBLE_IS_NOT_INF_MESSAGE(actual,message) UNITY_TEST_ASSERT_DOUBLE_IS_NOT_INF((actual), __LINE__, (message))
#define TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF_MESSAGE(actual,message) UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF((actual), __LINE__, (message))
#define TEST_ASSERT_DOUBLE_IS_NOT_NAN_MESSAGE(actual,message) UNITY_TEST_ASSERT_DOUBLE_IS_NOT_NAN((actual), __LINE__, (message))
#define TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE_MESSAGE(actual,message) UNITY_TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE((actual), __LINE__, (message))

/* Shorthand */

#define TEST_ASSERT_EQUAL_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT_EQUAL_INT((expected), (actual), __LINE__, (message))
#define TEST_ASSERT_NOT_EQUAL_MESSAGE(expected,actual,message) UNITY_TEST_ASSERT(((expected) != (actual)), __LINE__, (message))


















/* end of UNITY_FRAMEWORK_H */



# 5 "test/test_diag.c" 2
# 1 "Core/Inc/precharge.h" 1
/*
 * precharge.h
 *
 *  Created on: Oct 16, 2025
 *      Author: ordum
 */


#define INC_PRECHARGE_H_ 


#define PRECHARGE_H 





void prechargeInit(void);
void prechargeStart(void);





# 6 "test/test_diag.c" 2
# 1 "Core/Inc/pid.h" 1
/*
 * pid.h
 *
 *  Created on: Oct 16, 2025
 *      Author: ordum
 */


#define INC_PID_H_ 



# 1 "Core/Inc/main.h" 1
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.h
  * @brief          : Header for main.c file.
  *                   This file contains the common defines of the application.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Define to prevent recursive inclusion -------------------------------------*/

#define __MAIN_H 





/* Includes ------------------------------------------------------------------*/
# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal.h
  * @author  MCD Application Team
  * @brief   This file contains all the functions prototypes for the HAL
  *          module driver.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_H 





/* Includes ------------------------------------------------------------------*/
# 1 "Core/Inc/stm32g4xx_hal_conf.h" 1
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_conf.h
  * @author  MCD Application Team
  * @brief   HAL configuration file
  ******************************************************************************
 * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_CONF_H 





/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/

/* ########################## Module Selection ############################## */
/**
  * @brief This is the list of modules to be used in the HAL driver
  */

#define HAL_MODULE_ENABLED 

  #define HAL_ADC_MODULE_ENABLED 
/*#define HAL_COMP_MODULE_ENABLED   */
/*#define HAL_CORDIC_MODULE_ENABLED   */
/*#define HAL_CRC_MODULE_ENABLED   */
/*#define HAL_CRYP_MODULE_ENABLED   */
/*#define HAL_DAC_MODULE_ENABLED   */
#define HAL_FDCAN_MODULE_ENABLED 
/*#define HAL_FMAC_MODULE_ENABLED   */
/*#define HAL_HRTIM_MODULE_ENABLED   */
/*#define HAL_IRDA_MODULE_ENABLED   */
/*#define HAL_IWDG_MODULE_ENABLED   */
/*#define HAL_I2C_MODULE_ENABLED   */
/*#define HAL_I2S_MODULE_ENABLED   */
/*#define HAL_LPTIM_MODULE_ENABLED   */
/*#define HAL_NAND_MODULE_ENABLED   */
/*#define HAL_NOR_MODULE_ENABLED   */
/*#define HAL_OPAMP_MODULE_ENABLED   */
/*#define HAL_PCD_MODULE_ENABLED   */
/*#define HAL_QSPI_MODULE_ENABLED   */
/*#define HAL_RNG_MODULE_ENABLED   */
/*#define HAL_RTC_MODULE_ENABLED   */
/*#define HAL_SAI_MODULE_ENABLED   */
/*#define HAL_SMARTCARD_MODULE_ENABLED   */
/*#define HAL_SMBUS_MODULE_ENABLED   */
/*#define HAL_SPI_MODULE_ENABLED   */
/*#define HAL_SRAM_MODULE_ENABLED   */
#define HAL_TIM_MODULE_ENABLED 
#define HAL_UART_MODULE_ENABLED 
/*#define HAL_USART_MODULE_ENABLED   */
/*#define HAL_WWDG_MODULE_ENABLED   */
#define HAL_GPIO_MODULE_ENABLED 
#define HAL_EXTI_MODULE_ENABLED 
#define HAL_DMA_MODULE_ENABLED 
#define HAL_RCC_MODULE_ENABLED 
#define HAL_FLASH_MODULE_ENABLED 
#define HAL_PWR_MODULE_ENABLED 
#define HAL_CORTEX_MODULE_ENABLED 

/* ########################## Register Callbacks selection ############################## */
/**
  * @brief This is the list of modules where register callback can be used
  */
#define USE_HAL_ADC_REGISTER_CALLBACKS 0U
#define USE_HAL_COMP_REGISTER_CALLBACKS 0U
#define USE_HAL_CORDIC_REGISTER_CALLBACKS 0U
#define USE_HAL_CRYP_REGISTER_CALLBACKS 0U
#define USE_HAL_DAC_REGISTER_CALLBACKS 0U
#define USE_HAL_EXTI_REGISTER_CALLBACKS 0U
#define USE_HAL_FDCAN_REGISTER_CALLBACKS 0U
#define USE_HAL_FMAC_REGISTER_CALLBACKS 0U
#define USE_HAL_HRTIM_REGISTER_CALLBACKS 0U
#define USE_HAL_I2C_REGISTER_CALLBACKS 0U
#define USE_HAL_I2S_REGISTER_CALLBACKS 0U
#define USE_HAL_IRDA_REGISTER_CALLBACKS 0U
#define USE_HAL_LPTIM_REGISTER_CALLBACKS 0U
#define USE_HAL_NAND_REGISTER_CALLBACKS 0U
#define USE_HAL_NOR_REGISTER_CALLBACKS 0U
#define USE_HAL_OPAMP_REGISTER_CALLBACKS 0U
#define USE_HAL_PCD_REGISTER_CALLBACKS 0U
#define USE_HAL_QSPI_REGISTER_CALLBACKS 0U
#define USE_HAL_RNG_REGISTER_CALLBACKS 0U
#define USE_HAL_RTC_REGISTER_CALLBACKS 0U
#define USE_HAL_SAI_REGISTER_CALLBACKS 0U
#define USE_HAL_SMARTCARD_REGISTER_CALLBACKS 0U
#define USE_HAL_SMBUS_REGISTER_CALLBACKS 0U
#define USE_HAL_SPI_REGISTER_CALLBACKS 0U
#define USE_HAL_SRAM_REGISTER_CALLBACKS 0U
#define USE_HAL_TIM_REGISTER_CALLBACKS 0U
#define USE_HAL_UART_REGISTER_CALLBACKS 0U
#define USE_HAL_USART_REGISTER_CALLBACKS 0U
#define USE_HAL_WWDG_REGISTER_CALLBACKS 0U

/* ########################## Oscillator Values adaptation ####################*/
/**
  * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.
  *        This value is used by the RCC HAL module to compute the system frequency
  *        (when HSE is used as system clock source, directly or through the PLL).
  */

  #define HSE_VALUE (8000000UL)



  #define HSE_STARTUP_TIMEOUT (100UL)


/**
  * @brief Internal High Speed oscillator (HSI) value.
  *        This value is used by the RCC HAL module to compute the system frequency
  *        (when HSI is used as system clock source, directly or through the PLL).
  */

  #define HSI_VALUE (16000000UL)


/**
  * @brief Internal High Speed oscillator (HSI48) value for USB FS and RNG.
  *        This internal oscillator is mainly dedicated to provide a high precision clock to
  *        the USB peripheral by means of a special Clock Recovery System (CRS) circuitry.
  *        When the CRS is not used, the HSI48 RC oscillator runs on it default frequency
  *        which is subject to manufacturing process variations.
  */

  #define HSI48_VALUE (48000000UL)



/**
  * @brief Internal Low Speed oscillator (LSI) value.
  */

/*!< Value of the Internal Low Speed oscillator in Hz
The real value may vary depending on the variations in voltage and temperature.*/
#define LSI_VALUE (32000UL)

/**
  * @brief External Low Speed oscillator (LSE) value.
  *        This value is used by the UART, RTC HAL module to compute the system frequency
  */

#define LSE_VALUE (32768UL)



#define LSE_STARTUP_TIMEOUT (5000UL)


/**
  * @brief External clock source for I2S and SAI peripherals
  *        This value is used by the I2S and SAI HAL modules to compute the I2S and SAI clock source
  *        frequency, this source is inserted directly through I2S_CKIN pad.
  */

#define EXTERNAL_CLOCK_VALUE (12288000UL)


/* Tip: To avoid modifying this file each time you need to use different HSE,
   ===  you can define the HSE value in your toolchain compiler preprocessor. */

/* ########################### System Configuration ######################### */
/**
  * @brief This is the HAL system configuration section
  */

#define VDD_VALUE (3300UL)
#define TICK_INT_PRIORITY (7UL)
#define USE_RTOS 0U
#define PREFETCH_ENABLE 0U
#define INSTRUCTION_CACHE_ENABLE 1U
#define DATA_CACHE_ENABLE 1U

/* ########################## Assert Selection ############################## */
/**
  * @brief Uncomment the line below to expanse the "assert_param" macro in the
  *        HAL drivers code
  */
/* #define USE_FULL_ASSERT    1U */

/* ################## SPI peripheral configuration ########################## */

/* CRC FEATURE: Use to activate CRC feature inside HAL SPI Driver
 * Activated: CRC code is present inside driver
 * Deactivated: CRC code cleaned from driver
 */

#define USE_SPI_CRC 0U

/* Includes ------------------------------------------------------------------*/
/**
  * @brief Include module's header file
  */


# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_rcc.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_rcc.h
  * @author  MCD Application Team
  * @brief   Header file of RCC HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_RCC_H 





/* Includes ------------------------------------------------------------------*/
# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_def.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_def.h
  * @author  MCD Application Team
  * @brief   This file contains HAL common defines, enumeration, macros and
  *          structures definitions.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define __STM32G4xx_HAL_DEF 





/* Includes ------------------------------------------------------------------*/
# 1 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g4xx.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx.h
  * @author  MCD Application Team
  * @brief   CMSIS STM32G4xx Device Peripheral Access Layer Header File.
  *
  *          The file is the unique include file that the application programmer
  *          is using in the C source code, usually in main.c. This file contains:
  *           - Configuration section that allows to select:
  *              - The STM32G4xx device used in the target application
  *              - To use or not the peripherals drivers in application code(i.e.
  *                code will be based on direct access to peripherals registers
  *                rather than drivers API), this option is controlled by
  *                "#define USE_HAL_DRIVER"
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/** @addtogroup CMSIS
  * @{
  */

/** @addtogroup stm32g4xx
  * @{
  */


#define __STM32G4xx_H 





/** @addtogroup Library_configuration_section
  * @{
  */

/**
  * @brief STM32 Family
  */

#define STM32G4 


/* Uncomment the line below according to the target STM32G4 device used in your
   application
  */

# 77 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g4xx.h"

/*  Tip: To avoid modifying this file each time you need to switch between these
        devices, you can define the device in your toolchain compiler preprocessor.
  */
# 89 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g4xx.h"

/**
  * @brief CMSIS Device version number V1.2.5
  */
#define __STM32G4_CMSIS_VERSION_MAIN (0x01U)
#define __STM32G4_CMSIS_VERSION_SUB1 (0x02U)
#define __STM32G4_CMSIS_VERSION_SUB2 (0x05U)
#define __STM32G4_CMSIS_VERSION_RC (0x00U)
#define __STM32G4_CMSIS_VERSION ((__STM32G4_CMSIS_VERSION_MAIN << 24) |(__STM32G4_CMSIS_VERSION_SUB1 << 16) |(__STM32G4_CMSIS_VERSION_SUB2 << 8 ) |(__STM32G4_CMSIS_VERSION_RC))




/**
  * @}
  */

/** @addtogroup Device_Included
  * @{
  */








  # 1 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h" 1
/**
  ******************************************************************************
  * @file    stm32g473xx.h
  * @author  MCD Application Team
  * @brief   CMSIS STM32G473xx Device Peripheral Access Layer Header File.
  *
  *          This file contains:
  *           - Data structures and the address mapping for all peripherals
  *           - Peripheral's registers declarations and bits definition
  *           - Macros to access peripheral's registers hardware
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/** @addtogroup CMSIS_Device
  * @{
  */

/** @addtogroup stm32g473xx
  * @{
  */


#define __STM32G473xx_H 





/** @addtogroup Configuration_section_for_CMSIS
  * @{
  */

/**
  * @brief Configuration of the Cortex-M4 Processor and Core Peripherals
   */
#define __CM4_REV 0x0001U
#define __MPU_PRESENT 1U
#define __NVIC_PRIO_BITS 4U
#define __Vendor_SysTickConfig 0U
#define __FPU_PRESENT 1U

/**
  * @}
  */

/** @addtogroup Peripheral_interrupt_number_definition
  * @{
  */

/**
 * @brief STM32G4XX Interrupt Number Definition, according to the selected device
 *        in @ref Library_configuration_section
 */
typedef enum
{
/******  Cortex-M4 Processor Exceptions Numbers *********************************************************************************/
  NonMaskableInt_IRQn         = -14,    /*!< 2 Cortex-M4 Non Maskable Interrupt                                                 */
  HardFault_IRQn              = -13,    /*!< 3 Cortex-M4 Hard Fault Interrupt                                                   */
  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M4 Memory Management Interrupt                                            */
  BusFault_IRQn               = -11,    /*!< 5 Cortex-M4 Bus Fault Interrupt                                                    */
  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M4 Usage Fault Interrupt                                                  */
  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M4 SV Call Interrupt                                                     */
  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M4 Debug Monitor Interrupt                                               */
  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M4 Pend SV Interrupt                                                     */
  SysTick_IRQn                = -1,     /*!< 15 Cortex-M4 System Tick Interrupt                                                 */
/******  STM32 specific Interrupt Numbers ***************************************************************************************/
  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                                                          */
  PVD_PVM_IRQn                = 1,      /*!< PVD/PVM1/PVM2/PVM3/PVM4 through EXTI Line detection Interrupts                     */
  RTC_TAMP_LSECSS_IRQn        = 2,      /*!< RTC Tamper and TimeStamp and RCC LSE CSS interrupts through the EXTI               */
  RTC_WKUP_IRQn               = 3,      /*!< RTC Wakeup interrupt through the EXTI line                                         */
  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                                                             */
  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                                               */
  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                                               */
  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                                               */
  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                                               */
  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                                               */
  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                                               */
  DMA1_Channel1_IRQn          = 11,     /*!< DMA1 Channel 1 global Interrupt                                                    */
  DMA1_Channel2_IRQn          = 12,     /*!< DMA1 Channel 2 global Interrupt                                                    */
  DMA1_Channel3_IRQn          = 13,     /*!< DMA1 Channel 3 global Interrupt                                                    */
  DMA1_Channel4_IRQn          = 14,     /*!< DMA1 Channel 4 global Interrupt                                                    */
  DMA1_Channel5_IRQn          = 15,     /*!< DMA1 Channel 5 global Interrupt                                                    */
  DMA1_Channel6_IRQn          = 16,     /*!< DMA1 Channel 6 global Interrupt                                                    */
  DMA1_Channel7_IRQn          = 17,     /*!< DMA1 Channel 7 global Interrupt                                                    */
  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                                                     */
  USB_HP_IRQn                 = 19,     /*!< USB HP Interrupt                                                                   */
  USB_LP_IRQn                 = 20,     /*!< USB LP  Interrupt                                                                  */
  FDCAN1_IT0_IRQn             = 21,     /*!< FDCAN1 IT0 Interrupt                                                               */
  FDCAN1_IT1_IRQn             = 22,     /*!< FDCAN1 IT1 Interrupt                                                               */
  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                                      */
  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break, Transition error, Index error and TIM15 global interrupt               */
  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM16 global interrupt                                   */
  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 TIM1 Trigger, Commutation, Direction change, Index and TIM17 global interrupt */
  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                                     */
  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                                              */
  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                                              */
  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                                              */
  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                                               */
  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                                               */
  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                                               */
  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                                               */
  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                                              */
  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                                              */
  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                                            */
  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                                            */
  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                                            */
  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                                    */
  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                                    */
  USBWakeUp_IRQn              = 42,     /*!< USB Wakeup through EXTI line Interrupt                                             */
  TIM8_BRK_IRQn               = 43,     /*!< TIM8 Break, Transition error and Index error Interrupt                             */
  TIM8_UP_IRQn                = 44,     /*!< TIM8 Update Interrupt                                                              */
  TIM8_TRG_COM_IRQn           = 45,     /*!< TIM8 Trigger, Commutation, Direction change and Index Interrupt                    */
  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                                     */
  ADC3_IRQn                   = 47,     /*!< ADC3 global  Interrupt                                                             */
  FMC_IRQn                    = 48,     /*!< FMC global Interrupt                                                               */
  LPTIM1_IRQn                 = 49,     /*!< LP TIM1 Interrupt                                                                  */
  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                                              */
  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                                              */
  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                                             */
  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                                             */
  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&3 underrun error  interrupts                                  */
  TIM7_DAC_IRQn               = 55,     /*!< TIM7 global and DAC2&4 underrun error  interrupts                                  */
  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                                                    */
  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                                                    */
  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                                                    */
  DMA2_Channel4_IRQn          = 59,     /*!< DMA2 Channel 4 global Interrupt                                                    */
  DMA2_Channel5_IRQn          = 60,     /*!< DMA2 Channel 5 global Interrupt                                                    */
  ADC4_IRQn                   = 61,     /*!< ADC4 global Interrupt                                                              */
  ADC5_IRQn                   = 62,     /*!< ADC5 global Interrupt                                                              */
  UCPD1_IRQn                  = 63,     /*!< UCPD global Interrupt                                                              */
  COMP1_2_3_IRQn              = 64,     /*!< COMP1, COMP2 and COMP3 Interrupts                                                  */
  COMP4_5_6_IRQn              = 65,     /*!< COMP4, COMP5 and COMP6                                                             */
  COMP7_IRQn                  = 66,     /*!< COMP7 Interrupt                                                                    */
  CRS_IRQn                    = 75,     /*!< CRS global interrupt                                                               */
  SAI1_IRQn                   = 76,     /*!< Serial Audio Interface global interrupt                                            */
  TIM20_BRK_IRQn              = 77,     /*!< TIM20 Break, Transition error and Index error Interrupt                            */
  TIM20_UP_IRQn               = 78,     /*!< TIM20 Update interrupt                                                             */
  TIM20_TRG_COM_IRQn          = 79,     /*!< TIM20 Trigger, Commutation, Direction change and Index Interrupt                   */
  TIM20_CC_IRQn               = 80,     /*!< TIM20 Capture Compare interrupt                                                    */
  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                                               */
  I2C4_EV_IRQn                = 82,     /*!< I2C4 Event interrupt                                                               */
  I2C4_ER_IRQn                = 83,     /*!< I2C4 Error interrupt                                                               */
  SPI4_IRQn                   = 84,     /*!< SPI4 Event interrupt                                                               */
  FDCAN2_IT0_IRQn             = 86,     /*!< FDCAN2 interrupt line 0 interrupt                                                  */
  FDCAN2_IT1_IRQn             = 87,     /*!< FDCAN2 interrupt line 1 interrupt                                                  */
  FDCAN3_IT0_IRQn             = 88,     /*!< FDCAN3 interrupt line 0 interrupt                                                  */
  FDCAN3_IT1_IRQn             = 89,     /*!< FDCAN3 interrupt line 1 interrupt                                                  */
  RNG_IRQn                    = 90,     /*!< RNG global interrupt                                                               */
  LPUART1_IRQn                = 91,     /*!< LP UART 1 Interrupt                                                                */
  I2C3_EV_IRQn                = 92,     /*!< I2C3 Event Interrupt                                                               */
  I2C3_ER_IRQn                = 93,     /*!< I2C3 Error interrupt                                                               */
  DMAMUX_OVR_IRQn             = 94,     /*!< DMAMUX overrun global interrupt                                                    */
  QUADSPI_IRQn                = 95,     /*!< QUADSPI interrupt                                                                  */
  DMA1_Channel8_IRQn          = 96,     /*!< DMA1 Channel 8 interrupt                                                           */
  DMA2_Channel6_IRQn          = 97,     /*!< DMA2 Channel 6 interrupt                                                           */
  DMA2_Channel7_IRQn          = 98,     /*!< DMA2 Channel 7 interrupt                                                           */
  DMA2_Channel8_IRQn          = 99,     /*!< DMA2 Channel 8 interrupt                                                           */
  CORDIC_IRQn                 = 100,    /*!< CORDIC global Interrupt                                                            */
  FMAC_IRQn                   = 101     /*!< FMAC global Interrupt                                                              */
} IRQn_Type;

/**
  * @}
  */

# 1 "Drivers/CMSIS/Include/core_cm4.h" 1
/**************************************************************************//**
 * @file     core_cm4.h
 * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
 * @version  V5.1.0
 * @date     13. March 2019
 ******************************************************************************/
/*
 * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








#define __CORE_CM4_H_GENERIC 







/**
  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  CMSIS violates the following MISRA-C:2004 rules:

   \li Required Rule 8.5, object/function definition in header file.<br>
     Function definitions in header files are used to allow 'inlining'.

   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
     Unions are used for effective representation of core registers.

   \li Advisory Rule 19.7, Function-like macro defined.<br>
     Function-like macros are used to allow more efficient code.
 */


/*******************************************************************************
 *                 CMSIS definitions
 ******************************************************************************/
/**
  \ingroup Cortex_M4
  @{
 */

# 1 "Drivers/CMSIS/Include/cmsis_version.h" 1
/**************************************************************************//**
 * @file     cmsis_version.h
 * @brief    CMSIS Core(M) Version definitions
 * @version  V5.0.3
 * @date     24. June 2019
 ******************************************************************************/
/*
 * Copyright (c) 2009-2019 ARM Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








#define __CMSIS_VERSION_H 

/*  CMSIS Version definitions */
#define __CM_CMSIS_VERSION_MAIN ( 5U)
#define __CM_CMSIS_VERSION_SUB ( 3U)
#define __CM_CMSIS_VERSION ((__CM_CMSIS_VERSION_MAIN << 16U) | __CM_CMSIS_VERSION_SUB )

# 64 "Drivers/CMSIS/Include/core_cm4.h" 2

/* CMSIS CM4 definitions */
#define __CM4_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)
#define __CM4_CMSIS_VERSION_SUB (__CM_CMSIS_VERSION_SUB)
#define __CM4_CMSIS_VERSION ((__CM4_CMSIS_VERSION_MAIN << 16U) | __CM4_CMSIS_VERSION_SUB )


#define __CORTEX_M (4U)

/** __FPU_USED indicates whether an FPU is used or not.
    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
*/
# 101 "Drivers/CMSIS/Include/core_cm4.h"
  # 109 "Drivers/CMSIS/Include/core_cm4.h"
    #define __FPU_USED 0U
  

# 161 "Drivers/CMSIS/Include/core_cm4.h"

# 1 "Drivers/CMSIS/Include/cmsis_compiler.h" 1
/**************************************************************************//**
 * @file     cmsis_compiler.h
 * @brief    CMSIS compiler generic header file
 * @version  V5.1.0
 * @date     09. October 2018
 ******************************************************************************/
/*
 * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#define __CMSIS_COMPILER_H 



/*
 * Arm Compiler 4/5
 */
# 54 "Drivers/CMSIS/Include/cmsis_compiler.h"
  # 1 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
/**************************************************************************//**
 * @file     cmsis_gcc.h
 * @brief    CMSIS compiler GCC header file
 * @version  V5.2.0
 * @date     08. May 2019
 ******************************************************************************/
/*
 * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#define __CMSIS_GCC_H 

/* ignore some GCC warnings */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wunused-parameter"

/* Fallback for __has_builtin */




/* CMSIS compiler specific defines */

  #define __ASM __asm


  #define __INLINE inline


  #define __STATIC_INLINE static inline


  #define __STATIC_FORCEINLINE __attribute__((always_inline)) static inline


  #define __NO_RETURN __attribute__((__noreturn__))


  #define __USED __attribute__((used))


  #define __WEAK __attribute__((weak))


  #define __PACKED __attribute__((packed, aligned(1)))


  #define __PACKED_STRUCT struct __attribute__((packed, aligned(1)))


  #define __PACKED_UNION union __attribute__((packed, aligned(1)))


  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wpacked"
  #pragma GCC diagnostic ignored "-Wattributes"
  struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  #pragma GCC diagnostic pop
  #define __UNALIGNED_UINT32(x) (((struct T_UINT32 *)(x))->v)


  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wpacked"
  #pragma GCC diagnostic ignored "-Wattributes"
  __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  #pragma GCC diagnostic pop
  #define __UNALIGNED_UINT16_WRITE(addr,val) (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))


  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wpacked"
  #pragma GCC diagnostic ignored "-Wattributes"
  __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  #pragma GCC diagnostic pop
  #define __UNALIGNED_UINT16_READ(addr) (((const struct T_UINT16_READ *)(const void *)(addr))->v)


  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wpacked"
  #pragma GCC diagnostic ignored "-Wattributes"
  __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  #pragma GCC diagnostic pop
  #define __UNALIGNED_UINT32_WRITE(addr,val) (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))


  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wpacked"
  #pragma GCC diagnostic ignored "-Wattributes"
  __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
  #pragma GCC diagnostic pop
  #define __UNALIGNED_UINT32_READ(addr) (((const struct T_UINT32_READ *)(const void *)(addr))->v)


  #define __ALIGNED(x) __attribute__((aligned(x)))


  #define __RESTRICT __restrict


  #define __COMPILER_BARRIER() __ASM volatile("":::"memory")


/* #########################  Startup and Lowlevel Init  ######################## */



/**
  \brief   Initializes data and bss sections
  \details This default implementations initialized all data and additional bss
           sections relying on .copy.table and .zero.table specified properly
           in the used linker script.
  
 */
__STATIC_FORCEINLINE __NO_RETURN void __cmsis_start(void)
{
  extern void _start(void) __NO_RETURN;
  
  typedef struct {
    uint32_t const* src;
    uint32_t* dest;
    uint32_t  wlen;
  } __copy_table_t;
  
  typedef struct {
    uint32_t* dest;
    uint32_t  wlen;
  } __zero_table_t;
  
  extern const __copy_table_t __copy_table_start__;
  extern const __copy_table_t __copy_table_end__;
  extern const __zero_table_t __zero_table_start__;
  extern const __zero_table_t __zero_table_end__;

  for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable) {
    for(uint32_t i=0u; i<pTable->wlen; ++i) {
      pTable->dest[i] = pTable->src[i];
    }
  }
 
  for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable) {
    for(uint32_t i=0u; i<pTable->wlen; ++i) {
      pTable->dest[i] = 0u;
    }
  }
 
  _start();
}
  
#define __PROGRAM_START __cmsis_start



#define __INITIAL_SP __StackTop



#define __STACK_LIMIT __StackLimit



#define __VECTOR_TABLE __Vectors



#define __VECTOR_TABLE_ATTRIBUTE __attribute((used, section(".vectors")))


/* ###########################  Core Function Access  ########################### */
/** \ingroup  CMSIS_Core_FunctionInterface
    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  @{
 */

/**
  \brief   Enable IRQ Interrupts
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
}


/**
  \brief   Disable IRQ Interrupts
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
}


/**
  \brief   Get Control Register
  \details Returns the content of the Control Register.
  \return               Control Register value
 */
__STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
  return(result);
}


# 241 "Drivers/CMSIS/Include/cmsis_gcc.h"


/**
  \brief   Set Control Register
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
{
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
}


# 265 "Drivers/CMSIS/Include/cmsis_gcc.h"


/**
  \brief   Get IPSR Register
  \details Returns the content of the IPSR Register.
  \return               IPSR Register value
 */
__STATIC_FORCEINLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
  return(result);
}


/**
  \brief   Get APSR Register
  \details Returns the content of the APSR Register.
  \return               APSR Register value
 */
__STATIC_FORCEINLINE uint32_t __get_APSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
  return(result);
}


/**
  \brief   Get xPSR Register
  \details Returns the content of the xPSR Register.
  \return               xPSR Register value
 */
__STATIC_FORCEINLINE uint32_t __get_xPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
  return(result);
}


/**
  \brief   Get Process Stack Pointer
  \details Returns the current value of the Process Stack Pointer (PSP).
  \return               PSP Register value
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  return(result);
}


# 337 "Drivers/CMSIS/Include/cmsis_gcc.h"


/**
  \brief   Set Process Stack Pointer
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
}


# 361 "Drivers/CMSIS/Include/cmsis_gcc.h"


/**
  \brief   Get Main Stack Pointer
  \details Returns the current value of the Main Stack Pointer (MSP).
  \return               MSP Register value
 */
__STATIC_FORCEINLINE uint32_t __get_MSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, msp" : "=r" (result) );
  return(result);
}


# 391 "Drivers/CMSIS/Include/cmsis_gcc.h"


/**
  \brief   Set Main Stack Pointer
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
}


# 415 "Drivers/CMSIS/Include/cmsis_gcc.h"


# 442 "Drivers/CMSIS/Include/cmsis_gcc.h"


/**
  \brief   Get Priority Mask
  \details Returns the current state of the priority mask bit from the Priority Mask Register.
  \return               Priority Mask value
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  return(result);
}


# 472 "Drivers/CMSIS/Include/cmsis_gcc.h"


/**
  \brief   Set Priority Mask
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
}


# 496 "Drivers/CMSIS/Include/cmsis_gcc.h"


# 645 "Drivers/CMSIS/Include/cmsis_gcc.h"


# 826 "Drivers/CMSIS/Include/cmsis_gcc.h"


/**
  \brief   Get FPSCR
  \details Returns the current value of the Floating Point Status/Control register.
  \return               Floating Point Status/Control register value
 */
__STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
{
# 849 "Drivers/CMSIS/Include/cmsis_gcc.h"
  return(0U);

}


/**
  \brief   Set FPSCR
  \details Assigns the given value to the Floating Point Status/Control register.
  \param [in]    fpscr  Floating Point Status/Control value to set
 */
__STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
{
# 872 "Drivers/CMSIS/Include/cmsis_gcc.h"
  (void)fpscr;

}


/*@} end of CMSIS_Core_RegAccFunctions */


/* ##########################  Core Instruction Access  ######################### */
/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
  Access to dedicated instructions
  @{
*/

/* Define macros for porting to both thumb1 and thumb2.
 * For thumb1, use low register (r0-r7), specified by constraint "l"
 * Otherwise, use general registers, specified by constraint "r" */





#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
#define __CMSIS_GCC_RW_REG(r) "+r" (r)
#define __CMSIS_GCC_USE_REG(r) "r" (r)


/**
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
#define __NOP() __ASM volatile ("nop")

/**
  \brief   Wait For Interrupt
  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
 */
#define __WFI() __ASM volatile ("wfi")


/**
  \brief   Wait For Event
  \details Wait For Event is a hint instruction that permits the processor to enter
           a low-power state until one of a number of events occurs.
 */
#define __WFE() __ASM volatile ("wfe")


/**
  \brief   Send Event
  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 */
#define __SEV() __ASM volatile ("sev")


/**
  \brief   Instruction Synchronization Barrier
  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
}


/**
  \brief   Data Synchronization Barrier
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
}


/**
  \brief   Data Memory Barrier
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
}


/**
  \brief   Reverse byte order (32 bit)
  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
  \param [in]    value  Value to reverse
  \return               Reversed value
 */
__STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
{

  return __builtin_bswap32(value);






}


/**
  \brief   Reverse byte order (16 bit)
  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
  \param [in]    value  Value to reverse
  \return               Reversed value
 */
__STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
{
  uint32_t result;

  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
  return result;
}


/**
  \brief   Reverse byte order (16 bit)
  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
  \param [in]    value  Value to reverse
  \return               Reversed value
 */
__STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
{

  return (int16_t)__builtin_bswap16(value);






}


/**
  \brief   Rotate Right in unsigned value (32 bit)
  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
  \param [in]    op1  Value to rotate
  \param [in]    op2  Number of Bits to rotate
  \return               Rotated value
 */
__STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
{
  op2 %= 32U;
  if (op2 == 0U)
  {
    return op1;
  }
  return (op1 >> op2) | (op1 << (32U - op2));
}


/**
  \brief   Breakpoint
  \details Causes the processor to enter Debug state.
           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
  \param [in]    value  is ignored by the processor.
                 If required, a debugger can use it to store additional information about the breakpoint.
 */
#define __BKPT(value) __ASM volatile ("bkpt "#value)


/**
  \brief   Reverse bit order of value
  \details Reverses the bit order of the given value.
  \param [in]    value  Value to reverse
  \return               Reversed value
 */
__STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;






  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */

  result = value;                      /* r will be reversed bits of v; first get LSB of v */
  for (value >>= 1U; value != 0U; value >>= 1U)
  {
    result <<= 1U;
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */

  return result;
}


/**
  \brief   Count leading zeros
  \details Counts the number of leading zeros of a data value.
  \param [in]  value  Value to count the leading zeros
  \return             number of leading zeros in value
 */
__STATIC_FORCEINLINE uint8_t __CLZ(uint32_t value)
{
  /* Even though __builtin_clz produces a CLZ instruction on ARM, formally
     __builtin_clz(0) is undefined behaviour, so handle this case specially.
     This guarantees ARM-compatible results if happening to compile on a non-ARM
     target, and ensures the compiler doesn't decide to activate any
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
}


# 1224 "Drivers/CMSIS/Include/cmsis_gcc.h"


# 1374 "Drivers/CMSIS/Include/cmsis_gcc.h"

/**
  \brief   Signed Saturate
  \details Saturates a signed value.
  \param [in]  value  Value to be saturated
  \param [in]    sat  Bit position to saturate to (1..32)
  \return             Saturated value
 */
__STATIC_FORCEINLINE int32_t __SSAT(int32_t val, uint32_t sat)
{
  if ((sat >= 1U) && (sat <= 32U))
  {
    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
    const int32_t min = -1 - max ;
    if (val > max)
    {
      return max;
    }
    else if (val < min)
    {
      return min;
    }
  }
  return val;
}

/**
  \brief   Unsigned Saturate
  \details Saturates an unsigned value.
  \param [in]  value  Value to be saturated
  \param [in]    sat  Bit position to saturate to (0..31)
  \return             Saturated value
 */
__STATIC_FORCEINLINE uint32_t __USAT(int32_t val, uint32_t sat)
{
  if (sat <= 31U)
  {
    const uint32_t max = ((1U << sat) - 1U);
    if (val > (int32_t)max)
    {
      return max;
    }
    else if (val < 0)
    {
      return 0U;
    }
  }
  return (uint32_t)val;
}






# 1609 "Drivers/CMSIS/Include/cmsis_gcc.h"

/*@}*/ /* end of group CMSIS_Core_InstructionInterface */


/* ###################  Compiler specific Intrinsics  ########################### */
/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
  Access to dedicated SIMD instructions
  @{
*/

# 2163 "Drivers/CMSIS/Include/cmsis_gcc.h"
/*@} end of group CMSIS_SIMD_intrinsics */


#pragma GCC diagnostic pop

# 55 "Drivers/CMSIS/Include/cmsis_compiler.h" 2


/*
 * IAR Compiler
 */
# 280 "Drivers/CMSIS/Include/cmsis_compiler.h"




# 163 "Drivers/CMSIS/Include/core_cm4.h" 2











#define __CORE_CM4_H_DEPENDANT 





/* check device defines and use defaults */
# 207 "Drivers/CMSIS/Include/core_cm4.h"

/* IO definitions (access restrictions to peripheral registers) */
/**
    \defgroup CMSIS_glob_defs CMSIS Global Defines

    <strong>IO Type Qualifiers</strong> are used
    \li to specify the access to peripheral variables.
    \li for automatic generation of peripheral register debug information.
*/



  #define __I volatile const

#define __O volatile
#define __IO volatile

/* following defines should be used for structure members */
#define __IM volatile const
#define __OM volatile
#define __IOM volatile

/*@} end of group Cortex_M4 */



/*******************************************************************************
 *                 Register Abstraction
  Core Register contain:
  - Core Register
  - Core NVIC Register
  - Core SCB Register
  - Core SysTick Register
  - Core Debug Register
  - Core MPU Register
  - Core FPU Register
 ******************************************************************************/
/**
  \defgroup CMSIS_core_register Defines and Type Definitions
  \brief Type definitions and defines for Cortex-M processor based devices.
*/

/**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_CORE  Status and Control Registers
  \brief      Core Register type definitions.
  @{
 */

/**
  \brief  Union type to access the Application Program Status Register (APSR).
 */
typedef union
{
  struct
  {
    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
  } b;                                   /*!< Structure used for bit  access */
  uint32_t w;                            /*!< Type      used for word access */
} APSR_Type;

/* APSR Register Definitions */
#define APSR_N_Pos 31U
#define APSR_N_Msk (1UL << APSR_N_Pos)

#define APSR_Z_Pos 30U
#define APSR_Z_Msk (1UL << APSR_Z_Pos)

#define APSR_C_Pos 29U
#define APSR_C_Msk (1UL << APSR_C_Pos)

#define APSR_V_Pos 28U
#define APSR_V_Msk (1UL << APSR_V_Pos)

#define APSR_Q_Pos 27U
#define APSR_Q_Msk (1UL << APSR_Q_Pos)

#define APSR_GE_Pos 16U
#define APSR_GE_Msk (0xFUL << APSR_GE_Pos)


/**
  \brief  Union type to access the Interrupt Program Status Register (IPSR).
 */
typedef union
{
  struct
  {
    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
  } b;                                   /*!< Structure used for bit  access */
  uint32_t w;                            /*!< Type      used for word access */
} IPSR_Type;

/* IPSR Register Definitions */
#define IPSR_ISR_Pos 0U
#define IPSR_ISR_Msk (0x1FFUL )


/**
  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 */
typedef union
{
  struct
  {
    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
    uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
    uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
    uint32_t T:1;                        /*!< bit:     24  Thumb bit */
    uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
  } b;                                   /*!< Structure used for bit  access */
  uint32_t w;                            /*!< Type      used for word access */
} xPSR_Type;

/* xPSR Register Definitions */
#define xPSR_N_Pos 31U
#define xPSR_N_Msk (1UL << xPSR_N_Pos)

#define xPSR_Z_Pos 30U
#define xPSR_Z_Msk (1UL << xPSR_Z_Pos)

#define xPSR_C_Pos 29U
#define xPSR_C_Msk (1UL << xPSR_C_Pos)

#define xPSR_V_Pos 28U
#define xPSR_V_Msk (1UL << xPSR_V_Pos)

#define xPSR_Q_Pos 27U
#define xPSR_Q_Msk (1UL << xPSR_Q_Pos)

#define xPSR_ICI_IT_2_Pos 25U
#define xPSR_ICI_IT_2_Msk (3UL << xPSR_ICI_IT_2_Pos)

#define xPSR_T_Pos 24U
#define xPSR_T_Msk (1UL << xPSR_T_Pos)

#define xPSR_GE_Pos 16U
#define xPSR_GE_Msk (0xFUL << xPSR_GE_Pos)

#define xPSR_ICI_IT_1_Pos 10U
#define xPSR_ICI_IT_1_Msk (0x3FUL << xPSR_ICI_IT_1_Pos)

#define xPSR_ISR_Pos 0U
#define xPSR_ISR_Msk (0x1FFUL )


/**
  \brief  Union type to access the Control Registers (CONTROL).
 */
typedef union
{
  struct
  {
    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
  } b;                                   /*!< Structure used for bit  access */
  uint32_t w;                            /*!< Type      used for word access */
} CONTROL_Type;

/* CONTROL Register Definitions */
#define CONTROL_FPCA_Pos 2U
#define CONTROL_FPCA_Msk (1UL << CONTROL_FPCA_Pos)

#define CONTROL_SPSEL_Pos 1U
#define CONTROL_SPSEL_Msk (1UL << CONTROL_SPSEL_Pos)

#define CONTROL_nPRIV_Pos 0U
#define CONTROL_nPRIV_Msk (1UL )

/*@} end of group CMSIS_CORE */


/**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
  \brief      Type definitions for the NVIC Registers
  @{
 */

/**
  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 */
typedef struct
{
  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
        uint32_t RESERVED0[24U];
  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
        uint32_t RESERVED1[24U];
  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
        uint32_t RESERVED2[24U];
  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
        uint32_t RESERVED3[24U];
  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
        uint32_t RESERVED4[56U];
  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
        uint32_t RESERVED5[644U];
  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
}  NVIC_Type;

/* Software Triggered Interrupt Register Definitions */
#define NVIC_STIR_INTID_Pos 0U
#define NVIC_STIR_INTID_Msk (0x1FFUL )

/*@} end of group CMSIS_NVIC */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_SCB     System Control Block (SCB)
  \brief    Type definitions for the System Control Block Registers
  @{
 */

/**
  \brief  Structure type to access the System Control Block (SCB).
 */
typedef struct
{
  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
        uint32_t RESERVED0[5U];
  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
} SCB_Type;

/* SCB CPUID Register Definitions */
#define SCB_CPUID_IMPLEMENTER_Pos 24U
#define SCB_CPUID_IMPLEMENTER_Msk (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)

#define SCB_CPUID_VARIANT_Pos 20U
#define SCB_CPUID_VARIANT_Msk (0xFUL << SCB_CPUID_VARIANT_Pos)

#define SCB_CPUID_ARCHITECTURE_Pos 16U
#define SCB_CPUID_ARCHITECTURE_Msk (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)

#define SCB_CPUID_PARTNO_Pos 4U
#define SCB_CPUID_PARTNO_Msk (0xFFFUL << SCB_CPUID_PARTNO_Pos)

#define SCB_CPUID_REVISION_Pos 0U
#define SCB_CPUID_REVISION_Msk (0xFUL )

/* SCB Interrupt Control State Register Definitions */
#define SCB_ICSR_NMIPENDSET_Pos 31U
#define SCB_ICSR_NMIPENDSET_Msk (1UL << SCB_ICSR_NMIPENDSET_Pos)

#define SCB_ICSR_PENDSVSET_Pos 28U
#define SCB_ICSR_PENDSVSET_Msk (1UL << SCB_ICSR_PENDSVSET_Pos)

#define SCB_ICSR_PENDSVCLR_Pos 27U
#define SCB_ICSR_PENDSVCLR_Msk (1UL << SCB_ICSR_PENDSVCLR_Pos)

#define SCB_ICSR_PENDSTSET_Pos 26U
#define SCB_ICSR_PENDSTSET_Msk (1UL << SCB_ICSR_PENDSTSET_Pos)

#define SCB_ICSR_PENDSTCLR_Pos 25U
#define SCB_ICSR_PENDSTCLR_Msk (1UL << SCB_ICSR_PENDSTCLR_Pos)

#define SCB_ICSR_ISRPREEMPT_Pos 23U
#define SCB_ICSR_ISRPREEMPT_Msk (1UL << SCB_ICSR_ISRPREEMPT_Pos)

#define SCB_ICSR_ISRPENDING_Pos 22U
#define SCB_ICSR_ISRPENDING_Msk (1UL << SCB_ICSR_ISRPENDING_Pos)

#define SCB_ICSR_VECTPENDING_Pos 12U
#define SCB_ICSR_VECTPENDING_Msk (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)

#define SCB_ICSR_RETTOBASE_Pos 11U
#define SCB_ICSR_RETTOBASE_Msk (1UL << SCB_ICSR_RETTOBASE_Pos)

#define SCB_ICSR_VECTACTIVE_Pos 0U
#define SCB_ICSR_VECTACTIVE_Msk (0x1FFUL )

/* SCB Vector Table Offset Register Definitions */
#define SCB_VTOR_TBLOFF_Pos 7U
#define SCB_VTOR_TBLOFF_Msk (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)

/* SCB Application Interrupt and Reset Control Register Definitions */
#define SCB_AIRCR_VECTKEY_Pos 16U
#define SCB_AIRCR_VECTKEY_Msk (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)

#define SCB_AIRCR_VECTKEYSTAT_Pos 16U
#define SCB_AIRCR_VECTKEYSTAT_Msk (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)

#define SCB_AIRCR_ENDIANESS_Pos 15U
#define SCB_AIRCR_ENDIANESS_Msk (1UL << SCB_AIRCR_ENDIANESS_Pos)

#define SCB_AIRCR_PRIGROUP_Pos 8U
#define SCB_AIRCR_PRIGROUP_Msk (7UL << SCB_AIRCR_PRIGROUP_Pos)

#define SCB_AIRCR_SYSRESETREQ_Pos 2U
#define SCB_AIRCR_SYSRESETREQ_Msk (1UL << SCB_AIRCR_SYSRESETREQ_Pos)

#define SCB_AIRCR_VECTCLRACTIVE_Pos 1U
#define SCB_AIRCR_VECTCLRACTIVE_Msk (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)

#define SCB_AIRCR_VECTRESET_Pos 0U
#define SCB_AIRCR_VECTRESET_Msk (1UL )

/* SCB System Control Register Definitions */
#define SCB_SCR_SEVONPEND_Pos 4U
#define SCB_SCR_SEVONPEND_Msk (1UL << SCB_SCR_SEVONPEND_Pos)

#define SCB_SCR_SLEEPDEEP_Pos 2U
#define SCB_SCR_SLEEPDEEP_Msk (1UL << SCB_SCR_SLEEPDEEP_Pos)

#define SCB_SCR_SLEEPONEXIT_Pos 1U
#define SCB_SCR_SLEEPONEXIT_Msk (1UL << SCB_SCR_SLEEPONEXIT_Pos)

/* SCB Configuration Control Register Definitions */
#define SCB_CCR_STKALIGN_Pos 9U
#define SCB_CCR_STKALIGN_Msk (1UL << SCB_CCR_STKALIGN_Pos)

#define SCB_CCR_BFHFNMIGN_Pos 8U
#define SCB_CCR_BFHFNMIGN_Msk (1UL << SCB_CCR_BFHFNMIGN_Pos)

#define SCB_CCR_DIV_0_TRP_Pos 4U
#define SCB_CCR_DIV_0_TRP_Msk (1UL << SCB_CCR_DIV_0_TRP_Pos)

#define SCB_CCR_UNALIGN_TRP_Pos 3U
#define SCB_CCR_UNALIGN_TRP_Msk (1UL << SCB_CCR_UNALIGN_TRP_Pos)

#define SCB_CCR_USERSETMPEND_Pos 1U
#define SCB_CCR_USERSETMPEND_Msk (1UL << SCB_CCR_USERSETMPEND_Pos)

#define SCB_CCR_NONBASETHRDENA_Pos 0U
#define SCB_CCR_NONBASETHRDENA_Msk (1UL )

/* SCB System Handler Control and State Register Definitions */
#define SCB_SHCSR_USGFAULTENA_Pos 18U
#define SCB_SHCSR_USGFAULTENA_Msk (1UL << SCB_SHCSR_USGFAULTENA_Pos)

#define SCB_SHCSR_BUSFAULTENA_Pos 17U
#define SCB_SHCSR_BUSFAULTENA_Msk (1UL << SCB_SHCSR_BUSFAULTENA_Pos)

#define SCB_SHCSR_MEMFAULTENA_Pos 16U
#define SCB_SHCSR_MEMFAULTENA_Msk (1UL << SCB_SHCSR_MEMFAULTENA_Pos)

#define SCB_SHCSR_SVCALLPENDED_Pos 15U
#define SCB_SHCSR_SVCALLPENDED_Msk (1UL << SCB_SHCSR_SVCALLPENDED_Pos)

#define SCB_SHCSR_BUSFAULTPENDED_Pos 14U
#define SCB_SHCSR_BUSFAULTPENDED_Msk (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)

#define SCB_SHCSR_MEMFAULTPENDED_Pos 13U
#define SCB_SHCSR_MEMFAULTPENDED_Msk (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)

#define SCB_SHCSR_USGFAULTPENDED_Pos 12U
#define SCB_SHCSR_USGFAULTPENDED_Msk (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)

#define SCB_SHCSR_SYSTICKACT_Pos 11U
#define SCB_SHCSR_SYSTICKACT_Msk (1UL << SCB_SHCSR_SYSTICKACT_Pos)

#define SCB_SHCSR_PENDSVACT_Pos 10U
#define SCB_SHCSR_PENDSVACT_Msk (1UL << SCB_SHCSR_PENDSVACT_Pos)

#define SCB_SHCSR_MONITORACT_Pos 8U
#define SCB_SHCSR_MONITORACT_Msk (1UL << SCB_SHCSR_MONITORACT_Pos)

#define SCB_SHCSR_SVCALLACT_Pos 7U
#define SCB_SHCSR_SVCALLACT_Msk (1UL << SCB_SHCSR_SVCALLACT_Pos)

#define SCB_SHCSR_USGFAULTACT_Pos 3U
#define SCB_SHCSR_USGFAULTACT_Msk (1UL << SCB_SHCSR_USGFAULTACT_Pos)

#define SCB_SHCSR_BUSFAULTACT_Pos 1U
#define SCB_SHCSR_BUSFAULTACT_Msk (1UL << SCB_SHCSR_BUSFAULTACT_Pos)

#define SCB_SHCSR_MEMFAULTACT_Pos 0U
#define SCB_SHCSR_MEMFAULTACT_Msk (1UL )

/* SCB Configurable Fault Status Register Definitions */
#define SCB_CFSR_USGFAULTSR_Pos 16U
#define SCB_CFSR_USGFAULTSR_Msk (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)

#define SCB_CFSR_BUSFAULTSR_Pos 8U
#define SCB_CFSR_BUSFAULTSR_Msk (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)

#define SCB_CFSR_MEMFAULTSR_Pos 0U
#define SCB_CFSR_MEMFAULTSR_Msk (0xFFUL )

/* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
#define SCB_CFSR_MMARVALID_Pos (SCB_SHCSR_MEMFAULTACT_Pos + 7U)
#define SCB_CFSR_MMARVALID_Msk (1UL << SCB_CFSR_MMARVALID_Pos)

#define SCB_CFSR_MLSPERR_Pos (SCB_SHCSR_MEMFAULTACT_Pos + 5U)
#define SCB_CFSR_MLSPERR_Msk (1UL << SCB_CFSR_MLSPERR_Pos)

#define SCB_CFSR_MSTKERR_Pos (SCB_SHCSR_MEMFAULTACT_Pos + 4U)
#define SCB_CFSR_MSTKERR_Msk (1UL << SCB_CFSR_MSTKERR_Pos)

#define SCB_CFSR_MUNSTKERR_Pos (SCB_SHCSR_MEMFAULTACT_Pos + 3U)
#define SCB_CFSR_MUNSTKERR_Msk (1UL << SCB_CFSR_MUNSTKERR_Pos)

#define SCB_CFSR_DACCVIOL_Pos (SCB_SHCSR_MEMFAULTACT_Pos + 1U)
#define SCB_CFSR_DACCVIOL_Msk (1UL << SCB_CFSR_DACCVIOL_Pos)

#define SCB_CFSR_IACCVIOL_Pos (SCB_SHCSR_MEMFAULTACT_Pos + 0U)
#define SCB_CFSR_IACCVIOL_Msk (1UL )

/* BusFault Status Register (part of SCB Configurable Fault Status Register) */
#define SCB_CFSR_BFARVALID_Pos (SCB_CFSR_BUSFAULTSR_Pos + 7U)
#define SCB_CFSR_BFARVALID_Msk (1UL << SCB_CFSR_BFARVALID_Pos)

#define SCB_CFSR_LSPERR_Pos (SCB_CFSR_BUSFAULTSR_Pos + 5U)
#define SCB_CFSR_LSPERR_Msk (1UL << SCB_CFSR_LSPERR_Pos)

#define SCB_CFSR_STKERR_Pos (SCB_CFSR_BUSFAULTSR_Pos + 4U)
#define SCB_CFSR_STKERR_Msk (1UL << SCB_CFSR_STKERR_Pos)

#define SCB_CFSR_UNSTKERR_Pos (SCB_CFSR_BUSFAULTSR_Pos + 3U)
#define SCB_CFSR_UNSTKERR_Msk (1UL << SCB_CFSR_UNSTKERR_Pos)

#define SCB_CFSR_IMPRECISERR_Pos (SCB_CFSR_BUSFAULTSR_Pos + 2U)
#define SCB_CFSR_IMPRECISERR_Msk (1UL << SCB_CFSR_IMPRECISERR_Pos)

#define SCB_CFSR_PRECISERR_Pos (SCB_CFSR_BUSFAULTSR_Pos + 1U)
#define SCB_CFSR_PRECISERR_Msk (1UL << SCB_CFSR_PRECISERR_Pos)

#define SCB_CFSR_IBUSERR_Pos (SCB_CFSR_BUSFAULTSR_Pos + 0U)
#define SCB_CFSR_IBUSERR_Msk (1UL << SCB_CFSR_IBUSERR_Pos)

/* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
#define SCB_CFSR_DIVBYZERO_Pos (SCB_CFSR_USGFAULTSR_Pos + 9U)
#define SCB_CFSR_DIVBYZERO_Msk (1UL << SCB_CFSR_DIVBYZERO_Pos)

#define SCB_CFSR_UNALIGNED_Pos (SCB_CFSR_USGFAULTSR_Pos + 8U)
#define SCB_CFSR_UNALIGNED_Msk (1UL << SCB_CFSR_UNALIGNED_Pos)

#define SCB_CFSR_NOCP_Pos (SCB_CFSR_USGFAULTSR_Pos + 3U)
#define SCB_CFSR_NOCP_Msk (1UL << SCB_CFSR_NOCP_Pos)

#define SCB_CFSR_INVPC_Pos (SCB_CFSR_USGFAULTSR_Pos + 2U)
#define SCB_CFSR_INVPC_Msk (1UL << SCB_CFSR_INVPC_Pos)

#define SCB_CFSR_INVSTATE_Pos (SCB_CFSR_USGFAULTSR_Pos + 1U)
#define SCB_CFSR_INVSTATE_Msk (1UL << SCB_CFSR_INVSTATE_Pos)

#define SCB_CFSR_UNDEFINSTR_Pos (SCB_CFSR_USGFAULTSR_Pos + 0U)
#define SCB_CFSR_UNDEFINSTR_Msk (1UL << SCB_CFSR_UNDEFINSTR_Pos)

/* SCB Hard Fault Status Register Definitions */
#define SCB_HFSR_DEBUGEVT_Pos 31U
#define SCB_HFSR_DEBUGEVT_Msk (1UL << SCB_HFSR_DEBUGEVT_Pos)

#define SCB_HFSR_FORCED_Pos 30U
#define SCB_HFSR_FORCED_Msk (1UL << SCB_HFSR_FORCED_Pos)

#define SCB_HFSR_VECTTBL_Pos 1U
#define SCB_HFSR_VECTTBL_Msk (1UL << SCB_HFSR_VECTTBL_Pos)

/* SCB Debug Fault Status Register Definitions */
#define SCB_DFSR_EXTERNAL_Pos 4U
#define SCB_DFSR_EXTERNAL_Msk (1UL << SCB_DFSR_EXTERNAL_Pos)

#define SCB_DFSR_VCATCH_Pos 3U
#define SCB_DFSR_VCATCH_Msk (1UL << SCB_DFSR_VCATCH_Pos)

#define SCB_DFSR_DWTTRAP_Pos 2U
#define SCB_DFSR_DWTTRAP_Msk (1UL << SCB_DFSR_DWTTRAP_Pos)

#define SCB_DFSR_BKPT_Pos 1U
#define SCB_DFSR_BKPT_Msk (1UL << SCB_DFSR_BKPT_Pos)

#define SCB_DFSR_HALTED_Pos 0U
#define SCB_DFSR_HALTED_Msk (1UL )

/*@} end of group CMSIS_SCB */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
  \brief    Type definitions for the System Control and ID Register not in the SCB
  @{
 */

/**
  \brief  Structure type to access the System Control and ID Register not in the SCB.
 */
typedef struct
{
        uint32_t RESERVED0[1U];
  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
} SCnSCB_Type;

/* Interrupt Controller Type Register Definitions */
#define SCnSCB_ICTR_INTLINESNUM_Pos 0U
#define SCnSCB_ICTR_INTLINESNUM_Msk (0xFUL )

/* Auxiliary Control Register Definitions */
#define SCnSCB_ACTLR_DISOOFP_Pos 9U
#define SCnSCB_ACTLR_DISOOFP_Msk (1UL << SCnSCB_ACTLR_DISOOFP_Pos)

#define SCnSCB_ACTLR_DISFPCA_Pos 8U
#define SCnSCB_ACTLR_DISFPCA_Msk (1UL << SCnSCB_ACTLR_DISFPCA_Pos)

#define SCnSCB_ACTLR_DISFOLD_Pos 2U
#define SCnSCB_ACTLR_DISFOLD_Msk (1UL << SCnSCB_ACTLR_DISFOLD_Pos)

#define SCnSCB_ACTLR_DISDEFWBUF_Pos 1U
#define SCnSCB_ACTLR_DISDEFWBUF_Msk (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)

#define SCnSCB_ACTLR_DISMCYCINT_Pos 0U
#define SCnSCB_ACTLR_DISMCYCINT_Msk (1UL )

/*@} end of group CMSIS_SCnotSCB */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
  \brief    Type definitions for the System Timer Registers.
  @{
 */

/**
  \brief  Structure type to access the System Timer (SysTick).
 */
typedef struct
{
  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
} SysTick_Type;

/* SysTick Control / Status Register Definitions */
#define SysTick_CTRL_COUNTFLAG_Pos 16U
#define SysTick_CTRL_COUNTFLAG_Msk (1UL << SysTick_CTRL_COUNTFLAG_Pos)

#define SysTick_CTRL_CLKSOURCE_Pos 2U
#define SysTick_CTRL_CLKSOURCE_Msk (1UL << SysTick_CTRL_CLKSOURCE_Pos)

#define SysTick_CTRL_TICKINT_Pos 1U
#define SysTick_CTRL_TICKINT_Msk (1UL << SysTick_CTRL_TICKINT_Pos)

#define SysTick_CTRL_ENABLE_Pos 0U
#define SysTick_CTRL_ENABLE_Msk (1UL )

/* SysTick Reload Register Definitions */
#define SysTick_LOAD_RELOAD_Pos 0U
#define SysTick_LOAD_RELOAD_Msk (0xFFFFFFUL )

/* SysTick Current Register Definitions */
#define SysTick_VAL_CURRENT_Pos 0U
#define SysTick_VAL_CURRENT_Msk (0xFFFFFFUL )

/* SysTick Calibration Register Definitions */
#define SysTick_CALIB_NOREF_Pos 31U
#define SysTick_CALIB_NOREF_Msk (1UL << SysTick_CALIB_NOREF_Pos)

#define SysTick_CALIB_SKEW_Pos 30U
#define SysTick_CALIB_SKEW_Msk (1UL << SysTick_CALIB_SKEW_Pos)

#define SysTick_CALIB_TENMS_Pos 0U
#define SysTick_CALIB_TENMS_Msk (0xFFFFFFUL )

/*@} end of group CMSIS_SysTick */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
  @{
 */

/**
  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
 */
typedef struct
{
  __OM  union
  {
    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
        uint32_t RESERVED0[864U];
  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
        uint32_t RESERVED1[15U];
  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
        uint32_t RESERVED2[15U];
  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
        uint32_t RESERVED3[32U];
        uint32_t RESERVED4[43U];
  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
        uint32_t RESERVED5[6U];
  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
} ITM_Type;

/* ITM Trace Privilege Register Definitions */
#define ITM_TPR_PRIVMASK_Pos 0U
#define ITM_TPR_PRIVMASK_Msk (0xFFFFFFFFUL )

/* ITM Trace Control Register Definitions */
#define ITM_TCR_BUSY_Pos 23U
#define ITM_TCR_BUSY_Msk (1UL << ITM_TCR_BUSY_Pos)

#define ITM_TCR_TraceBusID_Pos 16U
#define ITM_TCR_TraceBusID_Msk (0x7FUL << ITM_TCR_TraceBusID_Pos)

#define ITM_TCR_GTSFREQ_Pos 10U
#define ITM_TCR_GTSFREQ_Msk (3UL << ITM_TCR_GTSFREQ_Pos)

#define ITM_TCR_TSPrescale_Pos 8U
#define ITM_TCR_TSPrescale_Msk (3UL << ITM_TCR_TSPrescale_Pos)

#define ITM_TCR_SWOENA_Pos 4U
#define ITM_TCR_SWOENA_Msk (1UL << ITM_TCR_SWOENA_Pos)

#define ITM_TCR_DWTENA_Pos 3U
#define ITM_TCR_DWTENA_Msk (1UL << ITM_TCR_DWTENA_Pos)

#define ITM_TCR_SYNCENA_Pos 2U
#define ITM_TCR_SYNCENA_Msk (1UL << ITM_TCR_SYNCENA_Pos)

#define ITM_TCR_TSENA_Pos 1U
#define ITM_TCR_TSENA_Msk (1UL << ITM_TCR_TSENA_Pos)

#define ITM_TCR_ITMENA_Pos 0U
#define ITM_TCR_ITMENA_Msk (1UL )

/* ITM Lock Status Register Definitions */
#define ITM_LSR_ByteAcc_Pos 2U
#define ITM_LSR_ByteAcc_Msk (1UL << ITM_LSR_ByteAcc_Pos)

#define ITM_LSR_Access_Pos 1U
#define ITM_LSR_Access_Msk (1UL << ITM_LSR_Access_Pos)

#define ITM_LSR_Present_Pos 0U
#define ITM_LSR_Present_Msk (1UL )

/*@}*/ /* end of group CMSIS_ITM */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
  @{
 */

/**
  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
 */
typedef struct
{
  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
        uint32_t RESERVED0[1U];
  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
        uint32_t RESERVED1[1U];
  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
        uint32_t RESERVED2[1U];
  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
} DWT_Type;

/* DWT Control Register Definitions */
#define DWT_CTRL_NUMCOMP_Pos 28U
#define DWT_CTRL_NUMCOMP_Msk (0xFUL << DWT_CTRL_NUMCOMP_Pos)

#define DWT_CTRL_NOTRCPKT_Pos 27U
#define DWT_CTRL_NOTRCPKT_Msk (0x1UL << DWT_CTRL_NOTRCPKT_Pos)

#define DWT_CTRL_NOEXTTRIG_Pos 26U
#define DWT_CTRL_NOEXTTRIG_Msk (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)

#define DWT_CTRL_NOCYCCNT_Pos 25U
#define DWT_CTRL_NOCYCCNT_Msk (0x1UL << DWT_CTRL_NOCYCCNT_Pos)

#define DWT_CTRL_NOPRFCNT_Pos 24U
#define DWT_CTRL_NOPRFCNT_Msk (0x1UL << DWT_CTRL_NOPRFCNT_Pos)

#define DWT_CTRL_CYCEVTENA_Pos 22U
#define DWT_CTRL_CYCEVTENA_Msk (0x1UL << DWT_CTRL_CYCEVTENA_Pos)

#define DWT_CTRL_FOLDEVTENA_Pos 21U
#define DWT_CTRL_FOLDEVTENA_Msk (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)

#define DWT_CTRL_LSUEVTENA_Pos 20U
#define DWT_CTRL_LSUEVTENA_Msk (0x1UL << DWT_CTRL_LSUEVTENA_Pos)

#define DWT_CTRL_SLEEPEVTENA_Pos 19U
#define DWT_CTRL_SLEEPEVTENA_Msk (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)

#define DWT_CTRL_EXCEVTENA_Pos 18U
#define DWT_CTRL_EXCEVTENA_Msk (0x1UL << DWT_CTRL_EXCEVTENA_Pos)

#define DWT_CTRL_CPIEVTENA_Pos 17U
#define DWT_CTRL_CPIEVTENA_Msk (0x1UL << DWT_CTRL_CPIEVTENA_Pos)

#define DWT_CTRL_EXCTRCENA_Pos 16U
#define DWT_CTRL_EXCTRCENA_Msk (0x1UL << DWT_CTRL_EXCTRCENA_Pos)

#define DWT_CTRL_PCSAMPLENA_Pos 12U
#define DWT_CTRL_PCSAMPLENA_Msk (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)

#define DWT_CTRL_SYNCTAP_Pos 10U
#define DWT_CTRL_SYNCTAP_Msk (0x3UL << DWT_CTRL_SYNCTAP_Pos)

#define DWT_CTRL_CYCTAP_Pos 9U
#define DWT_CTRL_CYCTAP_Msk (0x1UL << DWT_CTRL_CYCTAP_Pos)

#define DWT_CTRL_POSTINIT_Pos 5U
#define DWT_CTRL_POSTINIT_Msk (0xFUL << DWT_CTRL_POSTINIT_Pos)

#define DWT_CTRL_POSTPRESET_Pos 1U
#define DWT_CTRL_POSTPRESET_Msk (0xFUL << DWT_CTRL_POSTPRESET_Pos)

#define DWT_CTRL_CYCCNTENA_Pos 0U
#define DWT_CTRL_CYCCNTENA_Msk (0x1UL )

/* DWT CPI Count Register Definitions */
#define DWT_CPICNT_CPICNT_Pos 0U
#define DWT_CPICNT_CPICNT_Msk (0xFFUL )

/* DWT Exception Overhead Count Register Definitions */
#define DWT_EXCCNT_EXCCNT_Pos 0U
#define DWT_EXCCNT_EXCCNT_Msk (0xFFUL )

/* DWT Sleep Count Register Definitions */
#define DWT_SLEEPCNT_SLEEPCNT_Pos 0U
#define DWT_SLEEPCNT_SLEEPCNT_Msk (0xFFUL )

/* DWT LSU Count Register Definitions */
#define DWT_LSUCNT_LSUCNT_Pos 0U
#define DWT_LSUCNT_LSUCNT_Msk (0xFFUL )

/* DWT Folded-instruction Count Register Definitions */
#define DWT_FOLDCNT_FOLDCNT_Pos 0U
#define DWT_FOLDCNT_FOLDCNT_Msk (0xFFUL )

/* DWT Comparator Mask Register Definitions */
#define DWT_MASK_MASK_Pos 0U
#define DWT_MASK_MASK_Msk (0x1FUL )

/* DWT Comparator Function Register Definitions */
#define DWT_FUNCTION_MATCHED_Pos 24U
#define DWT_FUNCTION_MATCHED_Msk (0x1UL << DWT_FUNCTION_MATCHED_Pos)

#define DWT_FUNCTION_DATAVADDR1_Pos 16U
#define DWT_FUNCTION_DATAVADDR1_Msk (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)

#define DWT_FUNCTION_DATAVADDR0_Pos 12U
#define DWT_FUNCTION_DATAVADDR0_Msk (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)

#define DWT_FUNCTION_DATAVSIZE_Pos 10U
#define DWT_FUNCTION_DATAVSIZE_Msk (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)

#define DWT_FUNCTION_LNK1ENA_Pos 9U
#define DWT_FUNCTION_LNK1ENA_Msk (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)

#define DWT_FUNCTION_DATAVMATCH_Pos 8U
#define DWT_FUNCTION_DATAVMATCH_Msk (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)

#define DWT_FUNCTION_CYCMATCH_Pos 7U
#define DWT_FUNCTION_CYCMATCH_Msk (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)

#define DWT_FUNCTION_EMITRANGE_Pos 5U
#define DWT_FUNCTION_EMITRANGE_Msk (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)

#define DWT_FUNCTION_FUNCTION_Pos 0U
#define DWT_FUNCTION_FUNCTION_Msk (0xFUL )

/*@}*/ /* end of group CMSIS_DWT */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
  \brief    Type definitions for the Trace Port Interface (TPI)
  @{
 */

/**
  \brief  Structure type to access the Trace Port Interface Register (TPI).
 */
typedef struct
{
  __IM  uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
        uint32_t RESERVED0[2U];
  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
        uint32_t RESERVED1[55U];
  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
        uint32_t RESERVED2[131U];
  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
        uint32_t RESERVED3[759U];
  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER Register */
  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
        uint32_t RESERVED4[1U];
  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
        uint32_t RESERVED5[39U];
  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
        uint32_t RESERVED7[8U];
  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
} TPI_Type;

/* TPI Asynchronous Clock Prescaler Register Definitions */
#define TPI_ACPR_PRESCALER_Pos 0U
#define TPI_ACPR_PRESCALER_Msk (0x1FFFUL )

/* TPI Selected Pin Protocol Register Definitions */
#define TPI_SPPR_TXMODE_Pos 0U
#define TPI_SPPR_TXMODE_Msk (0x3UL )

/* TPI Formatter and Flush Status Register Definitions */
#define TPI_FFSR_FtNonStop_Pos 3U
#define TPI_FFSR_FtNonStop_Msk (0x1UL << TPI_FFSR_FtNonStop_Pos)

#define TPI_FFSR_TCPresent_Pos 2U
#define TPI_FFSR_TCPresent_Msk (0x1UL << TPI_FFSR_TCPresent_Pos)

#define TPI_FFSR_FtStopped_Pos 1U
#define TPI_FFSR_FtStopped_Msk (0x1UL << TPI_FFSR_FtStopped_Pos)

#define TPI_FFSR_FlInProg_Pos 0U
#define TPI_FFSR_FlInProg_Msk (0x1UL )

/* TPI Formatter and Flush Control Register Definitions */
#define TPI_FFCR_TrigIn_Pos 8U
#define TPI_FFCR_TrigIn_Msk (0x1UL << TPI_FFCR_TrigIn_Pos)

#define TPI_FFCR_EnFCont_Pos 1U
#define TPI_FFCR_EnFCont_Msk (0x1UL << TPI_FFCR_EnFCont_Pos)

/* TPI TRIGGER Register Definitions */
#define TPI_TRIGGER_TRIGGER_Pos 0U
#define TPI_TRIGGER_TRIGGER_Msk (0x1UL )

/* TPI Integration ETM Data Register Definitions (FIFO0) */
#define TPI_FIFO0_ITM_ATVALID_Pos 29U
#define TPI_FIFO0_ITM_ATVALID_Msk (0x1UL << TPI_FIFO0_ITM_ATVALID_Pos)

#define TPI_FIFO0_ITM_bytecount_Pos 27U
#define TPI_FIFO0_ITM_bytecount_Msk (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)

#define TPI_FIFO0_ETM_ATVALID_Pos 26U
#define TPI_FIFO0_ETM_ATVALID_Msk (0x1UL << TPI_FIFO0_ETM_ATVALID_Pos)

#define TPI_FIFO0_ETM_bytecount_Pos 24U
#define TPI_FIFO0_ETM_bytecount_Msk (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)

#define TPI_FIFO0_ETM2_Pos 16U
#define TPI_FIFO0_ETM2_Msk (0xFFUL << TPI_FIFO0_ETM2_Pos)

#define TPI_FIFO0_ETM1_Pos 8U
#define TPI_FIFO0_ETM1_Msk (0xFFUL << TPI_FIFO0_ETM1_Pos)

#define TPI_FIFO0_ETM0_Pos 0U
#define TPI_FIFO0_ETM0_Msk (0xFFUL )

/* TPI ITATBCTR2 Register Definitions */
#define TPI_ITATBCTR2_ATREADY2_Pos 0U
#define TPI_ITATBCTR2_ATREADY2_Msk (0x1UL )

#define TPI_ITATBCTR2_ATREADY1_Pos 0U
#define TPI_ITATBCTR2_ATREADY1_Msk (0x1UL )

/* TPI Integration ITM Data Register Definitions (FIFO1) */
#define TPI_FIFO1_ITM_ATVALID_Pos 29U
#define TPI_FIFO1_ITM_ATVALID_Msk (0x1UL << TPI_FIFO1_ITM_ATVALID_Pos)

#define TPI_FIFO1_ITM_bytecount_Pos 27U
#define TPI_FIFO1_ITM_bytecount_Msk (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)

#define TPI_FIFO1_ETM_ATVALID_Pos 26U
#define TPI_FIFO1_ETM_ATVALID_Msk (0x1UL << TPI_FIFO1_ETM_ATVALID_Pos)

#define TPI_FIFO1_ETM_bytecount_Pos 24U
#define TPI_FIFO1_ETM_bytecount_Msk (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)

#define TPI_FIFO1_ITM2_Pos 16U
#define TPI_FIFO1_ITM2_Msk (0xFFUL << TPI_FIFO1_ITM2_Pos)

#define TPI_FIFO1_ITM1_Pos 8U
#define TPI_FIFO1_ITM1_Msk (0xFFUL << TPI_FIFO1_ITM1_Pos)

#define TPI_FIFO1_ITM0_Pos 0U
#define TPI_FIFO1_ITM0_Msk (0xFFUL )

/* TPI ITATBCTR0 Register Definitions */
#define TPI_ITATBCTR0_ATREADY2_Pos 0U
#define TPI_ITATBCTR0_ATREADY2_Msk (0x1UL )

#define TPI_ITATBCTR0_ATREADY1_Pos 0U
#define TPI_ITATBCTR0_ATREADY1_Msk (0x1UL )

/* TPI Integration Mode Control Register Definitions */
#define TPI_ITCTRL_Mode_Pos 0U
#define TPI_ITCTRL_Mode_Msk (0x3UL )

/* TPI DEVID Register Definitions */
#define TPI_DEVID_NRZVALID_Pos 11U
#define TPI_DEVID_NRZVALID_Msk (0x1UL << TPI_DEVID_NRZVALID_Pos)

#define TPI_DEVID_MANCVALID_Pos 10U
#define TPI_DEVID_MANCVALID_Msk (0x1UL << TPI_DEVID_MANCVALID_Pos)

#define TPI_DEVID_PTINVALID_Pos 9U
#define TPI_DEVID_PTINVALID_Msk (0x1UL << TPI_DEVID_PTINVALID_Pos)

#define TPI_DEVID_MinBufSz_Pos 6U
#define TPI_DEVID_MinBufSz_Msk (0x7UL << TPI_DEVID_MinBufSz_Pos)

#define TPI_DEVID_AsynClkIn_Pos 5U
#define TPI_DEVID_AsynClkIn_Msk (0x1UL << TPI_DEVID_AsynClkIn_Pos)

#define TPI_DEVID_NrTraceInput_Pos 0U
#define TPI_DEVID_NrTraceInput_Msk (0x1FUL )

/* TPI DEVTYPE Register Definitions */
#define TPI_DEVTYPE_SubType_Pos 4U
#define TPI_DEVTYPE_SubType_Msk (0xFUL )

#define TPI_DEVTYPE_MajorType_Pos 0U
#define TPI_DEVTYPE_MajorType_Msk (0xFUL << TPI_DEVTYPE_MajorType_Pos)

/*@}*/ /* end of group CMSIS_TPI */



/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
  \brief    Type definitions for the Memory Protection Unit (MPU)
  @{
 */

/**
  \brief  Structure type to access the Memory Protection Unit (MPU).
 */
typedef struct
{
  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
} MPU_Type;

#define MPU_TYPE_RALIASES 4U

/* MPU Type Register Definitions */
#define MPU_TYPE_IREGION_Pos 16U
#define MPU_TYPE_IREGION_Msk (0xFFUL << MPU_TYPE_IREGION_Pos)

#define MPU_TYPE_DREGION_Pos 8U
#define MPU_TYPE_DREGION_Msk (0xFFUL << MPU_TYPE_DREGION_Pos)

#define MPU_TYPE_SEPARATE_Pos 0U
#define MPU_TYPE_SEPARATE_Msk (1UL )

/* MPU Control Register Definitions */
#define MPU_CTRL_PRIVDEFENA_Pos 2U
#define MPU_CTRL_PRIVDEFENA_Msk (1UL << MPU_CTRL_PRIVDEFENA_Pos)

#define MPU_CTRL_HFNMIENA_Pos 1U
#define MPU_CTRL_HFNMIENA_Msk (1UL << MPU_CTRL_HFNMIENA_Pos)

#define MPU_CTRL_ENABLE_Pos 0U
#define MPU_CTRL_ENABLE_Msk (1UL )

/* MPU Region Number Register Definitions */
#define MPU_RNR_REGION_Pos 0U
#define MPU_RNR_REGION_Msk (0xFFUL )

/* MPU Region Base Address Register Definitions */
#define MPU_RBAR_ADDR_Pos 5U
#define MPU_RBAR_ADDR_Msk (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)

#define MPU_RBAR_VALID_Pos 4U
#define MPU_RBAR_VALID_Msk (1UL << MPU_RBAR_VALID_Pos)

#define MPU_RBAR_REGION_Pos 0U
#define MPU_RBAR_REGION_Msk (0xFUL )

/* MPU Region Attribute and Size Register Definitions */
#define MPU_RASR_ATTRS_Pos 16U
#define MPU_RASR_ATTRS_Msk (0xFFFFUL << MPU_RASR_ATTRS_Pos)

#define MPU_RASR_XN_Pos 28U
#define MPU_RASR_XN_Msk (1UL << MPU_RASR_XN_Pos)

#define MPU_RASR_AP_Pos 24U
#define MPU_RASR_AP_Msk (0x7UL << MPU_RASR_AP_Pos)

#define MPU_RASR_TEX_Pos 19U
#define MPU_RASR_TEX_Msk (0x7UL << MPU_RASR_TEX_Pos)

#define MPU_RASR_S_Pos 18U
#define MPU_RASR_S_Msk (1UL << MPU_RASR_S_Pos)

#define MPU_RASR_C_Pos 17U
#define MPU_RASR_C_Msk (1UL << MPU_RASR_C_Pos)

#define MPU_RASR_B_Pos 16U
#define MPU_RASR_B_Msk (1UL << MPU_RASR_B_Pos)

#define MPU_RASR_SRD_Pos 8U
#define MPU_RASR_SRD_Msk (0xFFUL << MPU_RASR_SRD_Pos)

#define MPU_RASR_SIZE_Pos 1U
#define MPU_RASR_SIZE_Msk (0x1FUL << MPU_RASR_SIZE_Pos)

#define MPU_RASR_ENABLE_Pos 0U
#define MPU_RASR_ENABLE_Msk (1UL )

/*@} end of group CMSIS_MPU */



/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_FPU     Floating Point Unit (FPU)
  \brief    Type definitions for the Floating Point Unit (FPU)
  @{
 */

/**
  \brief  Structure type to access the Floating Point Unit (FPU).
 */
typedef struct
{
        uint32_t RESERVED0[1U];
  __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register */
  __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register */
  __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register */
  __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 */
  __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 */
  __IM  uint32_t MVFR2;                  /*!< Offset: 0x018 (R/ )  Media and FP Feature Register 2 */
} FPU_Type;

/* Floating-Point Context Control Register Definitions */
#define FPU_FPCCR_ASPEN_Pos 31U
#define FPU_FPCCR_ASPEN_Msk (1UL << FPU_FPCCR_ASPEN_Pos)

#define FPU_FPCCR_LSPEN_Pos 30U
#define FPU_FPCCR_LSPEN_Msk (1UL << FPU_FPCCR_LSPEN_Pos)

#define FPU_FPCCR_MONRDY_Pos 8U
#define FPU_FPCCR_MONRDY_Msk (1UL << FPU_FPCCR_MONRDY_Pos)

#define FPU_FPCCR_BFRDY_Pos 6U
#define FPU_FPCCR_BFRDY_Msk (1UL << FPU_FPCCR_BFRDY_Pos)

#define FPU_FPCCR_MMRDY_Pos 5U
#define FPU_FPCCR_MMRDY_Msk (1UL << FPU_FPCCR_MMRDY_Pos)

#define FPU_FPCCR_HFRDY_Pos 4U
#define FPU_FPCCR_HFRDY_Msk (1UL << FPU_FPCCR_HFRDY_Pos)

#define FPU_FPCCR_THREAD_Pos 3U
#define FPU_FPCCR_THREAD_Msk (1UL << FPU_FPCCR_THREAD_Pos)

#define FPU_FPCCR_USER_Pos 1U
#define FPU_FPCCR_USER_Msk (1UL << FPU_FPCCR_USER_Pos)

#define FPU_FPCCR_LSPACT_Pos 0U
#define FPU_FPCCR_LSPACT_Msk (1UL )

/* Floating-Point Context Address Register Definitions */
#define FPU_FPCAR_ADDRESS_Pos 3U
#define FPU_FPCAR_ADDRESS_Msk (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)

/* Floating-Point Default Status Control Register Definitions */
#define FPU_FPDSCR_AHP_Pos 26U
#define FPU_FPDSCR_AHP_Msk (1UL << FPU_FPDSCR_AHP_Pos)

#define FPU_FPDSCR_DN_Pos 25U
#define FPU_FPDSCR_DN_Msk (1UL << FPU_FPDSCR_DN_Pos)

#define FPU_FPDSCR_FZ_Pos 24U
#define FPU_FPDSCR_FZ_Msk (1UL << FPU_FPDSCR_FZ_Pos)

#define FPU_FPDSCR_RMode_Pos 22U
#define FPU_FPDSCR_RMode_Msk (3UL << FPU_FPDSCR_RMode_Pos)

/* Media and FP Feature Register 0 Definitions */
#define FPU_MVFR0_FP_rounding_modes_Pos 28U
#define FPU_MVFR0_FP_rounding_modes_Msk (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)

#define FPU_MVFR0_Short_vectors_Pos 24U
#define FPU_MVFR0_Short_vectors_Msk (0xFUL << FPU_MVFR0_Short_vectors_Pos)

#define FPU_MVFR0_Square_root_Pos 20U
#define FPU_MVFR0_Square_root_Msk (0xFUL << FPU_MVFR0_Square_root_Pos)

#define FPU_MVFR0_Divide_Pos 16U
#define FPU_MVFR0_Divide_Msk (0xFUL << FPU_MVFR0_Divide_Pos)

#define FPU_MVFR0_FP_excep_trapping_Pos 12U
#define FPU_MVFR0_FP_excep_trapping_Msk (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)

#define FPU_MVFR0_Double_precision_Pos 8U
#define FPU_MVFR0_Double_precision_Msk (0xFUL << FPU_MVFR0_Double_precision_Pos)

#define FPU_MVFR0_Single_precision_Pos 4U
#define FPU_MVFR0_Single_precision_Msk (0xFUL << FPU_MVFR0_Single_precision_Pos)

#define FPU_MVFR0_A_SIMD_registers_Pos 0U
#define FPU_MVFR0_A_SIMD_registers_Msk (0xFUL )

/* Media and FP Feature Register 1 Definitions */
#define FPU_MVFR1_FP_fused_MAC_Pos 28U
#define FPU_MVFR1_FP_fused_MAC_Msk (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)

#define FPU_MVFR1_FP_HPFP_Pos 24U
#define FPU_MVFR1_FP_HPFP_Msk (0xFUL << FPU_MVFR1_FP_HPFP_Pos)

#define FPU_MVFR1_D_NaN_mode_Pos 4U
#define FPU_MVFR1_D_NaN_mode_Msk (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)

#define FPU_MVFR1_FtZ_mode_Pos 0U
#define FPU_MVFR1_FtZ_mode_Msk (0xFUL )

/* Media and FP Feature Register 2 Definitions */

#define FPU_MVFR2_VFP_Misc_Pos 4U
#define FPU_MVFR2_VFP_Misc_Msk (0xFUL << FPU_MVFR2_VFP_Misc_Pos)

/*@} end of group CMSIS_FPU */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
  \brief    Type definitions for the Core Debug Registers
  @{
 */

/**
  \brief  Structure type to access the Core Debug Register (CoreDebug).
 */
typedef struct
{
  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
} CoreDebug_Type;

/* Debug Halting Control and Status Register Definitions */
#define CoreDebug_DHCSR_DBGKEY_Pos 16U
#define CoreDebug_DHCSR_DBGKEY_Msk (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)

#define CoreDebug_DHCSR_S_RESET_ST_Pos 25U
#define CoreDebug_DHCSR_S_RESET_ST_Msk (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)

#define CoreDebug_DHCSR_S_RETIRE_ST_Pos 24U
#define CoreDebug_DHCSR_S_RETIRE_ST_Msk (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)

#define CoreDebug_DHCSR_S_LOCKUP_Pos 19U
#define CoreDebug_DHCSR_S_LOCKUP_Msk (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)

#define CoreDebug_DHCSR_S_SLEEP_Pos 18U
#define CoreDebug_DHCSR_S_SLEEP_Msk (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)

#define CoreDebug_DHCSR_S_HALT_Pos 17U
#define CoreDebug_DHCSR_S_HALT_Msk (1UL << CoreDebug_DHCSR_S_HALT_Pos)

#define CoreDebug_DHCSR_S_REGRDY_Pos 16U
#define CoreDebug_DHCSR_S_REGRDY_Msk (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)

#define CoreDebug_DHCSR_C_SNAPSTALL_Pos 5U
#define CoreDebug_DHCSR_C_SNAPSTALL_Msk (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)

#define CoreDebug_DHCSR_C_MASKINTS_Pos 3U
#define CoreDebug_DHCSR_C_MASKINTS_Msk (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)

#define CoreDebug_DHCSR_C_STEP_Pos 2U
#define CoreDebug_DHCSR_C_STEP_Msk (1UL << CoreDebug_DHCSR_C_STEP_Pos)

#define CoreDebug_DHCSR_C_HALT_Pos 1U
#define CoreDebug_DHCSR_C_HALT_Msk (1UL << CoreDebug_DHCSR_C_HALT_Pos)

#define CoreDebug_DHCSR_C_DEBUGEN_Pos 0U
#define CoreDebug_DHCSR_C_DEBUGEN_Msk (1UL )

/* Debug Core Register Selector Register Definitions */
#define CoreDebug_DCRSR_REGWnR_Pos 16U
#define CoreDebug_DCRSR_REGWnR_Msk (1UL << CoreDebug_DCRSR_REGWnR_Pos)

#define CoreDebug_DCRSR_REGSEL_Pos 0U
#define CoreDebug_DCRSR_REGSEL_Msk (0x1FUL )

/* Debug Exception and Monitor Control Register Definitions */
#define CoreDebug_DEMCR_TRCENA_Pos 24U
#define CoreDebug_DEMCR_TRCENA_Msk (1UL << CoreDebug_DEMCR_TRCENA_Pos)

#define CoreDebug_DEMCR_MON_REQ_Pos 19U
#define CoreDebug_DEMCR_MON_REQ_Msk (1UL << CoreDebug_DEMCR_MON_REQ_Pos)

#define CoreDebug_DEMCR_MON_STEP_Pos 18U
#define CoreDebug_DEMCR_MON_STEP_Msk (1UL << CoreDebug_DEMCR_MON_STEP_Pos)

#define CoreDebug_DEMCR_MON_PEND_Pos 17U
#define CoreDebug_DEMCR_MON_PEND_Msk (1UL << CoreDebug_DEMCR_MON_PEND_Pos)

#define CoreDebug_DEMCR_MON_EN_Pos 16U
#define CoreDebug_DEMCR_MON_EN_Msk (1UL << CoreDebug_DEMCR_MON_EN_Pos)

#define CoreDebug_DEMCR_VC_HARDERR_Pos 10U
#define CoreDebug_DEMCR_VC_HARDERR_Msk (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)

#define CoreDebug_DEMCR_VC_INTERR_Pos 9U
#define CoreDebug_DEMCR_VC_INTERR_Msk (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)

#define CoreDebug_DEMCR_VC_BUSERR_Pos 8U
#define CoreDebug_DEMCR_VC_BUSERR_Msk (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)

#define CoreDebug_DEMCR_VC_STATERR_Pos 7U
#define CoreDebug_DEMCR_VC_STATERR_Msk (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)

#define CoreDebug_DEMCR_VC_CHKERR_Pos 6U
#define CoreDebug_DEMCR_VC_CHKERR_Msk (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)

#define CoreDebug_DEMCR_VC_NOCPERR_Pos 5U
#define CoreDebug_DEMCR_VC_NOCPERR_Msk (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)

#define CoreDebug_DEMCR_VC_MMERR_Pos 4U
#define CoreDebug_DEMCR_VC_MMERR_Msk (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)

#define CoreDebug_DEMCR_VC_CORERESET_Pos 0U
#define CoreDebug_DEMCR_VC_CORERESET_Msk (1UL )

/*@} end of group CMSIS_CoreDebug */


/**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_core_bitfield     Core register bit field macros
  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
  @{
 */

/**
  \brief   Mask and shift a bit field value for use in a register bit range.
  \param[in] field  Name of the register bit field.
  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
  \return           Masked and shifted value.
*/
#define _VAL2FLD(field,value) (((uint32_t)(value) << field ## _Pos) & field ## _Msk)

/**
  \brief     Mask and shift a register value to extract a bit filed value.
  \param[in] field  Name of the register bit field.
  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
  \return           Masked and shifted bit field value.
*/
#define _FLD2VAL(field,value) (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)

/*@} end of group CMSIS_core_bitfield */


/**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_core_base     Core Definitions
  \brief      Definitions for base addresses, unions, and structures.
  @{
 */

/* Memory mapping of Core Hardware */
#define SCS_BASE (0xE000E000UL)
#define ITM_BASE (0xE0000000UL)
#define DWT_BASE (0xE0001000UL)
#define TPI_BASE (0xE0040000UL)
#define CoreDebug_BASE (0xE000EDF0UL)
#define SysTick_BASE (SCS_BASE + 0x0010UL)
#define NVIC_BASE (SCS_BASE + 0x0100UL)
#define SCB_BASE (SCS_BASE + 0x0D00UL)

#define SCnSCB ((SCnSCB_Type *) SCS_BASE )
#define SCB ((SCB_Type *) SCB_BASE )
#define SysTick ((SysTick_Type *) SysTick_BASE )
#define NVIC ((NVIC_Type *) NVIC_BASE )
#define ITM ((ITM_Type *) ITM_BASE )
#define DWT ((DWT_Type *) DWT_BASE )
#define TPI ((TPI_Type *) TPI_BASE )
#define CoreDebug ((CoreDebug_Type *) CoreDebug_BASE)


  #define MPU_BASE (SCS_BASE + 0x0D90UL)
  #define MPU ((MPU_Type *) MPU_BASE )


#define FPU_BASE (SCS_BASE + 0x0F30UL)
#define FPU ((FPU_Type *) FPU_BASE )

/*@} */



/*******************************************************************************
 *                Hardware Abstraction Layer
  Core Function Interface contains:
  - Core NVIC Functions
  - Core SysTick Functions
  - Core Debug Functions
  - Core Register Access Functions
 ******************************************************************************/
/**
  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
*/



/* ##########################   NVIC functions  #################################### */
/**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
  \brief    Functions that manage interrupts and exceptions via the NVIC.
  @{
 */







  #define NVIC_SetPriorityGrouping __NVIC_SetPriorityGrouping
  #define NVIC_GetPriorityGrouping __NVIC_GetPriorityGrouping
  #define NVIC_EnableIRQ __NVIC_EnableIRQ
  #define NVIC_GetEnableIRQ __NVIC_GetEnableIRQ
  #define NVIC_DisableIRQ __NVIC_DisableIRQ
  #define NVIC_GetPendingIRQ __NVIC_GetPendingIRQ
  #define NVIC_SetPendingIRQ __NVIC_SetPendingIRQ
  #define NVIC_ClearPendingIRQ __NVIC_ClearPendingIRQ
  #define NVIC_GetActive __NVIC_GetActive
  #define NVIC_SetPriority __NVIC_SetPriority
  #define NVIC_GetPriority __NVIC_GetPriority
  #define NVIC_SystemReset __NVIC_SystemReset








  #define NVIC_SetVector __NVIC_SetVector
  #define NVIC_GetVector __NVIC_GetVector


#define NVIC_USER_IRQ_OFFSET 16


/* The following EXC_RETURN values are saved the LR on exception entry */
#define EXC_RETURN_HANDLER (0xFFFFFFF1UL)
#define EXC_RETURN_THREAD_MSP (0xFFFFFFF9UL)
#define EXC_RETURN_THREAD_PSP (0xFFFFFFFDUL)
#define EXC_RETURN_HANDLER_FPU (0xFFFFFFE1UL)
#define EXC_RETURN_THREAD_MSP_FPU (0xFFFFFFE9UL)
#define EXC_RETURN_THREAD_PSP_FPU (0xFFFFFFEDUL)


/**
  \brief   Set Priority Grouping
  \details Sets the priority grouping field using the required unlock sequence.
           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
           Only values from 0..7 are used.
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
}


/**
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
}


/**
  \brief   Enable Interrupt
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    __COMPILER_BARRIER();
  }
}


/**
  \brief   Get Interrupt Enable status
  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \return             0  Interrupt is not enabled.
  \return             1  Interrupt is enabled.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
  }
  else
  {
    return(0U);
  }
}


/**
  \brief   Disable Interrupt
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    __DSB();
    __ISB();
  }
}


/**
  \brief   Get Pending Interrupt
  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
  \param [in]      IRQn  Device specific interrupt number.
  \return             0  Interrupt status is not pending.
  \return             1  Interrupt status is pending.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
  }
  else
  {
    return(0U);
  }
}


/**
  \brief   Set Pending Interrupt
  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  }
}


/**
  \brief   Clear Pending Interrupt
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  }
}


/**
  \brief   Get Active Interrupt
  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
  \param [in]      IRQn  Device specific interrupt number.
  \return             0  Interrupt status is not active.
  \return             1  Interrupt status is active.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
  }
  else
  {
    return(0U);
  }
}


/**
  \brief   Set Interrupt Priority
  \details Sets the priority of a device specific interrupt or a processor exception.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}


/**
  \brief   Get Interrupt Priority
  \details Reads the priority of a device specific interrupt or a processor exception.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
  \param [in]   IRQn  Interrupt number.
  \return             Interrupt Priority.
                      Value is aligned automatically to the implemented priority bits of the microcontroller.
 */
__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
{

  if ((int32_t)(IRQn) >= 0)
  {
    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
  }
  else
  {
    return(((uint32_t)SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
  }
}


/**
  \brief   Encode Priority
  \details Encodes the priority for an interrupt with the given priority group,
           preemptive priority value, and subpriority value.
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]     PriorityGroup  Used priority group.
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
         );
}


/**
  \brief   Decode Priority
  \details Decodes an interrupt priority value with a given priority group to
           preemptive priority value and subpriority value.
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
  \param [in]     PriorityGroup  Used priority group.
  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
  \param [out]     pSubPriority  Subpriority value (starting from 0).
 */
__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
}


/**
  \brief   Set Interrupt Vector
  \details Sets an interrupt vector in SRAM based interrupt vector table.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
           VTOR must been relocated to SRAM before.
  \param [in]   IRQn      Interrupt number
  \param [in]   vector    Address of interrupt handler function
 */
__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
{
  uint32_t vectors = (uint32_t )SCB->VTOR;
  (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;
  /* ARM Application Note 321 states that the M4 does not require the architectural barrier */
}


/**
  \brief   Get Interrupt Vector
  \details Reads an interrupt vector from interrupt vector table.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
  \param [in]   IRQn      Interrupt number.
  \return                 Address of interrupt handler function
 */
__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
{
  uint32_t vectors = (uint32_t )SCB->VTOR;
  return (uint32_t)(* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4));
}


/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
  }
}

/*@} end of CMSIS_Core_NVICFunctions */


/* ##########################  MPU functions  #################################### */



# 1 "Drivers/CMSIS/Include/mpu_armv7.h" 1
/******************************************************************************
 * @file     mpu_armv7.h
 * @brief    CMSIS MPU API for Armv7-M MPU
 * @version  V5.1.0
 * @date     08. March 2019
 ******************************************************************************/
/*
 * Copyright (c) 2017-2019 Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 





 

#define ARM_MPU_ARMV7_H 

#define ARM_MPU_REGION_SIZE_32B ((uint8_t)0x04U)
#define ARM_MPU_REGION_SIZE_64B ((uint8_t)0x05U)
#define ARM_MPU_REGION_SIZE_128B ((uint8_t)0x06U)
#define ARM_MPU_REGION_SIZE_256B ((uint8_t)0x07U)
#define ARM_MPU_REGION_SIZE_512B ((uint8_t)0x08U)
#define ARM_MPU_REGION_SIZE_1KB ((uint8_t)0x09U)
#define ARM_MPU_REGION_SIZE_2KB ((uint8_t)0x0AU)
#define ARM_MPU_REGION_SIZE_4KB ((uint8_t)0x0BU)
#define ARM_MPU_REGION_SIZE_8KB ((uint8_t)0x0CU)
#define ARM_MPU_REGION_SIZE_16KB ((uint8_t)0x0DU)
#define ARM_MPU_REGION_SIZE_32KB ((uint8_t)0x0EU)
#define ARM_MPU_REGION_SIZE_64KB ((uint8_t)0x0FU)
#define ARM_MPU_REGION_SIZE_128KB ((uint8_t)0x10U)
#define ARM_MPU_REGION_SIZE_256KB ((uint8_t)0x11U)
#define ARM_MPU_REGION_SIZE_512KB ((uint8_t)0x12U)
#define ARM_MPU_REGION_SIZE_1MB ((uint8_t)0x13U)
#define ARM_MPU_REGION_SIZE_2MB ((uint8_t)0x14U)
#define ARM_MPU_REGION_SIZE_4MB ((uint8_t)0x15U)
#define ARM_MPU_REGION_SIZE_8MB ((uint8_t)0x16U)
#define ARM_MPU_REGION_SIZE_16MB ((uint8_t)0x17U)
#define ARM_MPU_REGION_SIZE_32MB ((uint8_t)0x18U)
#define ARM_MPU_REGION_SIZE_64MB ((uint8_t)0x19U)
#define ARM_MPU_REGION_SIZE_128MB ((uint8_t)0x1AU)
#define ARM_MPU_REGION_SIZE_256MB ((uint8_t)0x1BU)
#define ARM_MPU_REGION_SIZE_512MB ((uint8_t)0x1CU)
#define ARM_MPU_REGION_SIZE_1GB ((uint8_t)0x1DU)
#define ARM_MPU_REGION_SIZE_2GB ((uint8_t)0x1EU)
#define ARM_MPU_REGION_SIZE_4GB ((uint8_t)0x1FU)

#define ARM_MPU_AP_NONE 0U
#define ARM_MPU_AP_PRIV 1U
#define ARM_MPU_AP_URO 2U
#define ARM_MPU_AP_FULL 3U
#define ARM_MPU_AP_PRO 5U
#define ARM_MPU_AP_RO 6U

/** MPU Region Base Address Register Value
*
* \param Region The region to be configured, number 0 to 15.
* \param BaseAddress The base address for the region.
*/
#define ARM_MPU_RBAR(Region,BaseAddress) (((BaseAddress) & MPU_RBAR_ADDR_Msk) | ((Region) & MPU_RBAR_REGION_Msk) | (MPU_RBAR_VALID_Msk))




/**
* MPU Memory Access Attributes
* 
* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
* \param IsShareable       Region is shareable between multiple bus masters.
* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
*/  
#define ARM_MPU_ACCESS_(TypeExtField,IsShareable,IsCacheable,IsBufferable) ((((TypeExtField) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk) | (((IsShareable) << MPU_RASR_S_Pos) & MPU_RASR_S_Msk) | (((IsCacheable) << MPU_RASR_C_Pos) & MPU_RASR_C_Msk) | (((IsBufferable) << MPU_RASR_B_Pos) & MPU_RASR_B_Msk))





/**
* MPU Region Attribute and Size Register Value
* 
* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
* \param AccessAttributes  Memory access attribution, see \ref ARM_MPU_ACCESS_.
* \param SubRegionDisable  Sub-region disable field.
* \param Size              Region size of the region to be configured, for example 4K, 8K.
*/
#define ARM_MPU_RASR_EX(DisableExec,AccessPermission,AccessAttributes,SubRegionDisable,Size) ((((DisableExec) << MPU_RASR_XN_Pos) & MPU_RASR_XN_Msk) | (((AccessPermission) << MPU_RASR_AP_Pos) & MPU_RASR_AP_Msk) | (((AccessAttributes) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk))) | (((SubRegionDisable) << MPU_RASR_SRD_Pos) & MPU_RASR_SRD_Msk) | (((Size) << MPU_RASR_SIZE_Pos) & MPU_RASR_SIZE_Msk) | (((MPU_RASR_ENABLE_Msk))))







/**
* MPU Region Attribute and Size Register Value
* 
* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
* \param IsShareable       Region is shareable between multiple bus masters.
* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
* \param SubRegionDisable  Sub-region disable field.
* \param Size              Region size of the region to be configured, for example 4K, 8K.
*/                         
#define ARM_MPU_RASR(DisableExec,AccessPermission,TypeExtField,IsShareable,IsCacheable,IsBufferable,SubRegionDisable,Size) ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)


/**
* MPU Memory Access Attribute for strongly ordered memory.
*  - TEX: 000b
*  - Shareable
*  - Non-cacheable
*  - Non-bufferable
*/ 
#define ARM_MPU_ACCESS_ORDERED ARM_MPU_ACCESS_(0U, 1U, 0U, 0U)

/**
* MPU Memory Access Attribute for device memory.
*  - TEX: 000b (if shareable) or 010b (if non-shareable)
*  - Shareable or non-shareable
*  - Non-cacheable
*  - Bufferable (if shareable) or non-bufferable (if non-shareable)
*
* \param IsShareable Configures the device memory as shareable or non-shareable.
*/ 
#define ARM_MPU_ACCESS_DEVICE(IsShareable) ((IsShareable) ? ARM_MPU_ACCESS_(0U, 1U, 0U, 1U) : ARM_MPU_ACCESS_(2U, 0U, 0U, 0U))

/**
* MPU Memory Access Attribute for normal memory.
*  - TEX: 1BBb (reflecting outer cacheability rules)
*  - Shareable or non-shareable
*  - Cacheable or non-cacheable (reflecting inner cacheability rules)
*  - Bufferable or non-bufferable (reflecting inner cacheability rules)
*
* \param OuterCp Configures the outer cache policy.
* \param InnerCp Configures the inner cache policy.
* \param IsShareable Configures the memory as shareable or non-shareable.
*/ 
#define ARM_MPU_ACCESS_NORMAL(OuterCp,InnerCp,IsShareable) ARM_MPU_ACCESS_((4U | (OuterCp)), IsShareable, ((InnerCp) & 2U), ((InnerCp) & 1U))

/**
* MPU Memory Access Attribute non-cacheable policy.
*/
#define ARM_MPU_CACHEP_NOCACHE 0U

/**
* MPU Memory Access Attribute write-back, write and read allocate policy.
*/
#define ARM_MPU_CACHEP_WB_WRA 1U

/**
* MPU Memory Access Attribute write-through, no write allocate policy.
*/
#define ARM_MPU_CACHEP_WT_NWA 2U

/**
* MPU Memory Access Attribute write-back, no write allocate policy.
*/
#define ARM_MPU_CACHEP_WB_NWA 3U


/**
* Struct for a single MPU Region
*/
typedef struct {
  uint32_t RBAR; //!< The region base address register value (RBAR)
  uint32_t RASR; //!< The region attribute and size register value (RASR) \ref MPU_RASR
} ARM_MPU_Region_t;
    
/** Enable the MPU.
* \param MPU_Control Default access permissions for unconfigured regions.
*/
__STATIC_INLINE void ARM_MPU_Enable(uint32_t MPU_Control)
{
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;

  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;

  __DSB();
  __ISB();
}

/** Disable the MPU.
*/
__STATIC_INLINE void ARM_MPU_Disable(void)
{
  __DMB();

  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;

  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
}

/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
  MPU->RASR = 0U;
}

/** Configure an MPU region.
* \param rbar Value for RBAR register.
* \param rsar Value for RSAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
{
  MPU->RBAR = rbar;
  MPU->RASR = rasr;
}

/** Configure the given MPU region.
* \param rnr Region number to be configured.
* \param rbar Value for RBAR register.
* \param rsar Value for RSAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr)
{
  MPU->RNR = rnr;
  MPU->RBAR = rbar;
  MPU->RASR = rasr;
}

/** Memcopy with strictly ordered memory access, e.g. for register targets.
* \param dst Destination data is copied to.
* \param src Source data is copied from.
* \param len Amount of data words to be copied.
*/
__STATIC_INLINE void ARM_MPU_OrderedMemcpy(volatile uint32_t* dst, const uint32_t* __RESTRICT src, uint32_t len)
{
  uint32_t i;
  for (i = 0U; i < len; ++i) 
  {
    dst[i] = src[i];
  }
}

/** Load the given number of MPU regions from a table.
* \param table Pointer to the MPU configuration table.
* \param cnt Amount of regions to be configured.
*/
__STATIC_INLINE void ARM_MPU_Load(ARM_MPU_Region_t const* table, uint32_t cnt) 
{
  const uint32_t rowWordSize = sizeof(ARM_MPU_Region_t)/4U;
  while (cnt > MPU_TYPE_RALIASES) {
    ARM_MPU_OrderedMemcpy(&(MPU->RBAR), &(table->RBAR), MPU_TYPE_RALIASES*rowWordSize);
    table += MPU_TYPE_RALIASES;
    cnt -= MPU_TYPE_RALIASES;
  }
  ARM_MPU_OrderedMemcpy(&(MPU->RBAR), &(table->RBAR), cnt*rowWordSize);
}

# 1956 "Drivers/CMSIS/Include/core_cm4.h" 2




/* ##########################  FPU functions  #################################### */
/**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_Core_FpuFunctions FPU Functions
  \brief    Function that provides FPU type.
  @{
 */

/**
  \brief   get FPU type
  \details returns the FPU type
  \returns
   - \b  0: No FPU
   - \b  1: Single precision FPU
   - \b  2: Double + Single precision FPU
 */
__STATIC_INLINE uint32_t SCB_GetFPUType(void)
{
  uint32_t mvfr0;

  mvfr0 = FPU->MVFR0;
  if      ((mvfr0 & (FPU_MVFR0_Single_precision_Msk | FPU_MVFR0_Double_precision_Msk)) == 0x020U)
  {
    return 1U;           /* Single precision FPU */
  }
  else
  {
    return 0U;           /* No FPU */
  }
}


/*@} end of CMSIS_Core_FpuFunctions */



/* ##################################    SysTick function  ############################################ */
/**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
  \brief    Functions that configure the System.
  @{
 */



/**
  \brief   System Tick Configuration
  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
           Counter is in free running mode to generate periodic interrupts.
  \param [in]  ticks  Number of ticks between two interrupts.
  \return          0  Function succeeded.
  \return          1  Function failed.
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
}



/*@} end of CMSIS_Core_SysTickFunctions */



/* ##################################### Debug In/Output function ########################################### */
/**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_core_DebugFunctions ITM Functions
  \brief    Functions that access the ITM debug interface.
  @{
 */

extern volatile int32_t ITM_RxBuffer;                              /*!< External variable to receive characters. */
#define ITM_RXBUFFER_EMPTY ((int32_t)0x5AA55AA5U)


/**
  \brief   ITM Send Character
  \details Transmits a character via the ITM channel 0, and
           \li Just returns when no debugger is connected that has booked the output.
           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
  \param [in]     ch  Character to transmit.
  \returns            Character to transmit.
 */
__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
{
  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
  {
    while (ITM->PORT[0U].u32 == 0UL)
    {
      __NOP();
    }
    ITM->PORT[0U].u8 = (uint8_t)ch;
  }
  return (ch);
}


/**
  \brief   ITM Receive Character
  \details Inputs a character via the external variable \ref ITM_RxBuffer.
  \return             Received character.
  \return         -1  No character pending.
 */
__STATIC_INLINE int32_t ITM_ReceiveChar (void)
{
  int32_t ch = -1;                           /* no character available */

  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
  {
    ch = ITM_RxBuffer;
    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
  }

  return (ch);
}


/**
  \brief   ITM Check Character
  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
  \return          0  No character available.
  \return          1  Character available.
 */
__STATIC_INLINE int32_t ITM_CheckChar (void)
{

  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
  {
    return (0);                              /* no character available */
  }
  else
  {
    return (1);                              /*    character available */
  }
}

/*@} end of CMSIS_core_DebugFunctions */










# 178 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h" 2
# 1 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/system_stm32g4xx.h" 1
/**
  ******************************************************************************
  * @file    system_stm32g4xx.h
  * @author  MCD Application Team
  * @brief   CMSIS Cortex-M4 Device System Source File for STM32G4xx devices.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/** @addtogroup CMSIS
  * @{
  */

/** @addtogroup stm32g4xx_system
  * @{
  */

/**
  * @brief Define to prevent recursive inclusion
  */

#define __SYSTEM_STM32G4XX_H 





/** @addtogroup STM32G4xx_System_Includes
  * @{
  */

/**
  * @}
  */


/** @addtogroup STM32G4xx_System_Exported_Variables
  * @{
  */
  /* The SystemCoreClock variable is updated in three ways:
      1) by calling CMSIS function SystemCoreClockUpdate()
      2) by calling HAL API function HAL_RCC_GetSysClockFreq()
      3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency
         Note: If you use this function to configure the system clock; then there
               is no need to call the 2 first functions listed above, since SystemCoreClock
               variable is updated automatically.
  */
extern uint32_t SystemCoreClock;            /*!< System Clock Frequency (Core Clock) */

extern const uint8_t  AHBPrescTable[16];    /*!< AHB prescalers table values */
extern const uint8_t  APBPrescTable[8];     /*!< APB prescalers table values */

/**
  * @}
  */

/** @addtogroup STM32G4xx_System_Exported_Constants
  * @{
  */

/**
  * @}
  */

/** @addtogroup STM32G4xx_System_Exported_Macros
  * @{
  */

/**
  * @}
  */

/** @addtogroup STM32G4xx_System_Exported_Functions
  * @{
  */

extern void SystemInit(void);
extern void SystemCoreClockUpdate(void);
/**
  * @}
  */







/**
  * @}
  */

/**
  * @}
  */
# 179 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h" 2


/** @addtogroup Peripheral_registers_structures
  * @{
  */

/**
  * @brief Analog to Digital Converter
  */

typedef struct
{
  __IO uint32_t ISR;          /*!< ADC interrupt and status register,             Address offset: 0x00 */
  __IO uint32_t IER;          /*!< ADC interrupt enable register,                 Address offset: 0x04 */
  __IO uint32_t CR;           /*!< ADC control register,                          Address offset: 0x08 */
  __IO uint32_t CFGR;         /*!< ADC configuration register 1,                  Address offset: 0x0C */
  __IO uint32_t CFGR2;        /*!< ADC configuration register 2,                  Address offset: 0x10 */
  __IO uint32_t SMPR1;        /*!< ADC sampling time register 1,                  Address offset: 0x14 */
  __IO uint32_t SMPR2;        /*!< ADC sampling time register 2,                  Address offset: 0x18 */
       uint32_t RESERVED1;    /*!< Reserved,                                                      0x1C */
  __IO uint32_t TR1;          /*!< ADC analog watchdog 1 threshold register,      Address offset: 0x20 */
  __IO uint32_t TR2;          /*!< ADC analog watchdog 2 threshold register,      Address offset: 0x24 */
  __IO uint32_t TR3;          /*!< ADC analog watchdog 3 threshold register,      Address offset: 0x28 */
       uint32_t RESERVED2;    /*!< Reserved,                                                      0x2C */
  __IO uint32_t SQR1;         /*!< ADC group regular sequencer register 1,        Address offset: 0x30 */
  __IO uint32_t SQR2;         /*!< ADC group regular sequencer register 2,        Address offset: 0x34 */
  __IO uint32_t SQR3;         /*!< ADC group regular sequencer register 3,        Address offset: 0x38 */
  __IO uint32_t SQR4;         /*!< ADC group regular sequencer register 4,        Address offset: 0x3C */
  __IO uint32_t DR;           /*!< ADC group regular data register,               Address offset: 0x40 */
       uint32_t RESERVED3;    /*!< Reserved,                                                      0x44 */
       uint32_t RESERVED4;    /*!< Reserved,                                                      0x48 */
  __IO uint32_t JSQR;         /*!< ADC group injected sequencer register,         Address offset: 0x4C */
       uint32_t RESERVED5[4]; /*!< Reserved,                                               0x50 - 0x5C */
  __IO uint32_t OFR1;         /*!< ADC offset register 1,                         Address offset: 0x60 */
  __IO uint32_t OFR2;         /*!< ADC offset register 2,                         Address offset: 0x64 */
  __IO uint32_t OFR3;         /*!< ADC offset register 3,                         Address offset: 0x68 */
  __IO uint32_t OFR4;         /*!< ADC offset register 4,                         Address offset: 0x6C */
       uint32_t RESERVED6[4]; /*!< Reserved,                                               0x70 - 0x7C */
  __IO uint32_t JDR1;         /*!< ADC group injected rank 1 data register,       Address offset: 0x80 */
  __IO uint32_t JDR2;         /*!< ADC group injected rank 2 data register,       Address offset: 0x84 */
  __IO uint32_t JDR3;         /*!< ADC group injected rank 3 data register,       Address offset: 0x88 */
  __IO uint32_t JDR4;         /*!< ADC group injected rank 4 data register,       Address offset: 0x8C */
       uint32_t RESERVED7[4]; /*!< Reserved,                                             0x090 - 0x09C */
  __IO uint32_t AWD2CR;       /*!< ADC analog watchdog 2 configuration register,  Address offset: 0xA0 */
  __IO uint32_t AWD3CR;       /*!< ADC analog watchdog 3 Configuration Register,  Address offset: 0xA4 */
       uint32_t RESERVED8;    /*!< Reserved,                                                     0x0A8 */
       uint32_t RESERVED9;    /*!< Reserved,                                                     0x0AC */
  __IO uint32_t DIFSEL;       /*!< ADC differential mode selection register,      Address offset: 0xB0 */
  __IO uint32_t CALFACT;      /*!< ADC calibration factors,                       Address offset: 0xB4 */
       uint32_t RESERVED10[2];/*!< Reserved,                                             0x0B8 - 0x0BC */
  __IO uint32_t GCOMP;        /*!< ADC calibration factors,                       Address offset: 0xC0 */
} ADC_TypeDef;

typedef struct
{
  __IO uint32_t CSR;          /*!< ADC common status register,            Address offset: 0x300 + 0x00 */
  uint32_t      RESERVED1;    /*!< Reserved,                              Address offset: 0x300 + 0x04 */
  __IO uint32_t CCR;          /*!< ADC common configuration register,     Address offset: 0x300 + 0x08 */
  __IO uint32_t CDR;          /*!< ADC common group regular data register Address offset: 0x300 + 0x0C */
} ADC_Common_TypeDef;

/**
  * @brief FD Controller Area Network
  */

typedef struct
{
  __IO uint32_t CREL;         /*!< FDCAN Core Release register,                                     Address offset: 0x000 */
  __IO uint32_t ENDN;         /*!< FDCAN Endian register,                                           Address offset: 0x004 */
       uint32_t RESERVED1;    /*!< Reserved,                                                                        0x008 */
  __IO uint32_t DBTP;         /*!< FDCAN Data Bit Timing & Prescaler register,                      Address offset: 0x00C */
  __IO uint32_t TEST;         /*!< FDCAN Test register,                                             Address offset: 0x010 */
  __IO uint32_t RWD;          /*!< FDCAN RAM Watchdog register,                                     Address offset: 0x014 */
  __IO uint32_t CCCR;         /*!< FDCAN CC Control register,                                       Address offset: 0x018 */
  __IO uint32_t NBTP;         /*!< FDCAN Nominal Bit Timing & Prescaler register,                   Address offset: 0x01C */
  __IO uint32_t TSCC;         /*!< FDCAN Timestamp Counter Configuration register,                  Address offset: 0x020 */
  __IO uint32_t TSCV;         /*!< FDCAN Timestamp Counter Value register,                          Address offset: 0x024 */
  __IO uint32_t TOCC;         /*!< FDCAN Timeout Counter Configuration register,                    Address offset: 0x028 */
  __IO uint32_t TOCV;         /*!< FDCAN Timeout Counter Value register,                            Address offset: 0x02C */
       uint32_t RESERVED2[4]; /*!< Reserved,                                                                0x030 - 0x03C */
  __IO uint32_t ECR;          /*!< FDCAN Error Counter register,                                    Address offset: 0x040 */
  __IO uint32_t PSR;          /*!< FDCAN Protocol Status register,                                  Address offset: 0x044 */
  __IO uint32_t TDCR;         /*!< FDCAN Transmitter Delay Compensation register,                   Address offset: 0x048 */
       uint32_t RESERVED3;    /*!< Reserved,                                                                        0x04C */
  __IO uint32_t IR;           /*!< FDCAN Interrupt register,                                        Address offset: 0x050 */
  __IO uint32_t IE;           /*!< FDCAN Interrupt Enable register,                                 Address offset: 0x054 */
  __IO uint32_t ILS;          /*!< FDCAN Interrupt Line Select register,                            Address offset: 0x058 */
  __IO uint32_t ILE;          /*!< FDCAN Interrupt Line Enable register,                            Address offset: 0x05C */
       uint32_t RESERVED4[8]; /*!< Reserved,                                                                0x060 - 0x07C */
  __IO uint32_t RXGFC;        /*!< FDCAN Global Filter Configuration register,                      Address offset: 0x080 */
  __IO uint32_t XIDAM;        /*!< FDCAN Extended ID AND Mask register,                             Address offset: 0x084 */
  __IO uint32_t HPMS;         /*!< FDCAN High Priority Message Status register,                     Address offset: 0x088 */
       uint32_t RESERVED5;    /*!< Reserved,                                                                        0x08C */
  __IO uint32_t RXF0S;        /*!< FDCAN Rx FIFO 0 Status register,                                 Address offset: 0x090 */
  __IO uint32_t RXF0A;        /*!< FDCAN Rx FIFO 0 Acknowledge register,                            Address offset: 0x094 */
  __IO uint32_t RXF1S;        /*!< FDCAN Rx FIFO 1 Status register,                                 Address offset: 0x098 */
  __IO uint32_t RXF1A;        /*!< FDCAN Rx FIFO 1 Acknowledge register,                            Address offset: 0x09C */
       uint32_t RESERVED6[8]; /*!< Reserved,                                                                0x0A0 - 0x0BC */
  __IO uint32_t TXBC;         /*!< FDCAN Tx Buffer Configuration register,                          Address offset: 0x0C0 */
  __IO uint32_t TXFQS;        /*!< FDCAN Tx FIFO/Queue Status register,                             Address offset: 0x0C4 */
  __IO uint32_t TXBRP;        /*!< FDCAN Tx Buffer Request Pending register,                        Address offset: 0x0C8 */
  __IO uint32_t TXBAR;        /*!< FDCAN Tx Buffer Add Request register,                            Address offset: 0x0CC */
  __IO uint32_t TXBCR;        /*!< FDCAN Tx Buffer Cancellation Request register,                   Address offset: 0x0D0 */
  __IO uint32_t TXBTO;        /*!< FDCAN Tx Buffer Transmission Occurred register,                  Address offset: 0x0D4 */
  __IO uint32_t TXBCF;        /*!< FDCAN Tx Buffer Cancellation Finished register,                  Address offset: 0x0D8 */
  __IO uint32_t TXBTIE;       /*!< FDCAN Tx Buffer Transmission Interrupt Enable register,          Address offset: 0x0DC */
  __IO uint32_t TXBCIE;       /*!< FDCAN Tx Buffer Cancellation Finished Interrupt Enable register, Address offset: 0x0E0 */
  __IO uint32_t TXEFS;        /*!< FDCAN Tx Event FIFO Status register,                             Address offset: 0x0E4 */
  __IO uint32_t TXEFA;        /*!< FDCAN Tx Event FIFO Acknowledge register,                        Address offset: 0x0E8 */
} FDCAN_GlobalTypeDef;

/**
  * @brief FD Controller Area Network Configuration
  */

typedef struct
{
  __IO uint32_t CKDIV;        /*!< FDCAN clock divider register,                            Address offset: 0x100 + 0x000 */
} FDCAN_Config_TypeDef;

/**
  * @brief Comparator
  */

typedef struct
{
  __IO uint32_t CSR;         /*!< COMP control and status register, Address offset: 0x00 */
} COMP_TypeDef;

/**
  * @brief CRC calculation unit
  */

typedef struct
{
  __IO uint32_t DR;          /*!< CRC Data register,                           Address offset: 0x00 */
  __IO uint32_t IDR;         /*!< CRC Independent data register,               Address offset: 0x04 */
  __IO uint32_t CR;          /*!< CRC Control register,                        Address offset: 0x08 */
  uint32_t      RESERVED0;   /*!< Reserved,                                                    0x0C */
  __IO uint32_t INIT;        /*!< Initial CRC value register,                  Address offset: 0x10 */
  __IO uint32_t POL;         /*!< CRC polynomial register,                     Address offset: 0x14 */
} CRC_TypeDef;

/**
  * @brief Clock Recovery System
  */
typedef struct
{
  __IO uint32_t CR;          /*!< CRS ccontrol register,              Address offset: 0x00 */
  __IO uint32_t CFGR;        /*!< CRS configuration register,         Address offset: 0x04 */
  __IO uint32_t ISR;         /*!< CRS interrupt and status register,  Address offset: 0x08 */
  __IO uint32_t ICR;         /*!< CRS interrupt flag clear register,  Address offset: 0x0C */
} CRS_TypeDef;

/**
  * @brief Digital to Analog Converter
  */

typedef struct
{
  __IO uint32_t CR;          /*!< DAC control register,                                    Address offset: 0x00 */
  __IO uint32_t SWTRIGR;     /*!< DAC software trigger register,                           Address offset: 0x04 */
  __IO uint32_t DHR12R1;     /*!< DAC channel1 12-bit right-aligned data holding register, Address offset: 0x08 */
  __IO uint32_t DHR12L1;     /*!< DAC channel1 12-bit left aligned data holding register,  Address offset: 0x0C */
  __IO uint32_t DHR8R1;      /*!< DAC channel1 8-bit right aligned data holding register,  Address offset: 0x10 */
  __IO uint32_t DHR12R2;     /*!< DAC channel2 12-bit right aligned data holding register, Address offset: 0x14 */
  __IO uint32_t DHR12L2;     /*!< DAC channel2 12-bit left aligned data holding register,  Address offset: 0x18 */
  __IO uint32_t DHR8R2;      /*!< DAC channel2 8-bit right-aligned data holding register,  Address offset: 0x1C */
  __IO uint32_t DHR12RD;     /*!< Dual DAC 12-bit right-aligned data holding register,     Address offset: 0x20 */
  __IO uint32_t DHR12LD;     /*!< DUAL DAC 12-bit left aligned data holding register,      Address offset: 0x24 */
  __IO uint32_t DHR8RD;      /*!< DUAL DAC 8-bit right aligned data holding register,      Address offset: 0x28 */
  __IO uint32_t DOR1;        /*!< DAC channel1 data output register,                       Address offset: 0x2C */
  __IO uint32_t DOR2;        /*!< DAC channel2 data output register,                       Address offset: 0x30 */
  __IO uint32_t SR;          /*!< DAC status register,                                     Address offset: 0x34 */
  __IO uint32_t CCR;         /*!< DAC calibration control register,                        Address offset: 0x38 */
  __IO uint32_t MCR;         /*!< DAC mode control register,                               Address offset: 0x3C */
  __IO uint32_t SHSR1;       /*!< DAC Sample and Hold sample time register 1,              Address offset: 0x40 */
  __IO uint32_t SHSR2;       /*!< DAC Sample and Hold sample time register 2,              Address offset: 0x44 */
  __IO uint32_t SHHR;        /*!< DAC Sample and Hold hold time register,                  Address offset: 0x48 */
  __IO uint32_t SHRR;        /*!< DAC Sample and Hold refresh time register,               Address offset: 0x4C */
  __IO uint32_t RESERVED[2];
  __IO uint32_t STR1;        /*!< DAC Sawtooth register,                                   Address offset: 0x58 */
  __IO uint32_t STR2;        /*!< DAC Sawtooth register,                                   Address offset: 0x5C */
  __IO uint32_t STMODR;      /*!< DAC Sawtooth Mode register,                              Address offset: 0x60 */
} DAC_TypeDef;

/**
  * @brief Debug MCU
  */

typedef struct
{
  __IO uint32_t IDCODE;      /*!< MCU device ID code,                 Address offset: 0x00 */
  __IO uint32_t CR;          /*!< Debug MCU configuration register,   Address offset: 0x04 */
  __IO uint32_t APB1FZR1;    /*!< Debug MCU APB1 freeze register 1,   Address offset: 0x08 */
  __IO uint32_t APB1FZR2;    /*!< Debug MCU APB1 freeze register 2,   Address offset: 0x0C */
  __IO uint32_t APB2FZ;      /*!< Debug MCU APB2 freeze register,     Address offset: 0x10 */
} DBGMCU_TypeDef;

/**
  * @brief DMA Controller
  */

typedef struct
{
  __IO uint32_t CCR;         /*!< DMA channel x configuration register        */
  __IO uint32_t CNDTR;       /*!< DMA channel x number of data register       */
  __IO uint32_t CPAR;        /*!< DMA channel x peripheral address register   */
  __IO uint32_t CMAR;        /*!< DMA channel x memory address register       */
} DMA_Channel_TypeDef;

typedef struct
{
  __IO uint32_t ISR;         /*!< DMA interrupt status register,                 Address offset: 0x00 */
  __IO uint32_t IFCR;        /*!< DMA interrupt flag clear register,             Address offset: 0x04 */
} DMA_TypeDef;

/**
  * @brief DMA Multiplexer
  */

typedef struct
{
  __IO uint32_t   CCR;       /*!< DMA Multiplexer Channel x Control Register    Address offset: 0x0004 * (channel x) */
}DMAMUX_Channel_TypeDef;

typedef struct
{
  __IO uint32_t   CSR;      /*!< DMA Channel Status Register                    Address offset: 0x0080   */
  __IO uint32_t   CFR;      /*!< DMA Channel Clear Flag Register                Address offset: 0x0084   */
}DMAMUX_ChannelStatus_TypeDef;

typedef struct
{
  __IO uint32_t   RGCR;        /*!< DMA Request Generator x Control Register     Address offset: 0x0100 + 0x0004 * (Req Gen x) */
}DMAMUX_RequestGen_TypeDef;

typedef struct
{
  __IO uint32_t   RGSR;        /*!< DMA Request Generator Status Register        Address offset: 0x0140   */
  __IO uint32_t   RGCFR;        /*!< DMA Request Generator Clear Flag Register    Address offset: 0x0144   */
}DMAMUX_RequestGenStatus_TypeDef;

/**
  * @brief External Interrupt/Event Controller
  */

typedef struct
{
  __IO uint32_t IMR1;        /*!< EXTI Interrupt mask register 1,             Address offset: 0x00 */
  __IO uint32_t EMR1;        /*!< EXTI Event mask register 1,                 Address offset: 0x04 */
  __IO uint32_t RTSR1;       /*!< EXTI Rising trigger selection register 1,   Address offset: 0x08 */
  __IO uint32_t FTSR1;       /*!< EXTI Falling trigger selection register 1,  Address offset: 0x0C */
  __IO uint32_t SWIER1;      /*!< EXTI Software interrupt event register 1,   Address offset: 0x10 */
  __IO uint32_t PR1;         /*!< EXTI Pending register 1,                    Address offset: 0x14 */
  uint32_t      RESERVED1;   /*!< Reserved, 0x18                                                   */
  uint32_t      RESERVED2;   /*!< Reserved, 0x1C                                                   */
  __IO uint32_t IMR2;        /*!< EXTI Interrupt mask register 2,             Address offset: 0x20 */
  __IO uint32_t EMR2;        /*!< EXTI Event mask register 2,                 Address offset: 0x24 */
  __IO uint32_t RTSR2;       /*!< EXTI Rising trigger selection register 2,   Address offset: 0x28 */
  __IO uint32_t FTSR2;       /*!< EXTI Falling trigger selection register 2,  Address offset: 0x2C */
  __IO uint32_t SWIER2;      /*!< EXTI Software interrupt event register 2,   Address offset: 0x30 */
  __IO uint32_t PR2;         /*!< EXTI Pending register 2,                    Address offset: 0x34 */
} EXTI_TypeDef;

/**
  * @brief FLASH Registers
  */

typedef struct
{
  __IO uint32_t ACR;              /*!< FLASH access control register,            Address offset: 0x00 */
  __IO uint32_t PDKEYR;           /*!< FLASH power down key register,            Address offset: 0x04 */
  __IO uint32_t KEYR;             /*!< FLASH key register,                       Address offset: 0x08 */
  __IO uint32_t OPTKEYR;          /*!< FLASH option key register,                Address offset: 0x0C */
  __IO uint32_t SR;               /*!< FLASH status register,                    Address offset: 0x10 */
  __IO uint32_t CR;               /*!< FLASH control register,                   Address offset: 0x14 */
  __IO uint32_t ECCR;             /*!< FLASH ECC register,                       Address offset: 0x18 */
       uint32_t RESERVED1;        /*!< Reserved1,                                Address offset: 0x1C */
  __IO uint32_t OPTR;             /*!< FLASH option register,                    Address offset: 0x20 */
  __IO uint32_t PCROP1SR;         /*!< FLASH bank1 PCROP start address register, Address offset: 0x24 */
  __IO uint32_t PCROP1ER;         /*!< FLASH bank1 PCROP end address register,   Address offset: 0x28 */
  __IO uint32_t WRP1AR;           /*!< FLASH bank1 WRP area A address register,  Address offset: 0x2C */
  __IO uint32_t WRP1BR;           /*!< FLASH bank1 WRP area B address register,  Address offset: 0x30 */
       uint32_t RESERVED2[4];     /*!< Reserved2,                                Address offset: 0x34 */
  __IO uint32_t PCROP2SR;         /*!< FLASH bank2 PCROP start address register, Address offset: 0x44 */
  __IO uint32_t PCROP2ER;         /*!< FLASH bank2 PCROP end address register,   Address offset: 0x48 */
  __IO uint32_t WRP2AR;           /*!< FLASH bank2 WRP area A address register,  Address offset: 0x4C */
  __IO uint32_t WRP2BR;           /*!< FLASH bank2 WRP area B address register,  Address offset: 0x50 */
       uint32_t RESERVED3[7];     /*!< Reserved3,                                Address offset: 0x54 */
  __IO uint32_t SEC1R;            /*!< FLASH Securable memory register bank1,    Address offset: 0x70 */
  __IO uint32_t SEC2R;            /*!< FLASH Securable memory register bank2,    Address offset: 0x74 */
} FLASH_TypeDef;

/**
  * @brief FMAC
  */
typedef struct
{
  __IO uint32_t X1BUFCFG;        /*!< FMAC X1 Buffer Configuration register, Address offset: 0x00          */
  __IO uint32_t X2BUFCFG;        /*!< FMAC X2 Buffer Configuration register, Address offset: 0x04          */
  __IO uint32_t YBUFCFG;         /*!< FMAC Y Buffer Configuration register,  Address offset: 0x08          */
  __IO uint32_t PARAM;           /*!< FMAC Parameter register,               Address offset: 0x0C          */
  __IO uint32_t CR;              /*!< FMAC Control register,                 Address offset: 0x10          */
  __IO uint32_t SR;              /*!< FMAC Status register,                  Address offset: 0x14          */
  __IO uint32_t WDATA;           /*!< FMAC Write Data register,              Address offset: 0x18          */
  __IO uint32_t RDATA;           /*!< FMAC Read Data register,               Address offset: 0x1C          */
} FMAC_TypeDef;

/**
  * @brief Flexible Memory Controller
  */

typedef struct
{
  __IO uint32_t BTCR[8];     /*!< NOR/PSRAM chip-select control register(BCR) and chip-select timing register(BTR), Address offset: 0x00-1C */
  __IO uint32_t PCSCNTR;     /*!< PSRAM chip-select counter register,                                               Address offset:    0x20 */
} FMC_Bank1_TypeDef;

/**
  * @brief Flexible Memory Controller Bank1E
  */

typedef struct
{
  __IO uint32_t BWTR[7];     /*!< NOR/PSRAM write timing registers, Address offset: 0x104-0x11C */
} FMC_Bank1E_TypeDef;

/**
  * @brief Flexible Memory Controller Bank3
  */

typedef struct
{
  __IO uint32_t PCR;        /*!< NAND Flash control register,                       Address offset: 0x80 */
  __IO uint32_t SR;         /*!< NAND Flash FIFO status and interrupt register,     Address offset: 0x84 */
  __IO uint32_t PMEM;       /*!< NAND Flash Common memory space timing register,    Address offset: 0x88 */
  __IO uint32_t PATT;       /*!< NAND Flash Attribute memory space timing register, Address offset: 0x8C */
  uint32_t      RESERVED0;  /*!< Reserved, 0x90                                                            */
  __IO uint32_t ECCR;       /*!< NAND Flash ECC result registers,                   Address offset: 0x94 */
} FMC_Bank3_TypeDef;

/**
  * @brief General Purpose I/O
  */

typedef struct
{
  __IO uint32_t MODER;       /*!< GPIO port mode register,               Address offset: 0x00      */
  __IO uint32_t OTYPER;      /*!< GPIO port output type register,        Address offset: 0x04      */
  __IO uint32_t OSPEEDR;     /*!< GPIO port output speed register,       Address offset: 0x08      */
  __IO uint32_t PUPDR;       /*!< GPIO port pull-up/pull-down register,  Address offset: 0x0C      */
  __IO uint32_t IDR;         /*!< GPIO port input data register,         Address offset: 0x10      */
  __IO uint32_t ODR;         /*!< GPIO port output data register,        Address offset: 0x14      */
  __IO uint32_t BSRR;        /*!< GPIO port bit set/reset  register,     Address offset: 0x18      */
  __IO uint32_t LCKR;        /*!< GPIO port configuration lock register, Address offset: 0x1C      */
  __IO uint32_t AFR[2];      /*!< GPIO alternate function registers,     Address offset: 0x20-0x24 */
  __IO uint32_t BRR;         /*!< GPIO Bit Reset register,               Address offset: 0x28      */
} GPIO_TypeDef;

/**
  * @brief Inter-integrated Circuit Interface
  */

typedef struct
{
  __IO uint32_t CR1;         /*!< I2C Control register 1,            Address offset: 0x00 */
  __IO uint32_t CR2;         /*!< I2C Control register 2,            Address offset: 0x04 */
  __IO uint32_t OAR1;        /*!< I2C Own address 1 register,        Address offset: 0x08 */
  __IO uint32_t OAR2;        /*!< I2C Own address 2 register,        Address offset: 0x0C */
  __IO uint32_t TIMINGR;     /*!< I2C Timing register,               Address offset: 0x10 */
  __IO uint32_t TIMEOUTR;    /*!< I2C Timeout register,              Address offset: 0x14 */
  __IO uint32_t ISR;         /*!< I2C Interrupt and status register, Address offset: 0x18 */
  __IO uint32_t ICR;         /*!< I2C Interrupt clear register,      Address offset: 0x1C */
  __IO uint32_t PECR;        /*!< I2C PEC register,                  Address offset: 0x20 */
  __IO uint32_t RXDR;        /*!< I2C Receive data register,         Address offset: 0x24 */
  __IO uint32_t TXDR;        /*!< I2C Transmit data register,        Address offset: 0x28 */
} I2C_TypeDef;

/**
  * @brief Independent WATCHDOG
  */

typedef struct
{
  __IO uint32_t KR;          /*!< IWDG Key register,       Address offset: 0x00 */
  __IO uint32_t PR;          /*!< IWDG Prescaler register, Address offset: 0x04 */
  __IO uint32_t RLR;         /*!< IWDG Reload register,    Address offset: 0x08 */
  __IO uint32_t SR;          /*!< IWDG Status register,    Address offset: 0x0C */
  __IO uint32_t WINR;        /*!< IWDG Window register,    Address offset: 0x10 */
} IWDG_TypeDef;

/**
  * @brief LPTIMER
  */

typedef struct
{
  __IO uint32_t ISR;              /*!< LPTIM Interrupt and Status register,                Address offset: 0x00 */
  __IO uint32_t ICR;              /*!< LPTIM Interrupt Clear register,                     Address offset: 0x04 */
  __IO uint32_t IER;              /*!< LPTIM Interrupt Enable register,                    Address offset: 0x08 */
  __IO uint32_t CFGR;             /*!< LPTIM Configuration register,                       Address offset: 0x0C */
  __IO uint32_t CR;               /*!< LPTIM Control register,                             Address offset: 0x10 */
  __IO uint32_t CMP;              /*!< LPTIM Compare register,                             Address offset: 0x14 */
  __IO uint32_t ARR;              /*!< LPTIM Autoreload register,                          Address offset: 0x18 */
  __IO uint32_t CNT;              /*!< LPTIM Counter register,                             Address offset: 0x1C */
  __IO uint32_t OR;               /*!< LPTIM Option register,                              Address offset: 0x20 */
} LPTIM_TypeDef;

/**
  * @brief Operational Amplifier (OPAMP)
  */

typedef struct
{
  __IO uint32_t CSR;           /*!< OPAMP control/status register,                     Address offset: 0x00 */
  __IO uint32_t RESERVED[5];   /*!< OPAMP offset trimming register for normal mode,    Address offset: 0x04 */
  __IO uint32_t TCMR;          /*!< OPAMP timer controlled mux mode register,          Address offset: 0x18 */
} OPAMP_TypeDef;

/**
  * @brief Power Control
  */

typedef struct
{
  __IO uint32_t CR1;      /*!< PWR power control register 1,        Address offset: 0x00 */
  __IO uint32_t CR2;      /*!< PWR power control register 2,        Address offset: 0x04 */
  __IO uint32_t CR3;      /*!< PWR power control register 3,        Address offset: 0x08 */
  __IO uint32_t CR4;      /*!< PWR power control register 4,        Address offset: 0x0C */
  __IO uint32_t SR1;      /*!< PWR power status register 1,         Address offset: 0x10 */
  __IO uint32_t SR2;      /*!< PWR power status register 2,         Address offset: 0x14 */
  __IO uint32_t SCR;      /*!< PWR power status reset register,     Address offset: 0x18 */
  uint32_t RESERVED;      /*!< Reserved,                            Address offset: 0x1C */
  __IO uint32_t PUCRA;    /*!< Pull_up control register of portA,   Address offset: 0x20 */
  __IO uint32_t PDCRA;    /*!< Pull_Down control register of portA, Address offset: 0x24 */
  __IO uint32_t PUCRB;    /*!< Pull_up control register of portB,   Address offset: 0x28 */
  __IO uint32_t PDCRB;    /*!< Pull_Down control register of portB, Address offset: 0x2C */
  __IO uint32_t PUCRC;    /*!< Pull_up control register of portC,   Address offset: 0x30 */
  __IO uint32_t PDCRC;    /*!< Pull_Down control register of portC, Address offset: 0x34 */
  __IO uint32_t PUCRD;    /*!< Pull_up control register of portD,   Address offset: 0x38 */
  __IO uint32_t PDCRD;    /*!< Pull_Down control register of portD, Address offset: 0x3C */
  __IO uint32_t PUCRE;    /*!< Pull_up control register of portE,   Address offset: 0x40 */
  __IO uint32_t PDCRE;    /*!< Pull_Down control register of portE, Address offset: 0x44 */
  __IO uint32_t PUCRF;    /*!< Pull_up control register of portF,   Address offset: 0x48 */
  __IO uint32_t PDCRF;    /*!< Pull_Down control register of portF, Address offset: 0x4C */
  __IO uint32_t PUCRG;    /*!< Pull_up control register of portG,   Address offset: 0x50 */
  __IO uint32_t PDCRG;    /*!< Pull_Down control register of portG, Address offset: 0x54 */
  uint32_t RESERVED1[10]; /*!< Reserved                             Address offset: 0x58 - 0x7C */
  __IO uint32_t CR5;      /*!< PWR power control register 5,        Address offset: 0x80 */
} PWR_TypeDef;

/**
  * @brief QUAD Serial Peripheral Interface
  */

typedef struct
{
  __IO uint32_t CR;          /*!< QUADSPI Control register,                           Address offset: 0x00 */
  __IO uint32_t DCR;         /*!< QUADSPI Device Configuration register,              Address offset: 0x04 */
  __IO uint32_t SR;          /*!< QUADSPI Status register,                            Address offset: 0x08 */
  __IO uint32_t FCR;         /*!< QUADSPI Flag Clear register,                        Address offset: 0x0C */
  __IO uint32_t DLR;         /*!< QUADSPI Data Length register,                       Address offset: 0x10 */
  __IO uint32_t CCR;         /*!< QUADSPI Communication Configuration register,       Address offset: 0x14 */
  __IO uint32_t AR;          /*!< QUADSPI Address register,                           Address offset: 0x18 */
  __IO uint32_t ABR;         /*!< QUADSPI Alternate Bytes register,                   Address offset: 0x1C */
  __IO uint32_t DR;          /*!< QUADSPI Data register,                              Address offset: 0x20 */
  __IO uint32_t PSMKR;       /*!< QUADSPI Polling Status Mask register,               Address offset: 0x24 */
  __IO uint32_t PSMAR;       /*!< QUADSPI Polling Status Match register,              Address offset: 0x28 */
  __IO uint32_t PIR;         /*!< QUADSPI Polling Interval register,                  Address offset: 0x2C */
  __IO uint32_t LPTR;        /*!< QUADSPI Low Power Timeout register,                 Address offset: 0x30 */
} QUADSPI_TypeDef;

/**
  * @brief Reset and Clock Control
  */

typedef struct
{
  __IO uint32_t CR;          /*!< RCC clock control register,                                              Address offset: 0x00 */
  __IO uint32_t ICSCR;       /*!< RCC internal clock sources calibration register,                         Address offset: 0x04 */
  __IO uint32_t CFGR;        /*!< RCC clock configuration register,                                        Address offset: 0x08 */
  __IO uint32_t PLLCFGR;     /*!< RCC system PLL configuration register,                                   Address offset: 0x0C */
  uint32_t      RESERVED0;   /*!< Reserved,                                                                Address offset: 0x10 */
  uint32_t      RESERVED1;   /*!< Reserved,                                                                Address offset: 0x14 */
  __IO uint32_t CIER;        /*!< RCC clock interrupt enable register,                                     Address offset: 0x18 */
  __IO uint32_t CIFR;        /*!< RCC clock interrupt flag register,                                       Address offset: 0x1C */
  __IO uint32_t CICR;        /*!< RCC clock interrupt clear register,                                      Address offset: 0x20 */
  uint32_t      RESERVED2;   /*!< Reserved,                                                                Address offset: 0x24 */
  __IO uint32_t AHB1RSTR;    /*!< RCC AHB1 peripheral reset register,                                      Address offset: 0x28 */
  __IO uint32_t AHB2RSTR;    /*!< RCC AHB2 peripheral reset register,                                      Address offset: 0x2C */
  __IO uint32_t AHB3RSTR;    /*!< RCC AHB3 peripheral reset register,                                      Address offset: 0x30 */
  uint32_t      RESERVED3;   /*!< Reserved,                                                                Address offset: 0x34 */
  __IO uint32_t APB1RSTR1;   /*!< RCC APB1 peripheral reset register 1,                                    Address offset: 0x38 */
  __IO uint32_t APB1RSTR2;   /*!< RCC APB1 peripheral reset register 2,                                    Address offset: 0x3C */
  __IO uint32_t APB2RSTR;    /*!< RCC APB2 peripheral reset register,                                      Address offset: 0x40 */
  uint32_t      RESERVED4;   /*!< Reserved,                                                                Address offset: 0x44 */
  __IO uint32_t AHB1ENR;     /*!< RCC AHB1 peripheral clocks enable register,                              Address offset: 0x48 */
  __IO uint32_t AHB2ENR;     /*!< RCC AHB2 peripheral clocks enable register,                              Address offset: 0x4C */
  __IO uint32_t AHB3ENR;     /*!< RCC AHB3 peripheral clocks enable register,                              Address offset: 0x50 */
  uint32_t      RESERVED5;   /*!< Reserved,                                                                Address offset: 0x54 */
  __IO uint32_t APB1ENR1;    /*!< RCC APB1 peripheral clocks enable register 1,                            Address offset: 0x58 */
  __IO uint32_t APB1ENR2;    /*!< RCC APB1 peripheral clocks enable register 2,                            Address offset: 0x5C */
  __IO uint32_t APB2ENR;     /*!< RCC APB2 peripheral clocks enable register,                              Address offset: 0x60 */
  uint32_t      RESERVED6;   /*!< Reserved,                                                                Address offset: 0x64 */
  __IO uint32_t AHB1SMENR;   /*!< RCC AHB1 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x68 */
  __IO uint32_t AHB2SMENR;   /*!< RCC AHB2 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x6C */
  __IO uint32_t AHB3SMENR;   /*!< RCC AHB3 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x70 */
  uint32_t      RESERVED7;   /*!< Reserved,                                                                Address offset: 0x74 */
  __IO uint32_t APB1SMENR1;  /*!< RCC APB1 peripheral clocks enable in sleep mode and stop modes register 1, Address offset: 0x78 */
  __IO uint32_t APB1SMENR2;  /*!< RCC APB1 peripheral clocks enable in sleep mode and stop modes register 2, Address offset: 0x7C */
  __IO uint32_t APB2SMENR;   /*!< RCC APB2 peripheral clocks enable in sleep mode and stop modes register, Address offset: 0x80 */
  uint32_t      RESERVED8;   /*!< Reserved,                                                                Address offset: 0x84 */
  __IO uint32_t CCIPR;       /*!< RCC peripherals independent clock configuration register,                Address offset: 0x88 */
  uint32_t      RESERVED9;   /*!< Reserved,                                                                Address offset: 0x8C */
  __IO uint32_t BDCR;        /*!< RCC backup domain control register,                                      Address offset: 0x90 */
  __IO uint32_t CSR;         /*!< RCC clock control & status register,                                     Address offset: 0x94 */
  __IO uint32_t CRRCR;       /*!< RCC clock recovery RC register,                                          Address offset: 0x98 */
  __IO uint32_t CCIPR2;      /*!< RCC peripherals independent clock configuration register 2,              Address offset: 0x9C */
} RCC_TypeDef;

/**
  * @brief Real-Time Clock
  */
/*
* @brief Specific device feature definitions
*/
#define RTC_TAMP_INT_6_SUPPORT 
#define RTC_TAMP_INT_NB 4u

#define RTC_TAMP_NB 3u
#define RTC_BACKUP_NB 32u


typedef struct
{
  __IO uint32_t TR;          /*!< RTC time register,                                         Address offset: 0x00 */
  __IO uint32_t DR;          /*!< RTC date register,                                         Address offset: 0x04 */
  __IO uint32_t SSR;         /*!< RTC sub second register,                                   Address offset: 0x08 */
  __IO uint32_t ICSR;        /*!< RTC initialization control and status register,            Address offset: 0x0C */
  __IO uint32_t PRER;        /*!< RTC prescaler register,                                    Address offset: 0x10 */
  __IO uint32_t WUTR;        /*!< RTC wakeup timer register,                                 Address offset: 0x14 */
  __IO uint32_t CR;          /*!< RTC control register,                                      Address offset: 0x18 */
       uint32_t RESERVED0;   /*!< Reserved                                                   Address offset: 0x1C */
       uint32_t RESERVED1;   /*!< Reserved                                                   Address offset: 0x20 */
  __IO uint32_t WPR;         /*!< RTC write protection register,                             Address offset: 0x24 */
  __IO uint32_t CALR;        /*!< RTC calibration register,                                  Address offset: 0x28 */
  __IO uint32_t SHIFTR;      /*!< RTC shift control register,                                Address offset: 0x2C */
  __IO uint32_t TSTR;        /*!< RTC time stamp time register,                              Address offset: 0x30 */
  __IO uint32_t TSDR;        /*!< RTC time stamp date register,                              Address offset: 0x34 */
  __IO uint32_t TSSSR;       /*!< RTC time-stamp sub second register,                        Address offset: 0x38 */
       uint32_t RESERVED2;   /*!< Reserved                                                   Address offset: 0x3C */
  __IO uint32_t ALRMAR;      /*!< RTC alarm A register,                                      Address offset: 0x40 */
  __IO uint32_t ALRMASSR;    /*!< RTC alarm A sub second register,                           Address offset: 0x44 */
  __IO uint32_t ALRMBR;      /*!< RTC alarm B register,                                      Address offset: 0x48 */
  __IO uint32_t ALRMBSSR;    /*!< RTC alarm B sub second register,                           Address offset: 0x4C */
  __IO uint32_t SR;          /*!< RTC Status register,                                       Address offset: 0x50 */
  __IO uint32_t MISR;        /*!< RTC Masked Interrupt Status register,                      Address offset: 0x54 */
       uint32_t RESERVED3;   /*!< Reserved                                                   Address offset: 0x58 */
  __IO uint32_t SCR;         /*!< RTC Status Clear register,                                 Address offset: 0x5C */
} RTC_TypeDef;

/**
  * @brief Tamper and backup registers
  */

typedef struct
{
  __IO uint32_t CR1;                     /*!< TAMP configuration register 1,          Address offset: 0x00 */
  __IO uint32_t CR2;                     /*!< TAMP configuration register 2,          Address offset: 0x04 */
       uint32_t RESERVED0;               /*!< no configuration register 3,            Address offset: 0x08 */
  __IO uint32_t FLTCR;                   /*!< TAMP filter control register,           Address offset: 0x0C */
       uint32_t RESERVED1[6];            /*!< Reserved                                Address offset: 0x10 - 0x24 */
       uint32_t RESERVED2;               /*!< Reserved                                Address offset: 0x28 */
  __IO uint32_t IER;                     /*!< TAMP Interrupt enable register,         Address offset: 0x2C */
  __IO uint32_t SR;                      /*!< TAMP Status register,                   Address offset: 0x30 */
  __IO uint32_t MISR;                    /*!< TAMP Masked Interrupt Status register   Address offset: 0x34 */
       uint32_t RESERVED3;               /*!< Reserved                                Address offset: 0x38 */
  __IO uint32_t SCR;                     /*!< TAMP Status clear register,             Address offset: 0x3C */
       uint32_t RESERVED4[48];           /*!< Reserved                                Address offset: 0x040 - 0xFC */
  __IO uint32_t BKP0R;                   /*!< TAMP backup register 0,                 Address offset: 0x100 */
  __IO uint32_t BKP1R;                   /*!< TAMP backup register 1,                 Address offset: 0x104 */
  __IO uint32_t BKP2R;                   /*!< TAMP backup register 2,                 Address offset: 0x108 */
  __IO uint32_t BKP3R;                   /*!< TAMP backup register 3,                 Address offset: 0x10C */
  __IO uint32_t BKP4R;                   /*!< TAMP backup register 4,                 Address offset: 0x110 */
  __IO uint32_t BKP5R;                   /*!< TAMP backup register 5,                 Address offset: 0x114 */
  __IO uint32_t BKP6R;                   /*!< TAMP backup register 6,                 Address offset: 0x118 */
  __IO uint32_t BKP7R;                   /*!< TAMP backup register 7,                 Address offset: 0x11C */
  __IO uint32_t BKP8R;                   /*!< TAMP backup register 8,                 Address offset: 0x120 */
  __IO uint32_t BKP9R;                   /*!< TAMP backup register 9,                 Address offset: 0x124 */
  __IO uint32_t BKP10R;                  /*!< TAMP backup register 10,                Address offset: 0x128 */
  __IO uint32_t BKP11R;                  /*!< TAMP backup register 11,                Address offset: 0x12C */
  __IO uint32_t BKP12R;                  /*!< TAMP backup register 12,                Address offset: 0x130 */
  __IO uint32_t BKP13R;                  /*!< TAMP backup register 13,                Address offset: 0x134 */
  __IO uint32_t BKP14R;                  /*!< TAMP backup register 14,                Address offset: 0x138 */
  __IO uint32_t BKP15R;                  /*!< TAMP backup register 15,                Address offset: 0x13C */
  __IO uint32_t BKP16R;                  /*!< TAMP backup register 16,                Address offset: 0x140 */
  __IO uint32_t BKP17R;                  /*!< TAMP backup register 17,                Address offset: 0x144 */
  __IO uint32_t BKP18R;                  /*!< TAMP backup register 18,                Address offset: 0x148 */
  __IO uint32_t BKP19R;                  /*!< TAMP backup register 19,                Address offset: 0x14C */
  __IO uint32_t BKP20R;                  /*!< TAMP backup register 20,                Address offset: 0x150 */
  __IO uint32_t BKP21R;                  /*!< TAMP backup register 21,                Address offset: 0x154 */
  __IO uint32_t BKP22R;                  /*!< TAMP backup register 22,                Address offset: 0x158 */
  __IO uint32_t BKP23R;                  /*!< TAMP backup register 23,                Address offset: 0x15C */
  __IO uint32_t BKP24R;                  /*!< TAMP backup register 24,                Address offset: 0x160 */
  __IO uint32_t BKP25R;                  /*!< TAMP backup register 25,                Address offset: 0x164 */
  __IO uint32_t BKP26R;                  /*!< TAMP backup register 26,                Address offset: 0x168 */
  __IO uint32_t BKP27R;                  /*!< TAMP backup register 27,                Address offset: 0x16C */
  __IO uint32_t BKP28R;                  /*!< TAMP backup register 28,                Address offset: 0x170 */
  __IO uint32_t BKP29R;                  /*!< TAMP backup register 29,                Address offset: 0x174 */
  __IO uint32_t BKP30R;                  /*!< TAMP backup register 30,                Address offset: 0x178 */
  __IO uint32_t BKP31R;                  /*!< TAMP backup register 31,                Address offset: 0x17C */
} TAMP_TypeDef;

/**
  * @brief Serial Audio Interface
  */

typedef struct
{
  uint32_t      RESERVED[17]; /*!< Reserved,                                 Address offset: 0x00 to 0x40 */
  __IO uint32_t PDMCR;        /*!< SAI PDM control register,                 Address offset: 0x44 */
  __IO uint32_t PDMDLY;       /*!< SAI PDM delay register,                   Address offset: 0x48 */
} SAI_TypeDef;

typedef struct
{
  __IO uint32_t CR1;         /*!< SAI block x configuration register 1,     Address offset: 0x04 */
  __IO uint32_t CR2;         /*!< SAI block x configuration register 2,     Address offset: 0x08 */
  __IO uint32_t FRCR;        /*!< SAI block x frame configuration register, Address offset: 0x0C */
  __IO uint32_t SLOTR;       /*!< SAI block x slot register,                Address offset: 0x10 */
  __IO uint32_t IMR;         /*!< SAI block x interrupt mask register,      Address offset: 0x14 */
  __IO uint32_t SR;          /*!< SAI block x status register,              Address offset: 0x18 */
  __IO uint32_t CLRFR;       /*!< SAI block x clear flag register,          Address offset: 0x1C */
  __IO uint32_t DR;          /*!< SAI block x data register,                Address offset: 0x20 */
} SAI_Block_TypeDef;

/**
  * @brief Serial Peripheral Interface
  */

typedef struct
{
  __IO uint32_t CR1;         /*!< SPI Control register 1,                              Address offset: 0x00 */
  __IO uint32_t CR2;         /*!< SPI Control register 2,                              Address offset: 0x04 */
  __IO uint32_t SR;          /*!< SPI Status register,                                 Address offset: 0x08 */
  __IO uint32_t DR;          /*!< SPI data register,                                  Address offset: 0x0C */
  __IO uint32_t CRCPR;       /*!< SPI CRC polynomial register,                         Address offset: 0x10 */
  __IO uint32_t RXCRCR;      /*!< SPI Rx CRC register,                                 Address offset: 0x14 */
  __IO uint32_t TXCRCR;      /*!< SPI Tx CRC register,                                 Address offset: 0x18 */
  __IO uint32_t I2SCFGR;     /*!< SPI_I2S configuration register,                      Address offset: 0x1C */
  __IO uint32_t I2SPR;       /*!< SPI_I2S prescaler register,                          Address offset: 0x20 */
} SPI_TypeDef;

/**
  * @brief System configuration controller
  */

typedef struct
{
  __IO uint32_t MEMRMP;      /*!< SYSCFG memory remap register,                        Address offset: 0x00      */
  __IO uint32_t CFGR1;       /*!< SYSCFG configuration register 1,                     Address offset: 0x04      */
  __IO uint32_t EXTICR[4];   /*!< SYSCFG external interrupt configuration registers,   Address offset: 0x08-0x14 */
  __IO uint32_t SCSR;        /*!< SYSCFG CCMSRAM control and status register,          Address offset: 0x18      */
  __IO uint32_t CFGR2;       /*!< SYSCFG configuration register 2,                     Address offset: 0x1C      */
  __IO uint32_t SWPR;        /*!< SYSCFG CCMSRAM write protection register,            Address offset: 0x20      */
  __IO uint32_t SKR;         /*!< SYSCFG CCMSRAM Key Register,                         Address offset: 0x24      */
} SYSCFG_TypeDef;

/**
  * @brief TIM
  */

typedef struct
{
  __IO uint32_t CR1;         /*!< TIM control register 1,                   Address offset: 0x00 */
  __IO uint32_t CR2;         /*!< TIM control register 2,                   Address offset: 0x04 */
  __IO uint32_t SMCR;        /*!< TIM slave mode control register,          Address offset: 0x08 */
  __IO uint32_t DIER;        /*!< TIM DMA/interrupt enable register,        Address offset: 0x0C */
  __IO uint32_t SR;          /*!< TIM status register,                      Address offset: 0x10 */
  __IO uint32_t EGR;         /*!< TIM event generation register,            Address offset: 0x14 */
  __IO uint32_t CCMR1;       /*!< TIM capture/compare mode register 1,      Address offset: 0x18 */
  __IO uint32_t CCMR2;       /*!< TIM capture/compare mode register 2,      Address offset: 0x1C */
  __IO uint32_t CCER;        /*!< TIM capture/compare enable register,      Address offset: 0x20 */
  __IO uint32_t CNT;         /*!< TIM counter register,                     Address offset: 0x24 */
  __IO uint32_t PSC;         /*!< TIM prescaler,                            Address offset: 0x28 */
  __IO uint32_t ARR;         /*!< TIM auto-reload register,                 Address offset: 0x2C */
  __IO uint32_t RCR;         /*!< TIM repetition counter register,          Address offset: 0x30 */
  __IO uint32_t CCR1;        /*!< TIM capture/compare register 1,           Address offset: 0x34 */
  __IO uint32_t CCR2;        /*!< TIM capture/compare register 2,           Address offset: 0x38 */
  __IO uint32_t CCR3;        /*!< TIM capture/compare register 3,           Address offset: 0x3C */
  __IO uint32_t CCR4;        /*!< TIM capture/compare register 4,           Address offset: 0x40 */
  __IO uint32_t BDTR;        /*!< TIM break and dead-time register,         Address offset: 0x44 */
  __IO uint32_t CCR5;        /*!< TIM capture/compare register 5,           Address offset: 0x48 */
  __IO uint32_t CCR6;        /*!< TIM capture/compare register 6,           Address offset: 0x4C */
  __IO uint32_t CCMR3;       /*!< TIM capture/compare mode register 3,      Address offset: 0x50 */
  __IO uint32_t DTR2;        /*!< TIM deadtime register 2,                  Address offset: 0x54 */
  __IO uint32_t ECR;         /*!< TIM encoder control register,             Address offset: 0x58 */
  __IO uint32_t TISEL;       /*!< TIM Input Selection register,             Address offset: 0x5C */
  __IO uint32_t AF1;         /*!< TIM alternate function option register 1, Address offset: 0x60 */
  __IO uint32_t AF2;         /*!< TIM alternate function option register 2, Address offset: 0x64 */
  __IO uint32_t OR ;         /*!< TIM option register,                      Address offset: 0x68 */
       uint32_t RESERVED0[220];/*!< Reserved,                               Address offset: 0x6C */
  __IO uint32_t DCR;         /*!< TIM DMA control register,                 Address offset: 0x3DC */
  __IO uint32_t DMAR;        /*!< TIM DMA address for full transfer,        Address offset: 0x3E0 */
} TIM_TypeDef;

/**
  * @brief Universal Synchronous Asynchronous Receiver Transmitter
  */
typedef struct
{
  __IO uint32_t CR1;         /*!< USART Control register 1,                 Address offset: 0x00  */
  __IO uint32_t CR2;         /*!< USART Control register 2,                 Address offset: 0x04  */
  __IO uint32_t CR3;         /*!< USART Control register 3,                 Address offset: 0x08  */
  __IO uint32_t BRR;         /*!< USART Baud rate register,                 Address offset: 0x0C  */
  __IO uint32_t GTPR;        /*!< USART Guard time and prescaler register,  Address offset: 0x10  */
  __IO uint32_t RTOR;        /*!< USART Receiver Timeout register,          Address offset: 0x14  */
  __IO uint32_t RQR;         /*!< USART Request register,                   Address offset: 0x18  */
  __IO uint32_t ISR;         /*!< USART Interrupt and status register,      Address offset: 0x1C  */
  __IO uint32_t ICR;         /*!< USART Interrupt flag Clear register,      Address offset: 0x20  */
  __IO uint32_t RDR;         /*!< USART Receive Data register,              Address offset: 0x24  */
  __IO uint32_t TDR;         /*!< USART Transmit Data register,             Address offset: 0x28  */
  __IO uint32_t PRESC;       /*!< USART Prescaler register,                 Address offset: 0x2C  */
} USART_TypeDef;

/**
  * @brief Universal Serial Bus Full Speed Device
  */

typedef struct
{
  __IO uint16_t EP0R;            /*!< USB Endpoint 0 register,                Address offset: 0x00 */
  __IO uint16_t RESERVED0;       /*!< Reserved */
  __IO uint16_t EP1R;            /*!< USB Endpoint 1 register,                Address offset: 0x04 */
  __IO uint16_t RESERVED1;       /*!< Reserved */
  __IO uint16_t EP2R;            /*!< USB Endpoint 2 register,                Address offset: 0x08 */
  __IO uint16_t RESERVED2;       /*!< Reserved */
  __IO uint16_t EP3R;            /*!< USB Endpoint 3 register,                Address offset: 0x0C */
  __IO uint16_t RESERVED3;       /*!< Reserved */
  __IO uint16_t EP4R;            /*!< USB Endpoint 4 register,                Address offset: 0x10 */
  __IO uint16_t RESERVED4;       /*!< Reserved */
  __IO uint16_t EP5R;            /*!< USB Endpoint 5 register,                Address offset: 0x14 */
  __IO uint16_t RESERVED5;       /*!< Reserved */
  __IO uint16_t EP6R;            /*!< USB Endpoint 6 register,                Address offset: 0x18 */
  __IO uint16_t RESERVED6;       /*!< Reserved */
  __IO uint16_t EP7R;            /*!< USB Endpoint 7 register,                Address offset: 0x1C */
  __IO uint16_t RESERVED7[17];   /*!< Reserved */
  __IO uint16_t CNTR;            /*!< Control register,                       Address offset: 0x40 */
  __IO uint16_t RESERVED8;       /*!< Reserved */
  __IO uint16_t ISTR;            /*!< Interrupt status register,              Address offset: 0x44 */
  __IO uint16_t RESERVED9;       /*!< Reserved */
  __IO uint16_t FNR;             /*!< Frame number register,                  Address offset: 0x48 */
  __IO uint16_t RESERVEDA;       /*!< Reserved */
  __IO uint16_t DADDR;           /*!< Device address register,                Address offset: 0x4C */
  __IO uint16_t RESERVEDB;       /*!< Reserved */
  __IO uint16_t BTABLE;          /*!< Buffer Table address register,          Address offset: 0x50 */
  __IO uint16_t RESERVEDC;       /*!< Reserved */
  __IO uint16_t LPMCSR;          /*!< LPM Control and Status register,        Address offset: 0x54 */
  __IO uint16_t RESERVEDD;       /*!< Reserved */
  __IO uint16_t BCDR;            /*!< Battery Charging detector register,     Address offset: 0x58 */
  __IO uint16_t RESERVEDE;       /*!< Reserved */
} USB_TypeDef;

/**
  * @brief VREFBUF
  */

typedef struct
{
  __IO uint32_t CSR;         /*!< VREFBUF control and status register,         Address offset: 0x00 */
  __IO uint32_t CCR;         /*!< VREFBUF calibration and control register,    Address offset: 0x04 */
} VREFBUF_TypeDef;

/**
  * @brief Window WATCHDOG
  */

typedef struct
{
  __IO uint32_t CR;          /*!< WWDG Control register,       Address offset: 0x00 */
  __IO uint32_t CFR;         /*!< WWDG Configuration register, Address offset: 0x04 */
  __IO uint32_t SR;          /*!< WWDG Status register,        Address offset: 0x08 */
} WWDG_TypeDef;


/**
  * @brief RNG
  */
typedef struct
{
  __IO uint32_t CR;  /*!< RNG control register, Address offset: 0x00 */
  __IO uint32_t SR;  /*!< RNG status register,  Address offset: 0x04 */
  __IO uint32_t DR;  /*!< RNG data register,    Address offset: 0x08 */
} RNG_TypeDef;

/**
  * @brief CORDIC
  */

typedef struct
{
  __IO uint32_t CSR;          /*!< CORDIC control and status register,        Address offset: 0x00 */
  __IO uint32_t WDATA;        /*!< CORDIC argument register,                  Address offset: 0x04 */
  __IO uint32_t RDATA;        /*!< CORDIC result register,                    Address offset: 0x08 */
} CORDIC_TypeDef;

/**
  * @brief UCPD
  */

typedef struct
{
  __IO uint32_t CFG1;          /*!< UCPD configuration register 1,             Address offset: 0x00 */
  __IO uint32_t CFG2;          /*!< UCPD configuration register 2,             Address offset: 0x04 */
  __IO uint32_t RESERVED0;     /*!< UCPD reserved register,                    Address offset: 0x08 */
  __IO uint32_t CR;            /*!< UCPD control register,                     Address offset: 0x0C */
  __IO uint32_t IMR;           /*!< UCPD interrupt mask register,              Address offset: 0x10 */
  __IO uint32_t SR;            /*!< UCPD status register,                      Address offset: 0x14 */
  __IO uint32_t ICR;           /*!< UCPD interrupt flag clear register         Address offset: 0x18 */
  __IO uint32_t TX_ORDSET;     /*!< UCPD Tx ordered set type register,         Address offset: 0x1C */
  __IO uint32_t TX_PAYSZ;      /*!< UCPD Tx payload size register,             Address offset: 0x20 */
  __IO uint32_t TXDR;          /*!< UCPD Tx data register,                     Address offset: 0x24 */
  __IO uint32_t RX_ORDSET;     /*!< UCPD Rx ordered set type register,         Address offset: 0x28 */
  __IO uint32_t RX_PAYSZ;      /*!< UCPD Rx payload size register,             Address offset: 0x2C */
  __IO uint32_t RXDR;          /*!< UCPD Rx data register,                     Address offset: 0x30 */
  __IO uint32_t RX_ORDEXT1;    /*!< UCPD Rx ordered set extension 1 register,  Address offset: 0x34 */
  __IO uint32_t RX_ORDEXT2;    /*!< UCPD Rx ordered set extension 2 register,  Address offset: 0x38 */
} UCPD_TypeDef;


/**
  * @}
  */

/** @addtogroup Peripheral_memory_map
  * @{
  */

#define FLASH_BASE (0x08000000UL)
#define SRAM1_BASE (0x20000000UL)
#define SRAM2_BASE (0x20014000UL)
#define CCMSRAM_BASE (0x10000000UL)
#define PERIPH_BASE (0x40000000UL)
#define FMC_BASE (0x60000000UL)
#define QSPI_BASE (0x90000000UL)

#define FMC_R_BASE (0xA0000000UL)
#define QSPI_R_BASE (0xA0001000UL)
#define SRAM1_BB_BASE (0x22000000UL)
#define SRAM2_BB_BASE (0x22280000UL)
#define CCMSRAM_BB_BASE (0x22300000UL)
#define PERIPH_BB_BASE (0x42000000UL)
/* Legacy defines */
#define SRAM_BASE SRAM1_BASE
#define SRAM_BB_BASE SRAM1_BB_BASE

#define SRAM1_SIZE_MAX (0x00014000UL)
#define SRAM2_SIZE (0x00004000UL)
#define CCMSRAM_SIZE (0x00008000UL)

/*!< Peripheral memory map */
#define APB1PERIPH_BASE PERIPH_BASE
#define APB2PERIPH_BASE (PERIPH_BASE + 0x00010000UL)
#define AHB1PERIPH_BASE (PERIPH_BASE + 0x00020000UL)
#define AHB2PERIPH_BASE (PERIPH_BASE + 0x08000000UL)

#define FMC_BANK1 FMC_BASE
#define FMC_BANK1_1 FMC_BANK1
#define FMC_BANK1_2 (FMC_BANK1 + 0x04000000UL)
#define FMC_BANK1_3 (FMC_BANK1 + 0x08000000UL)
#define FMC_BANK1_4 (FMC_BANK1 + 0x0C000000UL)
#define FMC_BANK3 (FMC_BASE + 0x20000000UL)

/*!< APB1 peripherals */
#define TIM2_BASE (APB1PERIPH_BASE + 0x0000UL)
#define TIM3_BASE (APB1PERIPH_BASE + 0x0400UL)
#define TIM4_BASE (APB1PERIPH_BASE + 0x0800UL)
#define TIM5_BASE (APB1PERIPH_BASE + 0x0C00UL)
#define TIM6_BASE (APB1PERIPH_BASE + 0x1000UL)
#define TIM7_BASE (APB1PERIPH_BASE + 0x1400UL)
#define CRS_BASE (APB1PERIPH_BASE + 0x2000UL)
#define TAMP_BASE (APB1PERIPH_BASE + 0x2400UL)
#define RTC_BASE (APB1PERIPH_BASE + 0x2800UL)
#define WWDG_BASE (APB1PERIPH_BASE + 0x2C00UL)
#define IWDG_BASE (APB1PERIPH_BASE + 0x3000UL)
#define SPI2_BASE (APB1PERIPH_BASE + 0x3800UL)
#define SPI3_BASE (APB1PERIPH_BASE + 0x3C00UL)
#define USART2_BASE (APB1PERIPH_BASE + 0x4400UL)
#define USART3_BASE (APB1PERIPH_BASE + 0x4800UL)
#define UART4_BASE (APB1PERIPH_BASE + 0x4C00UL)
#define UART5_BASE (APB1PERIPH_BASE + 0x5000UL)
#define I2C1_BASE (APB1PERIPH_BASE + 0x5400UL)
#define I2C2_BASE (APB1PERIPH_BASE + 0x5800UL)
#define USB_BASE (APB1PERIPH_BASE + 0x5C00UL)
#define USB_PMAADDR (APB1PERIPH_BASE + 0x6000UL)
#define FDCAN1_BASE (APB1PERIPH_BASE + 0x6400UL)
#define FDCAN_CONFIG_BASE (APB1PERIPH_BASE + 0x6500UL)
#define FDCAN2_BASE (APB1PERIPH_BASE + 0x6800UL)
#define FDCAN3_BASE (APB1PERIPH_BASE + 0x6C00UL)
#define PWR_BASE (APB1PERIPH_BASE + 0x7000UL)
#define I2C3_BASE (APB1PERIPH_BASE + 0x7800UL)
#define LPTIM1_BASE (APB1PERIPH_BASE + 0x7C00UL)
#define LPUART1_BASE (APB1PERIPH_BASE + 0x8000UL)
#define I2C4_BASE (APB1PERIPH_BASE + 0x8400UL)
#define UCPD1_BASE (APB1PERIPH_BASE + 0xA000UL)
#define SRAMCAN_BASE (APB1PERIPH_BASE + 0xA400UL)

/*!< APB2 peripherals */
#define SYSCFG_BASE (APB2PERIPH_BASE + 0x0000UL)
#define VREFBUF_BASE (APB2PERIPH_BASE + 0x0030UL)
#define COMP1_BASE (APB2PERIPH_BASE + 0x0200UL)
#define COMP2_BASE (APB2PERIPH_BASE + 0x0204UL)
#define COMP3_BASE (APB2PERIPH_BASE + 0x0208UL)
#define COMP4_BASE (APB2PERIPH_BASE + 0x020CUL)
#define COMP5_BASE (APB2PERIPH_BASE + 0x0210UL)
#define COMP6_BASE (APB2PERIPH_BASE + 0x0214UL)
#define COMP7_BASE (APB2PERIPH_BASE + 0x0218UL)
#define OPAMP_BASE (APB2PERIPH_BASE + 0x0300UL)
#define OPAMP1_BASE (APB2PERIPH_BASE + 0x0300UL)
#define OPAMP2_BASE (APB2PERIPH_BASE + 0x0304UL)
#define OPAMP3_BASE (APB2PERIPH_BASE + 0x0308UL)
#define OPAMP4_BASE (APB2PERIPH_BASE + 0x030CUL)
#define OPAMP5_BASE (APB2PERIPH_BASE + 0x0310UL)
#define OPAMP6_BASE (APB2PERIPH_BASE + 0x0314UL)

#define EXTI_BASE (APB2PERIPH_BASE + 0x0400UL)
#define TIM1_BASE (APB2PERIPH_BASE + 0x2C00UL)
#define SPI1_BASE (APB2PERIPH_BASE + 0x3000UL)
#define TIM8_BASE (APB2PERIPH_BASE + 0x3400UL)
#define USART1_BASE (APB2PERIPH_BASE + 0x3800UL)
#define SPI4_BASE (APB2PERIPH_BASE + 0x3C00UL)
#define TIM15_BASE (APB2PERIPH_BASE + 0x4000UL)
#define TIM16_BASE (APB2PERIPH_BASE + 0x4400UL)
#define TIM17_BASE (APB2PERIPH_BASE + 0x4800UL)
#define TIM20_BASE (APB2PERIPH_BASE + 0x5000UL)
#define SAI1_BASE (APB2PERIPH_BASE + 0x5400UL)
#define SAI1_Block_A_BASE (SAI1_BASE + 0x0004UL)
#define SAI1_Block_B_BASE (SAI1_BASE + 0x0024UL)

/*!< AHB1 peripherals */
#define DMA1_BASE (AHB1PERIPH_BASE)
#define DMA2_BASE (AHB1PERIPH_BASE + 0x0400UL)
#define DMAMUX1_BASE (AHB1PERIPH_BASE + 0x0800UL)
#define CORDIC_BASE (AHB1PERIPH_BASE + 0x0C00UL)
#define RCC_BASE (AHB1PERIPH_BASE + 0x1000UL)
#define FMAC_BASE (AHB1PERIPH_BASE + 0x1400UL)
#define FLASH_R_BASE (AHB1PERIPH_BASE + 0x2000UL)
#define CRC_BASE (AHB1PERIPH_BASE + 0x3000UL)

#define DMA1_Channel1_BASE (DMA1_BASE + 0x0008UL)
#define DMA1_Channel2_BASE (DMA1_BASE + 0x001CUL)
#define DMA1_Channel3_BASE (DMA1_BASE + 0x0030UL)
#define DMA1_Channel4_BASE (DMA1_BASE + 0x0044UL)
#define DMA1_Channel5_BASE (DMA1_BASE + 0x0058UL)
#define DMA1_Channel6_BASE (DMA1_BASE + 0x006CUL)
#define DMA1_Channel7_BASE (DMA1_BASE + 0x0080UL)
#define DMA1_Channel8_BASE (DMA1_BASE + 0x0094UL)

#define DMA2_Channel1_BASE (DMA2_BASE + 0x0008UL)
#define DMA2_Channel2_BASE (DMA2_BASE + 0x001CUL)
#define DMA2_Channel3_BASE (DMA2_BASE + 0x0030UL)
#define DMA2_Channel4_BASE (DMA2_BASE + 0x0044UL)
#define DMA2_Channel5_BASE (DMA2_BASE + 0x0058UL)
#define DMA2_Channel6_BASE (DMA2_BASE + 0x006CUL)
#define DMA2_Channel7_BASE (DMA2_BASE + 0x0080UL)
#define DMA2_Channel8_BASE (DMA2_BASE + 0x0094UL)

#define DMAMUX1_Channel0_BASE (DMAMUX1_BASE)
#define DMAMUX1_Channel1_BASE (DMAMUX1_BASE + 0x0004UL)
#define DMAMUX1_Channel2_BASE (DMAMUX1_BASE + 0x0008UL)
#define DMAMUX1_Channel3_BASE (DMAMUX1_BASE + 0x000CUL)
#define DMAMUX1_Channel4_BASE (DMAMUX1_BASE + 0x0010UL)
#define DMAMUX1_Channel5_BASE (DMAMUX1_BASE + 0x0014UL)
#define DMAMUX1_Channel6_BASE (DMAMUX1_BASE + 0x0018UL)
#define DMAMUX1_Channel7_BASE (DMAMUX1_BASE + 0x001CUL)
#define DMAMUX1_Channel8_BASE (DMAMUX1_BASE + 0x0020UL)
#define DMAMUX1_Channel9_BASE (DMAMUX1_BASE + 0x0024UL)
#define DMAMUX1_Channel10_BASE (DMAMUX1_BASE + 0x0028UL)
#define DMAMUX1_Channel11_BASE (DMAMUX1_BASE + 0x002CUL)
#define DMAMUX1_Channel12_BASE (DMAMUX1_BASE + 0x0030UL)
#define DMAMUX1_Channel13_BASE (DMAMUX1_BASE + 0x0034UL)
#define DMAMUX1_Channel14_BASE (DMAMUX1_BASE + 0x0038UL)
#define DMAMUX1_Channel15_BASE (DMAMUX1_BASE + 0x003CUL)
#define DMAMUX1_RequestGenerator0_BASE (DMAMUX1_BASE + 0x0100UL)
#define DMAMUX1_RequestGenerator1_BASE (DMAMUX1_BASE + 0x0104UL)
#define DMAMUX1_RequestGenerator2_BASE (DMAMUX1_BASE + 0x0108UL)
#define DMAMUX1_RequestGenerator3_BASE (DMAMUX1_BASE + 0x010CUL)

#define DMAMUX1_ChannelStatus_BASE (DMAMUX1_BASE + 0x0080UL)
#define DMAMUX1_RequestGenStatus_BASE (DMAMUX1_BASE + 0x0140UL)

/*!< AHB2 peripherals */
#define GPIOA_BASE (AHB2PERIPH_BASE + 0x0000UL)
#define GPIOB_BASE (AHB2PERIPH_BASE + 0x0400UL)
#define GPIOC_BASE (AHB2PERIPH_BASE + 0x0800UL)
#define GPIOD_BASE (AHB2PERIPH_BASE + 0x0C00UL)
#define GPIOE_BASE (AHB2PERIPH_BASE + 0x1000UL)
#define GPIOF_BASE (AHB2PERIPH_BASE + 0x1400UL)
#define GPIOG_BASE (AHB2PERIPH_BASE + 0x1800UL)

#define ADC1_BASE (AHB2PERIPH_BASE + 0x08000000UL)
#define ADC2_BASE (AHB2PERIPH_BASE + 0x08000100UL)
#define ADC12_COMMON_BASE (AHB2PERIPH_BASE + 0x08000300UL)
#define ADC3_BASE (AHB2PERIPH_BASE + 0x08000400UL)
#define ADC4_BASE (AHB2PERIPH_BASE + 0x08000500UL)
#define ADC5_BASE (AHB2PERIPH_BASE + 0x08000600UL)
#define ADC345_COMMON_BASE (AHB2PERIPH_BASE + 0x08000700UL)

#define DAC_BASE (AHB2PERIPH_BASE + 0x08000800UL)
#define DAC1_BASE (AHB2PERIPH_BASE + 0x08000800UL)
#define DAC2_BASE (AHB2PERIPH_BASE + 0x08000C00UL)
#define DAC3_BASE (AHB2PERIPH_BASE + 0x08001000UL)
#define DAC4_BASE (AHB2PERIPH_BASE + 0x08001400UL)

/*!< FMC Banks registers base  address */
#define FMC_Bank1_R_BASE (FMC_R_BASE + 0x0000UL)
#define FMC_Bank1E_R_BASE (FMC_R_BASE + 0x0104UL)
#define FMC_Bank3_R_BASE (FMC_R_BASE + 0x0080UL)
#define RNG_BASE (AHB2PERIPH_BASE + 0x08060800UL)
/* Debug MCU registers base address */
#define DBGMCU_BASE (0xE0042000UL)

#define PACKAGE_BASE (0x1FFF7500UL)
#define UID_BASE (0x1FFF7590UL)
#define FLASHSIZE_BASE (0x1FFF75E0UL)
/**
  * @}
  */

/** @addtogroup Peripheral_declaration
  * @{
  */
#define TIM2 ((TIM_TypeDef *) TIM2_BASE)
#define TIM3 ((TIM_TypeDef *) TIM3_BASE)
#define TIM4 ((TIM_TypeDef *) TIM4_BASE)
#define TIM5 ((TIM_TypeDef *) TIM5_BASE)
#define TIM6 ((TIM_TypeDef *) TIM6_BASE)
#define TIM7 ((TIM_TypeDef *) TIM7_BASE)
#define CRS ((CRS_TypeDef *) CRS_BASE)
#define TAMP ((TAMP_TypeDef *) TAMP_BASE)
#define RTC ((RTC_TypeDef *) RTC_BASE)
#define WWDG ((WWDG_TypeDef *) WWDG_BASE)
#define IWDG ((IWDG_TypeDef *) IWDG_BASE)
#define SPI2 ((SPI_TypeDef *) SPI2_BASE)
#define SPI3 ((SPI_TypeDef *) SPI3_BASE)
#define USART2 ((USART_TypeDef *) USART2_BASE)
#define USART3 ((USART_TypeDef *) USART3_BASE)
#define UART4 ((USART_TypeDef *) UART4_BASE)
#define UART5 ((USART_TypeDef *) UART5_BASE)
#define I2C1 ((I2C_TypeDef *) I2C1_BASE)
#define I2C2 ((I2C_TypeDef *) I2C2_BASE)
#define USB ((USB_TypeDef *) USB_BASE)
#define FDCAN1 ((FDCAN_GlobalTypeDef *) FDCAN1_BASE)
#define FDCAN_CONFIG ((FDCAN_Config_TypeDef *) FDCAN_CONFIG_BASE)
#define FDCAN2 ((FDCAN_GlobalTypeDef *) FDCAN2_BASE)
#define FDCAN3 ((FDCAN_GlobalTypeDef *) FDCAN3_BASE)
#define PWR ((PWR_TypeDef *) PWR_BASE)
#define I2C3 ((I2C_TypeDef *) I2C3_BASE)
#define LPTIM1 ((LPTIM_TypeDef *) LPTIM1_BASE)
#define LPUART1 ((USART_TypeDef *) LPUART1_BASE)
#define I2C4 ((I2C_TypeDef *) I2C4_BASE)
#define UCPD1 ((UCPD_TypeDef *) UCPD1_BASE)

#define SYSCFG ((SYSCFG_TypeDef *) SYSCFG_BASE)
#define VREFBUF ((VREFBUF_TypeDef *) VREFBUF_BASE)
#define COMP1 ((COMP_TypeDef *) COMP1_BASE)
#define COMP2 ((COMP_TypeDef *) COMP2_BASE)
#define COMP3 ((COMP_TypeDef *) COMP3_BASE)
#define COMP4 ((COMP_TypeDef *) COMP4_BASE)
#define COMP5 ((COMP_TypeDef *) COMP5_BASE)
#define COMP6 ((COMP_TypeDef *) COMP6_BASE)
#define COMP7 ((COMP_TypeDef *) COMP7_BASE)

#define OPAMP ((OPAMP_TypeDef *) OPAMP_BASE)
#define OPAMP1 ((OPAMP_TypeDef *) OPAMP1_BASE)
#define OPAMP2 ((OPAMP_TypeDef *) OPAMP2_BASE)
#define OPAMP3 ((OPAMP_TypeDef *) OPAMP3_BASE)
#define OPAMP4 ((OPAMP_TypeDef *) OPAMP4_BASE)
#define OPAMP5 ((OPAMP_TypeDef *) OPAMP5_BASE)
#define OPAMP6 ((OPAMP_TypeDef *) OPAMP6_BASE)

#define EXTI ((EXTI_TypeDef *) EXTI_BASE)
#define TIM1 ((TIM_TypeDef *) TIM1_BASE)
#define SPI1 ((SPI_TypeDef *) SPI1_BASE)
#define TIM8 ((TIM_TypeDef *) TIM8_BASE)
#define USART1 ((USART_TypeDef *) USART1_BASE)
#define SPI4 ((SPI_TypeDef *) SPI4_BASE)
#define TIM15 ((TIM_TypeDef *) TIM15_BASE)
#define TIM16 ((TIM_TypeDef *) TIM16_BASE)
#define TIM17 ((TIM_TypeDef *) TIM17_BASE)
#define TIM20 ((TIM_TypeDef *) TIM20_BASE)
#define SAI1 ((SAI_TypeDef *) SAI1_BASE)
#define SAI1_Block_A ((SAI_Block_TypeDef *)SAI1_Block_A_BASE)
#define SAI1_Block_B ((SAI_Block_TypeDef *)SAI1_Block_B_BASE)
#define DMA1 ((DMA_TypeDef *) DMA1_BASE)
#define DMA2 ((DMA_TypeDef *) DMA2_BASE)
#define DMAMUX1 ((DMAMUX_Channel_TypeDef *) DMAMUX1_BASE)
#define CORDIC ((CORDIC_TypeDef *) CORDIC_BASE)
#define RCC ((RCC_TypeDef *) RCC_BASE)
#define FMAC ((FMAC_TypeDef *) FMAC_BASE)
#define FLASH ((FLASH_TypeDef *) FLASH_R_BASE)
#define CRC ((CRC_TypeDef *) CRC_BASE)

#define GPIOA ((GPIO_TypeDef *) GPIOA_BASE)
#define GPIOB ((GPIO_TypeDef *) GPIOB_BASE)
#define GPIOC ((GPIO_TypeDef *) GPIOC_BASE)
#define GPIOD ((GPIO_TypeDef *) GPIOD_BASE)
#define GPIOE ((GPIO_TypeDef *) GPIOE_BASE)
#define GPIOF ((GPIO_TypeDef *) GPIOF_BASE)
#define GPIOG ((GPIO_TypeDef *) GPIOG_BASE)
#define ADC1 ((ADC_TypeDef *) ADC1_BASE)
#define ADC2 ((ADC_TypeDef *) ADC2_BASE)
#define ADC12_COMMON ((ADC_Common_TypeDef *) ADC12_COMMON_BASE)
#define ADC3 ((ADC_TypeDef *) ADC3_BASE)
#define ADC4 ((ADC_TypeDef *) ADC4_BASE)
#define ADC5 ((ADC_TypeDef *) ADC5_BASE)
#define ADC345_COMMON ((ADC_Common_TypeDef *) ADC345_COMMON_BASE)
#define DAC ((DAC_TypeDef *) DAC_BASE)
#define DAC1 ((DAC_TypeDef *) DAC1_BASE)
#define DAC2 ((DAC_TypeDef *) DAC2_BASE)
#define DAC3 ((DAC_TypeDef *) DAC3_BASE)
#define DAC4 ((DAC_TypeDef *) DAC4_BASE)
#define RNG ((RNG_TypeDef *) RNG_BASE)

#define DMA1_Channel1 ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
#define DMA1_Channel2 ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
#define DMA1_Channel3 ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
#define DMA1_Channel4 ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
#define DMA1_Channel5 ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
#define DMA1_Channel6 ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
#define DMA1_Channel7 ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
#define DMA1_Channel8 ((DMA_Channel_TypeDef *) DMA1_Channel8_BASE)

#define DMA2_Channel1 ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
#define DMA2_Channel2 ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
#define DMA2_Channel3 ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
#define DMA2_Channel4 ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
#define DMA2_Channel5 ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
#define DMA2_Channel6 ((DMA_Channel_TypeDef *) DMA2_Channel6_BASE)
#define DMA2_Channel7 ((DMA_Channel_TypeDef *) DMA2_Channel7_BASE)
#define DMA2_Channel8 ((DMA_Channel_TypeDef *) DMA2_Channel8_BASE)

#define DMAMUX1_Channel0 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel0_BASE)
#define DMAMUX1_Channel1 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel1_BASE)
#define DMAMUX1_Channel2 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel2_BASE)
#define DMAMUX1_Channel3 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel3_BASE)
#define DMAMUX1_Channel4 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel4_BASE)
#define DMAMUX1_Channel5 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel5_BASE)
#define DMAMUX1_Channel6 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel6_BASE)
#define DMAMUX1_Channel7 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel7_BASE)
#define DMAMUX1_Channel8 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel8_BASE)
#define DMAMUX1_Channel9 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel9_BASE)
#define DMAMUX1_Channel10 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel10_BASE)
#define DMAMUX1_Channel11 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel11_BASE)
#define DMAMUX1_Channel12 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel12_BASE)
#define DMAMUX1_Channel13 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel13_BASE)
#define DMAMUX1_Channel14 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel14_BASE)
#define DMAMUX1_Channel15 ((DMAMUX_Channel_TypeDef *) DMAMUX1_Channel15_BASE)

#define DMAMUX1_RequestGenerator0 ((DMAMUX_RequestGen_TypeDef *) DMAMUX1_RequestGenerator0_BASE)
#define DMAMUX1_RequestGenerator1 ((DMAMUX_RequestGen_TypeDef *) DMAMUX1_RequestGenerator1_BASE)
#define DMAMUX1_RequestGenerator2 ((DMAMUX_RequestGen_TypeDef *) DMAMUX1_RequestGenerator2_BASE)
#define DMAMUX1_RequestGenerator3 ((DMAMUX_RequestGen_TypeDef *) DMAMUX1_RequestGenerator3_BASE)

#define DMAMUX1_ChannelStatus ((DMAMUX_ChannelStatus_TypeDef *) DMAMUX1_ChannelStatus_BASE)
#define DMAMUX1_RequestGenStatus ((DMAMUX_RequestGenStatus_TypeDef *) DMAMUX1_RequestGenStatus_BASE)

#define FMC_Bank1_R ((FMC_Bank1_TypeDef *) FMC_Bank1_R_BASE)
#define FMC_Bank1E_R ((FMC_Bank1E_TypeDef *) FMC_Bank1E_R_BASE)
#define FMC_Bank3_R ((FMC_Bank3_TypeDef *) FMC_Bank3_R_BASE)

#define QUADSPI ((QUADSPI_TypeDef *) QSPI_R_BASE)

#define DBGMCU ((DBGMCU_TypeDef *) DBGMCU_BASE)

/**
  * @}
  */

/** @addtogroup Exported_constants
  * @{
  */

  /** @addtogroup Hardware_Constant_Definition
    * @{
    */
#define LSI_STARTUP_TIME 130U

  /**
    * @}
    */

/** @addtogroup Peripheral_Registers_Bits_Definition
  * @{
  */

/******************************************************************************/
/*                         Peripheral Registers_Bits_Definition               */
/******************************************************************************/

/******************************************************************************/
/*                                                                            */
/*                        Analog to Digital Converter                         */
/*                                                                            */
/******************************************************************************/

/*
 * @brief Specific device feature definitions (not present on all devices in the STM32G4 series)
 */
#define ADC_MULTIMODE_SUPPORT 

/********************  Bit definition for ADC_ISR register  *******************/
#define ADC_ISR_ADRDY_Pos (0U)
#define ADC_ISR_ADRDY_Msk (0x1UL << ADC_ISR_ADRDY_Pos)
#define ADC_ISR_ADRDY ADC_ISR_ADRDY_Msk
#define ADC_ISR_EOSMP_Pos (1U)
#define ADC_ISR_EOSMP_Msk (0x1UL << ADC_ISR_EOSMP_Pos)
#define ADC_ISR_EOSMP ADC_ISR_EOSMP_Msk
#define ADC_ISR_EOC_Pos (2U)
#define ADC_ISR_EOC_Msk (0x1UL << ADC_ISR_EOC_Pos)
#define ADC_ISR_EOC ADC_ISR_EOC_Msk
#define ADC_ISR_EOS_Pos (3U)
#define ADC_ISR_EOS_Msk (0x1UL << ADC_ISR_EOS_Pos)
#define ADC_ISR_EOS ADC_ISR_EOS_Msk
#define ADC_ISR_OVR_Pos (4U)
#define ADC_ISR_OVR_Msk (0x1UL << ADC_ISR_OVR_Pos)
#define ADC_ISR_OVR ADC_ISR_OVR_Msk
#define ADC_ISR_JEOC_Pos (5U)
#define ADC_ISR_JEOC_Msk (0x1UL << ADC_ISR_JEOC_Pos)
#define ADC_ISR_JEOC ADC_ISR_JEOC_Msk
#define ADC_ISR_JEOS_Pos (6U)
#define ADC_ISR_JEOS_Msk (0x1UL << ADC_ISR_JEOS_Pos)
#define ADC_ISR_JEOS ADC_ISR_JEOS_Msk
#define ADC_ISR_AWD1_Pos (7U)
#define ADC_ISR_AWD1_Msk (0x1UL << ADC_ISR_AWD1_Pos)
#define ADC_ISR_AWD1 ADC_ISR_AWD1_Msk
#define ADC_ISR_AWD2_Pos (8U)
#define ADC_ISR_AWD2_Msk (0x1UL << ADC_ISR_AWD2_Pos)
#define ADC_ISR_AWD2 ADC_ISR_AWD2_Msk
#define ADC_ISR_AWD3_Pos (9U)
#define ADC_ISR_AWD3_Msk (0x1UL << ADC_ISR_AWD3_Pos)
#define ADC_ISR_AWD3 ADC_ISR_AWD3_Msk
#define ADC_ISR_JQOVF_Pos (10U)
#define ADC_ISR_JQOVF_Msk (0x1UL << ADC_ISR_JQOVF_Pos)
#define ADC_ISR_JQOVF ADC_ISR_JQOVF_Msk

/********************  Bit definition for ADC_IER register  *******************/
#define ADC_IER_ADRDYIE_Pos (0U)
#define ADC_IER_ADRDYIE_Msk (0x1UL << ADC_IER_ADRDYIE_Pos)
#define ADC_IER_ADRDYIE ADC_IER_ADRDYIE_Msk
#define ADC_IER_EOSMPIE_Pos (1U)
#define ADC_IER_EOSMPIE_Msk (0x1UL << ADC_IER_EOSMPIE_Pos)
#define ADC_IER_EOSMPIE ADC_IER_EOSMPIE_Msk
#define ADC_IER_EOCIE_Pos (2U)
#define ADC_IER_EOCIE_Msk (0x1UL << ADC_IER_EOCIE_Pos)
#define ADC_IER_EOCIE ADC_IER_EOCIE_Msk
#define ADC_IER_EOSIE_Pos (3U)
#define ADC_IER_EOSIE_Msk (0x1UL << ADC_IER_EOSIE_Pos)
#define ADC_IER_EOSIE ADC_IER_EOSIE_Msk
#define ADC_IER_OVRIE_Pos (4U)
#define ADC_IER_OVRIE_Msk (0x1UL << ADC_IER_OVRIE_Pos)
#define ADC_IER_OVRIE ADC_IER_OVRIE_Msk
#define ADC_IER_JEOCIE_Pos (5U)
#define ADC_IER_JEOCIE_Msk (0x1UL << ADC_IER_JEOCIE_Pos)
#define ADC_IER_JEOCIE ADC_IER_JEOCIE_Msk
#define ADC_IER_JEOSIE_Pos (6U)
#define ADC_IER_JEOSIE_Msk (0x1UL << ADC_IER_JEOSIE_Pos)
#define ADC_IER_JEOSIE ADC_IER_JEOSIE_Msk
#define ADC_IER_AWD1IE_Pos (7U)
#define ADC_IER_AWD1IE_Msk (0x1UL << ADC_IER_AWD1IE_Pos)
#define ADC_IER_AWD1IE ADC_IER_AWD1IE_Msk
#define ADC_IER_AWD2IE_Pos (8U)
#define ADC_IER_AWD2IE_Msk (0x1UL << ADC_IER_AWD2IE_Pos)
#define ADC_IER_AWD2IE ADC_IER_AWD2IE_Msk
#define ADC_IER_AWD3IE_Pos (9U)
#define ADC_IER_AWD3IE_Msk (0x1UL << ADC_IER_AWD3IE_Pos)
#define ADC_IER_AWD3IE ADC_IER_AWD3IE_Msk
#define ADC_IER_JQOVFIE_Pos (10U)
#define ADC_IER_JQOVFIE_Msk (0x1UL << ADC_IER_JQOVFIE_Pos)
#define ADC_IER_JQOVFIE ADC_IER_JQOVFIE_Msk

/********************  Bit definition for ADC_CR register  ********************/
#define ADC_CR_ADEN_Pos (0U)
#define ADC_CR_ADEN_Msk (0x1UL << ADC_CR_ADEN_Pos)
#define ADC_CR_ADEN ADC_CR_ADEN_Msk
#define ADC_CR_ADDIS_Pos (1U)
#define ADC_CR_ADDIS_Msk (0x1UL << ADC_CR_ADDIS_Pos)
#define ADC_CR_ADDIS ADC_CR_ADDIS_Msk
#define ADC_CR_ADSTART_Pos (2U)
#define ADC_CR_ADSTART_Msk (0x1UL << ADC_CR_ADSTART_Pos)
#define ADC_CR_ADSTART ADC_CR_ADSTART_Msk
#define ADC_CR_JADSTART_Pos (3U)
#define ADC_CR_JADSTART_Msk (0x1UL << ADC_CR_JADSTART_Pos)
#define ADC_CR_JADSTART ADC_CR_JADSTART_Msk
#define ADC_CR_ADSTP_Pos (4U)
#define ADC_CR_ADSTP_Msk (0x1UL << ADC_CR_ADSTP_Pos)
#define ADC_CR_ADSTP ADC_CR_ADSTP_Msk
#define ADC_CR_JADSTP_Pos (5U)
#define ADC_CR_JADSTP_Msk (0x1UL << ADC_CR_JADSTP_Pos)
#define ADC_CR_JADSTP ADC_CR_JADSTP_Msk
#define ADC_CR_ADVREGEN_Pos (28U)
#define ADC_CR_ADVREGEN_Msk (0x1UL << ADC_CR_ADVREGEN_Pos)
#define ADC_CR_ADVREGEN ADC_CR_ADVREGEN_Msk
#define ADC_CR_DEEPPWD_Pos (29U)
#define ADC_CR_DEEPPWD_Msk (0x1UL << ADC_CR_DEEPPWD_Pos)
#define ADC_CR_DEEPPWD ADC_CR_DEEPPWD_Msk
#define ADC_CR_ADCALDIF_Pos (30U)
#define ADC_CR_ADCALDIF_Msk (0x1UL << ADC_CR_ADCALDIF_Pos)
#define ADC_CR_ADCALDIF ADC_CR_ADCALDIF_Msk
#define ADC_CR_ADCAL_Pos (31U)
#define ADC_CR_ADCAL_Msk (0x1UL << ADC_CR_ADCAL_Pos)
#define ADC_CR_ADCAL ADC_CR_ADCAL_Msk

/********************  Bit definition for ADC_CFGR register  ******************/
#define ADC_CFGR_DMAEN_Pos (0U)
#define ADC_CFGR_DMAEN_Msk (0x1UL << ADC_CFGR_DMAEN_Pos)
#define ADC_CFGR_DMAEN ADC_CFGR_DMAEN_Msk
#define ADC_CFGR_DMACFG_Pos (1U)
#define ADC_CFGR_DMACFG_Msk (0x1UL << ADC_CFGR_DMACFG_Pos)
#define ADC_CFGR_DMACFG ADC_CFGR_DMACFG_Msk

#define ADC_CFGR_RES_Pos (3U)
#define ADC_CFGR_RES_Msk (0x3UL << ADC_CFGR_RES_Pos)
#define ADC_CFGR_RES ADC_CFGR_RES_Msk
#define ADC_CFGR_RES_0 (0x1UL << ADC_CFGR_RES_Pos)
#define ADC_CFGR_RES_1 (0x2UL << ADC_CFGR_RES_Pos)

#define ADC_CFGR_EXTSEL_Pos (5U)
#define ADC_CFGR_EXTSEL_Msk (0x1FUL << ADC_CFGR_EXTSEL_Pos)
#define ADC_CFGR_EXTSEL ADC_CFGR_EXTSEL_Msk
#define ADC_CFGR_EXTSEL_0 (0x1UL << ADC_CFGR_EXTSEL_Pos)
#define ADC_CFGR_EXTSEL_1 (0x2UL << ADC_CFGR_EXTSEL_Pos)
#define ADC_CFGR_EXTSEL_2 (0x4UL << ADC_CFGR_EXTSEL_Pos)
#define ADC_CFGR_EXTSEL_3 (0x8UL << ADC_CFGR_EXTSEL_Pos)
#define ADC_CFGR_EXTSEL_4 (0x10UL << ADC_CFGR_EXTSEL_Pos)

#define ADC_CFGR_EXTEN_Pos (10U)
#define ADC_CFGR_EXTEN_Msk (0x3UL << ADC_CFGR_EXTEN_Pos)
#define ADC_CFGR_EXTEN ADC_CFGR_EXTEN_Msk
#define ADC_CFGR_EXTEN_0 (0x1UL << ADC_CFGR_EXTEN_Pos)
#define ADC_CFGR_EXTEN_1 (0x2UL << ADC_CFGR_EXTEN_Pos)

#define ADC_CFGR_OVRMOD_Pos (12U)
#define ADC_CFGR_OVRMOD_Msk (0x1UL << ADC_CFGR_OVRMOD_Pos)
#define ADC_CFGR_OVRMOD ADC_CFGR_OVRMOD_Msk
#define ADC_CFGR_CONT_Pos (13U)
#define ADC_CFGR_CONT_Msk (0x1UL << ADC_CFGR_CONT_Pos)
#define ADC_CFGR_CONT ADC_CFGR_CONT_Msk
#define ADC_CFGR_AUTDLY_Pos (14U)
#define ADC_CFGR_AUTDLY_Msk (0x1UL << ADC_CFGR_AUTDLY_Pos)
#define ADC_CFGR_AUTDLY ADC_CFGR_AUTDLY_Msk
#define ADC_CFGR_ALIGN_Pos (15U)
#define ADC_CFGR_ALIGN_Msk (0x1UL << ADC_CFGR_ALIGN_Pos)
#define ADC_CFGR_ALIGN ADC_CFGR_ALIGN_Msk
#define ADC_CFGR_DISCEN_Pos (16U)
#define ADC_CFGR_DISCEN_Msk (0x1UL << ADC_CFGR_DISCEN_Pos)
#define ADC_CFGR_DISCEN ADC_CFGR_DISCEN_Msk

#define ADC_CFGR_DISCNUM_Pos (17U)
#define ADC_CFGR_DISCNUM_Msk (0x7UL << ADC_CFGR_DISCNUM_Pos)
#define ADC_CFGR_DISCNUM ADC_CFGR_DISCNUM_Msk
#define ADC_CFGR_DISCNUM_0 (0x1UL << ADC_CFGR_DISCNUM_Pos)
#define ADC_CFGR_DISCNUM_1 (0x2UL << ADC_CFGR_DISCNUM_Pos)
#define ADC_CFGR_DISCNUM_2 (0x4UL << ADC_CFGR_DISCNUM_Pos)

#define ADC_CFGR_JDISCEN_Pos (20U)
#define ADC_CFGR_JDISCEN_Msk (0x1UL << ADC_CFGR_JDISCEN_Pos)
#define ADC_CFGR_JDISCEN ADC_CFGR_JDISCEN_Msk
#define ADC_CFGR_JQM_Pos (21U)
#define ADC_CFGR_JQM_Msk (0x1UL << ADC_CFGR_JQM_Pos)
#define ADC_CFGR_JQM ADC_CFGR_JQM_Msk
#define ADC_CFGR_AWD1SGL_Pos (22U)
#define ADC_CFGR_AWD1SGL_Msk (0x1UL << ADC_CFGR_AWD1SGL_Pos)
#define ADC_CFGR_AWD1SGL ADC_CFGR_AWD1SGL_Msk
#define ADC_CFGR_AWD1EN_Pos (23U)
#define ADC_CFGR_AWD1EN_Msk (0x1UL << ADC_CFGR_AWD1EN_Pos)
#define ADC_CFGR_AWD1EN ADC_CFGR_AWD1EN_Msk
#define ADC_CFGR_JAWD1EN_Pos (24U)
#define ADC_CFGR_JAWD1EN_Msk (0x1UL << ADC_CFGR_JAWD1EN_Pos)
#define ADC_CFGR_JAWD1EN ADC_CFGR_JAWD1EN_Msk
#define ADC_CFGR_JAUTO_Pos (25U)
#define ADC_CFGR_JAUTO_Msk (0x1UL << ADC_CFGR_JAUTO_Pos)
#define ADC_CFGR_JAUTO ADC_CFGR_JAUTO_Msk

#define ADC_CFGR_AWD1CH_Pos (26U)
#define ADC_CFGR_AWD1CH_Msk (0x1FUL << ADC_CFGR_AWD1CH_Pos)
#define ADC_CFGR_AWD1CH ADC_CFGR_AWD1CH_Msk
#define ADC_CFGR_AWD1CH_0 (0x01UL << ADC_CFGR_AWD1CH_Pos)
#define ADC_CFGR_AWD1CH_1 (0x02UL << ADC_CFGR_AWD1CH_Pos)
#define ADC_CFGR_AWD1CH_2 (0x04UL << ADC_CFGR_AWD1CH_Pos)
#define ADC_CFGR_AWD1CH_3 (0x08UL << ADC_CFGR_AWD1CH_Pos)
#define ADC_CFGR_AWD1CH_4 (0x10UL << ADC_CFGR_AWD1CH_Pos)

#define ADC_CFGR_JQDIS_Pos (31U)
#define ADC_CFGR_JQDIS_Msk (0x1UL << ADC_CFGR_JQDIS_Pos)
#define ADC_CFGR_JQDIS ADC_CFGR_JQDIS_Msk

/********************  Bit definition for ADC_CFGR2 register  *****************/
#define ADC_CFGR2_ROVSE_Pos (0U)
#define ADC_CFGR2_ROVSE_Msk (0x1UL << ADC_CFGR2_ROVSE_Pos)
#define ADC_CFGR2_ROVSE ADC_CFGR2_ROVSE_Msk
#define ADC_CFGR2_JOVSE_Pos (1U)
#define ADC_CFGR2_JOVSE_Msk (0x1UL << ADC_CFGR2_JOVSE_Pos)
#define ADC_CFGR2_JOVSE ADC_CFGR2_JOVSE_Msk

#define ADC_CFGR2_OVSR_Pos (2U)
#define ADC_CFGR2_OVSR_Msk (0x7UL << ADC_CFGR2_OVSR_Pos)
#define ADC_CFGR2_OVSR ADC_CFGR2_OVSR_Msk
#define ADC_CFGR2_OVSR_0 (0x1UL << ADC_CFGR2_OVSR_Pos)
#define ADC_CFGR2_OVSR_1 (0x2UL << ADC_CFGR2_OVSR_Pos)
#define ADC_CFGR2_OVSR_2 (0x4UL << ADC_CFGR2_OVSR_Pos)

#define ADC_CFGR2_OVSS_Pos (5U)
#define ADC_CFGR2_OVSS_Msk (0xFUL << ADC_CFGR2_OVSS_Pos)
#define ADC_CFGR2_OVSS ADC_CFGR2_OVSS_Msk
#define ADC_CFGR2_OVSS_0 (0x1UL << ADC_CFGR2_OVSS_Pos)
#define ADC_CFGR2_OVSS_1 (0x2UL << ADC_CFGR2_OVSS_Pos)
#define ADC_CFGR2_OVSS_2 (0x4UL << ADC_CFGR2_OVSS_Pos)
#define ADC_CFGR2_OVSS_3 (0x8UL << ADC_CFGR2_OVSS_Pos)

#define ADC_CFGR2_TROVS_Pos (9U)
#define ADC_CFGR2_TROVS_Msk (0x1UL << ADC_CFGR2_TROVS_Pos)
#define ADC_CFGR2_TROVS ADC_CFGR2_TROVS_Msk
#define ADC_CFGR2_ROVSM_Pos (10U)
#define ADC_CFGR2_ROVSM_Msk (0x1UL << ADC_CFGR2_ROVSM_Pos)
#define ADC_CFGR2_ROVSM ADC_CFGR2_ROVSM_Msk

#define ADC_CFGR2_GCOMP_Pos (16U)
#define ADC_CFGR2_GCOMP_Msk (0x1UL << ADC_CFGR2_GCOMP_Pos)
#define ADC_CFGR2_GCOMP ADC_CFGR2_GCOMP_Msk

#define ADC_CFGR2_SWTRIG_Pos (25U)
#define ADC_CFGR2_SWTRIG_Msk (0x1UL << ADC_CFGR2_SWTRIG_Pos)
#define ADC_CFGR2_SWTRIG ADC_CFGR2_SWTRIG_Msk
#define ADC_CFGR2_BULB_Pos (26U)
#define ADC_CFGR2_BULB_Msk (0x1UL << ADC_CFGR2_BULB_Pos)
#define ADC_CFGR2_BULB ADC_CFGR2_BULB_Msk
#define ADC_CFGR2_SMPTRIG_Pos (27U)
#define ADC_CFGR2_SMPTRIG_Msk (0x1UL << ADC_CFGR2_SMPTRIG_Pos)
#define ADC_CFGR2_SMPTRIG ADC_CFGR2_SMPTRIG_Msk

/********************  Bit definition for ADC_SMPR1 register  *****************/
#define ADC_SMPR1_SMP0_Pos (0U)
#define ADC_SMPR1_SMP0_Msk (0x7UL << ADC_SMPR1_SMP0_Pos)
#define ADC_SMPR1_SMP0 ADC_SMPR1_SMP0_Msk
#define ADC_SMPR1_SMP0_0 (0x1UL << ADC_SMPR1_SMP0_Pos)
#define ADC_SMPR1_SMP0_1 (0x2UL << ADC_SMPR1_SMP0_Pos)
#define ADC_SMPR1_SMP0_2 (0x4UL << ADC_SMPR1_SMP0_Pos)

#define ADC_SMPR1_SMP1_Pos (3U)
#define ADC_SMPR1_SMP1_Msk (0x7UL << ADC_SMPR1_SMP1_Pos)
#define ADC_SMPR1_SMP1 ADC_SMPR1_SMP1_Msk
#define ADC_SMPR1_SMP1_0 (0x1UL << ADC_SMPR1_SMP1_Pos)
#define ADC_SMPR1_SMP1_1 (0x2UL << ADC_SMPR1_SMP1_Pos)
#define ADC_SMPR1_SMP1_2 (0x4UL << ADC_SMPR1_SMP1_Pos)

#define ADC_SMPR1_SMP2_Pos (6U)
#define ADC_SMPR1_SMP2_Msk (0x7UL << ADC_SMPR1_SMP2_Pos)
#define ADC_SMPR1_SMP2 ADC_SMPR1_SMP2_Msk
#define ADC_SMPR1_SMP2_0 (0x1UL << ADC_SMPR1_SMP2_Pos)
#define ADC_SMPR1_SMP2_1 (0x2UL << ADC_SMPR1_SMP2_Pos)
#define ADC_SMPR1_SMP2_2 (0x4UL << ADC_SMPR1_SMP2_Pos)

#define ADC_SMPR1_SMP3_Pos (9U)
#define ADC_SMPR1_SMP3_Msk (0x7UL << ADC_SMPR1_SMP3_Pos)
#define ADC_SMPR1_SMP3 ADC_SMPR1_SMP3_Msk
#define ADC_SMPR1_SMP3_0 (0x1UL << ADC_SMPR1_SMP3_Pos)
#define ADC_SMPR1_SMP3_1 (0x2UL << ADC_SMPR1_SMP3_Pos)
#define ADC_SMPR1_SMP3_2 (0x4UL << ADC_SMPR1_SMP3_Pos)

#define ADC_SMPR1_SMP4_Pos (12U)
#define ADC_SMPR1_SMP4_Msk (0x7UL << ADC_SMPR1_SMP4_Pos)
#define ADC_SMPR1_SMP4 ADC_SMPR1_SMP4_Msk
#define ADC_SMPR1_SMP4_0 (0x1UL << ADC_SMPR1_SMP4_Pos)
#define ADC_SMPR1_SMP4_1 (0x2UL << ADC_SMPR1_SMP4_Pos)
#define ADC_SMPR1_SMP4_2 (0x4UL << ADC_SMPR1_SMP4_Pos)

#define ADC_SMPR1_SMP5_Pos (15U)
#define ADC_SMPR1_SMP5_Msk (0x7UL << ADC_SMPR1_SMP5_Pos)
#define ADC_SMPR1_SMP5 ADC_SMPR1_SMP5_Msk
#define ADC_SMPR1_SMP5_0 (0x1UL << ADC_SMPR1_SMP5_Pos)
#define ADC_SMPR1_SMP5_1 (0x2UL << ADC_SMPR1_SMP5_Pos)
#define ADC_SMPR1_SMP5_2 (0x4UL << ADC_SMPR1_SMP5_Pos)

#define ADC_SMPR1_SMP6_Pos (18U)
#define ADC_SMPR1_SMP6_Msk (0x7UL << ADC_SMPR1_SMP6_Pos)
#define ADC_SMPR1_SMP6 ADC_SMPR1_SMP6_Msk
#define ADC_SMPR1_SMP6_0 (0x1UL << ADC_SMPR1_SMP6_Pos)
#define ADC_SMPR1_SMP6_1 (0x2UL << ADC_SMPR1_SMP6_Pos)
#define ADC_SMPR1_SMP6_2 (0x4UL << ADC_SMPR1_SMP6_Pos)

#define ADC_SMPR1_SMP7_Pos (21U)
#define ADC_SMPR1_SMP7_Msk (0x7UL << ADC_SMPR1_SMP7_Pos)
#define ADC_SMPR1_SMP7 ADC_SMPR1_SMP7_Msk
#define ADC_SMPR1_SMP7_0 (0x1UL << ADC_SMPR1_SMP7_Pos)
#define ADC_SMPR1_SMP7_1 (0x2UL << ADC_SMPR1_SMP7_Pos)
#define ADC_SMPR1_SMP7_2 (0x4UL << ADC_SMPR1_SMP7_Pos)

#define ADC_SMPR1_SMP8_Pos (24U)
#define ADC_SMPR1_SMP8_Msk (0x7UL << ADC_SMPR1_SMP8_Pos)
#define ADC_SMPR1_SMP8 ADC_SMPR1_SMP8_Msk
#define ADC_SMPR1_SMP8_0 (0x1UL << ADC_SMPR1_SMP8_Pos)
#define ADC_SMPR1_SMP8_1 (0x2UL << ADC_SMPR1_SMP8_Pos)
#define ADC_SMPR1_SMP8_2 (0x4UL << ADC_SMPR1_SMP8_Pos)

#define ADC_SMPR1_SMP9_Pos (27U)
#define ADC_SMPR1_SMP9_Msk (0x7UL << ADC_SMPR1_SMP9_Pos)
#define ADC_SMPR1_SMP9 ADC_SMPR1_SMP9_Msk
#define ADC_SMPR1_SMP9_0 (0x1UL << ADC_SMPR1_SMP9_Pos)
#define ADC_SMPR1_SMP9_1 (0x2UL << ADC_SMPR1_SMP9_Pos)
#define ADC_SMPR1_SMP9_2 (0x4UL << ADC_SMPR1_SMP9_Pos)

#define ADC_SMPR1_SMPPLUS_Pos (31U)
#define ADC_SMPR1_SMPPLUS_Msk (0x1UL << ADC_SMPR1_SMPPLUS_Pos)
#define ADC_SMPR1_SMPPLUS ADC_SMPR1_SMPPLUS_Msk

/********************  Bit definition for ADC_SMPR2 register  *****************/
#define ADC_SMPR2_SMP10_Pos (0U)
#define ADC_SMPR2_SMP10_Msk (0x7UL << ADC_SMPR2_SMP10_Pos)
#define ADC_SMPR2_SMP10 ADC_SMPR2_SMP10_Msk
#define ADC_SMPR2_SMP10_0 (0x1UL << ADC_SMPR2_SMP10_Pos)
#define ADC_SMPR2_SMP10_1 (0x2UL << ADC_SMPR2_SMP10_Pos)
#define ADC_SMPR2_SMP10_2 (0x4UL << ADC_SMPR2_SMP10_Pos)

#define ADC_SMPR2_SMP11_Pos (3U)
#define ADC_SMPR2_SMP11_Msk (0x7UL << ADC_SMPR2_SMP11_Pos)
#define ADC_SMPR2_SMP11 ADC_SMPR2_SMP11_Msk
#define ADC_SMPR2_SMP11_0 (0x1UL << ADC_SMPR2_SMP11_Pos)
#define ADC_SMPR2_SMP11_1 (0x2UL << ADC_SMPR2_SMP11_Pos)
#define ADC_SMPR2_SMP11_2 (0x4UL << ADC_SMPR2_SMP11_Pos)

#define ADC_SMPR2_SMP12_Pos (6U)
#define ADC_SMPR2_SMP12_Msk (0x7UL << ADC_SMPR2_SMP12_Pos)
#define ADC_SMPR2_SMP12 ADC_SMPR2_SMP12_Msk
#define ADC_SMPR2_SMP12_0 (0x1UL << ADC_SMPR2_SMP12_Pos)
#define ADC_SMPR2_SMP12_1 (0x2UL << ADC_SMPR2_SMP12_Pos)
#define ADC_SMPR2_SMP12_2 (0x4UL << ADC_SMPR2_SMP12_Pos)

#define ADC_SMPR2_SMP13_Pos (9U)
#define ADC_SMPR2_SMP13_Msk (0x7UL << ADC_SMPR2_SMP13_Pos)
#define ADC_SMPR2_SMP13 ADC_SMPR2_SMP13_Msk
#define ADC_SMPR2_SMP13_0 (0x1UL << ADC_SMPR2_SMP13_Pos)
#define ADC_SMPR2_SMP13_1 (0x2UL << ADC_SMPR2_SMP13_Pos)
#define ADC_SMPR2_SMP13_2 (0x4UL << ADC_SMPR2_SMP13_Pos)

#define ADC_SMPR2_SMP14_Pos (12U)
#define ADC_SMPR2_SMP14_Msk (0x7UL << ADC_SMPR2_SMP14_Pos)
#define ADC_SMPR2_SMP14 ADC_SMPR2_SMP14_Msk
#define ADC_SMPR2_SMP14_0 (0x1UL << ADC_SMPR2_SMP14_Pos)
#define ADC_SMPR2_SMP14_1 (0x2UL << ADC_SMPR2_SMP14_Pos)
#define ADC_SMPR2_SMP14_2 (0x4UL << ADC_SMPR2_SMP14_Pos)

#define ADC_SMPR2_SMP15_Pos (15U)
#define ADC_SMPR2_SMP15_Msk (0x7UL << ADC_SMPR2_SMP15_Pos)
#define ADC_SMPR2_SMP15 ADC_SMPR2_SMP15_Msk
#define ADC_SMPR2_SMP15_0 (0x1UL << ADC_SMPR2_SMP15_Pos)
#define ADC_SMPR2_SMP15_1 (0x2UL << ADC_SMPR2_SMP15_Pos)
#define ADC_SMPR2_SMP15_2 (0x4UL << ADC_SMPR2_SMP15_Pos)

#define ADC_SMPR2_SMP16_Pos (18U)
#define ADC_SMPR2_SMP16_Msk (0x7UL << ADC_SMPR2_SMP16_Pos)
#define ADC_SMPR2_SMP16 ADC_SMPR2_SMP16_Msk
#define ADC_SMPR2_SMP16_0 (0x1UL << ADC_SMPR2_SMP16_Pos)
#define ADC_SMPR2_SMP16_1 (0x2UL << ADC_SMPR2_SMP16_Pos)
#define ADC_SMPR2_SMP16_2 (0x4UL << ADC_SMPR2_SMP16_Pos)

#define ADC_SMPR2_SMP17_Pos (21U)
#define ADC_SMPR2_SMP17_Msk (0x7UL << ADC_SMPR2_SMP17_Pos)
#define ADC_SMPR2_SMP17 ADC_SMPR2_SMP17_Msk
#define ADC_SMPR2_SMP17_0 (0x1UL << ADC_SMPR2_SMP17_Pos)
#define ADC_SMPR2_SMP17_1 (0x2UL << ADC_SMPR2_SMP17_Pos)
#define ADC_SMPR2_SMP17_2 (0x4UL << ADC_SMPR2_SMP17_Pos)

#define ADC_SMPR2_SMP18_Pos (24U)
#define ADC_SMPR2_SMP18_Msk (0x7UL << ADC_SMPR2_SMP18_Pos)
#define ADC_SMPR2_SMP18 ADC_SMPR2_SMP18_Msk
#define ADC_SMPR2_SMP18_0 (0x1UL << ADC_SMPR2_SMP18_Pos)
#define ADC_SMPR2_SMP18_1 (0x2UL << ADC_SMPR2_SMP18_Pos)
#define ADC_SMPR2_SMP18_2 (0x4UL << ADC_SMPR2_SMP18_Pos)

/********************  Bit definition for ADC_TR1 register  *******************/
#define ADC_TR1_LT1_Pos (0U)
#define ADC_TR1_LT1_Msk (0xFFFUL << ADC_TR1_LT1_Pos)
#define ADC_TR1_LT1 ADC_TR1_LT1_Msk

#define ADC_TR1_AWDFILT_Pos (12U)
#define ADC_TR1_AWDFILT_Msk (0x7UL << ADC_TR1_AWDFILT_Pos)
#define ADC_TR1_AWDFILT ADC_TR1_AWDFILT_Msk
#define ADC_TR1_AWDFILT_0 (0x1UL << ADC_TR1_AWDFILT_Pos)
#define ADC_TR1_AWDFILT_1 (0x2UL << ADC_TR1_AWDFILT_Pos)
#define ADC_TR1_AWDFILT_2 (0x4UL << ADC_TR1_AWDFILT_Pos)

#define ADC_TR1_HT1_Pos (16U)
#define ADC_TR1_HT1_Msk (0xFFFUL << ADC_TR1_HT1_Pos)
#define ADC_TR1_HT1 ADC_TR1_HT1_Msk

/********************  Bit definition for ADC_TR2 register  *******************/
#define ADC_TR2_LT2_Pos (0U)
#define ADC_TR2_LT2_Msk (0xFFUL << ADC_TR2_LT2_Pos)
#define ADC_TR2_LT2 ADC_TR2_LT2_Msk

#define ADC_TR2_HT2_Pos (16U)
#define ADC_TR2_HT2_Msk (0xFFUL << ADC_TR2_HT2_Pos)
#define ADC_TR2_HT2 ADC_TR2_HT2_Msk

/********************  Bit definition for ADC_TR3 register  *******************/
#define ADC_TR3_LT3_Pos (0U)
#define ADC_TR3_LT3_Msk (0xFFUL << ADC_TR3_LT3_Pos)
#define ADC_TR3_LT3 ADC_TR3_LT3_Msk

#define ADC_TR3_HT3_Pos (16U)
#define ADC_TR3_HT3_Msk (0xFFUL << ADC_TR3_HT3_Pos)
#define ADC_TR3_HT3 ADC_TR3_HT3_Msk

/********************  Bit definition for ADC_SQR1 register  ******************/
#define ADC_SQR1_L_Pos (0U)
#define ADC_SQR1_L_Msk (0xFUL << ADC_SQR1_L_Pos)
#define ADC_SQR1_L ADC_SQR1_L_Msk
#define ADC_SQR1_L_0 (0x1UL << ADC_SQR1_L_Pos)
#define ADC_SQR1_L_1 (0x2UL << ADC_SQR1_L_Pos)
#define ADC_SQR1_L_2 (0x4UL << ADC_SQR1_L_Pos)
#define ADC_SQR1_L_3 (0x8UL << ADC_SQR1_L_Pos)

#define ADC_SQR1_SQ1_Pos (6U)
#define ADC_SQR1_SQ1_Msk (0x1FUL << ADC_SQR1_SQ1_Pos)
#define ADC_SQR1_SQ1 ADC_SQR1_SQ1_Msk
#define ADC_SQR1_SQ1_0 (0x01UL << ADC_SQR1_SQ1_Pos)
#define ADC_SQR1_SQ1_1 (0x02UL << ADC_SQR1_SQ1_Pos)
#define ADC_SQR1_SQ1_2 (0x04UL << ADC_SQR1_SQ1_Pos)
#define ADC_SQR1_SQ1_3 (0x08UL << ADC_SQR1_SQ1_Pos)
#define ADC_SQR1_SQ1_4 (0x10UL << ADC_SQR1_SQ1_Pos)

#define ADC_SQR1_SQ2_Pos (12U)
#define ADC_SQR1_SQ2_Msk (0x1FUL << ADC_SQR1_SQ2_Pos)
#define ADC_SQR1_SQ2 ADC_SQR1_SQ2_Msk
#define ADC_SQR1_SQ2_0 (0x01UL << ADC_SQR1_SQ2_Pos)
#define ADC_SQR1_SQ2_1 (0x02UL << ADC_SQR1_SQ2_Pos)
#define ADC_SQR1_SQ2_2 (0x04UL << ADC_SQR1_SQ2_Pos)
#define ADC_SQR1_SQ2_3 (0x08UL << ADC_SQR1_SQ2_Pos)
#define ADC_SQR1_SQ2_4 (0x10UL << ADC_SQR1_SQ2_Pos)

#define ADC_SQR1_SQ3_Pos (18U)
#define ADC_SQR1_SQ3_Msk (0x1FUL << ADC_SQR1_SQ3_Pos)
#define ADC_SQR1_SQ3 ADC_SQR1_SQ3_Msk
#define ADC_SQR1_SQ3_0 (0x01UL << ADC_SQR1_SQ3_Pos)
#define ADC_SQR1_SQ3_1 (0x02UL << ADC_SQR1_SQ3_Pos)
#define ADC_SQR1_SQ3_2 (0x04UL << ADC_SQR1_SQ3_Pos)
#define ADC_SQR1_SQ3_3 (0x08UL << ADC_SQR1_SQ3_Pos)
#define ADC_SQR1_SQ3_4 (0x10UL<< ADC_SQR1_SQ3_Pos)

#define ADC_SQR1_SQ4_Pos (24U)
#define ADC_SQR1_SQ4_Msk (0x1FUL << ADC_SQR1_SQ4_Pos)
#define ADC_SQR1_SQ4 ADC_SQR1_SQ4_Msk
#define ADC_SQR1_SQ4_0 (0x01UL << ADC_SQR1_SQ4_Pos)
#define ADC_SQR1_SQ4_1 (0x02UL << ADC_SQR1_SQ4_Pos)
#define ADC_SQR1_SQ4_2 (0x04UL << ADC_SQR1_SQ4_Pos)
#define ADC_SQR1_SQ4_3 (0x08UL << ADC_SQR1_SQ4_Pos)
#define ADC_SQR1_SQ4_4 (0x10UL << ADC_SQR1_SQ4_Pos)

/********************  Bit definition for ADC_SQR2 register  ******************/
#define ADC_SQR2_SQ5_Pos (0U)
#define ADC_SQR2_SQ5_Msk (0x1FUL << ADC_SQR2_SQ5_Pos)
#define ADC_SQR2_SQ5 ADC_SQR2_SQ5_Msk
#define ADC_SQR2_SQ5_0 (0x01UL << ADC_SQR2_SQ5_Pos)
#define ADC_SQR2_SQ5_1 (0x02UL << ADC_SQR2_SQ5_Pos)
#define ADC_SQR2_SQ5_2 (0x04UL << ADC_SQR2_SQ5_Pos)
#define ADC_SQR2_SQ5_3 (0x08UL << ADC_SQR2_SQ5_Pos)
#define ADC_SQR2_SQ5_4 (0x10UL << ADC_SQR2_SQ5_Pos)

#define ADC_SQR2_SQ6_Pos (6U)
#define ADC_SQR2_SQ6_Msk (0x1FUL << ADC_SQR2_SQ6_Pos)
#define ADC_SQR2_SQ6 ADC_SQR2_SQ6_Msk
#define ADC_SQR2_SQ6_0 (0x01UL << ADC_SQR2_SQ6_Pos)
#define ADC_SQR2_SQ6_1 (0x02UL << ADC_SQR2_SQ6_Pos)
#define ADC_SQR2_SQ6_2 (0x04UL << ADC_SQR2_SQ6_Pos)
#define ADC_SQR2_SQ6_3 (0x08UL << ADC_SQR2_SQ6_Pos)
#define ADC_SQR2_SQ6_4 (0x10UL << ADC_SQR2_SQ6_Pos)

#define ADC_SQR2_SQ7_Pos (12U)
#define ADC_SQR2_SQ7_Msk (0x1FUL << ADC_SQR2_SQ7_Pos)
#define ADC_SQR2_SQ7 ADC_SQR2_SQ7_Msk
#define ADC_SQR2_SQ7_0 (0x01UL << ADC_SQR2_SQ7_Pos)
#define ADC_SQR2_SQ7_1 (0x02UL << ADC_SQR2_SQ7_Pos)
#define ADC_SQR2_SQ7_2 (0x04UL << ADC_SQR2_SQ7_Pos)
#define ADC_SQR2_SQ7_3 (0x08UL << ADC_SQR2_SQ7_Pos)
#define ADC_SQR2_SQ7_4 (0x10UL << ADC_SQR2_SQ7_Pos)

#define ADC_SQR2_SQ8_Pos (18U)
#define ADC_SQR2_SQ8_Msk (0x1FUL << ADC_SQR2_SQ8_Pos)
#define ADC_SQR2_SQ8 ADC_SQR2_SQ8_Msk
#define ADC_SQR2_SQ8_0 (0x01UL << ADC_SQR2_SQ8_Pos)
#define ADC_SQR2_SQ8_1 (0x02UL << ADC_SQR2_SQ8_Pos)
#define ADC_SQR2_SQ8_2 (0x04UL << ADC_SQR2_SQ8_Pos)
#define ADC_SQR2_SQ8_3 (0x08UL << ADC_SQR2_SQ8_Pos)
#define ADC_SQR2_SQ8_4 (0x10UL << ADC_SQR2_SQ8_Pos)

#define ADC_SQR2_SQ9_Pos (24U)
#define ADC_SQR2_SQ9_Msk (0x1FUL << ADC_SQR2_SQ9_Pos)
#define ADC_SQR2_SQ9 ADC_SQR2_SQ9_Msk
#define ADC_SQR2_SQ9_0 (0x01UL << ADC_SQR2_SQ9_Pos)
#define ADC_SQR2_SQ9_1 (0x02UL << ADC_SQR2_SQ9_Pos)
#define ADC_SQR2_SQ9_2 (0x04UL << ADC_SQR2_SQ9_Pos)
#define ADC_SQR2_SQ9_3 (0x08UL << ADC_SQR2_SQ9_Pos)
#define ADC_SQR2_SQ9_4 (0x10UL << ADC_SQR2_SQ9_Pos)

/********************  Bit definition for ADC_SQR3 register  ******************/
#define ADC_SQR3_SQ10_Pos (0U)
#define ADC_SQR3_SQ10_Msk (0x1FUL << ADC_SQR3_SQ10_Pos)
#define ADC_SQR3_SQ10 ADC_SQR3_SQ10_Msk
#define ADC_SQR3_SQ10_0 (0x01UL << ADC_SQR3_SQ10_Pos)
#define ADC_SQR3_SQ10_1 (0x02UL << ADC_SQR3_SQ10_Pos)
#define ADC_SQR3_SQ10_2 (0x04UL << ADC_SQR3_SQ10_Pos)
#define ADC_SQR3_SQ10_3 (0x08UL << ADC_SQR3_SQ10_Pos)
#define ADC_SQR3_SQ10_4 (0x10UL << ADC_SQR3_SQ10_Pos)

#define ADC_SQR3_SQ11_Pos (6U)
#define ADC_SQR3_SQ11_Msk (0x1FUL << ADC_SQR3_SQ11_Pos)
#define ADC_SQR3_SQ11 ADC_SQR3_SQ11_Msk
#define ADC_SQR3_SQ11_0 (0x01UL << ADC_SQR3_SQ11_Pos)
#define ADC_SQR3_SQ11_1 (0x02UL << ADC_SQR3_SQ11_Pos)
#define ADC_SQR3_SQ11_2 (0x04UL << ADC_SQR3_SQ11_Pos)
#define ADC_SQR3_SQ11_3 (0x08UL << ADC_SQR3_SQ11_Pos)
#define ADC_SQR3_SQ11_4 (0x10UL << ADC_SQR3_SQ11_Pos)

#define ADC_SQR3_SQ12_Pos (12U)
#define ADC_SQR3_SQ12_Msk (0x1FUL << ADC_SQR3_SQ12_Pos)
#define ADC_SQR3_SQ12 ADC_SQR3_SQ12_Msk
#define ADC_SQR3_SQ12_0 (0x01UL << ADC_SQR3_SQ12_Pos)
#define ADC_SQR3_SQ12_1 (0x02UL << ADC_SQR3_SQ12_Pos)
#define ADC_SQR3_SQ12_2 (0x04UL << ADC_SQR3_SQ12_Pos)
#define ADC_SQR3_SQ12_3 (0x08UL << ADC_SQR3_SQ12_Pos)
#define ADC_SQR3_SQ12_4 (0x10UL << ADC_SQR3_SQ12_Pos)

#define ADC_SQR3_SQ13_Pos (18U)
#define ADC_SQR3_SQ13_Msk (0x1FUL << ADC_SQR3_SQ13_Pos)
#define ADC_SQR3_SQ13 ADC_SQR3_SQ13_Msk
#define ADC_SQR3_SQ13_0 (0x01UL << ADC_SQR3_SQ13_Pos)
#define ADC_SQR3_SQ13_1 (0x02UL << ADC_SQR3_SQ13_Pos)
#define ADC_SQR3_SQ13_2 (0x04UL << ADC_SQR3_SQ13_Pos)
#define ADC_SQR3_SQ13_3 (0x08UL << ADC_SQR3_SQ13_Pos)
#define ADC_SQR3_SQ13_4 (0x10UL << ADC_SQR3_SQ13_Pos)

#define ADC_SQR3_SQ14_Pos (24U)
#define ADC_SQR3_SQ14_Msk (0x1FUL << ADC_SQR3_SQ14_Pos)
#define ADC_SQR3_SQ14 ADC_SQR3_SQ14_Msk
#define ADC_SQR3_SQ14_0 (0x01UL << ADC_SQR3_SQ14_Pos)
#define ADC_SQR3_SQ14_1 (0x02UL << ADC_SQR3_SQ14_Pos)
#define ADC_SQR3_SQ14_2 (0x04UL << ADC_SQR3_SQ14_Pos)
#define ADC_SQR3_SQ14_3 (0x08UL << ADC_SQR3_SQ14_Pos)
#define ADC_SQR3_SQ14_4 (0x10UL << ADC_SQR3_SQ14_Pos)

/********************  Bit definition for ADC_SQR4 register  ******************/
#define ADC_SQR4_SQ15_Pos (0U)
#define ADC_SQR4_SQ15_Msk (0x1FUL << ADC_SQR4_SQ15_Pos)
#define ADC_SQR4_SQ15 ADC_SQR4_SQ15_Msk
#define ADC_SQR4_SQ15_0 (0x01UL << ADC_SQR4_SQ15_Pos)
#define ADC_SQR4_SQ15_1 (0x02UL << ADC_SQR4_SQ15_Pos)
#define ADC_SQR4_SQ15_2 (0x04UL << ADC_SQR4_SQ15_Pos)
#define ADC_SQR4_SQ15_3 (0x08UL << ADC_SQR4_SQ15_Pos)
#define ADC_SQR4_SQ15_4 (0x10UL << ADC_SQR4_SQ15_Pos)

#define ADC_SQR4_SQ16_Pos (6U)
#define ADC_SQR4_SQ16_Msk (0x1FUL << ADC_SQR4_SQ16_Pos)
#define ADC_SQR4_SQ16 ADC_SQR4_SQ16_Msk
#define ADC_SQR4_SQ16_0 (0x01UL << ADC_SQR4_SQ16_Pos)
#define ADC_SQR4_SQ16_1 (0x02UL << ADC_SQR4_SQ16_Pos)
#define ADC_SQR4_SQ16_2 (0x04UL << ADC_SQR4_SQ16_Pos)
#define ADC_SQR4_SQ16_3 (0x08UL << ADC_SQR4_SQ16_Pos)
#define ADC_SQR4_SQ16_4 (0x10UL << ADC_SQR4_SQ16_Pos)

/********************  Bit definition for ADC_DR register  ********************/
#define ADC_DR_RDATA_Pos (0U)
#define ADC_DR_RDATA_Msk (0xFFFFUL << ADC_DR_RDATA_Pos)
#define ADC_DR_RDATA ADC_DR_RDATA_Msk

/********************  Bit definition for ADC_JSQR register  ******************/
#define ADC_JSQR_JL_Pos (0U)
#define ADC_JSQR_JL_Msk (0x3UL << ADC_JSQR_JL_Pos)
#define ADC_JSQR_JL ADC_JSQR_JL_Msk
#define ADC_JSQR_JL_0 (0x1UL << ADC_JSQR_JL_Pos)
#define ADC_JSQR_JL_1 (0x2UL << ADC_JSQR_JL_Pos)

#define ADC_JSQR_JEXTSEL_Pos (2U)
#define ADC_JSQR_JEXTSEL_Msk (0x1FUL << ADC_JSQR_JEXTSEL_Pos)
#define ADC_JSQR_JEXTSEL ADC_JSQR_JEXTSEL_Msk
#define ADC_JSQR_JEXTSEL_0 (0x1UL << ADC_JSQR_JEXTSEL_Pos)
#define ADC_JSQR_JEXTSEL_1 (0x2UL << ADC_JSQR_JEXTSEL_Pos)
#define ADC_JSQR_JEXTSEL_2 (0x4UL << ADC_JSQR_JEXTSEL_Pos)
#define ADC_JSQR_JEXTSEL_3 (0x8UL << ADC_JSQR_JEXTSEL_Pos)
#define ADC_JSQR_JEXTSEL_4 (0x10UL << ADC_JSQR_JEXTSEL_Pos)

#define ADC_JSQR_JEXTEN_Pos (7U)
#define ADC_JSQR_JEXTEN_Msk (0x3UL << ADC_JSQR_JEXTEN_Pos)
#define ADC_JSQR_JEXTEN ADC_JSQR_JEXTEN_Msk
#define ADC_JSQR_JEXTEN_0 (0x1UL << ADC_JSQR_JEXTEN_Pos)
#define ADC_JSQR_JEXTEN_1 (0x2UL << ADC_JSQR_JEXTEN_Pos)

#define ADC_JSQR_JSQ1_Pos (9U)
#define ADC_JSQR_JSQ1_Msk (0x1FUL << ADC_JSQR_JSQ1_Pos)
#define ADC_JSQR_JSQ1 ADC_JSQR_JSQ1_Msk
#define ADC_JSQR_JSQ1_0 (0x01UL << ADC_JSQR_JSQ1_Pos)
#define ADC_JSQR_JSQ1_1 (0x02UL << ADC_JSQR_JSQ1_Pos)
#define ADC_JSQR_JSQ1_2 (0x04UL << ADC_JSQR_JSQ1_Pos)
#define ADC_JSQR_JSQ1_3 (0x08UL << ADC_JSQR_JSQ1_Pos)
#define ADC_JSQR_JSQ1_4 (0x10UL << ADC_JSQR_JSQ1_Pos)

#define ADC_JSQR_JSQ2_Pos (15U)
#define ADC_JSQR_JSQ2_Msk (0x1FUL << ADC_JSQR_JSQ2_Pos)
#define ADC_JSQR_JSQ2 ADC_JSQR_JSQ2_Msk
#define ADC_JSQR_JSQ2_0 (0x01UL << ADC_JSQR_JSQ2_Pos)
#define ADC_JSQR_JSQ2_1 (0x02UL << ADC_JSQR_JSQ2_Pos)
#define ADC_JSQR_JSQ2_2 (0x04UL << ADC_JSQR_JSQ2_Pos)
#define ADC_JSQR_JSQ2_3 (0x08UL << ADC_JSQR_JSQ2_Pos)
#define ADC_JSQR_JSQ2_4 (0x10UL << ADC_JSQR_JSQ2_Pos)

#define ADC_JSQR_JSQ3_Pos (21U)
#define ADC_JSQR_JSQ3_Msk (0x1FUL << ADC_JSQR_JSQ3_Pos)
#define ADC_JSQR_JSQ3 ADC_JSQR_JSQ3_Msk
#define ADC_JSQR_JSQ3_0 (0x01UL << ADC_JSQR_JSQ3_Pos)
#define ADC_JSQR_JSQ3_1 (0x02UL << ADC_JSQR_JSQ3_Pos)
#define ADC_JSQR_JSQ3_2 (0x04UL << ADC_JSQR_JSQ3_Pos)
#define ADC_JSQR_JSQ3_3 (0x08UL << ADC_JSQR_JSQ3_Pos)
#define ADC_JSQR_JSQ3_4 (0x10UL << ADC_JSQR_JSQ3_Pos)

#define ADC_JSQR_JSQ4_Pos (27U)
#define ADC_JSQR_JSQ4_Msk (0x1FUL << ADC_JSQR_JSQ4_Pos)
#define ADC_JSQR_JSQ4 ADC_JSQR_JSQ4_Msk
#define ADC_JSQR_JSQ4_0 (0x01UL << ADC_JSQR_JSQ4_Pos)
#define ADC_JSQR_JSQ4_1 (0x02UL << ADC_JSQR_JSQ4_Pos)
#define ADC_JSQR_JSQ4_2 (0x04UL << ADC_JSQR_JSQ4_Pos)
#define ADC_JSQR_JSQ4_3 (0x08UL << ADC_JSQR_JSQ4_Pos)
#define ADC_JSQR_JSQ4_4 (0x10UL << ADC_JSQR_JSQ4_Pos)

/********************  Bit definition for ADC_OFR1 register  ******************/
#define ADC_OFR1_OFFSET1_Pos (0U)
#define ADC_OFR1_OFFSET1_Msk (0xFFFUL << ADC_OFR1_OFFSET1_Pos)
#define ADC_OFR1_OFFSET1 ADC_OFR1_OFFSET1_Msk

#define ADC_OFR1_OFFSETPOS_Pos (24U)
#define ADC_OFR1_OFFSETPOS_Msk (0x1UL << ADC_OFR1_OFFSETPOS_Pos)
#define ADC_OFR1_OFFSETPOS ADC_OFR1_OFFSETPOS_Msk
#define ADC_OFR1_SATEN_Pos (25U)
#define ADC_OFR1_SATEN_Msk (0x1UL << ADC_OFR1_SATEN_Pos)
#define ADC_OFR1_SATEN ADC_OFR1_SATEN_Msk

#define ADC_OFR1_OFFSET1_CH_Pos (26U)
#define ADC_OFR1_OFFSET1_CH_Msk (0x1FUL << ADC_OFR1_OFFSET1_CH_Pos)
#define ADC_OFR1_OFFSET1_CH ADC_OFR1_OFFSET1_CH_Msk
#define ADC_OFR1_OFFSET1_CH_0 (0x01UL << ADC_OFR1_OFFSET1_CH_Pos)
#define ADC_OFR1_OFFSET1_CH_1 (0x02UL << ADC_OFR1_OFFSET1_CH_Pos)
#define ADC_OFR1_OFFSET1_CH_2 (0x04UL << ADC_OFR1_OFFSET1_CH_Pos)
#define ADC_OFR1_OFFSET1_CH_3 (0x08UL << ADC_OFR1_OFFSET1_CH_Pos)
#define ADC_OFR1_OFFSET1_CH_4 (0x10UL << ADC_OFR1_OFFSET1_CH_Pos)

#define ADC_OFR1_OFFSET1_EN_Pos (31U)
#define ADC_OFR1_OFFSET1_EN_Msk (0x1UL << ADC_OFR1_OFFSET1_EN_Pos)
#define ADC_OFR1_OFFSET1_EN ADC_OFR1_OFFSET1_EN_Msk

/********************  Bit definition for ADC_OFR2 register  ******************/
#define ADC_OFR2_OFFSET2_Pos (0U)
#define ADC_OFR2_OFFSET2_Msk (0xFFFUL << ADC_OFR2_OFFSET2_Pos)
#define ADC_OFR2_OFFSET2 ADC_OFR2_OFFSET2_Msk

#define ADC_OFR2_OFFSETPOS_Pos (24U)
#define ADC_OFR2_OFFSETPOS_Msk (0x1UL << ADC_OFR2_OFFSETPOS_Pos)
#define ADC_OFR2_OFFSETPOS ADC_OFR2_OFFSETPOS_Msk
#define ADC_OFR2_SATEN_Pos (25U)
#define ADC_OFR2_SATEN_Msk (0x1UL << ADC_OFR2_SATEN_Pos)
#define ADC_OFR2_SATEN ADC_OFR2_SATEN_Msk

#define ADC_OFR2_OFFSET2_CH_Pos (26U)
#define ADC_OFR2_OFFSET2_CH_Msk (0x1FUL << ADC_OFR2_OFFSET2_CH_Pos)
#define ADC_OFR2_OFFSET2_CH ADC_OFR2_OFFSET2_CH_Msk
#define ADC_OFR2_OFFSET2_CH_0 (0x01UL << ADC_OFR2_OFFSET2_CH_Pos)
#define ADC_OFR2_OFFSET2_CH_1 (0x02UL << ADC_OFR2_OFFSET2_CH_Pos)
#define ADC_OFR2_OFFSET2_CH_2 (0x04UL << ADC_OFR2_OFFSET2_CH_Pos)
#define ADC_OFR2_OFFSET2_CH_3 (0x08UL << ADC_OFR2_OFFSET2_CH_Pos)
#define ADC_OFR2_OFFSET2_CH_4 (0x10UL << ADC_OFR2_OFFSET2_CH_Pos)

#define ADC_OFR2_OFFSET2_EN_Pos (31U)
#define ADC_OFR2_OFFSET2_EN_Msk (0x1UL << ADC_OFR2_OFFSET2_EN_Pos)
#define ADC_OFR2_OFFSET2_EN ADC_OFR2_OFFSET2_EN_Msk

/********************  Bit definition for ADC_OFR3 register  ******************/
#define ADC_OFR3_OFFSET3_Pos (0U)
#define ADC_OFR3_OFFSET3_Msk (0xFFFUL << ADC_OFR3_OFFSET3_Pos)
#define ADC_OFR3_OFFSET3 ADC_OFR3_OFFSET3_Msk

#define ADC_OFR3_OFFSETPOS_Pos (24U)
#define ADC_OFR3_OFFSETPOS_Msk (0x1UL << ADC_OFR3_OFFSETPOS_Pos)
#define ADC_OFR3_OFFSETPOS ADC_OFR3_OFFSETPOS_Msk
#define ADC_OFR3_SATEN_Pos (25U)
#define ADC_OFR3_SATEN_Msk (0x1UL << ADC_OFR3_SATEN_Pos)
#define ADC_OFR3_SATEN ADC_OFR3_SATEN_Msk

#define ADC_OFR3_OFFSET3_CH_Pos (26U)
#define ADC_OFR3_OFFSET3_CH_Msk (0x1FUL << ADC_OFR3_OFFSET3_CH_Pos)
#define ADC_OFR3_OFFSET3_CH ADC_OFR3_OFFSET3_CH_Msk
#define ADC_OFR3_OFFSET3_CH_0 (0x01UL << ADC_OFR3_OFFSET3_CH_Pos)
#define ADC_OFR3_OFFSET3_CH_1 (0x02UL << ADC_OFR3_OFFSET3_CH_Pos)
#define ADC_OFR3_OFFSET3_CH_2 (0x04UL << ADC_OFR3_OFFSET3_CH_Pos)
#define ADC_OFR3_OFFSET3_CH_3 (0x08UL << ADC_OFR3_OFFSET3_CH_Pos)
#define ADC_OFR3_OFFSET3_CH_4 (0x10UL << ADC_OFR3_OFFSET3_CH_Pos)

#define ADC_OFR3_OFFSET3_EN_Pos (31U)
#define ADC_OFR3_OFFSET3_EN_Msk (0x1UL << ADC_OFR3_OFFSET3_EN_Pos)
#define ADC_OFR3_OFFSET3_EN ADC_OFR3_OFFSET3_EN_Msk

/********************  Bit definition for ADC_OFR4 register  ******************/
#define ADC_OFR4_OFFSET4_Pos (0U)
#define ADC_OFR4_OFFSET4_Msk (0xFFFUL << ADC_OFR4_OFFSET4_Pos)
#define ADC_OFR4_OFFSET4 ADC_OFR4_OFFSET4_Msk

#define ADC_OFR4_OFFSETPOS_Pos (24U)
#define ADC_OFR4_OFFSETPOS_Msk (0x1UL << ADC_OFR4_OFFSETPOS_Pos)
#define ADC_OFR4_OFFSETPOS ADC_OFR4_OFFSETPOS_Msk
#define ADC_OFR4_SATEN_Pos (25U)
#define ADC_OFR4_SATEN_Msk (0x1UL << ADC_OFR4_SATEN_Pos)
#define ADC_OFR4_SATEN ADC_OFR4_SATEN_Msk

#define ADC_OFR4_OFFSET4_CH_Pos (26U)
#define ADC_OFR4_OFFSET4_CH_Msk (0x1FUL << ADC_OFR4_OFFSET4_CH_Pos)
#define ADC_OFR4_OFFSET4_CH ADC_OFR4_OFFSET4_CH_Msk
#define ADC_OFR4_OFFSET4_CH_0 (0x01UL << ADC_OFR4_OFFSET4_CH_Pos)
#define ADC_OFR4_OFFSET4_CH_1 (0x02UL << ADC_OFR4_OFFSET4_CH_Pos)
#define ADC_OFR4_OFFSET4_CH_2 (0x04UL << ADC_OFR4_OFFSET4_CH_Pos)
#define ADC_OFR4_OFFSET4_CH_3 (0x08UL << ADC_OFR4_OFFSET4_CH_Pos)
#define ADC_OFR4_OFFSET4_CH_4 (0x10UL << ADC_OFR4_OFFSET4_CH_Pos)

#define ADC_OFR4_OFFSET4_EN_Pos (31U)
#define ADC_OFR4_OFFSET4_EN_Msk (0x1UL << ADC_OFR4_OFFSET4_EN_Pos)
#define ADC_OFR4_OFFSET4_EN ADC_OFR4_OFFSET4_EN_Msk

/********************  Bit definition for ADC_JDR1 register  ******************/
#define ADC_JDR1_JDATA_Pos (0U)
#define ADC_JDR1_JDATA_Msk (0xFFFFUL << ADC_JDR1_JDATA_Pos)
#define ADC_JDR1_JDATA ADC_JDR1_JDATA_Msk

/********************  Bit definition for ADC_JDR2 register  ******************/
#define ADC_JDR2_JDATA_Pos (0U)
#define ADC_JDR2_JDATA_Msk (0xFFFFUL << ADC_JDR2_JDATA_Pos)
#define ADC_JDR2_JDATA ADC_JDR2_JDATA_Msk

/********************  Bit definition for ADC_JDR3 register  ******************/
#define ADC_JDR3_JDATA_Pos (0U)
#define ADC_JDR3_JDATA_Msk (0xFFFFUL << ADC_JDR3_JDATA_Pos)
#define ADC_JDR3_JDATA ADC_JDR3_JDATA_Msk

/********************  Bit definition for ADC_JDR4 register  ******************/
#define ADC_JDR4_JDATA_Pos (0U)
#define ADC_JDR4_JDATA_Msk (0xFFFFUL << ADC_JDR4_JDATA_Pos)
#define ADC_JDR4_JDATA ADC_JDR4_JDATA_Msk

/********************  Bit definition for ADC_AWD2CR register  ****************/
#define ADC_AWD2CR_AWD2CH_Pos (0U)
#define ADC_AWD2CR_AWD2CH_Msk (0x7FFFFUL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH ADC_AWD2CR_AWD2CH_Msk
#define ADC_AWD2CR_AWD2CH_0 (0x00001UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_1 (0x00002UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_2 (0x00004UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_3 (0x00008UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_4 (0x00010UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_5 (0x00020UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_6 (0x00040UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_7 (0x00080UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_8 (0x00100UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_9 (0x00200UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_10 (0x00400UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_11 (0x00800UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_12 (0x01000UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_13 (0x02000UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_14 (0x04000UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_15 (0x08000UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_16 (0x10000UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_17 (0x20000UL << ADC_AWD2CR_AWD2CH_Pos)
#define ADC_AWD2CR_AWD2CH_18 (0x40000UL << ADC_AWD2CR_AWD2CH_Pos)

/********************  Bit definition for ADC_AWD3CR register  ****************/
#define ADC_AWD3CR_AWD3CH_Pos (0U)
#define ADC_AWD3CR_AWD3CH_Msk (0x7FFFFUL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH ADC_AWD3CR_AWD3CH_Msk
#define ADC_AWD3CR_AWD3CH_0 (0x00001UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_1 (0x00002UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_2 (0x00004UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_3 (0x00008UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_4 (0x00010UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_5 (0x00020UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_6 (0x00040UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_7 (0x00080UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_8 (0x00100UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_9 (0x00200UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_10 (0x00400UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_11 (0x00800UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_12 (0x01000UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_13 (0x02000UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_14 (0x04000UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_15 (0x08000UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_16 (0x10000UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_17 (0x20000UL << ADC_AWD3CR_AWD3CH_Pos)
#define ADC_AWD3CR_AWD3CH_18 (0x40000UL << ADC_AWD3CR_AWD3CH_Pos)

/********************  Bit definition for ADC_DIFSEL register  ****************/
#define ADC_DIFSEL_DIFSEL_Pos (0U)
#define ADC_DIFSEL_DIFSEL_Msk (0x7FFFFUL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL ADC_DIFSEL_DIFSEL_Msk
#define ADC_DIFSEL_DIFSEL_0 (0x00001UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_1 (0x00002UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_2 (0x00004UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_3 (0x00008UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_4 (0x00010UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_5 (0x00020UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_6 (0x00040UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_7 (0x00080UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_8 (0x00100UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_9 (0x00200UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_10 (0x00400UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_11 (0x00800UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_12 (0x01000UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_13 (0x02000UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_14 (0x04000UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_15 (0x08000UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_16 (0x10000UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_17 (0x20000UL << ADC_DIFSEL_DIFSEL_Pos)
#define ADC_DIFSEL_DIFSEL_18 (0x40000UL << ADC_DIFSEL_DIFSEL_Pos)

/********************  Bit definition for ADC_CALFACT register  ***************/
#define ADC_CALFACT_CALFACT_S_Pos (0U)
#define ADC_CALFACT_CALFACT_S_Msk (0x7FUL << ADC_CALFACT_CALFACT_S_Pos)
#define ADC_CALFACT_CALFACT_S ADC_CALFACT_CALFACT_S_Msk
#define ADC_CALFACT_CALFACT_S_0 (0x01UL << ADC_CALFACT_CALFACT_S_Pos)
#define ADC_CALFACT_CALFACT_S_1 (0x02UL << ADC_CALFACT_CALFACT_S_Pos)
#define ADC_CALFACT_CALFACT_S_2 (0x04UL << ADC_CALFACT_CALFACT_S_Pos)
#define ADC_CALFACT_CALFACT_S_3 (0x08UL << ADC_CALFACT_CALFACT_S_Pos)
#define ADC_CALFACT_CALFACT_S_4 (0x10UL << ADC_CALFACT_CALFACT_S_Pos)
#define ADC_CALFACT_CALFACT_S_5 (0x20UL << ADC_CALFACT_CALFACT_S_Pos)
#define ADC_CALFACT_CALFACT_S_6 (0x40UL << ADC_CALFACT_CALFACT_S_Pos)

#define ADC_CALFACT_CALFACT_D_Pos (16U)
#define ADC_CALFACT_CALFACT_D_Msk (0x7FUL << ADC_CALFACT_CALFACT_D_Pos)
#define ADC_CALFACT_CALFACT_D ADC_CALFACT_CALFACT_D_Msk
#define ADC_CALFACT_CALFACT_D_0 (0x01UL << ADC_CALFACT_CALFACT_D_Pos)
#define ADC_CALFACT_CALFACT_D_1 (0x02UL << ADC_CALFACT_CALFACT_D_Pos)
#define ADC_CALFACT_CALFACT_D_2 (0x04UL << ADC_CALFACT_CALFACT_D_Pos)
#define ADC_CALFACT_CALFACT_D_3 (0x08UL << ADC_CALFACT_CALFACT_D_Pos)
#define ADC_CALFACT_CALFACT_D_4 (0x10UL << ADC_CALFACT_CALFACT_D_Pos)
#define ADC_CALFACT_CALFACT_D_5 (0x20UL << ADC_CALFACT_CALFACT_D_Pos)
#define ADC_CALFACT_CALFACT_D_6 (0x40UL << ADC_CALFACT_CALFACT_D_Pos)

/********************  Bit definition for ADC_GCOMP register  *****************/
#define ADC_GCOMP_GCOMPCOEFF_Pos (0U)
#define ADC_GCOMP_GCOMPCOEFF_Msk (0x3FFFUL << ADC_GCOMP_GCOMPCOEFF_Pos)
#define ADC_GCOMP_GCOMPCOEFF ADC_GCOMP_GCOMPCOEFF_Msk

/*************************  ADC Common registers  *****************************/
/********************  Bit definition for ADC_CSR register  *******************/
#define ADC_CSR_ADRDY_MST_Pos (0U)
#define ADC_CSR_ADRDY_MST_Msk (0x1UL << ADC_CSR_ADRDY_MST_Pos)
#define ADC_CSR_ADRDY_MST ADC_CSR_ADRDY_MST_Msk
#define ADC_CSR_EOSMP_MST_Pos (1U)
#define ADC_CSR_EOSMP_MST_Msk (0x1UL << ADC_CSR_EOSMP_MST_Pos)
#define ADC_CSR_EOSMP_MST ADC_CSR_EOSMP_MST_Msk
#define ADC_CSR_EOC_MST_Pos (2U)
#define ADC_CSR_EOC_MST_Msk (0x1UL << ADC_CSR_EOC_MST_Pos)
#define ADC_CSR_EOC_MST ADC_CSR_EOC_MST_Msk
#define ADC_CSR_EOS_MST_Pos (3U)
#define ADC_CSR_EOS_MST_Msk (0x1UL << ADC_CSR_EOS_MST_Pos)
#define ADC_CSR_EOS_MST ADC_CSR_EOS_MST_Msk
#define ADC_CSR_OVR_MST_Pos (4U)
#define ADC_CSR_OVR_MST_Msk (0x1UL << ADC_CSR_OVR_MST_Pos)
#define ADC_CSR_OVR_MST ADC_CSR_OVR_MST_Msk
#define ADC_CSR_JEOC_MST_Pos (5U)
#define ADC_CSR_JEOC_MST_Msk (0x1UL << ADC_CSR_JEOC_MST_Pos)
#define ADC_CSR_JEOC_MST ADC_CSR_JEOC_MST_Msk
#define ADC_CSR_JEOS_MST_Pos (6U)
#define ADC_CSR_JEOS_MST_Msk (0x1UL << ADC_CSR_JEOS_MST_Pos)
#define ADC_CSR_JEOS_MST ADC_CSR_JEOS_MST_Msk
#define ADC_CSR_AWD1_MST_Pos (7U)
#define ADC_CSR_AWD1_MST_Msk (0x1UL << ADC_CSR_AWD1_MST_Pos)
#define ADC_CSR_AWD1_MST ADC_CSR_AWD1_MST_Msk
#define ADC_CSR_AWD2_MST_Pos (8U)
#define ADC_CSR_AWD2_MST_Msk (0x1UL << ADC_CSR_AWD2_MST_Pos)
#define ADC_CSR_AWD2_MST ADC_CSR_AWD2_MST_Msk
#define ADC_CSR_AWD3_MST_Pos (9U)
#define ADC_CSR_AWD3_MST_Msk (0x1UL << ADC_CSR_AWD3_MST_Pos)
#define ADC_CSR_AWD3_MST ADC_CSR_AWD3_MST_Msk
#define ADC_CSR_JQOVF_MST_Pos (10U)
#define ADC_CSR_JQOVF_MST_Msk (0x1UL << ADC_CSR_JQOVF_MST_Pos)
#define ADC_CSR_JQOVF_MST ADC_CSR_JQOVF_MST_Msk

#define ADC_CSR_ADRDY_SLV_Pos (16U)
#define ADC_CSR_ADRDY_SLV_Msk (0x1UL << ADC_CSR_ADRDY_SLV_Pos)
#define ADC_CSR_ADRDY_SLV ADC_CSR_ADRDY_SLV_Msk
#define ADC_CSR_EOSMP_SLV_Pos (17U)
#define ADC_CSR_EOSMP_SLV_Msk (0x1UL << ADC_CSR_EOSMP_SLV_Pos)
#define ADC_CSR_EOSMP_SLV ADC_CSR_EOSMP_SLV_Msk
#define ADC_CSR_EOC_SLV_Pos (18U)
#define ADC_CSR_EOC_SLV_Msk (0x1UL << ADC_CSR_EOC_SLV_Pos)
#define ADC_CSR_EOC_SLV ADC_CSR_EOC_SLV_Msk
#define ADC_CSR_EOS_SLV_Pos (19U)
#define ADC_CSR_EOS_SLV_Msk (0x1UL << ADC_CSR_EOS_SLV_Pos)
#define ADC_CSR_EOS_SLV ADC_CSR_EOS_SLV_Msk
#define ADC_CSR_OVR_SLV_Pos (20U)
#define ADC_CSR_OVR_SLV_Msk (0x1UL << ADC_CSR_OVR_SLV_Pos)
#define ADC_CSR_OVR_SLV ADC_CSR_OVR_SLV_Msk
#define ADC_CSR_JEOC_SLV_Pos (21U)
#define ADC_CSR_JEOC_SLV_Msk (0x1UL << ADC_CSR_JEOC_SLV_Pos)
#define ADC_CSR_JEOC_SLV ADC_CSR_JEOC_SLV_Msk
#define ADC_CSR_JEOS_SLV_Pos (22U)
#define ADC_CSR_JEOS_SLV_Msk (0x1UL << ADC_CSR_JEOS_SLV_Pos)
#define ADC_CSR_JEOS_SLV ADC_CSR_JEOS_SLV_Msk
#define ADC_CSR_AWD1_SLV_Pos (23U)
#define ADC_CSR_AWD1_SLV_Msk (0x1UL << ADC_CSR_AWD1_SLV_Pos)
#define ADC_CSR_AWD1_SLV ADC_CSR_AWD1_SLV_Msk
#define ADC_CSR_AWD2_SLV_Pos (24U)
#define ADC_CSR_AWD2_SLV_Msk (0x1UL << ADC_CSR_AWD2_SLV_Pos)
#define ADC_CSR_AWD2_SLV ADC_CSR_AWD2_SLV_Msk
#define ADC_CSR_AWD3_SLV_Pos (25U)
#define ADC_CSR_AWD3_SLV_Msk (0x1UL << ADC_CSR_AWD3_SLV_Pos)
#define ADC_CSR_AWD3_SLV ADC_CSR_AWD3_SLV_Msk
#define ADC_CSR_JQOVF_SLV_Pos (26U)
#define ADC_CSR_JQOVF_SLV_Msk (0x1UL << ADC_CSR_JQOVF_SLV_Pos)
#define ADC_CSR_JQOVF_SLV ADC_CSR_JQOVF_SLV_Msk

/********************  Bit definition for ADC_CCR register  *******************/
#define ADC_CCR_DUAL_Pos (0U)
#define ADC_CCR_DUAL_Msk (0x1FUL << ADC_CCR_DUAL_Pos)
#define ADC_CCR_DUAL ADC_CCR_DUAL_Msk
#define ADC_CCR_DUAL_0 (0x01UL << ADC_CCR_DUAL_Pos)
#define ADC_CCR_DUAL_1 (0x02UL << ADC_CCR_DUAL_Pos)
#define ADC_CCR_DUAL_2 (0x04UL << ADC_CCR_DUAL_Pos)
#define ADC_CCR_DUAL_3 (0x08UL << ADC_CCR_DUAL_Pos)
#define ADC_CCR_DUAL_4 (0x10UL << ADC_CCR_DUAL_Pos)

#define ADC_CCR_DELAY_Pos (8U)
#define ADC_CCR_DELAY_Msk (0xFUL << ADC_CCR_DELAY_Pos)
#define ADC_CCR_DELAY ADC_CCR_DELAY_Msk
#define ADC_CCR_DELAY_0 (0x1UL << ADC_CCR_DELAY_Pos)
#define ADC_CCR_DELAY_1 (0x2UL << ADC_CCR_DELAY_Pos)
#define ADC_CCR_DELAY_2 (0x4UL << ADC_CCR_DELAY_Pos)
#define ADC_CCR_DELAY_3 (0x8UL << ADC_CCR_DELAY_Pos)

#define ADC_CCR_DMACFG_Pos (13U)
#define ADC_CCR_DMACFG_Msk (0x1UL << ADC_CCR_DMACFG_Pos)
#define ADC_CCR_DMACFG ADC_CCR_DMACFG_Msk

#define ADC_CCR_MDMA_Pos (14U)
#define ADC_CCR_MDMA_Msk (0x3UL << ADC_CCR_MDMA_Pos)
#define ADC_CCR_MDMA ADC_CCR_MDMA_Msk
#define ADC_CCR_MDMA_0 (0x1UL << ADC_CCR_MDMA_Pos)
#define ADC_CCR_MDMA_1 (0x2UL << ADC_CCR_MDMA_Pos)

#define ADC_CCR_CKMODE_Pos (16U)
#define ADC_CCR_CKMODE_Msk (0x3UL << ADC_CCR_CKMODE_Pos)
#define ADC_CCR_CKMODE ADC_CCR_CKMODE_Msk
#define ADC_CCR_CKMODE_0 (0x1UL << ADC_CCR_CKMODE_Pos)
#define ADC_CCR_CKMODE_1 (0x2UL << ADC_CCR_CKMODE_Pos)

#define ADC_CCR_PRESC_Pos (18U)
#define ADC_CCR_PRESC_Msk (0xFUL << ADC_CCR_PRESC_Pos)
#define ADC_CCR_PRESC ADC_CCR_PRESC_Msk
#define ADC_CCR_PRESC_0 (0x1UL << ADC_CCR_PRESC_Pos)
#define ADC_CCR_PRESC_1 (0x2UL << ADC_CCR_PRESC_Pos)
#define ADC_CCR_PRESC_2 (0x4UL << ADC_CCR_PRESC_Pos)
#define ADC_CCR_PRESC_3 (0x8UL << ADC_CCR_PRESC_Pos)

#define ADC_CCR_VREFEN_Pos (22U)
#define ADC_CCR_VREFEN_Msk (0x1UL << ADC_CCR_VREFEN_Pos)
#define ADC_CCR_VREFEN ADC_CCR_VREFEN_Msk
#define ADC_CCR_VSENSESEL_Pos (23U)
#define ADC_CCR_VSENSESEL_Msk (0x1UL << ADC_CCR_VSENSESEL_Pos)
#define ADC_CCR_VSENSESEL ADC_CCR_VSENSESEL_Msk
#define ADC_CCR_VBATSEL_Pos (24U)
#define ADC_CCR_VBATSEL_Msk (0x1UL << ADC_CCR_VBATSEL_Pos)
#define ADC_CCR_VBATSEL ADC_CCR_VBATSEL_Msk

/********************  Bit definition for ADC_CDR register  *******************/
#define ADC_CDR_RDATA_MST_Pos (0U)
#define ADC_CDR_RDATA_MST_Msk (0xFFFFUL << ADC_CDR_RDATA_MST_Pos)
#define ADC_CDR_RDATA_MST ADC_CDR_RDATA_MST_Msk

#define ADC_CDR_RDATA_SLV_Pos (16U)
#define ADC_CDR_RDATA_SLV_Msk (0xFFFFUL << ADC_CDR_RDATA_SLV_Pos)
#define ADC_CDR_RDATA_SLV ADC_CDR_RDATA_SLV_Msk


/******************************************************************************/
/*                                                                            */
/*                      Analog Comparators (COMP)                             */
/*                                                                            */
/******************************************************************************/
/**********************  Bit definition for COMP_CSR register  ****************/
#define COMP_CSR_EN_Pos (0U)
#define COMP_CSR_EN_Msk (0x1UL << COMP_CSR_EN_Pos)
#define COMP_CSR_EN COMP_CSR_EN_Msk

#define COMP_CSR_INMSEL_Pos (4U)
#define COMP_CSR_INMSEL_Msk (0xFUL << COMP_CSR_INMSEL_Pos)
#define COMP_CSR_INMSEL COMP_CSR_INMSEL_Msk
#define COMP_CSR_INMSEL_0 (0x1UL << COMP_CSR_INMSEL_Pos)
#define COMP_CSR_INMSEL_1 (0x2UL << COMP_CSR_INMSEL_Pos)
#define COMP_CSR_INMSEL_2 (0x4UL << COMP_CSR_INMSEL_Pos)
#define COMP_CSR_INMSEL_3 (0x8UL << COMP_CSR_INMSEL_Pos)

#define COMP_CSR_INPSEL_Pos (8U)
#define COMP_CSR_INPSEL_Msk (0x1UL << COMP_CSR_INPSEL_Pos)
#define COMP_CSR_INPSEL COMP_CSR_INPSEL_Msk

#define COMP_CSR_POLARITY_Pos (15U)
#define COMP_CSR_POLARITY_Msk (0x1UL << COMP_CSR_POLARITY_Pos)
#define COMP_CSR_POLARITY COMP_CSR_POLARITY_Msk

#define COMP_CSR_HYST_Pos (16U)
#define COMP_CSR_HYST_Msk (0x7UL << COMP_CSR_HYST_Pos)
#define COMP_CSR_HYST COMP_CSR_HYST_Msk
#define COMP_CSR_HYST_0 (0x1UL << COMP_CSR_HYST_Pos)
#define COMP_CSR_HYST_1 (0x2UL << COMP_CSR_HYST_Pos)
#define COMP_CSR_HYST_2 (0x4UL << COMP_CSR_HYST_Pos)

#define COMP_CSR_BLANKING_Pos (19U)
#define COMP_CSR_BLANKING_Msk (0x7UL << COMP_CSR_BLANKING_Pos)
#define COMP_CSR_BLANKING COMP_CSR_BLANKING_Msk
#define COMP_CSR_BLANKING_0 (0x1UL << COMP_CSR_BLANKING_Pos)
#define COMP_CSR_BLANKING_1 (0x2UL << COMP_CSR_BLANKING_Pos)
#define COMP_CSR_BLANKING_2 (0x4UL << COMP_CSR_BLANKING_Pos)

#define COMP_CSR_BRGEN_Pos (22U)
#define COMP_CSR_BRGEN_Msk (0x1UL << COMP_CSR_BRGEN_Pos)
#define COMP_CSR_BRGEN COMP_CSR_BRGEN_Msk

#define COMP_CSR_SCALEN_Pos (23U)
#define COMP_CSR_SCALEN_Msk (0x1UL << COMP_CSR_SCALEN_Pos)
#define COMP_CSR_SCALEN COMP_CSR_SCALEN_Msk

#define COMP_CSR_VALUE_Pos (30U)
#define COMP_CSR_VALUE_Msk (0x1UL << COMP_CSR_VALUE_Pos)
#define COMP_CSR_VALUE COMP_CSR_VALUE_Msk

#define COMP_CSR_LOCK_Pos (31U)
#define COMP_CSR_LOCK_Msk (0x1UL << COMP_CSR_LOCK_Pos)
#define COMP_CSR_LOCK COMP_CSR_LOCK_Msk

/******************************************************************************/
/*                                                                            */
/*                          CORDIC calculation unit                           */
/*                                                                            */
/******************************************************************************/
/*******************  Bit definition for CORDIC_CSR register  *****************/
#define CORDIC_CSR_FUNC_Pos (0U)
#define CORDIC_CSR_FUNC_Msk (0xFUL << CORDIC_CSR_FUNC_Pos)
#define CORDIC_CSR_FUNC CORDIC_CSR_FUNC_Msk
#define CORDIC_CSR_FUNC_0 (0x1UL << CORDIC_CSR_FUNC_Pos)
#define CORDIC_CSR_FUNC_1 (0x2UL << CORDIC_CSR_FUNC_Pos)
#define CORDIC_CSR_FUNC_2 (0x4UL << CORDIC_CSR_FUNC_Pos)
#define CORDIC_CSR_FUNC_3 (0x8UL << CORDIC_CSR_FUNC_Pos)
#define CORDIC_CSR_PRECISION_Pos (4U)
#define CORDIC_CSR_PRECISION_Msk (0xFUL << CORDIC_CSR_PRECISION_Pos)
#define CORDIC_CSR_PRECISION CORDIC_CSR_PRECISION_Msk
#define CORDIC_CSR_PRECISION_0 (0x1UL << CORDIC_CSR_PRECISION_Pos)
#define CORDIC_CSR_PRECISION_1 (0x2UL << CORDIC_CSR_PRECISION_Pos)
#define CORDIC_CSR_PRECISION_2 (0x4UL << CORDIC_CSR_PRECISION_Pos)
#define CORDIC_CSR_PRECISION_3 (0x8UL << CORDIC_CSR_PRECISION_Pos)
#define CORDIC_CSR_SCALE_Pos (8U)
#define CORDIC_CSR_SCALE_Msk (0x7UL << CORDIC_CSR_SCALE_Pos)
#define CORDIC_CSR_SCALE CORDIC_CSR_SCALE_Msk
#define CORDIC_CSR_SCALE_0 (0x1UL << CORDIC_CSR_SCALE_Pos)
#define CORDIC_CSR_SCALE_1 (0x2UL << CORDIC_CSR_SCALE_Pos)
#define CORDIC_CSR_SCALE_2 (0x4UL << CORDIC_CSR_SCALE_Pos)
#define CORDIC_CSR_IEN_Pos (16U)
#define CORDIC_CSR_IEN_Msk (0x1UL << CORDIC_CSR_IEN_Pos)
#define CORDIC_CSR_IEN CORDIC_CSR_IEN_Msk
#define CORDIC_CSR_DMAREN_Pos (17U)
#define CORDIC_CSR_DMAREN_Msk (0x1UL << CORDIC_CSR_DMAREN_Pos)
#define CORDIC_CSR_DMAREN CORDIC_CSR_DMAREN_Msk
#define CORDIC_CSR_DMAWEN_Pos (18U)
#define CORDIC_CSR_DMAWEN_Msk (0x1UL << CORDIC_CSR_DMAWEN_Pos)
#define CORDIC_CSR_DMAWEN CORDIC_CSR_DMAWEN_Msk
#define CORDIC_CSR_NRES_Pos (19U)
#define CORDIC_CSR_NRES_Msk (0x1UL << CORDIC_CSR_NRES_Pos)
#define CORDIC_CSR_NRES CORDIC_CSR_NRES_Msk
#define CORDIC_CSR_NARGS_Pos (20U)
#define CORDIC_CSR_NARGS_Msk (0x1UL << CORDIC_CSR_NARGS_Pos)
#define CORDIC_CSR_NARGS CORDIC_CSR_NARGS_Msk
#define CORDIC_CSR_RESSIZE_Pos (21U)
#define CORDIC_CSR_RESSIZE_Msk (0x1UL << CORDIC_CSR_RESSIZE_Pos)
#define CORDIC_CSR_RESSIZE CORDIC_CSR_RESSIZE_Msk
#define CORDIC_CSR_ARGSIZE_Pos (22U)
#define CORDIC_CSR_ARGSIZE_Msk (0x1UL << CORDIC_CSR_ARGSIZE_Pos)
#define CORDIC_CSR_ARGSIZE CORDIC_CSR_ARGSIZE_Msk
#define CORDIC_CSR_RRDY_Pos (31U)
#define CORDIC_CSR_RRDY_Msk (0x1UL << CORDIC_CSR_RRDY_Pos)
#define CORDIC_CSR_RRDY CORDIC_CSR_RRDY_Msk

/*******************  Bit definition for CORDIC_WDATA register  ***************/
#define CORDIC_WDATA_ARG_Pos (0U)
#define CORDIC_WDATA_ARG_Msk (0xFFFFFFFFUL << CORDIC_WDATA_ARG_Pos)
#define CORDIC_WDATA_ARG CORDIC_WDATA_ARG_Msk

/*******************  Bit definition for CORDIC_RDATA register  ***************/
#define CORDIC_RDATA_RES_Pos (0U)
#define CORDIC_RDATA_RES_Msk (0xFFFFFFFFUL << CORDIC_RDATA_RES_Pos)
#define CORDIC_RDATA_RES CORDIC_RDATA_RES_Msk

/******************************************************************************/
/*                                                                            */
/*                          CRC calculation unit                              */
/*                                                                            */
/******************************************************************************/
/*******************  Bit definition for CRC_DR register  *********************/
#define CRC_DR_DR_Pos (0U)
#define CRC_DR_DR_Msk (0xFFFFFFFFUL << CRC_DR_DR_Pos)
#define CRC_DR_DR CRC_DR_DR_Msk

/*******************  Bit definition for CRC_IDR register  ********************/
#define CRC_IDR_IDR_Pos (0U)
#define CRC_IDR_IDR_Msk (0xFFFFFFFFUL << CRC_IDR_IDR_Pos)
#define CRC_IDR_IDR CRC_IDR_IDR_Msk

/********************  Bit definition for CRC_CR register  ********************/
#define CRC_CR_RESET_Pos (0U)
#define CRC_CR_RESET_Msk (0x1UL << CRC_CR_RESET_Pos)
#define CRC_CR_RESET CRC_CR_RESET_Msk
#define CRC_CR_POLYSIZE_Pos (3U)
#define CRC_CR_POLYSIZE_Msk (0x3UL << CRC_CR_POLYSIZE_Pos)
#define CRC_CR_POLYSIZE CRC_CR_POLYSIZE_Msk
#define CRC_CR_POLYSIZE_0 (0x1UL << CRC_CR_POLYSIZE_Pos)
#define CRC_CR_POLYSIZE_1 (0x2UL << CRC_CR_POLYSIZE_Pos)
#define CRC_CR_REV_IN_Pos (5U)
#define CRC_CR_REV_IN_Msk (0x3UL << CRC_CR_REV_IN_Pos)
#define CRC_CR_REV_IN CRC_CR_REV_IN_Msk
#define CRC_CR_REV_IN_0 (0x1UL << CRC_CR_REV_IN_Pos)
#define CRC_CR_REV_IN_1 (0x2UL << CRC_CR_REV_IN_Pos)
#define CRC_CR_REV_OUT_Pos (7U)
#define CRC_CR_REV_OUT_Msk (0x1UL << CRC_CR_REV_OUT_Pos)
#define CRC_CR_REV_OUT CRC_CR_REV_OUT_Msk

/*******************  Bit definition for CRC_INIT register  *******************/
#define CRC_INIT_INIT_Pos (0U)
#define CRC_INIT_INIT_Msk (0xFFFFFFFFUL << CRC_INIT_INIT_Pos)
#define CRC_INIT_INIT CRC_INIT_INIT_Msk

/*******************  Bit definition for CRC_POL register  ********************/
#define CRC_POL_POL_Pos (0U)
#define CRC_POL_POL_Msk (0xFFFFFFFFUL << CRC_POL_POL_Pos)
#define CRC_POL_POL CRC_POL_POL_Msk

/******************************************************************************/
/*                                                                            */
/*                          CRS Clock Recovery System                         */
/******************************************************************************/

/*******************  Bit definition for CRS_CR register  *********************/
#define CRS_CR_SYNCOKIE_Pos (0U)
#define CRS_CR_SYNCOKIE_Msk (0x1UL << CRS_CR_SYNCOKIE_Pos)
#define CRS_CR_SYNCOKIE CRS_CR_SYNCOKIE_Msk
#define CRS_CR_SYNCWARNIE_Pos (1U)
#define CRS_CR_SYNCWARNIE_Msk (0x1UL << CRS_CR_SYNCWARNIE_Pos)
#define CRS_CR_SYNCWARNIE CRS_CR_SYNCWARNIE_Msk
#define CRS_CR_ERRIE_Pos (2U)
#define CRS_CR_ERRIE_Msk (0x1UL << CRS_CR_ERRIE_Pos)
#define CRS_CR_ERRIE CRS_CR_ERRIE_Msk
#define CRS_CR_ESYNCIE_Pos (3U)
#define CRS_CR_ESYNCIE_Msk (0x1UL << CRS_CR_ESYNCIE_Pos)
#define CRS_CR_ESYNCIE CRS_CR_ESYNCIE_Msk
#define CRS_CR_CEN_Pos (5U)
#define CRS_CR_CEN_Msk (0x1UL << CRS_CR_CEN_Pos)
#define CRS_CR_CEN CRS_CR_CEN_Msk
#define CRS_CR_AUTOTRIMEN_Pos (6U)
#define CRS_CR_AUTOTRIMEN_Msk (0x1UL << CRS_CR_AUTOTRIMEN_Pos)
#define CRS_CR_AUTOTRIMEN CRS_CR_AUTOTRIMEN_Msk
#define CRS_CR_SWSYNC_Pos (7U)
#define CRS_CR_SWSYNC_Msk (0x1UL << CRS_CR_SWSYNC_Pos)
#define CRS_CR_SWSYNC CRS_CR_SWSYNC_Msk
#define CRS_CR_TRIM_Pos (8U)
#define CRS_CR_TRIM_Msk (0x7FUL << CRS_CR_TRIM_Pos)
#define CRS_CR_TRIM CRS_CR_TRIM_Msk

/*******************  Bit definition for CRS_CFGR register  *********************/
#define CRS_CFGR_RELOAD_Pos (0U)
#define CRS_CFGR_RELOAD_Msk (0xFFFFUL << CRS_CFGR_RELOAD_Pos)
#define CRS_CFGR_RELOAD CRS_CFGR_RELOAD_Msk
#define CRS_CFGR_FELIM_Pos (16U)
#define CRS_CFGR_FELIM_Msk (0xFFUL << CRS_CFGR_FELIM_Pos)
#define CRS_CFGR_FELIM CRS_CFGR_FELIM_Msk

#define CRS_CFGR_SYNCDIV_Pos (24U)
#define CRS_CFGR_SYNCDIV_Msk (0x7UL << CRS_CFGR_SYNCDIV_Pos)
#define CRS_CFGR_SYNCDIV CRS_CFGR_SYNCDIV_Msk
#define CRS_CFGR_SYNCDIV_0 (0x1UL << CRS_CFGR_SYNCDIV_Pos)
#define CRS_CFGR_SYNCDIV_1 (0x2UL << CRS_CFGR_SYNCDIV_Pos)
#define CRS_CFGR_SYNCDIV_2 (0x4UL << CRS_CFGR_SYNCDIV_Pos)

#define CRS_CFGR_SYNCSRC_Pos (28U)
#define CRS_CFGR_SYNCSRC_Msk (0x3UL << CRS_CFGR_SYNCSRC_Pos)
#define CRS_CFGR_SYNCSRC CRS_CFGR_SYNCSRC_Msk
#define CRS_CFGR_SYNCSRC_0 (0x1UL << CRS_CFGR_SYNCSRC_Pos)
#define CRS_CFGR_SYNCSRC_1 (0x2UL << CRS_CFGR_SYNCSRC_Pos)

#define CRS_CFGR_SYNCPOL_Pos (31U)
#define CRS_CFGR_SYNCPOL_Msk (0x1UL << CRS_CFGR_SYNCPOL_Pos)
#define CRS_CFGR_SYNCPOL CRS_CFGR_SYNCPOL_Msk

/*******************  Bit definition for CRS_ISR register  *********************/
#define CRS_ISR_SYNCOKF_Pos (0U)
#define CRS_ISR_SYNCOKF_Msk (0x1UL << CRS_ISR_SYNCOKF_Pos)
#define CRS_ISR_SYNCOKF CRS_ISR_SYNCOKF_Msk
#define CRS_ISR_SYNCWARNF_Pos (1U)
#define CRS_ISR_SYNCWARNF_Msk (0x1UL << CRS_ISR_SYNCWARNF_Pos)
#define CRS_ISR_SYNCWARNF CRS_ISR_SYNCWARNF_Msk
#define CRS_ISR_ERRF_Pos (2U)
#define CRS_ISR_ERRF_Msk (0x1UL << CRS_ISR_ERRF_Pos)
#define CRS_ISR_ERRF CRS_ISR_ERRF_Msk
#define CRS_ISR_ESYNCF_Pos (3U)
#define CRS_ISR_ESYNCF_Msk (0x1UL << CRS_ISR_ESYNCF_Pos)
#define CRS_ISR_ESYNCF CRS_ISR_ESYNCF_Msk
#define CRS_ISR_SYNCERR_Pos (8U)
#define CRS_ISR_SYNCERR_Msk (0x1UL << CRS_ISR_SYNCERR_Pos)
#define CRS_ISR_SYNCERR CRS_ISR_SYNCERR_Msk
#define CRS_ISR_SYNCMISS_Pos (9U)
#define CRS_ISR_SYNCMISS_Msk (0x1UL << CRS_ISR_SYNCMISS_Pos)
#define CRS_ISR_SYNCMISS CRS_ISR_SYNCMISS_Msk
#define CRS_ISR_TRIMOVF_Pos (10U)
#define CRS_ISR_TRIMOVF_Msk (0x1UL << CRS_ISR_TRIMOVF_Pos)
#define CRS_ISR_TRIMOVF CRS_ISR_TRIMOVF_Msk
#define CRS_ISR_FEDIR_Pos (15U)
#define CRS_ISR_FEDIR_Msk (0x1UL << CRS_ISR_FEDIR_Pos)
#define CRS_ISR_FEDIR CRS_ISR_FEDIR_Msk
#define CRS_ISR_FECAP_Pos (16U)
#define CRS_ISR_FECAP_Msk (0xFFFFUL << CRS_ISR_FECAP_Pos)
#define CRS_ISR_FECAP CRS_ISR_FECAP_Msk

/*******************  Bit definition for CRS_ICR register  *********************/
#define CRS_ICR_SYNCOKC_Pos (0U)
#define CRS_ICR_SYNCOKC_Msk (0x1UL << CRS_ICR_SYNCOKC_Pos)
#define CRS_ICR_SYNCOKC CRS_ICR_SYNCOKC_Msk
#define CRS_ICR_SYNCWARNC_Pos (1U)
#define CRS_ICR_SYNCWARNC_Msk (0x1UL << CRS_ICR_SYNCWARNC_Pos)
#define CRS_ICR_SYNCWARNC CRS_ICR_SYNCWARNC_Msk
#define CRS_ICR_ERRC_Pos (2U)
#define CRS_ICR_ERRC_Msk (0x1UL << CRS_ICR_ERRC_Pos)
#define CRS_ICR_ERRC CRS_ICR_ERRC_Msk
#define CRS_ICR_ESYNCC_Pos (3U)
#define CRS_ICR_ESYNCC_Msk (0x1UL << CRS_ICR_ESYNCC_Pos)
#define CRS_ICR_ESYNCC CRS_ICR_ESYNCC_Msk

/******************************************************************************/
/*                                                                            */
/*                      Digital to Analog Converter                           */
/*                                                                            */
/******************************************************************************/
/*
 * @brief Specific device feature definitions (not present on all devices in the STM32G4 series)
 */
#define DAC_CHANNEL2_SUPPORT 

/********************  Bit definition for DAC_CR register  ********************/
#define DAC_CR_EN1_Pos (0U)
#define DAC_CR_EN1_Msk (0x1UL << DAC_CR_EN1_Pos)
#define DAC_CR_EN1 DAC_CR_EN1_Msk
#define DAC_CR_TEN1_Pos (1U)
#define DAC_CR_TEN1_Msk (0x1UL << DAC_CR_TEN1_Pos)
#define DAC_CR_TEN1 DAC_CR_TEN1_Msk

#define DAC_CR_TSEL1_Pos (2U)
#define DAC_CR_TSEL1_Msk (0xFUL << DAC_CR_TSEL1_Pos)
#define DAC_CR_TSEL1 DAC_CR_TSEL1_Msk
#define DAC_CR_TSEL1_0 (0x1UL << DAC_CR_TSEL1_Pos)
#define DAC_CR_TSEL1_1 (0x2UL << DAC_CR_TSEL1_Pos)
#define DAC_CR_TSEL1_2 (0x4UL << DAC_CR_TSEL1_Pos)
#define DAC_CR_TSEL1_3 (0x8UL << DAC_CR_TSEL1_Pos)

#define DAC_CR_WAVE1_Pos (6U)
#define DAC_CR_WAVE1_Msk (0x3UL << DAC_CR_WAVE1_Pos)
#define DAC_CR_WAVE1 DAC_CR_WAVE1_Msk
#define DAC_CR_WAVE1_0 (0x1UL << DAC_CR_WAVE1_Pos)
#define DAC_CR_WAVE1_1 (0x2UL << DAC_CR_WAVE1_Pos)

#define DAC_CR_MAMP1_Pos (8U)
#define DAC_CR_MAMP1_Msk (0xFUL << DAC_CR_MAMP1_Pos)
#define DAC_CR_MAMP1 DAC_CR_MAMP1_Msk
#define DAC_CR_MAMP1_0 (0x1UL << DAC_CR_MAMP1_Pos)
#define DAC_CR_MAMP1_1 (0x2UL << DAC_CR_MAMP1_Pos)
#define DAC_CR_MAMP1_2 (0x4UL << DAC_CR_MAMP1_Pos)
#define DAC_CR_MAMP1_3 (0x8UL << DAC_CR_MAMP1_Pos)

#define DAC_CR_DMAEN1_Pos (12U)
#define DAC_CR_DMAEN1_Msk (0x1UL << DAC_CR_DMAEN1_Pos)
#define DAC_CR_DMAEN1 DAC_CR_DMAEN1_Msk
#define DAC_CR_DMAUDRIE1_Pos (13U)
#define DAC_CR_DMAUDRIE1_Msk (0x1UL << DAC_CR_DMAUDRIE1_Pos)
#define DAC_CR_DMAUDRIE1 DAC_CR_DMAUDRIE1_Msk
#define DAC_CR_CEN1_Pos (14U)
#define DAC_CR_CEN1_Msk (0x1UL << DAC_CR_CEN1_Pos)
#define DAC_CR_CEN1 DAC_CR_CEN1_Msk

#define DAC_CR_HFSEL_Pos (15U)
#define DAC_CR_HFSEL_Msk (0x1UL << DAC_CR_HFSEL_Pos)
#define DAC_CR_HFSEL DAC_CR_HFSEL_Msk

#define DAC_CR_EN2_Pos (16U)
#define DAC_CR_EN2_Msk (0x1UL << DAC_CR_EN2_Pos)
#define DAC_CR_EN2 DAC_CR_EN2_Msk
#define DAC_CR_TEN2_Pos (17U)
#define DAC_CR_TEN2_Msk (0x1UL << DAC_CR_TEN2_Pos)
#define DAC_CR_TEN2 DAC_CR_TEN2_Msk

#define DAC_CR_TSEL2_Pos (18U)
#define DAC_CR_TSEL2_Msk (0xFUL << DAC_CR_TSEL2_Pos)
#define DAC_CR_TSEL2 DAC_CR_TSEL2_Msk
#define DAC_CR_TSEL2_0 (0x1UL << DAC_CR_TSEL2_Pos)
#define DAC_CR_TSEL2_1 (0x2UL << DAC_CR_TSEL2_Pos)
#define DAC_CR_TSEL2_2 (0x4UL << DAC_CR_TSEL2_Pos)
#define DAC_CR_TSEL2_3 (0x8UL << DAC_CR_TSEL2_Pos)

#define DAC_CR_WAVE2_Pos (22U)
#define DAC_CR_WAVE2_Msk (0x3UL << DAC_CR_WAVE2_Pos)
#define DAC_CR_WAVE2 DAC_CR_WAVE2_Msk
#define DAC_CR_WAVE2_0 (0x1UL << DAC_CR_WAVE2_Pos)
#define DAC_CR_WAVE2_1 (0x2UL << DAC_CR_WAVE2_Pos)

#define DAC_CR_MAMP2_Pos (24U)
#define DAC_CR_MAMP2_Msk (0xFUL << DAC_CR_MAMP2_Pos)
#define DAC_CR_MAMP2 DAC_CR_MAMP2_Msk
#define DAC_CR_MAMP2_0 (0x1UL << DAC_CR_MAMP2_Pos)
#define DAC_CR_MAMP2_1 (0x2UL << DAC_CR_MAMP2_Pos)
#define DAC_CR_MAMP2_2 (0x4UL << DAC_CR_MAMP2_Pos)
#define DAC_CR_MAMP2_3 (0x8UL << DAC_CR_MAMP2_Pos)

#define DAC_CR_DMAEN2_Pos (28U)
#define DAC_CR_DMAEN2_Msk (0x1UL << DAC_CR_DMAEN2_Pos)
#define DAC_CR_DMAEN2 DAC_CR_DMAEN2_Msk
#define DAC_CR_DMAUDRIE2_Pos (29U)
#define DAC_CR_DMAUDRIE2_Msk (0x1UL << DAC_CR_DMAUDRIE2_Pos)
#define DAC_CR_DMAUDRIE2 DAC_CR_DMAUDRIE2_Msk
#define DAC_CR_CEN2_Pos (30U)
#define DAC_CR_CEN2_Msk (0x1UL << DAC_CR_CEN2_Pos)
#define DAC_CR_CEN2 DAC_CR_CEN2_Msk

/*****************  Bit definition for DAC_SWTRIGR register  ******************/
#define DAC_SWTRIGR_SWTRIG1_Pos (0U)
#define DAC_SWTRIGR_SWTRIG1_Msk (0x1UL << DAC_SWTRIGR_SWTRIG1_Pos)
#define DAC_SWTRIGR_SWTRIG1 DAC_SWTRIGR_SWTRIG1_Msk
#define DAC_SWTRIGR_SWTRIG2_Pos (1U)
#define DAC_SWTRIGR_SWTRIG2_Msk (0x1UL << DAC_SWTRIGR_SWTRIG2_Pos)
#define DAC_SWTRIGR_SWTRIG2 DAC_SWTRIGR_SWTRIG2_Msk
#define DAC_SWTRIGR_SWTRIGB1_Pos (16U)
#define DAC_SWTRIGR_SWTRIGB1_Msk (0x1UL << DAC_SWTRIGR_SWTRIGB1_Pos)
#define DAC_SWTRIGR_SWTRIGB1 DAC_SWTRIGR_SWTRIGB1_Msk
#define DAC_SWTRIGR_SWTRIGB2_Pos (17U)
#define DAC_SWTRIGR_SWTRIGB2_Msk (0x1UL << DAC_SWTRIGR_SWTRIGB2_Pos)
#define DAC_SWTRIGR_SWTRIGB2 DAC_SWTRIGR_SWTRIGB2_Msk

/*****************  Bit definition for DAC_DHR12R1 register  ******************/
#define DAC_DHR12R1_DACC1DHR_Pos (0U)
#define DAC_DHR12R1_DACC1DHR_Msk (0xFFFUL << DAC_DHR12R1_DACC1DHR_Pos)
#define DAC_DHR12R1_DACC1DHR DAC_DHR12R1_DACC1DHR_Msk
#define DAC_DHR12R1_DACC1DHRB_Pos (16U)
#define DAC_DHR12R1_DACC1DHRB_Msk (0xFFFUL << DAC_DHR12R1_DACC1DHRB_Pos)
#define DAC_DHR12R1_DACC1DHRB DAC_DHR12R1_DACC1DHRB_Msk

/*****************  Bit definition for DAC_DHR12L1 register  ******************/
#define DAC_DHR12L1_DACC1DHR_Pos (4U)
#define DAC_DHR12L1_DACC1DHR_Msk (0xFFFUL << DAC_DHR12L1_DACC1DHR_Pos)
#define DAC_DHR12L1_DACC1DHR DAC_DHR12L1_DACC1DHR_Msk
#define DAC_DHR12L1_DACC1DHRB_Pos (20U)
#define DAC_DHR12L1_DACC1DHRB_Msk (0xFFFUL << DAC_DHR12L1_DACC1DHRB_Pos)
#define DAC_DHR12L1_DACC1DHRB DAC_DHR12L1_DACC1DHRB_Msk

/******************  Bit definition for DAC_DHR8R1 register  ******************/
#define DAC_DHR8R1_DACC1DHR_Pos (0U)
#define DAC_DHR8R1_DACC1DHR_Msk (0xFFUL << DAC_DHR8R1_DACC1DHR_Pos)
#define DAC_DHR8R1_DACC1DHR DAC_DHR8R1_DACC1DHR_Msk
#define DAC_DHR8R1_DACC1DHRB_Pos (8U)
#define DAC_DHR8R1_DACC1DHRB_Msk (0xFFUL << DAC_DHR8R1_DACC1DHRB_Pos)
#define DAC_DHR8R1_DACC1DHRB DAC_DHR8R1_DACC1DHRB_Msk

/*****************  Bit definition for DAC_DHR12R2 register  ******************/
#define DAC_DHR12R2_DACC2DHR_Pos (0U)
#define DAC_DHR12R2_DACC2DHR_Msk (0xFFFUL << DAC_DHR12R2_DACC2DHR_Pos)
#define DAC_DHR12R2_DACC2DHR DAC_DHR12R2_DACC2DHR_Msk
#define DAC_DHR12R2_DACC2DHRB_Pos (16U)
#define DAC_DHR12R2_DACC2DHRB_Msk (0xFFFUL << DAC_DHR12R2_DACC2DHRB_Pos)
#define DAC_DHR12R2_DACC2DHRB DAC_DHR12R2_DACC2DHRB_Msk

/*****************  Bit definition for DAC_DHR12L2 register  ******************/
#define DAC_DHR12L2_DACC2DHR_Pos (4U)
#define DAC_DHR12L2_DACC2DHR_Msk (0xFFFUL << DAC_DHR12L2_DACC2DHR_Pos)
#define DAC_DHR12L2_DACC2DHR DAC_DHR12L2_DACC2DHR_Msk
#define DAC_DHR12L2_DACC2DHRB_Pos (20U)
#define DAC_DHR12L2_DACC2DHRB_Msk (0xFFFUL << DAC_DHR12L2_DACC2DHRB_Pos)
#define DAC_DHR12L2_DACC2DHRB DAC_DHR12L2_DACC2DHRB_Msk

/******************  Bit definition for DAC_DHR8R2 register  ******************/
#define DAC_DHR8R2_DACC2DHR_Pos (0U)
#define DAC_DHR8R2_DACC2DHR_Msk (0xFFUL << DAC_DHR8R2_DACC2DHR_Pos)
#define DAC_DHR8R2_DACC2DHR DAC_DHR8R2_DACC2DHR_Msk
#define DAC_DHR8R2_DACC2DHRB_Pos (8U)
#define DAC_DHR8R2_DACC2DHRB_Msk (0xFFUL << DAC_DHR8R2_DACC2DHRB_Pos)
#define DAC_DHR8R2_DACC2DHRB DAC_DHR8R2_DACC2DHRB_Msk

/*****************  Bit definition for DAC_DHR12RD register  ******************/
#define DAC_DHR12RD_DACC1DHR_Pos (0U)
#define DAC_DHR12RD_DACC1DHR_Msk (0xFFFUL << DAC_DHR12RD_DACC1DHR_Pos)
#define DAC_DHR12RD_DACC1DHR DAC_DHR12RD_DACC1DHR_Msk
#define DAC_DHR12RD_DACC2DHR_Pos (16U)
#define DAC_DHR12RD_DACC2DHR_Msk (0xFFFUL << DAC_DHR12RD_DACC2DHR_Pos)
#define DAC_DHR12RD_DACC2DHR DAC_DHR12RD_DACC2DHR_Msk

/*****************  Bit definition for DAC_DHR12LD register  ******************/
#define DAC_DHR12LD_DACC1DHR_Pos (4U)
#define DAC_DHR12LD_DACC1DHR_Msk (0xFFFUL << DAC_DHR12LD_DACC1DHR_Pos)
#define DAC_DHR12LD_DACC1DHR DAC_DHR12LD_DACC1DHR_Msk
#define DAC_DHR12LD_DACC2DHR_Pos (20U)
#define DAC_DHR12LD_DACC2DHR_Msk (0xFFFUL << DAC_DHR12LD_DACC2DHR_Pos)
#define DAC_DHR12LD_DACC2DHR DAC_DHR12LD_DACC2DHR_Msk

/******************  Bit definition for DAC_DHR8RD register  ******************/
#define DAC_DHR8RD_DACC1DHR_Pos (0U)
#define DAC_DHR8RD_DACC1DHR_Msk (0xFFUL << DAC_DHR8RD_DACC1DHR_Pos)
#define DAC_DHR8RD_DACC1DHR DAC_DHR8RD_DACC1DHR_Msk
#define DAC_DHR8RD_DACC2DHR_Pos (8U)
#define DAC_DHR8RD_DACC2DHR_Msk (0xFFUL << DAC_DHR8RD_DACC2DHR_Pos)
#define DAC_DHR8RD_DACC2DHR DAC_DHR8RD_DACC2DHR_Msk

/*******************  Bit definition for DAC_DOR1 register  *******************/
#define DAC_DOR1_DACC1DOR_Pos (0U)
#define DAC_DOR1_DACC1DOR_Msk (0xFFFUL << DAC_DOR1_DACC1DOR_Pos)
#define DAC_DOR1_DACC1DOR DAC_DOR1_DACC1DOR_Msk
#define DAC_DOR1_DACC1DORB_Pos (16U)
#define DAC_DOR1_DACC1DORB_Msk (0xFFFUL << DAC_DOR1_DACC1DORB_Pos)
#define DAC_DOR1_DACC1DORB DAC_DOR1_DACC1DORB_Msk

/*******************  Bit definition for DAC_DOR2 register  *******************/
#define DAC_DOR2_DACC2DOR_Pos (0U)
#define DAC_DOR2_DACC2DOR_Msk (0xFFFUL << DAC_DOR2_DACC2DOR_Pos)
#define DAC_DOR2_DACC2DOR DAC_DOR2_DACC2DOR_Msk
#define DAC_DOR2_DACC2DORB_Pos (16U)
#define DAC_DOR2_DACC2DORB_Msk (0xFFFUL << DAC_DOR2_DACC2DORB_Pos)
#define DAC_DOR2_DACC2DORB DAC_DOR2_DACC2DORB_Msk

/********************  Bit definition for DAC_SR register  ********************/
#define DAC_SR_DAC1RDY_Pos (11U)
#define DAC_SR_DAC1RDY_Msk (0x1UL << DAC_SR_DAC1RDY_Pos)
#define DAC_SR_DAC1RDY DAC_SR_DAC1RDY_Msk
#define DAC_SR_DORSTAT1_Pos (12U)
#define DAC_SR_DORSTAT1_Msk (0x1UL << DAC_SR_DORSTAT1_Pos)
#define DAC_SR_DORSTAT1 DAC_SR_DORSTAT1_Msk
#define DAC_SR_DMAUDR1_Pos (13U)
#define DAC_SR_DMAUDR1_Msk (0x1UL << DAC_SR_DMAUDR1_Pos)
#define DAC_SR_DMAUDR1 DAC_SR_DMAUDR1_Msk
#define DAC_SR_CAL_FLAG1_Pos (14U)
#define DAC_SR_CAL_FLAG1_Msk (0x1UL << DAC_SR_CAL_FLAG1_Pos)
#define DAC_SR_CAL_FLAG1 DAC_SR_CAL_FLAG1_Msk
#define DAC_SR_BWST1_Pos (15U)
#define DAC_SR_BWST1_Msk (0x1UL << DAC_SR_BWST1_Pos)
#define DAC_SR_BWST1 DAC_SR_BWST1_Msk

#define DAC_SR_DAC2RDY_Pos (27U)
#define DAC_SR_DAC2RDY_Msk (0x1UL << DAC_SR_DAC2RDY_Pos)
#define DAC_SR_DAC2RDY DAC_SR_DAC2RDY_Msk
#define DAC_SR_DORSTAT2_Pos (28U)
#define DAC_SR_DORSTAT2_Msk (0x1UL << DAC_SR_DORSTAT2_Pos)
#define DAC_SR_DORSTAT2 DAC_SR_DORSTAT2_Msk
#define DAC_SR_DMAUDR2_Pos (29U)
#define DAC_SR_DMAUDR2_Msk (0x1UL << DAC_SR_DMAUDR2_Pos)
#define DAC_SR_DMAUDR2 DAC_SR_DMAUDR2_Msk
#define DAC_SR_CAL_FLAG2_Pos (30U)
#define DAC_SR_CAL_FLAG2_Msk (0x1UL << DAC_SR_CAL_FLAG2_Pos)
#define DAC_SR_CAL_FLAG2 DAC_SR_CAL_FLAG2_Msk
#define DAC_SR_BWST2_Pos (31U)
#define DAC_SR_BWST2_Msk (0x1UL << DAC_SR_BWST2_Pos)
#define DAC_SR_BWST2 DAC_SR_BWST2_Msk

/*******************  Bit definition for DAC_CCR register  ********************/
#define DAC_CCR_OTRIM1_Pos (0U)
#define DAC_CCR_OTRIM1_Msk (0x1FUL << DAC_CCR_OTRIM1_Pos)
#define DAC_CCR_OTRIM1 DAC_CCR_OTRIM1_Msk
#define DAC_CCR_OTRIM2_Pos (16U)
#define DAC_CCR_OTRIM2_Msk (0x1FUL << DAC_CCR_OTRIM2_Pos)
#define DAC_CCR_OTRIM2 DAC_CCR_OTRIM2_Msk

/*******************  Bit definition for DAC_MCR register  *******************/
#define DAC_MCR_MODE1_Pos (0U)
#define DAC_MCR_MODE1_Msk (0x7UL << DAC_MCR_MODE1_Pos)
#define DAC_MCR_MODE1 DAC_MCR_MODE1_Msk
#define DAC_MCR_MODE1_0 (0x1UL << DAC_MCR_MODE1_Pos)
#define DAC_MCR_MODE1_1 (0x2UL << DAC_MCR_MODE1_Pos)
#define DAC_MCR_MODE1_2 (0x4UL << DAC_MCR_MODE1_Pos)

#define DAC_MCR_DMADOUBLE1_Pos (8U)
#define DAC_MCR_DMADOUBLE1_Msk (0x1UL << DAC_MCR_DMADOUBLE1_Pos)
#define DAC_MCR_DMADOUBLE1 DAC_MCR_DMADOUBLE1_Msk

#define DAC_MCR_SINFORMAT1_Pos (9U)
#define DAC_MCR_SINFORMAT1_Msk (0x1UL << DAC_MCR_SINFORMAT1_Pos)
#define DAC_MCR_SINFORMAT1 DAC_MCR_SINFORMAT1_Msk

#define DAC_MCR_HFSEL_Pos (14U)
#define DAC_MCR_HFSEL_Msk (0x3UL << DAC_MCR_HFSEL_Pos)
#define DAC_MCR_HFSEL DAC_MCR_HFSEL_Msk
#define DAC_MCR_HFSEL_0 (0x1UL << DAC_MCR_HFSEL_Pos)
#define DAC_MCR_HFSEL_1 (0x2UL << DAC_MCR_HFSEL_Pos)

#define DAC_MCR_MODE2_Pos (16U)
#define DAC_MCR_MODE2_Msk (0x7UL << DAC_MCR_MODE2_Pos)
#define DAC_MCR_MODE2 DAC_MCR_MODE2_Msk
#define DAC_MCR_MODE2_0 (0x1UL << DAC_MCR_MODE2_Pos)
#define DAC_MCR_MODE2_1 (0x2UL << DAC_MCR_MODE2_Pos)
#define DAC_MCR_MODE2_2 (0x4UL << DAC_MCR_MODE2_Pos)

#define DAC_MCR_DMADOUBLE2_Pos (24U)
#define DAC_MCR_DMADOUBLE2_Msk (0x1UL << DAC_MCR_DMADOUBLE2_Pos)
#define DAC_MCR_DMADOUBLE2 DAC_MCR_DMADOUBLE2_Msk

#define DAC_MCR_SINFORMAT2_Pos (25U)
#define DAC_MCR_SINFORMAT2_Msk (0x1UL << DAC_MCR_SINFORMAT2_Pos)
#define DAC_MCR_SINFORMAT2 DAC_MCR_SINFORMAT2_Msk

/******************  Bit definition for DAC_SHSR1 register  ******************/
#define DAC_SHSR1_TSAMPLE1_Pos (0U)
#define DAC_SHSR1_TSAMPLE1_Msk (0x3FFUL << DAC_SHSR1_TSAMPLE1_Pos)
#define DAC_SHSR1_TSAMPLE1 DAC_SHSR1_TSAMPLE1_Msk

/******************  Bit definition for DAC_SHSR2 register  ******************/
#define DAC_SHSR2_TSAMPLE2_Pos (0U)
#define DAC_SHSR2_TSAMPLE2_Msk (0x3FFUL << DAC_SHSR2_TSAMPLE2_Pos)
#define DAC_SHSR2_TSAMPLE2 DAC_SHSR2_TSAMPLE2_Msk

/******************  Bit definition for DAC_SHHR register  ******************/
#define DAC_SHHR_THOLD1_Pos (0U)
#define DAC_SHHR_THOLD1_Msk (0x3FFUL << DAC_SHHR_THOLD1_Pos)
#define DAC_SHHR_THOLD1 DAC_SHHR_THOLD1_Msk
#define DAC_SHHR_THOLD2_Pos (16U)
#define DAC_SHHR_THOLD2_Msk (0x3FFUL << DAC_SHHR_THOLD2_Pos)
#define DAC_SHHR_THOLD2 DAC_SHHR_THOLD2_Msk

/******************  Bit definition for DAC_SHRR register  ******************/
#define DAC_SHRR_TREFRESH1_Pos (0U)
#define DAC_SHRR_TREFRESH1_Msk (0xFFUL << DAC_SHRR_TREFRESH1_Pos)
#define DAC_SHRR_TREFRESH1 DAC_SHRR_TREFRESH1_Msk
#define DAC_SHRR_TREFRESH2_Pos (16U)
#define DAC_SHRR_TREFRESH2_Msk (0xFFUL << DAC_SHRR_TREFRESH2_Pos)
#define DAC_SHRR_TREFRESH2 DAC_SHRR_TREFRESH2_Msk

/******************  Bit definition for DAC_STR1 register  ******************/
#define DAC_STR1_STRSTDATA1_Pos (0U)
#define DAC_STR1_STRSTDATA1_Msk (0xFFFUL << DAC_STR1_STRSTDATA1_Pos)
#define DAC_STR1_STRSTDATA1 DAC_STR1_STRSTDATA1_Msk
#define DAC_STR1_STDIR1_Pos (12U)
#define DAC_STR1_STDIR1_Msk (0x1UL << DAC_STR1_STDIR1_Pos)
#define DAC_STR1_STDIR1 DAC_STR1_STDIR1_Msk

#define DAC_STR1_STINCDATA1_Pos (16U)
#define DAC_STR1_STINCDATA1_Msk (0xFFFFUL << DAC_STR1_STINCDATA1_Pos)
#define DAC_STR1_STINCDATA1 DAC_STR1_STINCDATA1_Msk

/******************  Bit definition for DAC_STR2 register  ******************/
#define DAC_STR2_STRSTDATA2_Pos (0U)
#define DAC_STR2_STRSTDATA2_Msk (0xFFFUL << DAC_STR2_STRSTDATA2_Pos)
#define DAC_STR2_STRSTDATA2 DAC_STR2_STRSTDATA2_Msk
#define DAC_STR2_STDIR2_Pos (12U)
#define DAC_STR2_STDIR2_Msk (0x1UL << DAC_STR2_STDIR2_Pos)
#define DAC_STR2_STDIR2 DAC_STR2_STDIR2_Msk

#define DAC_STR2_STINCDATA2_Pos (16U)
#define DAC_STR2_STINCDATA2_Msk (0xFFFFUL << DAC_STR2_STINCDATA2_Pos)
#define DAC_STR2_STINCDATA2 DAC_STR2_STINCDATA2_Msk

/******************  Bit definition for DAC_STMODR register  ****************/
#define DAC_STMODR_STRSTTRIGSEL1_Pos (0U)
#define DAC_STMODR_STRSTTRIGSEL1_Msk (0xFUL << DAC_STMODR_STRSTTRIGSEL1_Pos)
#define DAC_STMODR_STRSTTRIGSEL1 DAC_STMODR_STRSTTRIGSEL1_Msk
#define DAC_STMODR_STRSTTRIGSEL1_0 (0x1UL << DAC_STMODR_STRSTTRIGSEL1_Pos)
#define DAC_STMODR_STRSTTRIGSEL1_1 (0x2UL << DAC_STMODR_STRSTTRIGSEL1_Pos)
#define DAC_STMODR_STRSTTRIGSEL1_2 (0x4UL << DAC_STMODR_STRSTTRIGSEL1_Pos)
#define DAC_STMODR_STRSTTRIGSEL1_3 (0x8UL << DAC_STMODR_STRSTTRIGSEL1_Pos)

#define DAC_STMODR_STINCTRIGSEL1_Pos (8U)
#define DAC_STMODR_STINCTRIGSEL1_Msk (0xFUL << DAC_STMODR_STINCTRIGSEL1_Pos)
#define DAC_STMODR_STINCTRIGSEL1 DAC_STMODR_STINCTRIGSEL1_Msk
#define DAC_STMODR_STINCTRIGSEL1_0 (0x1UL << DAC_STMODR_STINCTRIGSEL1_Pos)
#define DAC_STMODR_STINCTRIGSEL1_1 (0x2UL << DAC_STMODR_STINCTRIGSEL1_Pos)
#define DAC_STMODR_STINCTRIGSEL1_2 (0x4UL << DAC_STMODR_STINCTRIGSEL1_Pos)
#define DAC_STMODR_STINCTRIGSEL1_3 (0x8UL << DAC_STMODR_STINCTRIGSEL1_Pos)

#define DAC_STMODR_STRSTTRIGSEL2_Pos (16U)
#define DAC_STMODR_STRSTTRIGSEL2_Msk (0xFUL << DAC_STMODR_STRSTTRIGSEL2_Pos)
#define DAC_STMODR_STRSTTRIGSEL2 DAC_STMODR_STRSTTRIGSEL2_Msk
#define DAC_STMODR_STRSTTRIGSEL2_0 (0x1UL << DAC_STMODR_STRSTTRIGSEL2_Pos)
#define DAC_STMODR_STRSTTRIGSEL2_1 (0x2UL << DAC_STMODR_STRSTTRIGSEL2_Pos)
#define DAC_STMODR_STRSTTRIGSEL2_2 (0x4UL << DAC_STMODR_STRSTTRIGSEL2_Pos)
#define DAC_STMODR_STRSTTRIGSEL2_3 (0x8UL << DAC_STMODR_STRSTTRIGSEL2_Pos)

#define DAC_STMODR_STINCTRIGSEL2_Pos (24U)
#define DAC_STMODR_STINCTRIGSEL2_Msk (0xFUL << DAC_STMODR_STINCTRIGSEL2_Pos)
#define DAC_STMODR_STINCTRIGSEL2 DAC_STMODR_STINCTRIGSEL2_Msk
#define DAC_STMODR_STINCTRIGSEL2_0 (0x1UL << DAC_STMODR_STINCTRIGSEL2_Pos)
#define DAC_STMODR_STINCTRIGSEL2_1 (0x2UL << DAC_STMODR_STINCTRIGSEL2_Pos)
#define DAC_STMODR_STINCTRIGSEL2_2 (0x4UL << DAC_STMODR_STINCTRIGSEL2_Pos)
#define DAC_STMODR_STINCTRIGSEL2_3 (0x8UL << DAC_STMODR_STINCTRIGSEL2_Pos)

/******************************************************************************/
/*                                                                            */
/*                                 Debug MCU                                  */
/*                                                                            */
/******************************************************************************/
/********************  Bit definition for DBGMCU_IDCODE register  *************/
#define DBGMCU_IDCODE_DEV_ID_Pos (0U)
#define DBGMCU_IDCODE_DEV_ID_Msk (0xFFFUL << DBGMCU_IDCODE_DEV_ID_Pos)
#define DBGMCU_IDCODE_DEV_ID DBGMCU_IDCODE_DEV_ID_Msk
#define DBGMCU_IDCODE_REV_ID_Pos (16U)
#define DBGMCU_IDCODE_REV_ID_Msk (0xFFFFUL << DBGMCU_IDCODE_REV_ID_Pos)
#define DBGMCU_IDCODE_REV_ID DBGMCU_IDCODE_REV_ID_Msk

/********************  Bit definition for DBGMCU_CR register  *****************/
#define DBGMCU_CR_DBG_SLEEP_Pos (0U)
#define DBGMCU_CR_DBG_SLEEP_Msk (0x1UL << DBGMCU_CR_DBG_SLEEP_Pos)
#define DBGMCU_CR_DBG_SLEEP DBGMCU_CR_DBG_SLEEP_Msk
#define DBGMCU_CR_DBG_STOP_Pos (1U)
#define DBGMCU_CR_DBG_STOP_Msk (0x1UL << DBGMCU_CR_DBG_STOP_Pos)
#define DBGMCU_CR_DBG_STOP DBGMCU_CR_DBG_STOP_Msk
#define DBGMCU_CR_DBG_STANDBY_Pos (2U)
#define DBGMCU_CR_DBG_STANDBY_Msk (0x1UL << DBGMCU_CR_DBG_STANDBY_Pos)
#define DBGMCU_CR_DBG_STANDBY DBGMCU_CR_DBG_STANDBY_Msk
#define DBGMCU_CR_TRACE_IOEN_Pos (5U)
#define DBGMCU_CR_TRACE_IOEN_Msk (0x1UL << DBGMCU_CR_TRACE_IOEN_Pos)
#define DBGMCU_CR_TRACE_IOEN DBGMCU_CR_TRACE_IOEN_Msk

#define DBGMCU_CR_TRACE_MODE_Pos (6U)
#define DBGMCU_CR_TRACE_MODE_Msk (0x3UL << DBGMCU_CR_TRACE_MODE_Pos)
#define DBGMCU_CR_TRACE_MODE DBGMCU_CR_TRACE_MODE_Msk
#define DBGMCU_CR_TRACE_MODE_0 (0x1UL << DBGMCU_CR_TRACE_MODE_Pos)
#define DBGMCU_CR_TRACE_MODE_1 (0x2UL << DBGMCU_CR_TRACE_MODE_Pos)

/********************  Bit definition for DBGMCU_APB1FZR1 register  ***********/
#define DBGMCU_APB1FZR1_DBG_TIM2_STOP_Pos (0U)
#define DBGMCU_APB1FZR1_DBG_TIM2_STOP_Msk (0x1UL << DBGMCU_APB1FZR1_DBG_TIM2_STOP_Pos)
#define DBGMCU_APB1FZR1_DBG_TIM2_STOP DBGMCU_APB1FZR1_DBG_TIM2_STOP_Msk
#define DBGMCU_APB1FZR1_DBG_TIM3_STOP_Pos (1U)
#define DBGMCU_APB1FZR1_DBG_TIM3_STOP_Msk (0x1UL << DBGMCU_APB1FZR1_DBG_TIM3_STOP_Pos)
#define DBGMCU_APB1FZR1_DBG_TIM3_STOP DBGMCU_APB1FZR1_DBG_TIM3_STOP_Msk
#define DBGMCU_APB1FZR1_DBG_TIM4_STOP_Pos (2U)
#define DBGMCU_APB1FZR1_DBG_TIM4_STOP_Msk (0x1UL << DBGMCU_APB1FZR1_DBG_TIM4_STOP_Pos)
#define DBGMCU_APB1FZR1_DBG_TIM4_STOP DBGMCU_APB1FZR1_DBG_TIM4_STOP_Msk
#define DBGMCU_APB1FZR1_DBG_TIM5_STOP_Pos (3U)
#define DBGMCU_APB1FZR1_DBG_TIM5_STOP_Msk (0x1UL << DBGMCU_APB1FZR1_DBG_TIM5_STOP_Pos)
#define DBGMCU_APB1FZR1_DBG_TIM5_STOP DBGMCU_APB1FZR1_DBG_TIM5_STOP_Msk
#define DBGMCU_APB1FZR1_DBG_TIM6_STOP_Pos (4U)
#define DBGMCU_APB1FZR1_DBG_TIM6_STOP_Msk (0x1UL << DBGMCU_APB1FZR1_DBG_TIM6_STOP_Pos)
#define DBGMCU_APB1FZR1_DBG_TIM6_STOP DBGMCU_APB1FZR1_DBG_TIM6_STOP_Msk
#define DBGMCU_APB1FZR1_DBG_TIM7_STOP_Pos (5U)
#define DBGMCU_APB1FZR1_DBG_TIM7_STOP_Msk (0x1UL << DBGMCU_APB1FZR1_DBG_TIM7_STOP_Pos)
#define DBGMCU_APB1FZR1_DBG_TIM7_STOP DBGMCU_APB1FZR1_DBG_TIM7_STOP_Msk
#define DBGMCU_APB1FZR1_DBG_RTC_STOP_Pos (10U)
#define DBGMCU_APB1FZR1_DBG_RTC_STOP_Msk (0x1UL << DBGMCU_APB1FZR1_DBG_RTC_STOP_Pos)
#define DBGMCU_APB1FZR1_DBG_RTC_STOP DBGMCU_APB1FZR1_DBG_RTC_STOP_Msk
#define DBGMCU_APB1FZR1_DBG_WWDG_STOP_Pos (11U)
#define DBGMCU_APB1FZR1_DBG_WWDG_STOP_Msk (0x1UL << DBGMCU_APB1FZR1_DBG_WWDG_STOP_Pos)
#define DBGMCU_APB1FZR1_DBG_WWDG_STOP DBGMCU_APB1FZR1_DBG_WWDG_STOP_Msk
#define DBGMCU_APB1FZR1_DBG_IWDG_STOP_Pos (12U)
#define DBGMCU_APB1FZR1_DBG_IWDG_STOP_Msk (0x1UL << DBGMCU_APB1FZR1_DBG_IWDG_STOP_Pos)
#define DBGMCU_APB1FZR1_DBG_IWDG_STOP DBGMCU_APB1FZR1_DBG_IWDG_STOP_Msk
#define DBGMCU_APB1FZR1_DBG_I2C1_STOP_Pos (21U)
#define DBGMCU_APB1FZR1_DBG_I2C1_STOP_Msk (0x1UL << DBGMCU_APB1FZR1_DBG_I2C1_STOP_Pos)
#define DBGMCU_APB1FZR1_DBG_I2C1_STOP DBGMCU_APB1FZR1_DBG_I2C1_STOP_Msk
#define DBGMCU_APB1FZR1_DBG_I2C2_STOP_Pos (22U)
#define DBGMCU_APB1FZR1_DBG_I2C2_STOP_Msk (0x1UL << DBGMCU_APB1FZR1_DBG_I2C2_STOP_Pos)
#define DBGMCU_APB1FZR1_DBG_I2C2_STOP DBGMCU_APB1FZR1_DBG_I2C2_STOP_Msk
#define DBGMCU_APB1FZR1_DBG_I2C3_STOP_Pos (30U)
#define DBGMCU_APB1FZR1_DBG_I2C3_STOP_Msk (0x1UL << DBGMCU_APB1FZR1_DBG_I2C3_STOP_Pos)
#define DBGMCU_APB1FZR1_DBG_I2C3_STOP DBGMCU_APB1FZR1_DBG_I2C3_STOP_Msk
#define DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Pos (31U)
#define DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Msk (0x1UL << DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Pos)
#define DBGMCU_APB1FZR1_DBG_LPTIM1_STOP DBGMCU_APB1FZR1_DBG_LPTIM1_STOP_Msk

/********************  Bit definition for DBGMCU_APB1FZR2 register  **********/
#define DBGMCU_APB1FZR2_DBG_I2C4_STOP_Pos (1U)
#define DBGMCU_APB1FZR2_DBG_I2C4_STOP_Msk (0x1UL << DBGMCU_APB1FZR2_DBG_I2C4_STOP_Pos)
#define DBGMCU_APB1FZR2_DBG_I2C4_STOP DBGMCU_APB1FZR2_DBG_I2C4_STOP_Msk

/********************  Bit definition for DBGMCU_APB2FZ register  ************/
#define DBGMCU_APB2FZ_DBG_TIM1_STOP_Pos (11U)
#define DBGMCU_APB2FZ_DBG_TIM1_STOP_Msk (0x1UL << DBGMCU_APB2FZ_DBG_TIM1_STOP_Pos)
#define DBGMCU_APB2FZ_DBG_TIM1_STOP DBGMCU_APB2FZ_DBG_TIM1_STOP_Msk
#define DBGMCU_APB2FZ_DBG_TIM8_STOP_Pos (13U)
#define DBGMCU_APB2FZ_DBG_TIM8_STOP_Msk (0x1UL << DBGMCU_APB2FZ_DBG_TIM8_STOP_Pos)
#define DBGMCU_APB2FZ_DBG_TIM8_STOP DBGMCU_APB2FZ_DBG_TIM8_STOP_Msk
#define DBGMCU_APB2FZ_DBG_TIM15_STOP_Pos (16U)
#define DBGMCU_APB2FZ_DBG_TIM15_STOP_Msk (0x1UL << DBGMCU_APB2FZ_DBG_TIM15_STOP_Pos)
#define DBGMCU_APB2FZ_DBG_TIM15_STOP DBGMCU_APB2FZ_DBG_TIM15_STOP_Msk
#define DBGMCU_APB2FZ_DBG_TIM16_STOP_Pos (17U)
#define DBGMCU_APB2FZ_DBG_TIM16_STOP_Msk (0x1UL << DBGMCU_APB2FZ_DBG_TIM16_STOP_Pos)
#define DBGMCU_APB2FZ_DBG_TIM16_STOP DBGMCU_APB2FZ_DBG_TIM16_STOP_Msk
#define DBGMCU_APB2FZ_DBG_TIM17_STOP_Pos (18U)
#define DBGMCU_APB2FZ_DBG_TIM17_STOP_Msk (0x1UL << DBGMCU_APB2FZ_DBG_TIM17_STOP_Pos)
#define DBGMCU_APB2FZ_DBG_TIM17_STOP DBGMCU_APB2FZ_DBG_TIM17_STOP_Msk
#define DBGMCU_APB2FZ_DBG_TIM20_STOP_Pos (20U)
#define DBGMCU_APB2FZ_DBG_TIM20_STOP_Msk (0x1UL << DBGMCU_APB2FZ_DBG_TIM20_STOP_Pos)
#define DBGMCU_APB2FZ_DBG_TIM20_STOP DBGMCU_APB2FZ_DBG_TIM20_STOP_Msk

/******************************************************************************/
/*                                                                            */
/*                           DMA Controller (DMA)                             */
/*                                                                            */
/******************************************************************************/

/*******************  Bit definition for DMA_ISR register  ********************/
#define DMA_ISR_GIF1_Pos (0U)
#define DMA_ISR_GIF1_Msk (0x1UL << DMA_ISR_GIF1_Pos)
#define DMA_ISR_GIF1 DMA_ISR_GIF1_Msk
#define DMA_ISR_TCIF1_Pos (1U)
#define DMA_ISR_TCIF1_Msk (0x1UL << DMA_ISR_TCIF1_Pos)
#define DMA_ISR_TCIF1 DMA_ISR_TCIF1_Msk
#define DMA_ISR_HTIF1_Pos (2U)
#define DMA_ISR_HTIF1_Msk (0x1UL << DMA_ISR_HTIF1_Pos)
#define DMA_ISR_HTIF1 DMA_ISR_HTIF1_Msk
#define DMA_ISR_TEIF1_Pos (3U)
#define DMA_ISR_TEIF1_Msk (0x1UL << DMA_ISR_TEIF1_Pos)
#define DMA_ISR_TEIF1 DMA_ISR_TEIF1_Msk
#define DMA_ISR_GIF2_Pos (4U)
#define DMA_ISR_GIF2_Msk (0x1UL << DMA_ISR_GIF2_Pos)
#define DMA_ISR_GIF2 DMA_ISR_GIF2_Msk
#define DMA_ISR_TCIF2_Pos (5U)
#define DMA_ISR_TCIF2_Msk (0x1UL << DMA_ISR_TCIF2_Pos)
#define DMA_ISR_TCIF2 DMA_ISR_TCIF2_Msk
#define DMA_ISR_HTIF2_Pos (6U)
#define DMA_ISR_HTIF2_Msk (0x1UL << DMA_ISR_HTIF2_Pos)
#define DMA_ISR_HTIF2 DMA_ISR_HTIF2_Msk
#define DMA_ISR_TEIF2_Pos (7U)
#define DMA_ISR_TEIF2_Msk (0x1UL << DMA_ISR_TEIF2_Pos)
#define DMA_ISR_TEIF2 DMA_ISR_TEIF2_Msk
#define DMA_ISR_GIF3_Pos (8U)
#define DMA_ISR_GIF3_Msk (0x1UL << DMA_ISR_GIF3_Pos)
#define DMA_ISR_GIF3 DMA_ISR_GIF3_Msk
#define DMA_ISR_TCIF3_Pos (9U)
#define DMA_ISR_TCIF3_Msk (0x1UL << DMA_ISR_TCIF3_Pos)
#define DMA_ISR_TCIF3 DMA_ISR_TCIF3_Msk
#define DMA_ISR_HTIF3_Pos (10U)
#define DMA_ISR_HTIF3_Msk (0x1UL << DMA_ISR_HTIF3_Pos)
#define DMA_ISR_HTIF3 DMA_ISR_HTIF3_Msk
#define DMA_ISR_TEIF3_Pos (11U)
#define DMA_ISR_TEIF3_Msk (0x1UL << DMA_ISR_TEIF3_Pos)
#define DMA_ISR_TEIF3 DMA_ISR_TEIF3_Msk
#define DMA_ISR_GIF4_Pos (12U)
#define DMA_ISR_GIF4_Msk (0x1UL << DMA_ISR_GIF4_Pos)
#define DMA_ISR_GIF4 DMA_ISR_GIF4_Msk
#define DMA_ISR_TCIF4_Pos (13U)
#define DMA_ISR_TCIF4_Msk (0x1UL << DMA_ISR_TCIF4_Pos)
#define DMA_ISR_TCIF4 DMA_ISR_TCIF4_Msk
#define DMA_ISR_HTIF4_Pos (14U)
#define DMA_ISR_HTIF4_Msk (0x1UL << DMA_ISR_HTIF4_Pos)
#define DMA_ISR_HTIF4 DMA_ISR_HTIF4_Msk
#define DMA_ISR_TEIF4_Pos (15U)
#define DMA_ISR_TEIF4_Msk (0x1UL << DMA_ISR_TEIF4_Pos)
#define DMA_ISR_TEIF4 DMA_ISR_TEIF4_Msk
#define DMA_ISR_GIF5_Pos (16U)
#define DMA_ISR_GIF5_Msk (0x1UL << DMA_ISR_GIF5_Pos)
#define DMA_ISR_GIF5 DMA_ISR_GIF5_Msk
#define DMA_ISR_TCIF5_Pos (17U)
#define DMA_ISR_TCIF5_Msk (0x1UL << DMA_ISR_TCIF5_Pos)
#define DMA_ISR_TCIF5 DMA_ISR_TCIF5_Msk
#define DMA_ISR_HTIF5_Pos (18U)
#define DMA_ISR_HTIF5_Msk (0x1UL << DMA_ISR_HTIF5_Pos)
#define DMA_ISR_HTIF5 DMA_ISR_HTIF5_Msk
#define DMA_ISR_TEIF5_Pos (19U)
#define DMA_ISR_TEIF5_Msk (0x1UL << DMA_ISR_TEIF5_Pos)
#define DMA_ISR_TEIF5 DMA_ISR_TEIF5_Msk
#define DMA_ISR_GIF6_Pos (20U)
#define DMA_ISR_GIF6_Msk (0x1UL << DMA_ISR_GIF6_Pos)
#define DMA_ISR_GIF6 DMA_ISR_GIF6_Msk
#define DMA_ISR_TCIF6_Pos (21U)
#define DMA_ISR_TCIF6_Msk (0x1UL << DMA_ISR_TCIF6_Pos)
#define DMA_ISR_TCIF6 DMA_ISR_TCIF6_Msk
#define DMA_ISR_HTIF6_Pos (22U)
#define DMA_ISR_HTIF6_Msk (0x1UL << DMA_ISR_HTIF6_Pos)
#define DMA_ISR_HTIF6 DMA_ISR_HTIF6_Msk
#define DMA_ISR_TEIF6_Pos (23U)
#define DMA_ISR_TEIF6_Msk (0x1UL << DMA_ISR_TEIF6_Pos)
#define DMA_ISR_TEIF6 DMA_ISR_TEIF6_Msk
#define DMA_ISR_GIF7_Pos (24U)
#define DMA_ISR_GIF7_Msk (0x1UL << DMA_ISR_GIF7_Pos)
#define DMA_ISR_GIF7 DMA_ISR_GIF7_Msk
#define DMA_ISR_TCIF7_Pos (25U)
#define DMA_ISR_TCIF7_Msk (0x1UL << DMA_ISR_TCIF7_Pos)
#define DMA_ISR_TCIF7 DMA_ISR_TCIF7_Msk
#define DMA_ISR_HTIF7_Pos (26U)
#define DMA_ISR_HTIF7_Msk (0x1UL << DMA_ISR_HTIF7_Pos)
#define DMA_ISR_HTIF7 DMA_ISR_HTIF7_Msk
#define DMA_ISR_TEIF7_Pos (27U)
#define DMA_ISR_TEIF7_Msk (0x1UL << DMA_ISR_TEIF7_Pos)
#define DMA_ISR_TEIF7 DMA_ISR_TEIF7_Msk
#define DMA_ISR_GIF8_Pos (28U)
#define DMA_ISR_GIF8_Msk (0x1UL << DMA_ISR_GIF8_Pos)
#define DMA_ISR_GIF8 DMA_ISR_GIF8_Msk
#define DMA_ISR_TCIF8_Pos (29U)
#define DMA_ISR_TCIF8_Msk (0x1UL << DMA_ISR_TCIF8_Pos)
#define DMA_ISR_TCIF8 DMA_ISR_TCIF8_Msk
#define DMA_ISR_HTIF8_Pos (30U)
#define DMA_ISR_HTIF8_Msk (0x1UL << DMA_ISR_HTIF8_Pos)
#define DMA_ISR_HTIF8 DMA_ISR_HTIF8_Msk
#define DMA_ISR_TEIF8_Pos (31U)
#define DMA_ISR_TEIF8_Msk (0x1UL << DMA_ISR_TEIF8_Pos)
#define DMA_ISR_TEIF8 DMA_ISR_TEIF8_Msk

/*******************  Bit definition for DMA_IFCR register  *******************/
#define DMA_IFCR_CGIF1_Pos (0U)
#define DMA_IFCR_CGIF1_Msk (0x1UL << DMA_IFCR_CGIF1_Pos)
#define DMA_IFCR_CGIF1 DMA_IFCR_CGIF1_Msk
#define DMA_IFCR_CTCIF1_Pos (1U)
#define DMA_IFCR_CTCIF1_Msk (0x1UL << DMA_IFCR_CTCIF1_Pos)
#define DMA_IFCR_CTCIF1 DMA_IFCR_CTCIF1_Msk
#define DMA_IFCR_CHTIF1_Pos (2U)
#define DMA_IFCR_CHTIF1_Msk (0x1UL << DMA_IFCR_CHTIF1_Pos)
#define DMA_IFCR_CHTIF1 DMA_IFCR_CHTIF1_Msk
#define DMA_IFCR_CTEIF1_Pos (3U)
#define DMA_IFCR_CTEIF1_Msk (0x1UL << DMA_IFCR_CTEIF1_Pos)
#define DMA_IFCR_CTEIF1 DMA_IFCR_CTEIF1_Msk
#define DMA_IFCR_CGIF2_Pos (4U)
#define DMA_IFCR_CGIF2_Msk (0x1UL << DMA_IFCR_CGIF2_Pos)
#define DMA_IFCR_CGIF2 DMA_IFCR_CGIF2_Msk
#define DMA_IFCR_CTCIF2_Pos (5U)
#define DMA_IFCR_CTCIF2_Msk (0x1UL << DMA_IFCR_CTCIF2_Pos)
#define DMA_IFCR_CTCIF2 DMA_IFCR_CTCIF2_Msk
#define DMA_IFCR_CHTIF2_Pos (6U)
#define DMA_IFCR_CHTIF2_Msk (0x1UL << DMA_IFCR_CHTIF2_Pos)
#define DMA_IFCR_CHTIF2 DMA_IFCR_CHTIF2_Msk
#define DMA_IFCR_CTEIF2_Pos (7U)
#define DMA_IFCR_CTEIF2_Msk (0x1UL << DMA_IFCR_CTEIF2_Pos)
#define DMA_IFCR_CTEIF2 DMA_IFCR_CTEIF2_Msk
#define DMA_IFCR_CGIF3_Pos (8U)
#define DMA_IFCR_CGIF3_Msk (0x1UL << DMA_IFCR_CGIF3_Pos)
#define DMA_IFCR_CGIF3 DMA_IFCR_CGIF3_Msk
#define DMA_IFCR_CTCIF3_Pos (9U)
#define DMA_IFCR_CTCIF3_Msk (0x1UL << DMA_IFCR_CTCIF3_Pos)
#define DMA_IFCR_CTCIF3 DMA_IFCR_CTCIF3_Msk
#define DMA_IFCR_CHTIF3_Pos (10U)
#define DMA_IFCR_CHTIF3_Msk (0x1UL << DMA_IFCR_CHTIF3_Pos)
#define DMA_IFCR_CHTIF3 DMA_IFCR_CHTIF3_Msk
#define DMA_IFCR_CTEIF3_Pos (11U)
#define DMA_IFCR_CTEIF3_Msk (0x1UL << DMA_IFCR_CTEIF3_Pos)
#define DMA_IFCR_CTEIF3 DMA_IFCR_CTEIF3_Msk
#define DMA_IFCR_CGIF4_Pos (12U)
#define DMA_IFCR_CGIF4_Msk (0x1UL << DMA_IFCR_CGIF4_Pos)
#define DMA_IFCR_CGIF4 DMA_IFCR_CGIF4_Msk
#define DMA_IFCR_CTCIF4_Pos (13U)
#define DMA_IFCR_CTCIF4_Msk (0x1UL << DMA_IFCR_CTCIF4_Pos)
#define DMA_IFCR_CTCIF4 DMA_IFCR_CTCIF4_Msk
#define DMA_IFCR_CHTIF4_Pos (14U)
#define DMA_IFCR_CHTIF4_Msk (0x1UL << DMA_IFCR_CHTIF4_Pos)
#define DMA_IFCR_CHTIF4 DMA_IFCR_CHTIF4_Msk
#define DMA_IFCR_CTEIF4_Pos (15U)
#define DMA_IFCR_CTEIF4_Msk (0x1UL << DMA_IFCR_CTEIF4_Pos)
#define DMA_IFCR_CTEIF4 DMA_IFCR_CTEIF4_Msk
#define DMA_IFCR_CGIF5_Pos (16U)
#define DMA_IFCR_CGIF5_Msk (0x1UL << DMA_IFCR_CGIF5_Pos)
#define DMA_IFCR_CGIF5 DMA_IFCR_CGIF5_Msk
#define DMA_IFCR_CTCIF5_Pos (17U)
#define DMA_IFCR_CTCIF5_Msk (0x1UL << DMA_IFCR_CTCIF5_Pos)
#define DMA_IFCR_CTCIF5 DMA_IFCR_CTCIF5_Msk
#define DMA_IFCR_CHTIF5_Pos (18U)
#define DMA_IFCR_CHTIF5_Msk (0x1UL << DMA_IFCR_CHTIF5_Pos)
#define DMA_IFCR_CHTIF5 DMA_IFCR_CHTIF5_Msk
#define DMA_IFCR_CTEIF5_Pos (19U)
#define DMA_IFCR_CTEIF5_Msk (0x1UL << DMA_IFCR_CTEIF5_Pos)
#define DMA_IFCR_CTEIF5 DMA_IFCR_CTEIF5_Msk
#define DMA_IFCR_CGIF6_Pos (20U)
#define DMA_IFCR_CGIF6_Msk (0x1UL << DMA_IFCR_CGIF6_Pos)
#define DMA_IFCR_CGIF6 DMA_IFCR_CGIF6_Msk
#define DMA_IFCR_CTCIF6_Pos (21U)
#define DMA_IFCR_CTCIF6_Msk (0x1UL << DMA_IFCR_CTCIF6_Pos)
#define DMA_IFCR_CTCIF6 DMA_IFCR_CTCIF6_Msk
#define DMA_IFCR_CHTIF6_Pos (22U)
#define DMA_IFCR_CHTIF6_Msk (0x1UL << DMA_IFCR_CHTIF6_Pos)
#define DMA_IFCR_CHTIF6 DMA_IFCR_CHTIF6_Msk
#define DMA_IFCR_CTEIF6_Pos (23U)
#define DMA_IFCR_CTEIF6_Msk (0x1UL << DMA_IFCR_CTEIF6_Pos)
#define DMA_IFCR_CTEIF6 DMA_IFCR_CTEIF6_Msk
#define DMA_IFCR_CGIF7_Pos (24U)
#define DMA_IFCR_CGIF7_Msk (0x1UL << DMA_IFCR_CGIF7_Pos)
#define DMA_IFCR_CGIF7 DMA_IFCR_CGIF7_Msk
#define DMA_IFCR_CTCIF7_Pos (25U)
#define DMA_IFCR_CTCIF7_Msk (0x1UL << DMA_IFCR_CTCIF7_Pos)
#define DMA_IFCR_CTCIF7 DMA_IFCR_CTCIF7_Msk
#define DMA_IFCR_CHTIF7_Pos (26U)
#define DMA_IFCR_CHTIF7_Msk (0x1UL << DMA_IFCR_CHTIF7_Pos)
#define DMA_IFCR_CHTIF7 DMA_IFCR_CHTIF7_Msk
#define DMA_IFCR_CTEIF7_Pos (27U)
#define DMA_IFCR_CTEIF7_Msk (0x1UL << DMA_IFCR_CTEIF7_Pos)
#define DMA_IFCR_CTEIF7 DMA_IFCR_CTEIF7_Msk
#define DMA_IFCR_CGIF8_Pos (28U)
#define DMA_IFCR_CGIF8_Msk (0x1UL << DMA_IFCR_CGIF8_Pos)
#define DMA_IFCR_CGIF8 DMA_IFCR_CGIF8_Msk
#define DMA_IFCR_CTCIF8_Pos (29U)
#define DMA_IFCR_CTCIF8_Msk (0x1UL << DMA_IFCR_CTCIF8_Pos)
#define DMA_IFCR_CTCIF8 DMA_IFCR_CTCIF8_Msk
#define DMA_IFCR_CHTIF8_Pos (30U)
#define DMA_IFCR_CHTIF8_Msk (0x1UL << DMA_IFCR_CHTIF8_Pos)
#define DMA_IFCR_CHTIF8 DMA_IFCR_CHTIF8_Msk
#define DMA_IFCR_CTEIF8_Pos (31U)
#define DMA_IFCR_CTEIF8_Msk (0x1UL << DMA_IFCR_CTEIF8_Pos)
#define DMA_IFCR_CTEIF8 DMA_IFCR_CTEIF8_Msk

/*******************  Bit definition for DMA_CCR register  ********************/
#define DMA_CCR_EN_Pos (0U)
#define DMA_CCR_EN_Msk (0x1UL << DMA_CCR_EN_Pos)
#define DMA_CCR_EN DMA_CCR_EN_Msk
#define DMA_CCR_TCIE_Pos (1U)
#define DMA_CCR_TCIE_Msk (0x1UL << DMA_CCR_TCIE_Pos)
#define DMA_CCR_TCIE DMA_CCR_TCIE_Msk
#define DMA_CCR_HTIE_Pos (2U)
#define DMA_CCR_HTIE_Msk (0x1UL << DMA_CCR_HTIE_Pos)
#define DMA_CCR_HTIE DMA_CCR_HTIE_Msk
#define DMA_CCR_TEIE_Pos (3U)
#define DMA_CCR_TEIE_Msk (0x1UL << DMA_CCR_TEIE_Pos)
#define DMA_CCR_TEIE DMA_CCR_TEIE_Msk
#define DMA_CCR_DIR_Pos (4U)
#define DMA_CCR_DIR_Msk (0x1UL << DMA_CCR_DIR_Pos)
#define DMA_CCR_DIR DMA_CCR_DIR_Msk
#define DMA_CCR_CIRC_Pos (5U)
#define DMA_CCR_CIRC_Msk (0x1UL << DMA_CCR_CIRC_Pos)
#define DMA_CCR_CIRC DMA_CCR_CIRC_Msk
#define DMA_CCR_PINC_Pos (6U)
#define DMA_CCR_PINC_Msk (0x1UL << DMA_CCR_PINC_Pos)
#define DMA_CCR_PINC DMA_CCR_PINC_Msk
#define DMA_CCR_MINC_Pos (7U)
#define DMA_CCR_MINC_Msk (0x1UL << DMA_CCR_MINC_Pos)
#define DMA_CCR_MINC DMA_CCR_MINC_Msk

#define DMA_CCR_PSIZE_Pos (8U)
#define DMA_CCR_PSIZE_Msk (0x3UL << DMA_CCR_PSIZE_Pos)
#define DMA_CCR_PSIZE DMA_CCR_PSIZE_Msk
#define DMA_CCR_PSIZE_0 (0x1UL << DMA_CCR_PSIZE_Pos)
#define DMA_CCR_PSIZE_1 (0x2UL << DMA_CCR_PSIZE_Pos)

#define DMA_CCR_MSIZE_Pos (10U)
#define DMA_CCR_MSIZE_Msk (0x3UL << DMA_CCR_MSIZE_Pos)
#define DMA_CCR_MSIZE DMA_CCR_MSIZE_Msk
#define DMA_CCR_MSIZE_0 (0x1UL << DMA_CCR_MSIZE_Pos)
#define DMA_CCR_MSIZE_1 (0x2UL << DMA_CCR_MSIZE_Pos)

#define DMA_CCR_PL_Pos (12U)
#define DMA_CCR_PL_Msk (0x3UL << DMA_CCR_PL_Pos)
#define DMA_CCR_PL DMA_CCR_PL_Msk
#define DMA_CCR_PL_0 (0x1UL << DMA_CCR_PL_Pos)
#define DMA_CCR_PL_1 (0x2UL << DMA_CCR_PL_Pos)

#define DMA_CCR_MEM2MEM_Pos (14U)
#define DMA_CCR_MEM2MEM_Msk (0x1UL << DMA_CCR_MEM2MEM_Pos)
#define DMA_CCR_MEM2MEM DMA_CCR_MEM2MEM_Msk

/******************  Bit definition for DMA_CNDTR register  *******************/
#define DMA_CNDTR_NDT_Pos (0U)
#define DMA_CNDTR_NDT_Msk (0xFFFFUL << DMA_CNDTR_NDT_Pos)
#define DMA_CNDTR_NDT DMA_CNDTR_NDT_Msk

/******************  Bit definition for DMA_CPAR register  ********************/
#define DMA_CPAR_PA_Pos (0U)
#define DMA_CPAR_PA_Msk (0xFFFFFFFFUL << DMA_CPAR_PA_Pos)
#define DMA_CPAR_PA DMA_CPAR_PA_Msk

/******************  Bit definition for DMA_CMAR register  ********************/
#define DMA_CMAR_MA_Pos (0U)
#define DMA_CMAR_MA_Msk (0xFFFFFFFFUL << DMA_CMAR_MA_Pos)
#define DMA_CMAR_MA DMA_CMAR_MA_Msk

/******************************************************************************/
/*                                                                            */
/*                             DMAMUX Controller                              */
/*                                                                            */
/******************************************************************************/

/********************  Bits definition for DMAMUX_CxCR register  **************/
#define DMAMUX_CxCR_DMAREQ_ID_Pos (0U)
#define DMAMUX_CxCR_DMAREQ_ID_Msk (0xFFUL << DMAMUX_CxCR_DMAREQ_ID_Pos)
#define DMAMUX_CxCR_DMAREQ_ID DMAMUX_CxCR_DMAREQ_ID_Msk
#define DMAMUX_CxCR_DMAREQ_ID_0 (0x01UL << DMAMUX_CxCR_DMAREQ_ID_Pos)
#define DMAMUX_CxCR_DMAREQ_ID_1 (0x02UL << DMAMUX_CxCR_DMAREQ_ID_Pos)
#define DMAMUX_CxCR_DMAREQ_ID_2 (0x04UL << DMAMUX_CxCR_DMAREQ_ID_Pos)
#define DMAMUX_CxCR_DMAREQ_ID_3 (0x08UL << DMAMUX_CxCR_DMAREQ_ID_Pos)
#define DMAMUX_CxCR_DMAREQ_ID_4 (0x10UL << DMAMUX_CxCR_DMAREQ_ID_Pos)
#define DMAMUX_CxCR_DMAREQ_ID_5 (0x20UL << DMAMUX_CxCR_DMAREQ_ID_Pos)
#define DMAMUX_CxCR_DMAREQ_ID_6 (0x40UL << DMAMUX_CxCR_DMAREQ_ID_Pos)
#define DMAMUX_CxCR_DMAREQ_ID_7 (0x80UL << DMAMUX_CxCR_DMAREQ_ID_Pos)

#define DMAMUX_CxCR_SOIE_Pos (8U)
#define DMAMUX_CxCR_SOIE_Msk (0x1UL << DMAMUX_CxCR_SOIE_Pos)
#define DMAMUX_CxCR_SOIE DMAMUX_CxCR_SOIE_Msk

#define DMAMUX_CxCR_EGE_Pos (9U)
#define DMAMUX_CxCR_EGE_Msk (0x1UL << DMAMUX_CxCR_EGE_Pos)
#define DMAMUX_CxCR_EGE DMAMUX_CxCR_EGE_Msk

#define DMAMUX_CxCR_SE_Pos (16U)
#define DMAMUX_CxCR_SE_Msk (0x1UL << DMAMUX_CxCR_SE_Pos)
#define DMAMUX_CxCR_SE DMAMUX_CxCR_SE_Msk

#define DMAMUX_CxCR_SPOL_Pos (17U)
#define DMAMUX_CxCR_SPOL_Msk (0x3UL << DMAMUX_CxCR_SPOL_Pos)
#define DMAMUX_CxCR_SPOL DMAMUX_CxCR_SPOL_Msk
#define DMAMUX_CxCR_SPOL_0 (0x1UL << DMAMUX_CxCR_SPOL_Pos)
#define DMAMUX_CxCR_SPOL_1 (0x2UL << DMAMUX_CxCR_SPOL_Pos)

#define DMAMUX_CxCR_NBREQ_Pos (19U)
#define DMAMUX_CxCR_NBREQ_Msk (0x1FUL << DMAMUX_CxCR_NBREQ_Pos)
#define DMAMUX_CxCR_NBREQ DMAMUX_CxCR_NBREQ_Msk
#define DMAMUX_CxCR_NBREQ_0 (0x01UL << DMAMUX_CxCR_NBREQ_Pos)
#define DMAMUX_CxCR_NBREQ_1 (0x02UL << DMAMUX_CxCR_NBREQ_Pos)
#define DMAMUX_CxCR_NBREQ_2 (0x04UL << DMAMUX_CxCR_NBREQ_Pos)
#define DMAMUX_CxCR_NBREQ_3 (0x08UL << DMAMUX_CxCR_NBREQ_Pos)
#define DMAMUX_CxCR_NBREQ_4 (0x10UL << DMAMUX_CxCR_NBREQ_Pos)

#define DMAMUX_CxCR_SYNC_ID_Pos (24U)
#define DMAMUX_CxCR_SYNC_ID_Msk (0x1FUL << DMAMUX_CxCR_SYNC_ID_Pos)
#define DMAMUX_CxCR_SYNC_ID DMAMUX_CxCR_SYNC_ID_Msk
#define DMAMUX_CxCR_SYNC_ID_0 (0x01UL << DMAMUX_CxCR_SYNC_ID_Pos)
#define DMAMUX_CxCR_SYNC_ID_1 (0x02UL << DMAMUX_CxCR_SYNC_ID_Pos)
#define DMAMUX_CxCR_SYNC_ID_2 (0x04UL << DMAMUX_CxCR_SYNC_ID_Pos)
#define DMAMUX_CxCR_SYNC_ID_3 (0x08UL << DMAMUX_CxCR_SYNC_ID_Pos)
#define DMAMUX_CxCR_SYNC_ID_4 (0x10UL << DMAMUX_CxCR_SYNC_ID_Pos)

/********************  Bits definition for DMAMUX_CSR register  ****************/
#define DMAMUX_CSR_SOF0_Pos (0U)
#define DMAMUX_CSR_SOF0_Msk (0x1UL << DMAMUX_CSR_SOF0_Pos)
#define DMAMUX_CSR_SOF0 DMAMUX_CSR_SOF0_Msk
#define DMAMUX_CSR_SOF1_Pos (1U)
#define DMAMUX_CSR_SOF1_Msk (0x1UL << DMAMUX_CSR_SOF1_Pos)
#define DMAMUX_CSR_SOF1 DMAMUX_CSR_SOF1_Msk
#define DMAMUX_CSR_SOF2_Pos (2U)
#define DMAMUX_CSR_SOF2_Msk (0x1UL << DMAMUX_CSR_SOF2_Pos)
#define DMAMUX_CSR_SOF2 DMAMUX_CSR_SOF2_Msk
#define DMAMUX_CSR_SOF3_Pos (3U)
#define DMAMUX_CSR_SOF3_Msk (0x1UL << DMAMUX_CSR_SOF3_Pos)
#define DMAMUX_CSR_SOF3 DMAMUX_CSR_SOF3_Msk
#define DMAMUX_CSR_SOF4_Pos (4U)
#define DMAMUX_CSR_SOF4_Msk (0x1UL << DMAMUX_CSR_SOF4_Pos)
#define DMAMUX_CSR_SOF4 DMAMUX_CSR_SOF4_Msk
#define DMAMUX_CSR_SOF5_Pos (5U)
#define DMAMUX_CSR_SOF5_Msk (0x1UL << DMAMUX_CSR_SOF5_Pos)
#define DMAMUX_CSR_SOF5 DMAMUX_CSR_SOF5_Msk
#define DMAMUX_CSR_SOF6_Pos (6U)
#define DMAMUX_CSR_SOF6_Msk (0x1UL << DMAMUX_CSR_SOF6_Pos)
#define DMAMUX_CSR_SOF6 DMAMUX_CSR_SOF6_Msk
#define DMAMUX_CSR_SOF7_Pos (7U)
#define DMAMUX_CSR_SOF7_Msk (0x1UL << DMAMUX_CSR_SOF7_Pos)
#define DMAMUX_CSR_SOF7 DMAMUX_CSR_SOF7_Msk
#define DMAMUX_CSR_SOF8_Pos (8U)
#define DMAMUX_CSR_SOF8_Msk (0x1UL << DMAMUX_CSR_SOF8_Pos)
#define DMAMUX_CSR_SOF8 DMAMUX_CSR_SOF8_Msk
#define DMAMUX_CSR_SOF9_Pos (9U)
#define DMAMUX_CSR_SOF9_Msk (0x1UL << DMAMUX_CSR_SOF9_Pos)
#define DMAMUX_CSR_SOF9 DMAMUX_CSR_SOF9_Msk
#define DMAMUX_CSR_SOF10_Pos (10U)
#define DMAMUX_CSR_SOF10_Msk (0x1UL << DMAMUX_CSR_SOF10_Pos)
#define DMAMUX_CSR_SOF10 DMAMUX_CSR_SOF10_Msk
#define DMAMUX_CSR_SOF11_Pos (11U)
#define DMAMUX_CSR_SOF11_Msk (0x1UL << DMAMUX_CSR_SOF11_Pos)
#define DMAMUX_CSR_SOF11 DMAMUX_CSR_SOF11_Msk
#define DMAMUX_CSR_SOF12_Pos (12U)
#define DMAMUX_CSR_SOF12_Msk (0x1UL << DMAMUX_CSR_SOF12_Pos)
#define DMAMUX_CSR_SOF12 DMAMUX_CSR_SOF12_Msk
#define DMAMUX_CSR_SOF13_Pos (13U)
#define DMAMUX_CSR_SOF13_Msk (0x1UL << DMAMUX_CSR_SOF13_Pos)
#define DMAMUX_CSR_SOF13 DMAMUX_CSR_SOF13_Msk
#define DMAMUX_CSR_SOF14_Pos (14U)
#define DMAMUX_CSR_SOF14_Msk (0x1UL << DMAMUX_CSR_SOF14_Pos)
#define DMAMUX_CSR_SOF14 DMAMUX_CSR_SOF14_Msk
#define DMAMUX_CSR_SOF15_Pos (15U)
#define DMAMUX_CSR_SOF15_Msk (0x1UL << DMAMUX_CSR_SOF15_Pos)
#define DMAMUX_CSR_SOF15 DMAMUX_CSR_SOF15_Msk

/********************  Bits definition for DMAMUX_CFR register  ****************/
#define DMAMUX_CFR_CSOF0_Pos (0U)
#define DMAMUX_CFR_CSOF0_Msk (0x1UL << DMAMUX_CFR_CSOF0_Pos)
#define DMAMUX_CFR_CSOF0 DMAMUX_CFR_CSOF0_Msk
#define DMAMUX_CFR_CSOF1_Pos (1U)
#define DMAMUX_CFR_CSOF1_Msk (0x1UL << DMAMUX_CFR_CSOF1_Pos)
#define DMAMUX_CFR_CSOF1 DMAMUX_CFR_CSOF1_Msk
#define DMAMUX_CFR_CSOF2_Pos (2U)
#define DMAMUX_CFR_CSOF2_Msk (0x1UL << DMAMUX_CFR_CSOF2_Pos)
#define DMAMUX_CFR_CSOF2 DMAMUX_CFR_CSOF2_Msk
#define DMAMUX_CFR_CSOF3_Pos (3U)
#define DMAMUX_CFR_CSOF3_Msk (0x1UL << DMAMUX_CFR_CSOF3_Pos)
#define DMAMUX_CFR_CSOF3 DMAMUX_CFR_CSOF3_Msk
#define DMAMUX_CFR_CSOF4_Pos (4U)
#define DMAMUX_CFR_CSOF4_Msk (0x1UL << DMAMUX_CFR_CSOF4_Pos)
#define DMAMUX_CFR_CSOF4 DMAMUX_CFR_CSOF4_Msk
#define DMAMUX_CFR_CSOF5_Pos (5U)
#define DMAMUX_CFR_CSOF5_Msk (0x1UL << DMAMUX_CFR_CSOF5_Pos)
#define DMAMUX_CFR_CSOF5 DMAMUX_CFR_CSOF5_Msk
#define DMAMUX_CFR_CSOF6_Pos (6U)
#define DMAMUX_CFR_CSOF6_Msk (0x1UL << DMAMUX_CFR_CSOF6_Pos)
#define DMAMUX_CFR_CSOF6 DMAMUX_CFR_CSOF6_Msk
#define DMAMUX_CFR_CSOF7_Pos (7U)
#define DMAMUX_CFR_CSOF7_Msk (0x1UL << DMAMUX_CFR_CSOF7_Pos)
#define DMAMUX_CFR_CSOF7 DMAMUX_CFR_CSOF7_Msk
#define DMAMUX_CFR_CSOF8_Pos (8U)
#define DMAMUX_CFR_CSOF8_Msk (0x1UL << DMAMUX_CFR_CSOF8_Pos)
#define DMAMUX_CFR_CSOF8 DMAMUX_CFR_CSOF8_Msk
#define DMAMUX_CFR_CSOF9_Pos (9U)
#define DMAMUX_CFR_CSOF9_Msk (0x1UL << DMAMUX_CFR_CSOF9_Pos)
#define DMAMUX_CFR_CSOF9 DMAMUX_CFR_CSOF9_Msk
#define DMAMUX_CFR_CSOF10_Pos (10U)
#define DMAMUX_CFR_CSOF10_Msk (0x1UL << DMAMUX_CFR_CSOF10_Pos)
#define DMAMUX_CFR_CSOF10 DMAMUX_CFR_CSOF10_Msk
#define DMAMUX_CFR_CSOF11_Pos (11U)
#define DMAMUX_CFR_CSOF11_Msk (0x1UL << DMAMUX_CFR_CSOF11_Pos)
#define DMAMUX_CFR_CSOF11 DMAMUX_CFR_CSOF11_Msk
#define DMAMUX_CFR_CSOF12_Pos (12U)
#define DMAMUX_CFR_CSOF12_Msk (0x1UL << DMAMUX_CFR_CSOF12_Pos)
#define DMAMUX_CFR_CSOF12 DMAMUX_CFR_CSOF12_Msk
#define DMAMUX_CFR_CSOF13_Pos (13U)
#define DMAMUX_CFR_CSOF13_Msk (0x1UL << DMAMUX_CFR_CSOF13_Pos)
#define DMAMUX_CFR_CSOF13 DMAMUX_CFR_CSOF13_Msk
#define DMAMUX_CFR_CSOF14_Pos (14U)
#define DMAMUX_CFR_CSOF14_Msk (0x1UL << DMAMUX_CFR_CSOF14_Pos)
#define DMAMUX_CFR_CSOF14 DMAMUX_CFR_CSOF14_Msk
#define DMAMUX_CFR_CSOF15_Pos (15U)
#define DMAMUX_CFR_CSOF15_Msk (0x1UL << DMAMUX_CFR_CSOF15_Pos)
#define DMAMUX_CFR_CSOF15 DMAMUX_CFR_CSOF15_Msk

/********************  Bits definition for DMAMUX_RGxCR register  ************/
#define DMAMUX_RGxCR_SIG_ID_Pos (0U)
#define DMAMUX_RGxCR_SIG_ID_Msk (0x1FUL << DMAMUX_RGxCR_SIG_ID_Pos)
#define DMAMUX_RGxCR_SIG_ID DMAMUX_RGxCR_SIG_ID_Msk
#define DMAMUX_RGxCR_SIG_ID_0 (0x01UL << DMAMUX_RGxCR_SIG_ID_Pos)
#define DMAMUX_RGxCR_SIG_ID_1 (0x02UL << DMAMUX_RGxCR_SIG_ID_Pos)
#define DMAMUX_RGxCR_SIG_ID_2 (0x04UL << DMAMUX_RGxCR_SIG_ID_Pos)
#define DMAMUX_RGxCR_SIG_ID_3 (0x08UL << DMAMUX_RGxCR_SIG_ID_Pos)
#define DMAMUX_RGxCR_SIG_ID_4 (0x10UL << DMAMUX_RGxCR_SIG_ID_Pos)

#define DMAMUX_RGxCR_OIE_Pos (8U)
#define DMAMUX_RGxCR_OIE_Msk (0x1UL << DMAMUX_RGxCR_OIE_Pos)
#define DMAMUX_RGxCR_OIE DMAMUX_RGxCR_OIE_Msk

#define DMAMUX_RGxCR_GE_Pos (16U)
#define DMAMUX_RGxCR_GE_Msk (0x1UL << DMAMUX_RGxCR_GE_Pos)
#define DMAMUX_RGxCR_GE DMAMUX_RGxCR_GE_Msk

#define DMAMUX_RGxCR_GPOL_Pos (17U)
#define DMAMUX_RGxCR_GPOL_Msk (0x3UL << DMAMUX_RGxCR_GPOL_Pos)
#define DMAMUX_RGxCR_GPOL DMAMUX_RGxCR_GPOL_Msk
#define DMAMUX_RGxCR_GPOL_0 (0x1UL << DMAMUX_RGxCR_GPOL_Pos)
#define DMAMUX_RGxCR_GPOL_1 (0x2UL << DMAMUX_RGxCR_GPOL_Pos)

#define DMAMUX_RGxCR_GNBREQ_Pos (19U)
#define DMAMUX_RGxCR_GNBREQ_Msk (0x1FUL << DMAMUX_RGxCR_GNBREQ_Pos)
#define DMAMUX_RGxCR_GNBREQ DMAMUX_RGxCR_GNBREQ_Msk
#define DMAMUX_RGxCR_GNBREQ_0 (0x01UL << DMAMUX_RGxCR_GNBREQ_Pos)
#define DMAMUX_RGxCR_GNBREQ_1 (0x02UL << DMAMUX_RGxCR_GNBREQ_Pos)
#define DMAMUX_RGxCR_GNBREQ_2 (0x04UL << DMAMUX_RGxCR_GNBREQ_Pos)
#define DMAMUX_RGxCR_GNBREQ_3 (0x08UL << DMAMUX_RGxCR_GNBREQ_Pos)
#define DMAMUX_RGxCR_GNBREQ_4 (0x10UL << DMAMUX_RGxCR_GNBREQ_Pos)

/********************  Bits definition for DMAMUX_RGSR register  **************/
#define DMAMUX_RGSR_OF0_Pos (0U)
#define DMAMUX_RGSR_OF0_Msk (0x1UL << DMAMUX_RGSR_OF0_Pos)
#define DMAMUX_RGSR_OF0 DMAMUX_RGSR_OF0_Msk
#define DMAMUX_RGSR_OF1_Pos (1U)
#define DMAMUX_RGSR_OF1_Msk (0x1UL << DMAMUX_RGSR_OF1_Pos)
#define DMAMUX_RGSR_OF1 DMAMUX_RGSR_OF1_Msk
#define DMAMUX_RGSR_OF2_Pos (2U)
#define DMAMUX_RGSR_OF2_Msk (0x1UL << DMAMUX_RGSR_OF2_Pos)
#define DMAMUX_RGSR_OF2 DMAMUX_RGSR_OF2_Msk
#define DMAMUX_RGSR_OF3_Pos (3U)
#define DMAMUX_RGSR_OF3_Msk (0x1UL << DMAMUX_RGSR_OF3_Pos)
#define DMAMUX_RGSR_OF3 DMAMUX_RGSR_OF3_Msk

/********************  Bits definition for DMAMUX_RGCFR register  ************/
#define DMAMUX_RGCFR_COF0_Pos (0U)
#define DMAMUX_RGCFR_COF0_Msk (0x1UL << DMAMUX_RGCFR_COF0_Pos)
#define DMAMUX_RGCFR_COF0 DMAMUX_RGCFR_COF0_Msk
#define DMAMUX_RGCFR_COF1_Pos (1U)
#define DMAMUX_RGCFR_COF1_Msk (0x1UL << DMAMUX_RGCFR_COF1_Pos)
#define DMAMUX_RGCFR_COF1 DMAMUX_RGCFR_COF1_Msk
#define DMAMUX_RGCFR_COF2_Pos (2U)
#define DMAMUX_RGCFR_COF2_Msk (0x1UL << DMAMUX_RGCFR_COF2_Pos)
#define DMAMUX_RGCFR_COF2 DMAMUX_RGCFR_COF2_Msk
#define DMAMUX_RGCFR_COF3_Pos (3U)
#define DMAMUX_RGCFR_COF3_Msk (0x1UL << DMAMUX_RGCFR_COF3_Pos)
#define DMAMUX_RGCFR_COF3 DMAMUX_RGCFR_COF3_Msk

/******************** Bits definition for DMAMUX_IPHW_CFGR2  ******************/
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ0_Pos (0U)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ0_Msk (0x1UL << DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ0_Pos)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ0 DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ0_Msk
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ1_Pos (1U)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ1_Msk (0x1UL << DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ1_Pos)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ1 DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ1_Msk
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ2_Pos (2U)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ2_Msk (0x1UL << DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ2_Pos)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ2 DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ2_Msk
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ3_Pos (3U)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ3_Msk (0x1UL << DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ3_Pos)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ3 DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ3_Msk
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ4_Pos (4U)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ4_Msk (0x1UL << DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ4_Pos)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ4 DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ4_Msk
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ5_Pos (5U)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ5_Msk (0x1UL << DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ5_Pos)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ5 DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ5_Msk
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ6_Pos (6U)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ6_Msk (0x1UL << DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ6_Pos)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ6 DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ6_Msk
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ7_Pos (7U)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ7_Msk (0x1UL << DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ7_Pos)
#define DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ7 DMAMUX_IPHW_CFGR2_NUM_DMA_EXT_REQ7_Msk

/******************** Bits definition for DMAMUX_IPHW_CFGR1  ******************/
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS0_Pos (0U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS0_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS0_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS0 DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS0_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS1_Pos (1U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS1_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS1_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS1 DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS1_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS2_Pos (2U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS2_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS2_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS2 DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS2_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS3_Pos (3U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS3_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS3_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS3 DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS3_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS4_Pos (4U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS4_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS4_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS4 DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS4_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS5_Pos (5U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS5_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS5_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS5 DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS5_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS6_Pos (6U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS6_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS6_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS6 DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS6_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS7_Pos (7U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS7_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS7_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS7 DMAMUX_IPHW_CFGR1_NUM_DMA_STREAMS7_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ0_Pos (8U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ0_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ0_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ0 DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ0_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ1_Pos (9U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ1_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ1_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ1 DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ1_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ2_Pos (10U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ2_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ2_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ2 DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ2_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ3_Pos (11U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ3_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ3_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ3 DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ3_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ4_Pos (12U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ4_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ4_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ4 DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ4_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ5_Pos (13U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ5_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ5_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ5 DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ5_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ6_Pos (14U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ6_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ6_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ6 DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ6_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ7_Pos (15U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ7_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ7_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ7 DMAMUX_IPHW_CFGR1_NUM_DMA_PERIPH_REQ7_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG0_Pos (16U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG0_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG0_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG0 DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG0_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG1_Pos (17U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG1_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG1_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG1 DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG1_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG2_Pos (18U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG2_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG2_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG2 DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG2_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG3_Pos (19U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG3_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG3_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG3 DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG3_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG4_Pos (20U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG4_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG4_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG4 DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG4_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG5_Pos (21U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG5_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG5_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG5 DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG5_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG6_Pos (22U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG6_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG6_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG6 DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG6_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG7_Pos (23U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG7_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG7_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG7 DMAMUX_IPHW_CFGR1_NUM_DMA_TRIG7_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN0_Pos (24U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN0_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN0_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN0 DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN0_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN1_Pos (25U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN1_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN1_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN1 DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN1_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN2_Pos (26U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN2_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN2_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN2 DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN2_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN3_Pos (27U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN3_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN3_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN3 DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN3_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN4_Pos (28U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN4_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN4_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN4 DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN4_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN5_Pos (29U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN5_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN5_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN5 DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN5_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN6_Pos (30U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN6_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN6_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN6 DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN6_Msk
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN7_Pos (31U)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN7_Msk (0x1UL << DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN7_Pos)
#define DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN7 DMAMUX_IPHW_CFGR1_NUM_DMA_REQGEN7_Msk


/******************************************************************************/
/*                                                                            */
/*                    External Interrupt/Event Controller                     */
/*                                                                            */
/******************************************************************************/
/*******************  Bit definition for EXTI_IMR1 register  ******************/
#define EXTI_IMR1_IM0_Pos (0U)
#define EXTI_IMR1_IM0_Msk (0x1UL << EXTI_IMR1_IM0_Pos)
#define EXTI_IMR1_IM0 EXTI_IMR1_IM0_Msk
#define EXTI_IMR1_IM1_Pos (1U)
#define EXTI_IMR1_IM1_Msk (0x1UL << EXTI_IMR1_IM1_Pos)
#define EXTI_IMR1_IM1 EXTI_IMR1_IM1_Msk
#define EXTI_IMR1_IM2_Pos (2U)
#define EXTI_IMR1_IM2_Msk (0x1UL << EXTI_IMR1_IM2_Pos)
#define EXTI_IMR1_IM2 EXTI_IMR1_IM2_Msk
#define EXTI_IMR1_IM3_Pos (3U)
#define EXTI_IMR1_IM3_Msk (0x1UL << EXTI_IMR1_IM3_Pos)
#define EXTI_IMR1_IM3 EXTI_IMR1_IM3_Msk
#define EXTI_IMR1_IM4_Pos (4U)
#define EXTI_IMR1_IM4_Msk (0x1UL << EXTI_IMR1_IM4_Pos)
#define EXTI_IMR1_IM4 EXTI_IMR1_IM4_Msk
#define EXTI_IMR1_IM5_Pos (5U)
#define EXTI_IMR1_IM5_Msk (0x1UL << EXTI_IMR1_IM5_Pos)
#define EXTI_IMR1_IM5 EXTI_IMR1_IM5_Msk
#define EXTI_IMR1_IM6_Pos (6U)
#define EXTI_IMR1_IM6_Msk (0x1UL << EXTI_IMR1_IM6_Pos)
#define EXTI_IMR1_IM6 EXTI_IMR1_IM6_Msk
#define EXTI_IMR1_IM7_Pos (7U)
#define EXTI_IMR1_IM7_Msk (0x1UL << EXTI_IMR1_IM7_Pos)
#define EXTI_IMR1_IM7 EXTI_IMR1_IM7_Msk
#define EXTI_IMR1_IM8_Pos (8U)
#define EXTI_IMR1_IM8_Msk (0x1UL << EXTI_IMR1_IM8_Pos)
#define EXTI_IMR1_IM8 EXTI_IMR1_IM8_Msk
#define EXTI_IMR1_IM9_Pos (9U)
#define EXTI_IMR1_IM9_Msk (0x1UL << EXTI_IMR1_IM9_Pos)
#define EXTI_IMR1_IM9 EXTI_IMR1_IM9_Msk
#define EXTI_IMR1_IM10_Pos (10U)
#define EXTI_IMR1_IM10_Msk (0x1UL << EXTI_IMR1_IM10_Pos)
#define EXTI_IMR1_IM10 EXTI_IMR1_IM10_Msk
#define EXTI_IMR1_IM11_Pos (11U)
#define EXTI_IMR1_IM11_Msk (0x1UL << EXTI_IMR1_IM11_Pos)
#define EXTI_IMR1_IM11 EXTI_IMR1_IM11_Msk
#define EXTI_IMR1_IM12_Pos (12U)
#define EXTI_IMR1_IM12_Msk (0x1UL << EXTI_IMR1_IM12_Pos)
#define EXTI_IMR1_IM12 EXTI_IMR1_IM12_Msk
#define EXTI_IMR1_IM13_Pos (13U)
#define EXTI_IMR1_IM13_Msk (0x1UL << EXTI_IMR1_IM13_Pos)
#define EXTI_IMR1_IM13 EXTI_IMR1_IM13_Msk
#define EXTI_IMR1_IM14_Pos (14U)
#define EXTI_IMR1_IM14_Msk (0x1UL << EXTI_IMR1_IM14_Pos)
#define EXTI_IMR1_IM14 EXTI_IMR1_IM14_Msk
#define EXTI_IMR1_IM15_Pos (15U)
#define EXTI_IMR1_IM15_Msk (0x1UL << EXTI_IMR1_IM15_Pos)
#define EXTI_IMR1_IM15 EXTI_IMR1_IM15_Msk
#define EXTI_IMR1_IM16_Pos (16U)
#define EXTI_IMR1_IM16_Msk (0x1UL << EXTI_IMR1_IM16_Pos)
#define EXTI_IMR1_IM16 EXTI_IMR1_IM16_Msk
#define EXTI_IMR1_IM17_Pos (17U)
#define EXTI_IMR1_IM17_Msk (0x1UL << EXTI_IMR1_IM17_Pos)
#define EXTI_IMR1_IM17 EXTI_IMR1_IM17_Msk
#define EXTI_IMR1_IM18_Pos (18U)
#define EXTI_IMR1_IM18_Msk (0x1UL << EXTI_IMR1_IM18_Pos)
#define EXTI_IMR1_IM18 EXTI_IMR1_IM18_Msk
#define EXTI_IMR1_IM19_Pos (19U)
#define EXTI_IMR1_IM19_Msk (0x1UL << EXTI_IMR1_IM19_Pos)
#define EXTI_IMR1_IM19 EXTI_IMR1_IM19_Msk
#define EXTI_IMR1_IM20_Pos (20U)
#define EXTI_IMR1_IM20_Msk (0x1UL << EXTI_IMR1_IM20_Pos)
#define EXTI_IMR1_IM20 EXTI_IMR1_IM20_Msk
#define EXTI_IMR1_IM21_Pos (21U)
#define EXTI_IMR1_IM21_Msk (0x1UL << EXTI_IMR1_IM21_Pos)
#define EXTI_IMR1_IM21 EXTI_IMR1_IM21_Msk
#define EXTI_IMR1_IM22_Pos (22U)
#define EXTI_IMR1_IM22_Msk (0x1UL << EXTI_IMR1_IM22_Pos)
#define EXTI_IMR1_IM22 EXTI_IMR1_IM22_Msk
#define EXTI_IMR1_IM23_Pos (23U)
#define EXTI_IMR1_IM23_Msk (0x1UL << EXTI_IMR1_IM23_Pos)
#define EXTI_IMR1_IM23 EXTI_IMR1_IM23_Msk
#define EXTI_IMR1_IM24_Pos (24U)
#define EXTI_IMR1_IM24_Msk (0x1UL << EXTI_IMR1_IM24_Pos)
#define EXTI_IMR1_IM24 EXTI_IMR1_IM24_Msk
#define EXTI_IMR1_IM25_Pos (25U)
#define EXTI_IMR1_IM25_Msk (0x1UL << EXTI_IMR1_IM25_Pos)
#define EXTI_IMR1_IM25 EXTI_IMR1_IM25_Msk
#define EXTI_IMR1_IM26_Pos (26U)
#define EXTI_IMR1_IM26_Msk (0x1UL << EXTI_IMR1_IM26_Pos)
#define EXTI_IMR1_IM26 EXTI_IMR1_IM26_Msk
#define EXTI_IMR1_IM27_Pos (27U)
#define EXTI_IMR1_IM27_Msk (0x1UL << EXTI_IMR1_IM27_Pos)
#define EXTI_IMR1_IM27 EXTI_IMR1_IM27_Msk
#define EXTI_IMR1_IM28_Pos (28U)
#define EXTI_IMR1_IM28_Msk (0x1UL << EXTI_IMR1_IM28_Pos)
#define EXTI_IMR1_IM28 EXTI_IMR1_IM28_Msk
#define EXTI_IMR1_IM29_Pos (29U)
#define EXTI_IMR1_IM29_Msk (0x1UL << EXTI_IMR1_IM29_Pos)
#define EXTI_IMR1_IM29 EXTI_IMR1_IM29_Msk
#define EXTI_IMR1_IM30_Pos (30U)
#define EXTI_IMR1_IM30_Msk (0x1UL << EXTI_IMR1_IM30_Pos)
#define EXTI_IMR1_IM30 EXTI_IMR1_IM30_Msk
#define EXTI_IMR1_IM31_Pos (31U)
#define EXTI_IMR1_IM31_Msk (0x1UL << EXTI_IMR1_IM31_Pos)
#define EXTI_IMR1_IM31 EXTI_IMR1_IM31_Msk
#define EXTI_IMR1_IM_Pos (0U)
#define EXTI_IMR1_IM_Msk (0xFFFFFFFFUL << EXTI_IMR1_IM_Pos)
#define EXTI_IMR1_IM EXTI_IMR1_IM_Msk

/*******************  Bit definition for EXTI_EMR1 register  ******************/
#define EXTI_EMR1_EM0_Pos (0U)
#define EXTI_EMR1_EM0_Msk (0x1UL << EXTI_EMR1_EM0_Pos)
#define EXTI_EMR1_EM0 EXTI_EMR1_EM0_Msk
#define EXTI_EMR1_EM1_Pos (1U)
#define EXTI_EMR1_EM1_Msk (0x1UL << EXTI_EMR1_EM1_Pos)
#define EXTI_EMR1_EM1 EXTI_EMR1_EM1_Msk
#define EXTI_EMR1_EM2_Pos (2U)
#define EXTI_EMR1_EM2_Msk (0x1UL << EXTI_EMR1_EM2_Pos)
#define EXTI_EMR1_EM2 EXTI_EMR1_EM2_Msk
#define EXTI_EMR1_EM3_Pos (3U)
#define EXTI_EMR1_EM3_Msk (0x1UL << EXTI_EMR1_EM3_Pos)
#define EXTI_EMR1_EM3 EXTI_EMR1_EM3_Msk
#define EXTI_EMR1_EM4_Pos (4U)
#define EXTI_EMR1_EM4_Msk (0x1UL << EXTI_EMR1_EM4_Pos)
#define EXTI_EMR1_EM4 EXTI_EMR1_EM4_Msk
#define EXTI_EMR1_EM5_Pos (5U)
#define EXTI_EMR1_EM5_Msk (0x1UL << EXTI_EMR1_EM5_Pos)
#define EXTI_EMR1_EM5 EXTI_EMR1_EM5_Msk
#define EXTI_EMR1_EM6_Pos (6U)
#define EXTI_EMR1_EM6_Msk (0x1UL << EXTI_EMR1_EM6_Pos)
#define EXTI_EMR1_EM6 EXTI_EMR1_EM6_Msk
#define EXTI_EMR1_EM7_Pos (7U)
#define EXTI_EMR1_EM7_Msk (0x1UL << EXTI_EMR1_EM7_Pos)
#define EXTI_EMR1_EM7 EXTI_EMR1_EM7_Msk
#define EXTI_EMR1_EM8_Pos (8U)
#define EXTI_EMR1_EM8_Msk (0x1UL << EXTI_EMR1_EM8_Pos)
#define EXTI_EMR1_EM8 EXTI_EMR1_EM8_Msk
#define EXTI_EMR1_EM9_Pos (9U)
#define EXTI_EMR1_EM9_Msk (0x1UL << EXTI_EMR1_EM9_Pos)
#define EXTI_EMR1_EM9 EXTI_EMR1_EM9_Msk
#define EXTI_EMR1_EM10_Pos (10U)
#define EXTI_EMR1_EM10_Msk (0x1UL << EXTI_EMR1_EM10_Pos)
#define EXTI_EMR1_EM10 EXTI_EMR1_EM10_Msk
#define EXTI_EMR1_EM11_Pos (11U)
#define EXTI_EMR1_EM11_Msk (0x1UL << EXTI_EMR1_EM11_Pos)
#define EXTI_EMR1_EM11 EXTI_EMR1_EM11_Msk
#define EXTI_EMR1_EM12_Pos (12U)
#define EXTI_EMR1_EM12_Msk (0x1UL << EXTI_EMR1_EM12_Pos)
#define EXTI_EMR1_EM12 EXTI_EMR1_EM12_Msk
#define EXTI_EMR1_EM13_Pos (13U)
#define EXTI_EMR1_EM13_Msk (0x1UL << EXTI_EMR1_EM13_Pos)
#define EXTI_EMR1_EM13 EXTI_EMR1_EM13_Msk
#define EXTI_EMR1_EM14_Pos (14U)
#define EXTI_EMR1_EM14_Msk (0x1UL << EXTI_EMR1_EM14_Pos)
#define EXTI_EMR1_EM14 EXTI_EMR1_EM14_Msk
#define EXTI_EMR1_EM15_Pos (15U)
#define EXTI_EMR1_EM15_Msk (0x1UL << EXTI_EMR1_EM15_Pos)
#define EXTI_EMR1_EM15 EXTI_EMR1_EM15_Msk
#define EXTI_EMR1_EM16_Pos (16U)
#define EXTI_EMR1_EM16_Msk (0x1UL << EXTI_EMR1_EM16_Pos)
#define EXTI_EMR1_EM16 EXTI_EMR1_EM16_Msk
#define EXTI_EMR1_EM17_Pos (17U)
#define EXTI_EMR1_EM17_Msk (0x1UL << EXTI_EMR1_EM17_Pos)
#define EXTI_EMR1_EM17 EXTI_EMR1_EM17_Msk
#define EXTI_EMR1_EM18_Pos (18U)
#define EXTI_EMR1_EM18_Msk (0x1UL << EXTI_EMR1_EM18_Pos)
#define EXTI_EMR1_EM18 EXTI_EMR1_EM18_Msk
#define EXTI_EMR1_EM19_Pos (19U)
#define EXTI_EMR1_EM19_Msk (0x1UL << EXTI_EMR1_EM19_Pos)
#define EXTI_EMR1_EM19 EXTI_EMR1_EM19_Msk
#define EXTI_EMR1_EM20_Pos (20U)
#define EXTI_EMR1_EM20_Msk (0x1UL << EXTI_EMR1_EM20_Pos)
#define EXTI_EMR1_EM20 EXTI_EMR1_EM20_Msk
#define EXTI_EMR1_EM21_Pos (21U)
#define EXTI_EMR1_EM21_Msk (0x1UL << EXTI_EMR1_EM21_Pos)
#define EXTI_EMR1_EM21 EXTI_EMR1_EM21_Msk
#define EXTI_EMR1_EM22_Pos (22U)
#define EXTI_EMR1_EM22_Msk (0x1UL << EXTI_EMR1_EM22_Pos)
#define EXTI_EMR1_EM22 EXTI_EMR1_EM22_Msk
#define EXTI_EMR1_EM23_Pos (23U)
#define EXTI_EMR1_EM23_Msk (0x1UL << EXTI_EMR1_EM23_Pos)
#define EXTI_EMR1_EM23 EXTI_EMR1_EM23_Msk
#define EXTI_EMR1_EM24_Pos (24U)
#define EXTI_EMR1_EM24_Msk (0x1UL << EXTI_EMR1_EM24_Pos)
#define EXTI_EMR1_EM24 EXTI_EMR1_EM24_Msk
#define EXTI_EMR1_EM25_Pos (25U)
#define EXTI_EMR1_EM25_Msk (0x1UL << EXTI_EMR1_EM25_Pos)
#define EXTI_EMR1_EM25 EXTI_EMR1_EM25_Msk
#define EXTI_EMR1_EM26_Pos (26U)
#define EXTI_EMR1_EM26_Msk (0x1UL << EXTI_EMR1_EM26_Pos)
#define EXTI_EMR1_EM26 EXTI_EMR1_EM26_Msk
#define EXTI_EMR1_EM27_Pos (27U)
#define EXTI_EMR1_EM27_Msk (0x1UL << EXTI_EMR1_EM27_Pos)
#define EXTI_EMR1_EM27 EXTI_EMR1_EM27_Msk
#define EXTI_EMR1_EM28_Pos (28U)
#define EXTI_EMR1_EM28_Msk (0x1UL << EXTI_EMR1_EM28_Pos)
#define EXTI_EMR1_EM28 EXTI_EMR1_EM28_Msk
#define EXTI_EMR1_EM29_Pos (29U)
#define EXTI_EMR1_EM29_Msk (0x1UL << EXTI_EMR1_EM29_Pos)
#define EXTI_EMR1_EM29 EXTI_EMR1_EM29_Msk
#define EXTI_EMR1_EM30_Pos (30U)
#define EXTI_EMR1_EM30_Msk (0x1UL << EXTI_EMR1_EM30_Pos)
#define EXTI_EMR1_EM30 EXTI_EMR1_EM30_Msk
#define EXTI_EMR1_EM31_Pos (31U)
#define EXTI_EMR1_EM31_Msk (0x1UL << EXTI_EMR1_EM31_Pos)
#define EXTI_EMR1_EM31 EXTI_EMR1_EM31_Msk

/******************  Bit definition for EXTI_RTSR1 register  ******************/
#define EXTI_RTSR1_RT0_Pos (0U)
#define EXTI_RTSR1_RT0_Msk (0x1UL << EXTI_RTSR1_RT0_Pos)
#define EXTI_RTSR1_RT0 EXTI_RTSR1_RT0_Msk
#define EXTI_RTSR1_RT1_Pos (1U)
#define EXTI_RTSR1_RT1_Msk (0x1UL << EXTI_RTSR1_RT1_Pos)
#define EXTI_RTSR1_RT1 EXTI_RTSR1_RT1_Msk
#define EXTI_RTSR1_RT2_Pos (2U)
#define EXTI_RTSR1_RT2_Msk (0x1UL << EXTI_RTSR1_RT2_Pos)
#define EXTI_RTSR1_RT2 EXTI_RTSR1_RT2_Msk
#define EXTI_RTSR1_RT3_Pos (3U)
#define EXTI_RTSR1_RT3_Msk (0x1UL << EXTI_RTSR1_RT3_Pos)
#define EXTI_RTSR1_RT3 EXTI_RTSR1_RT3_Msk
#define EXTI_RTSR1_RT4_Pos (4U)
#define EXTI_RTSR1_RT4_Msk (0x1UL << EXTI_RTSR1_RT4_Pos)
#define EXTI_RTSR1_RT4 EXTI_RTSR1_RT4_Msk
#define EXTI_RTSR1_RT5_Pos (5U)
#define EXTI_RTSR1_RT5_Msk (0x1UL << EXTI_RTSR1_RT5_Pos)
#define EXTI_RTSR1_RT5 EXTI_RTSR1_RT5_Msk
#define EXTI_RTSR1_RT6_Pos (6U)
#define EXTI_RTSR1_RT6_Msk (0x1UL << EXTI_RTSR1_RT6_Pos)
#define EXTI_RTSR1_RT6 EXTI_RTSR1_RT6_Msk
#define EXTI_RTSR1_RT7_Pos (7U)
#define EXTI_RTSR1_RT7_Msk (0x1UL << EXTI_RTSR1_RT7_Pos)
#define EXTI_RTSR1_RT7 EXTI_RTSR1_RT7_Msk
#define EXTI_RTSR1_RT8_Pos (8U)
#define EXTI_RTSR1_RT8_Msk (0x1UL << EXTI_RTSR1_RT8_Pos)
#define EXTI_RTSR1_RT8 EXTI_RTSR1_RT8_Msk
#define EXTI_RTSR1_RT9_Pos (9U)
#define EXTI_RTSR1_RT9_Msk (0x1UL << EXTI_RTSR1_RT9_Pos)
#define EXTI_RTSR1_RT9 EXTI_RTSR1_RT9_Msk
#define EXTI_RTSR1_RT10_Pos (10U)
#define EXTI_RTSR1_RT10_Msk (0x1UL << EXTI_RTSR1_RT10_Pos)
#define EXTI_RTSR1_RT10 EXTI_RTSR1_RT10_Msk
#define EXTI_RTSR1_RT11_Pos (11U)
#define EXTI_RTSR1_RT11_Msk (0x1UL << EXTI_RTSR1_RT11_Pos)
#define EXTI_RTSR1_RT11 EXTI_RTSR1_RT11_Msk
#define EXTI_RTSR1_RT12_Pos (12U)
#define EXTI_RTSR1_RT12_Msk (0x1UL << EXTI_RTSR1_RT12_Pos)
#define EXTI_RTSR1_RT12 EXTI_RTSR1_RT12_Msk
#define EXTI_RTSR1_RT13_Pos (13U)
#define EXTI_RTSR1_RT13_Msk (0x1UL << EXTI_RTSR1_RT13_Pos)
#define EXTI_RTSR1_RT13 EXTI_RTSR1_RT13_Msk
#define EXTI_RTSR1_RT14_Pos (14U)
#define EXTI_RTSR1_RT14_Msk (0x1UL << EXTI_RTSR1_RT14_Pos)
#define EXTI_RTSR1_RT14 EXTI_RTSR1_RT14_Msk
#define EXTI_RTSR1_RT15_Pos (15U)
#define EXTI_RTSR1_RT15_Msk (0x1UL << EXTI_RTSR1_RT15_Pos)
#define EXTI_RTSR1_RT15 EXTI_RTSR1_RT15_Msk
#define EXTI_RTSR1_RT16_Pos (16U)
#define EXTI_RTSR1_RT16_Msk (0x1UL << EXTI_RTSR1_RT16_Pos)
#define EXTI_RTSR1_RT16 EXTI_RTSR1_RT16_Msk
#define EXTI_RTSR1_RT17_Pos (17U)
#define EXTI_RTSR1_RT17_Msk (0x1UL << EXTI_RTSR1_RT17_Pos)
#define EXTI_RTSR1_RT17 EXTI_RTSR1_RT17_Msk
#define EXTI_RTSR1_RT19_Pos (19U)
#define EXTI_RTSR1_RT19_Msk (0x1UL << EXTI_RTSR1_RT19_Pos)
#define EXTI_RTSR1_RT19 EXTI_RTSR1_RT19_Msk
#define EXTI_RTSR1_RT20_Pos (20U)
#define EXTI_RTSR1_RT20_Msk (0x1UL << EXTI_RTSR1_RT20_Pos)
#define EXTI_RTSR1_RT20 EXTI_RTSR1_RT20_Msk
#define EXTI_RTSR1_RT21_Pos (21U)
#define EXTI_RTSR1_RT21_Msk (0x1UL << EXTI_RTSR1_RT21_Pos)
#define EXTI_RTSR1_RT21 EXTI_RTSR1_RT21_Msk
#define EXTI_RTSR1_RT22_Pos (22U)
#define EXTI_RTSR1_RT22_Msk (0x1UL << EXTI_RTSR1_RT22_Pos)
#define EXTI_RTSR1_RT22 EXTI_RTSR1_RT22_Msk
#define EXTI_RTSR1_RT29_Pos (29U)
#define EXTI_RTSR1_RT29_Msk (0x1UL << EXTI_RTSR1_RT29_Pos)
#define EXTI_RTSR1_RT29 EXTI_RTSR1_RT29_Msk
#define EXTI_RTSR1_RT30_Pos (30U)
#define EXTI_RTSR1_RT30_Msk (0x1UL << EXTI_RTSR1_RT30_Pos)
#define EXTI_RTSR1_RT30 EXTI_RTSR1_RT30_Msk
#define EXTI_RTSR1_RT31_Pos (31U)
#define EXTI_RTSR1_RT31_Msk (0x1UL << EXTI_RTSR1_RT31_Pos)
#define EXTI_RTSR1_RT31 EXTI_RTSR1_RT31_Msk

/******************  Bit definition for EXTI_FTSR1 register  ******************/
#define EXTI_FTSR1_FT0_Pos (0U)
#define EXTI_FTSR1_FT0_Msk (0x1UL << EXTI_FTSR1_FT0_Pos)
#define EXTI_FTSR1_FT0 EXTI_FTSR1_FT0_Msk
#define EXTI_FTSR1_FT1_Pos (1U)
#define EXTI_FTSR1_FT1_Msk (0x1UL << EXTI_FTSR1_FT1_Pos)
#define EXTI_FTSR1_FT1 EXTI_FTSR1_FT1_Msk
#define EXTI_FTSR1_FT2_Pos (2U)
#define EXTI_FTSR1_FT2_Msk (0x1UL << EXTI_FTSR1_FT2_Pos)
#define EXTI_FTSR1_FT2 EXTI_FTSR1_FT2_Msk
#define EXTI_FTSR1_FT3_Pos (3U)
#define EXTI_FTSR1_FT3_Msk (0x1UL << EXTI_FTSR1_FT3_Pos)
#define EXTI_FTSR1_FT3 EXTI_FTSR1_FT3_Msk
#define EXTI_FTSR1_FT4_Pos (4U)
#define EXTI_FTSR1_FT4_Msk (0x1UL << EXTI_FTSR1_FT4_Pos)
#define EXTI_FTSR1_FT4 EXTI_FTSR1_FT4_Msk
#define EXTI_FTSR1_FT5_Pos (5U)
#define EXTI_FTSR1_FT5_Msk (0x1UL << EXTI_FTSR1_FT5_Pos)
#define EXTI_FTSR1_FT5 EXTI_FTSR1_FT5_Msk
#define EXTI_FTSR1_FT6_Pos (6U)
#define EXTI_FTSR1_FT6_Msk (0x1UL << EXTI_FTSR1_FT6_Pos)
#define EXTI_FTSR1_FT6 EXTI_FTSR1_FT6_Msk
#define EXTI_FTSR1_FT7_Pos (7U)
#define EXTI_FTSR1_FT7_Msk (0x1UL << EXTI_FTSR1_FT7_Pos)
#define EXTI_FTSR1_FT7 EXTI_FTSR1_FT7_Msk
#define EXTI_FTSR1_FT8_Pos (8U)
#define EXTI_FTSR1_FT8_Msk (0x1UL << EXTI_FTSR1_FT8_Pos)
#define EXTI_FTSR1_FT8 EXTI_FTSR1_FT8_Msk
#define EXTI_FTSR1_FT9_Pos (9U)
#define EXTI_FTSR1_FT9_Msk (0x1UL << EXTI_FTSR1_FT9_Pos)
#define EXTI_FTSR1_FT9 EXTI_FTSR1_FT9_Msk
#define EXTI_FTSR1_FT10_Pos (10U)
#define EXTI_FTSR1_FT10_Msk (0x1UL << EXTI_FTSR1_FT10_Pos)
#define EXTI_FTSR1_FT10 EXTI_FTSR1_FT10_Msk
#define EXTI_FTSR1_FT11_Pos (11U)
#define EXTI_FTSR1_FT11_Msk (0x1UL << EXTI_FTSR1_FT11_Pos)
#define EXTI_FTSR1_FT11 EXTI_FTSR1_FT11_Msk
#define EXTI_FTSR1_FT12_Pos (12U)
#define EXTI_FTSR1_FT12_Msk (0x1UL << EXTI_FTSR1_FT12_Pos)
#define EXTI_FTSR1_FT12 EXTI_FTSR1_FT12_Msk
#define EXTI_FTSR1_FT13_Pos (13U)
#define EXTI_FTSR1_FT13_Msk (0x1UL << EXTI_FTSR1_FT13_Pos)
#define EXTI_FTSR1_FT13 EXTI_FTSR1_FT13_Msk
#define EXTI_FTSR1_FT14_Pos (14U)
#define EXTI_FTSR1_FT14_Msk (0x1UL << EXTI_FTSR1_FT14_Pos)
#define EXTI_FTSR1_FT14 EXTI_FTSR1_FT14_Msk
#define EXTI_FTSR1_FT15_Pos (15U)
#define EXTI_FTSR1_FT15_Msk (0x1UL << EXTI_FTSR1_FT15_Pos)
#define EXTI_FTSR1_FT15 EXTI_FTSR1_FT15_Msk
#define EXTI_FTSR1_FT16_Pos (16U)
#define EXTI_FTSR1_FT16_Msk (0x1UL << EXTI_FTSR1_FT16_Pos)
#define EXTI_FTSR1_FT16 EXTI_FTSR1_FT16_Msk
#define EXTI_FTSR1_FT17_Pos (17U)
#define EXTI_FTSR1_FT17_Msk (0x1UL << EXTI_FTSR1_FT17_Pos)
#define EXTI_FTSR1_FT17 EXTI_FTSR1_FT17_Msk
#define EXTI_FTSR1_FT19_Pos (19U)
#define EXTI_FTSR1_FT19_Msk (0x1UL << EXTI_FTSR1_FT19_Pos)
#define EXTI_FTSR1_FT19 EXTI_FTSR1_FT19_Msk
#define EXTI_FTSR1_FT20_Pos (20U)
#define EXTI_FTSR1_FT20_Msk (0x1UL << EXTI_FTSR1_FT20_Pos)
#define EXTI_FTSR1_FT20 EXTI_FTSR1_FT20_Msk
#define EXTI_FTSR1_FT21_Pos (21U)
#define EXTI_FTSR1_FT21_Msk (0x1UL << EXTI_FTSR1_FT21_Pos)
#define EXTI_FTSR1_FT21 EXTI_FTSR1_FT21_Msk
#define EXTI_FTSR1_FT22_Pos (22U)
#define EXTI_FTSR1_FT22_Msk (0x1UL << EXTI_FTSR1_FT22_Pos)
#define EXTI_FTSR1_FT22 EXTI_FTSR1_FT22_Msk
#define EXTI_FTSR1_FT29_Pos (29U)
#define EXTI_FTSR1_FT29_Msk (0x1UL << EXTI_FTSR1_FT29_Pos)
#define EXTI_FTSR1_FT29 EXTI_FTSR1_FT29_Msk
#define EXTI_FTSR1_FT30_Pos (30U)
#define EXTI_FTSR1_FT30_Msk (0x1UL << EXTI_FTSR1_FT30_Pos)
#define EXTI_FTSR1_FT30 EXTI_FTSR1_FT30_Msk
#define EXTI_FTSR1_FT31_Pos (31U)
#define EXTI_FTSR1_FT31_Msk (0x1UL << EXTI_FTSR1_FT31_Pos)
#define EXTI_FTSR1_FT31 EXTI_FTSR1_FT31_Msk

/******************  Bit definition for EXTI_SWIER1 register  *****************/
#define EXTI_SWIER1_SWI0_Pos (0U)
#define EXTI_SWIER1_SWI0_Msk (0x1UL << EXTI_SWIER1_SWI0_Pos)
#define EXTI_SWIER1_SWI0 EXTI_SWIER1_SWI0_Msk
#define EXTI_SWIER1_SWI1_Pos (1U)
#define EXTI_SWIER1_SWI1_Msk (0x1UL << EXTI_SWIER1_SWI1_Pos)
#define EXTI_SWIER1_SWI1 EXTI_SWIER1_SWI1_Msk
#define EXTI_SWIER1_SWI2_Pos (2U)
#define EXTI_SWIER1_SWI2_Msk (0x1UL << EXTI_SWIER1_SWI2_Pos)
#define EXTI_SWIER1_SWI2 EXTI_SWIER1_SWI2_Msk
#define EXTI_SWIER1_SWI3_Pos (3U)
#define EXTI_SWIER1_SWI3_Msk (0x1UL << EXTI_SWIER1_SWI3_Pos)
#define EXTI_SWIER1_SWI3 EXTI_SWIER1_SWI3_Msk
#define EXTI_SWIER1_SWI4_Pos (4U)
#define EXTI_SWIER1_SWI4_Msk (0x1UL << EXTI_SWIER1_SWI4_Pos)
#define EXTI_SWIER1_SWI4 EXTI_SWIER1_SWI4_Msk
#define EXTI_SWIER1_SWI5_Pos (5U)
#define EXTI_SWIER1_SWI5_Msk (0x1UL << EXTI_SWIER1_SWI5_Pos)
#define EXTI_SWIER1_SWI5 EXTI_SWIER1_SWI5_Msk
#define EXTI_SWIER1_SWI6_Pos (6U)
#define EXTI_SWIER1_SWI6_Msk (0x1UL << EXTI_SWIER1_SWI6_Pos)
#define EXTI_SWIER1_SWI6 EXTI_SWIER1_SWI6_Msk
#define EXTI_SWIER1_SWI7_Pos (7U)
#define EXTI_SWIER1_SWI7_Msk (0x1UL << EXTI_SWIER1_SWI7_Pos)
#define EXTI_SWIER1_SWI7 EXTI_SWIER1_SWI7_Msk
#define EXTI_SWIER1_SWI8_Pos (8U)
#define EXTI_SWIER1_SWI8_Msk (0x1UL << EXTI_SWIER1_SWI8_Pos)
#define EXTI_SWIER1_SWI8 EXTI_SWIER1_SWI8_Msk
#define EXTI_SWIER1_SWI9_Pos (9U)
#define EXTI_SWIER1_SWI9_Msk (0x1UL << EXTI_SWIER1_SWI9_Pos)
#define EXTI_SWIER1_SWI9 EXTI_SWIER1_SWI9_Msk
#define EXTI_SWIER1_SWI10_Pos (10U)
#define EXTI_SWIER1_SWI10_Msk (0x1UL << EXTI_SWIER1_SWI10_Pos)
#define EXTI_SWIER1_SWI10 EXTI_SWIER1_SWI10_Msk
#define EXTI_SWIER1_SWI11_Pos (11U)
#define EXTI_SWIER1_SWI11_Msk (0x1UL << EXTI_SWIER1_SWI11_Pos)
#define EXTI_SWIER1_SWI11 EXTI_SWIER1_SWI11_Msk
#define EXTI_SWIER1_SWI12_Pos (12U)
#define EXTI_SWIER1_SWI12_Msk (0x1UL << EXTI_SWIER1_SWI12_Pos)
#define EXTI_SWIER1_SWI12 EXTI_SWIER1_SWI12_Msk
#define EXTI_SWIER1_SWI13_Pos (13U)
#define EXTI_SWIER1_SWI13_Msk (0x1UL << EXTI_SWIER1_SWI13_Pos)
#define EXTI_SWIER1_SWI13 EXTI_SWIER1_SWI13_Msk
#define EXTI_SWIER1_SWI14_Pos (14U)
#define EXTI_SWIER1_SWI14_Msk (0x1UL << EXTI_SWIER1_SWI14_Pos)
#define EXTI_SWIER1_SWI14 EXTI_SWIER1_SWI14_Msk
#define EXTI_SWIER1_SWI15_Pos (15U)
#define EXTI_SWIER1_SWI15_Msk (0x1UL << EXTI_SWIER1_SWI15_Pos)
#define EXTI_SWIER1_SWI15 EXTI_SWIER1_SWI15_Msk
#define EXTI_SWIER1_SWI16_Pos (16U)
#define EXTI_SWIER1_SWI16_Msk (0x1UL << EXTI_SWIER1_SWI16_Pos)
#define EXTI_SWIER1_SWI16 EXTI_SWIER1_SWI16_Msk
#define EXTI_SWIER1_SWI17_Pos (17U)
#define EXTI_SWIER1_SWI17_Msk (0x1UL << EXTI_SWIER1_SWI17_Pos)
#define EXTI_SWIER1_SWI17 EXTI_SWIER1_SWI17_Msk
#define EXTI_SWIER1_SWI19_Pos (19U)
#define EXTI_SWIER1_SWI19_Msk (0x1UL << EXTI_SWIER1_SWI19_Pos)
#define EXTI_SWIER1_SWI19 EXTI_SWIER1_SWI19_Msk
#define EXTI_SWIER1_SWI20_Pos (20U)
#define EXTI_SWIER1_SWI20_Msk (0x1UL << EXTI_SWIER1_SWI20_Pos)
#define EXTI_SWIER1_SWI20 EXTI_SWIER1_SWI20_Msk
#define EXTI_SWIER1_SWI21_Pos (21U)
#define EXTI_SWIER1_SWI21_Msk (0x1UL << EXTI_SWIER1_SWI21_Pos)
#define EXTI_SWIER1_SWI21 EXTI_SWIER1_SWI21_Msk
#define EXTI_SWIER1_SWI22_Pos (22U)
#define EXTI_SWIER1_SWI22_Msk (0x1UL << EXTI_SWIER1_SWI22_Pos)
#define EXTI_SWIER1_SWI22 EXTI_SWIER1_SWI22_Msk
#define EXTI_SWIER1_SWI29_Pos (29U)
#define EXTI_SWIER1_SWI29_Msk (0x1UL << EXTI_SWIER1_SWI29_Pos)
#define EXTI_SWIER1_SWI29 EXTI_SWIER1_SWI29_Msk
#define EXTI_SWIER1_SWI30_Pos (30U)
#define EXTI_SWIER1_SWI30_Msk (0x1UL << EXTI_SWIER1_SWI30_Pos)
#define EXTI_SWIER1_SWI30 EXTI_SWIER1_SWI30_Msk
#define EXTI_SWIER1_SWI31_Pos (31U)
#define EXTI_SWIER1_SWI31_Msk (0x1UL << EXTI_SWIER1_SWI31_Pos)
#define EXTI_SWIER1_SWI31 EXTI_SWIER1_SWI31_Msk

/*******************  Bit definition for EXTI_PR1 register  *******************/
#define EXTI_PR1_PIF0_Pos (0U)
#define EXTI_PR1_PIF0_Msk (0x1UL << EXTI_PR1_PIF0_Pos)
#define EXTI_PR1_PIF0 EXTI_PR1_PIF0_Msk
#define EXTI_PR1_PIF1_Pos (1U)
#define EXTI_PR1_PIF1_Msk (0x1UL << EXTI_PR1_PIF1_Pos)
#define EXTI_PR1_PIF1 EXTI_PR1_PIF1_Msk
#define EXTI_PR1_PIF2_Pos (2U)
#define EXTI_PR1_PIF2_Msk (0x1UL << EXTI_PR1_PIF2_Pos)
#define EXTI_PR1_PIF2 EXTI_PR1_PIF2_Msk
#define EXTI_PR1_PIF3_Pos (3U)
#define EXTI_PR1_PIF3_Msk (0x1UL << EXTI_PR1_PIF3_Pos)
#define EXTI_PR1_PIF3 EXTI_PR1_PIF3_Msk
#define EXTI_PR1_PIF4_Pos (4U)
#define EXTI_PR1_PIF4_Msk (0x1UL << EXTI_PR1_PIF4_Pos)
#define EXTI_PR1_PIF4 EXTI_PR1_PIF4_Msk
#define EXTI_PR1_PIF5_Pos (5U)
#define EXTI_PR1_PIF5_Msk (0x1UL << EXTI_PR1_PIF5_Pos)
#define EXTI_PR1_PIF5 EXTI_PR1_PIF5_Msk
#define EXTI_PR1_PIF6_Pos (6U)
#define EXTI_PR1_PIF6_Msk (0x1UL << EXTI_PR1_PIF6_Pos)
#define EXTI_PR1_PIF6 EXTI_PR1_PIF6_Msk
#define EXTI_PR1_PIF7_Pos (7U)
#define EXTI_PR1_PIF7_Msk (0x1UL << EXTI_PR1_PIF7_Pos)
#define EXTI_PR1_PIF7 EXTI_PR1_PIF7_Msk
#define EXTI_PR1_PIF8_Pos (8U)
#define EXTI_PR1_PIF8_Msk (0x1UL << EXTI_PR1_PIF8_Pos)
#define EXTI_PR1_PIF8 EXTI_PR1_PIF8_Msk
#define EXTI_PR1_PIF9_Pos (9U)
#define EXTI_PR1_PIF9_Msk (0x1UL << EXTI_PR1_PIF9_Pos)
#define EXTI_PR1_PIF9 EXTI_PR1_PIF9_Msk
#define EXTI_PR1_PIF10_Pos (10U)
#define EXTI_PR1_PIF10_Msk (0x1UL << EXTI_PR1_PIF10_Pos)
#define EXTI_PR1_PIF10 EXTI_PR1_PIF10_Msk
#define EXTI_PR1_PIF11_Pos (11U)
#define EXTI_PR1_PIF11_Msk (0x1UL << EXTI_PR1_PIF11_Pos)
#define EXTI_PR1_PIF11 EXTI_PR1_PIF11_Msk
#define EXTI_PR1_PIF12_Pos (12U)
#define EXTI_PR1_PIF12_Msk (0x1UL << EXTI_PR1_PIF12_Pos)
#define EXTI_PR1_PIF12 EXTI_PR1_PIF12_Msk
#define EXTI_PR1_PIF13_Pos (13U)
#define EXTI_PR1_PIF13_Msk (0x1UL << EXTI_PR1_PIF13_Pos)
#define EXTI_PR1_PIF13 EXTI_PR1_PIF13_Msk
#define EXTI_PR1_PIF14_Pos (14U)
#define EXTI_PR1_PIF14_Msk (0x1UL << EXTI_PR1_PIF14_Pos)
#define EXTI_PR1_PIF14 EXTI_PR1_PIF14_Msk
#define EXTI_PR1_PIF15_Pos (15U)
#define EXTI_PR1_PIF15_Msk (0x1UL << EXTI_PR1_PIF15_Pos)
#define EXTI_PR1_PIF15 EXTI_PR1_PIF15_Msk
#define EXTI_PR1_PIF16_Pos (16U)
#define EXTI_PR1_PIF16_Msk (0x1UL << EXTI_PR1_PIF16_Pos)
#define EXTI_PR1_PIF16 EXTI_PR1_PIF16_Msk
#define EXTI_PR1_PIF17_Pos (17U)
#define EXTI_PR1_PIF17_Msk (0x1UL << EXTI_PR1_PIF17_Pos)
#define EXTI_PR1_PIF17 EXTI_PR1_PIF17_Msk
#define EXTI_PR1_PIF19_Pos (19U)
#define EXTI_PR1_PIF19_Msk (0x1UL << EXTI_PR1_PIF19_Pos)
#define EXTI_PR1_PIF19 EXTI_PR1_PIF19_Msk
#define EXTI_PR1_PIF20_Pos (20U)
#define EXTI_PR1_PIF20_Msk (0x1UL << EXTI_PR1_PIF20_Pos)
#define EXTI_PR1_PIF20 EXTI_PR1_PIF20_Msk
#define EXTI_PR1_PIF21_Pos (21U)
#define EXTI_PR1_PIF21_Msk (0x1UL << EXTI_PR1_PIF21_Pos)
#define EXTI_PR1_PIF21 EXTI_PR1_PIF21_Msk
#define EXTI_PR1_PIF22_Pos (22U)
#define EXTI_PR1_PIF22_Msk (0x1UL << EXTI_PR1_PIF22_Pos)
#define EXTI_PR1_PIF22 EXTI_PR1_PIF22_Msk
#define EXTI_PR1_PIF29_Pos (29U)
#define EXTI_PR1_PIF29_Msk (0x1UL << EXTI_PR1_PIF29_Pos)
#define EXTI_PR1_PIF29 EXTI_PR1_PIF29_Msk
#define EXTI_PR1_PIF30_Pos (30U)
#define EXTI_PR1_PIF30_Msk (0x1UL << EXTI_PR1_PIF30_Pos)
#define EXTI_PR1_PIF30 EXTI_PR1_PIF30_Msk
#define EXTI_PR1_PIF31_Pos (31U)
#define EXTI_PR1_PIF31_Msk (0x1UL << EXTI_PR1_PIF31_Pos)
#define EXTI_PR1_PIF31 EXTI_PR1_PIF31_Msk

/*******************  Bit definition for EXTI_IMR2 register  ******************/
#define EXTI_IMR2_IM32_Pos (0U)
#define EXTI_IMR2_IM32_Msk (0x1UL << EXTI_IMR2_IM32_Pos)
#define EXTI_IMR2_IM32 EXTI_IMR2_IM32_Msk
#define EXTI_IMR2_IM33_Pos (1U)
#define EXTI_IMR2_IM33_Msk (0x1UL << EXTI_IMR2_IM33_Pos)
#define EXTI_IMR2_IM33 EXTI_IMR2_IM33_Msk
#define EXTI_IMR2_IM34_Pos (2U)
#define EXTI_IMR2_IM34_Msk (0x1UL << EXTI_IMR2_IM34_Pos)
#define EXTI_IMR2_IM34 EXTI_IMR2_IM34_Msk
#define EXTI_IMR2_IM35_Pos (3U)
#define EXTI_IMR2_IM35_Msk (0x1UL << EXTI_IMR2_IM35_Pos)
#define EXTI_IMR2_IM35 EXTI_IMR2_IM35_Msk
#define EXTI_IMR2_IM36_Pos (4U)
#define EXTI_IMR2_IM36_Msk (0x1UL << EXTI_IMR2_IM36_Pos)
#define EXTI_IMR2_IM36 EXTI_IMR2_IM36_Msk
#define EXTI_IMR2_IM37_Pos (5U)
#define EXTI_IMR2_IM37_Msk (0x1UL << EXTI_IMR2_IM37_Pos)
#define EXTI_IMR2_IM37 EXTI_IMR2_IM37_Msk
#define EXTI_IMR2_IM38_Pos (6U)
#define EXTI_IMR2_IM38_Msk (0x1UL << EXTI_IMR2_IM38_Pos)
#define EXTI_IMR2_IM38 EXTI_IMR2_IM38_Msk
#define EXTI_IMR2_IM39_Pos (7U)
#define EXTI_IMR2_IM39_Msk (0x1UL << EXTI_IMR2_IM39_Pos)
#define EXTI_IMR2_IM39 EXTI_IMR2_IM39_Msk
#define EXTI_IMR2_IM40_Pos (8U)
#define EXTI_IMR2_IM40_Msk (0x1UL << EXTI_IMR2_IM40_Pos)
#define EXTI_IMR2_IM40 EXTI_IMR2_IM40_Msk
#define EXTI_IMR2_IM41_Pos (9U)
#define EXTI_IMR2_IM41_Msk (0x1UL << EXTI_IMR2_IM41_Pos)
#define EXTI_IMR2_IM41 EXTI_IMR2_IM41_Msk
#define EXTI_IMR2_IM42_Pos (10U)
#define EXTI_IMR2_IM42_Msk (0x1UL << EXTI_IMR2_IM42_Pos)
#define EXTI_IMR2_IM42 EXTI_IMR2_IM42_Msk
#define EXTI_IMR2_IM_Pos (0U)
#define EXTI_IMR2_IM_Msk (0x7FFUL << EXTI_IMR2_IM_Pos)
#define EXTI_IMR2_IM EXTI_IMR2_IM_Msk

/*******************  Bit definition for EXTI_EMR2 register  ******************/
#define EXTI_EMR2_EM32_Pos (0U)
#define EXTI_EMR2_EM32_Msk (0x1UL << EXTI_EMR2_EM32_Pos)
#define EXTI_EMR2_EM32 EXTI_EMR2_EM32_Msk
#define EXTI_EMR2_EM33_Pos (1U)
#define EXTI_EMR2_EM33_Msk (0x1UL << EXTI_EMR2_EM33_Pos)
#define EXTI_EMR2_EM33 EXTI_EMR2_EM33_Msk
#define EXTI_EMR2_EM34_Pos (2U)
#define EXTI_EMR2_EM34_Msk (0x1UL << EXTI_EMR2_EM34_Pos)
#define EXTI_EMR2_EM34 EXTI_EMR2_EM34_Msk
#define EXTI_EMR2_EM35_Pos (3U)
#define EXTI_EMR2_EM35_Msk (0x1UL << EXTI_EMR2_EM35_Pos)
#define EXTI_EMR2_EM35 EXTI_EMR2_EM35_Msk
#define EXTI_EMR2_EM36_Pos (4U)
#define EXTI_EMR2_EM36_Msk (0x1UL << EXTI_EMR2_EM36_Pos)
#define EXTI_EMR2_EM36 EXTI_EMR2_EM36_Msk
#define EXTI_EMR2_EM37_Pos (5U)
#define EXTI_EMR2_EM37_Msk (0x1UL << EXTI_EMR2_EM37_Pos)
#define EXTI_EMR2_EM37 EXTI_EMR2_EM37_Msk
#define EXTI_EMR2_EM38_Pos (6U)
#define EXTI_EMR2_EM38_Msk (0x1UL << EXTI_EMR2_EM38_Pos)
#define EXTI_EMR2_EM38 EXTI_EMR2_EM38_Msk
#define EXTI_EMR2_EM39_Pos (7U)
#define EXTI_EMR2_EM39_Msk (0x1UL << EXTI_EMR2_EM39_Pos)
#define EXTI_EMR2_EM39 EXTI_EMR2_EM39_Msk
#define EXTI_EMR2_EM40_Pos (8U)
#define EXTI_EMR2_EM40_Msk (0x1UL << EXTI_EMR2_EM40_Pos)
#define EXTI_EMR2_EM40 EXTI_EMR2_EM40_Msk
#define EXTI_EMR2_EM41_Pos (9U)
#define EXTI_EMR2_EM41_Msk (0x1UL << EXTI_EMR2_EM41_Pos)
#define EXTI_EMR2_EM41 EXTI_EMR2_EM41_Msk
#define EXTI_EMR2_EM42_Pos (10U)
#define EXTI_EMR2_EM42_Msk (0x1UL << EXTI_EMR2_EM42_Pos)
#define EXTI_EMR2_EM42 EXTI_EMR2_EM42_Msk
#define EXTI_EMR2_EM_Pos (0U)
#define EXTI_EMR2_EM_Msk (0x7FFUL << EXTI_EMR2_EM_Pos)
#define EXTI_EMR2_EM EXTI_EMR2_EM_Msk

/******************  Bit definition for EXTI_RTSR2 register  ******************/
#define EXTI_RTSR2_RT32_Pos (0U)
#define EXTI_RTSR2_RT32_Msk (0x1UL << EXTI_RTSR2_RT32_Pos)
#define EXTI_RTSR2_RT32 EXTI_RTSR2_RT32_Msk
#define EXTI_RTSR2_RT33_Pos (1U)
#define EXTI_RTSR2_RT33_Msk (0x1UL << EXTI_RTSR2_RT33_Pos)
#define EXTI_RTSR2_RT33 EXTI_RTSR2_RT33_Msk
#define EXTI_RTSR2_RT38_Pos (6U)
#define EXTI_RTSR2_RT38_Msk (0x1UL << EXTI_RTSR2_RT38_Pos)
#define EXTI_RTSR2_RT38 EXTI_RTSR2_RT38_Msk
#define EXTI_RTSR2_RT39_Pos (7U)
#define EXTI_RTSR2_RT39_Msk (0x1UL << EXTI_RTSR2_RT39_Pos)
#define EXTI_RTSR2_RT39 EXTI_RTSR2_RT39_Msk
#define EXTI_RTSR2_RT40_Pos (8U)
#define EXTI_RTSR2_RT40_Msk (0x1UL << EXTI_RTSR2_RT40_Pos)
#define EXTI_RTSR2_RT40 EXTI_RTSR2_RT40_Msk
#define EXTI_RTSR2_RT41_Pos (9U)
#define EXTI_RTSR2_RT41_Msk (0x1UL << EXTI_RTSR2_RT41_Pos)
#define EXTI_RTSR2_RT41 EXTI_RTSR2_RT41_Msk

/******************  Bit definition for EXTI_FTSR2 register  ******************/
#define EXTI_FTSR2_FT32_Pos (0U)
#define EXTI_FTSR2_FT32_Msk (0x1UL << EXTI_FTSR2_FT32_Pos)
#define EXTI_FTSR2_FT32 EXTI_FTSR2_FT32_Msk
#define EXTI_FTSR2_FT33_Pos (1U)
#define EXTI_FTSR2_FT33_Msk (0x1UL << EXTI_FTSR2_FT33_Pos)
#define EXTI_FTSR2_FT33 EXTI_FTSR2_FT33_Msk
#define EXTI_FTSR2_FT38_Pos (6U)
#define EXTI_FTSR2_FT38_Msk (0x1UL << EXTI_FTSR2_FT38_Pos)
#define EXTI_FTSR2_FT38 EXTI_FTSR2_FT38_Msk
#define EXTI_FTSR2_FT39_Pos (7U)
#define EXTI_FTSR2_FT39_Msk (0x1UL << EXTI_FTSR2_FT39_Pos)
#define EXTI_FTSR2_FT39 EXTI_FTSR2_FT39_Msk
#define EXTI_FTSR2_FT40_Pos (8U)
#define EXTI_FTSR2_FT40_Msk (0x1UL << EXTI_FTSR2_FT40_Pos)
#define EXTI_FTSR2_FT40 EXTI_FTSR2_FT40_Msk
#define EXTI_FTSR2_FT41_Pos (9U)
#define EXTI_FTSR2_FT41_Msk (0x1UL << EXTI_FTSR2_FT41_Pos)
#define EXTI_FTSR2_FT41 EXTI_FTSR2_FT41_Msk

/******************  Bit definition for EXTI_SWIER2 register  *****************/
#define EXTI_SWIER2_SWI32_Pos (0U)
#define EXTI_SWIER2_SWI32_Msk (0x1UL << EXTI_SWIER2_SWI32_Pos)
#define EXTI_SWIER2_SWI32 EXTI_SWIER2_SWI32_Msk
#define EXTI_SWIER2_SWI33_Pos (1U)
#define EXTI_SWIER2_SWI33_Msk (0x1UL << EXTI_SWIER2_SWI33_Pos)
#define EXTI_SWIER2_SWI33 EXTI_SWIER2_SWI33_Msk
#define EXTI_SWIER2_SWI38_Pos (6U)
#define EXTI_SWIER2_SWI38_Msk (0x1UL << EXTI_SWIER2_SWI38_Pos)
#define EXTI_SWIER2_SWI38 EXTI_SWIER2_SWI38_Msk
#define EXTI_SWIER2_SWI39_Pos (7U)
#define EXTI_SWIER2_SWI39_Msk (0x1UL << EXTI_SWIER2_SWI39_Pos)
#define EXTI_SWIER2_SWI39 EXTI_SWIER2_SWI39_Msk
#define EXTI_SWIER2_SWI40_Pos (8U)
#define EXTI_SWIER2_SWI40_Msk (0x1UL << EXTI_SWIER2_SWI40_Pos)
#define EXTI_SWIER2_SWI40 EXTI_SWIER2_SWI40_Msk
#define EXTI_SWIER2_SWI41_Pos (9U)
#define EXTI_SWIER2_SWI41_Msk (0x1UL << EXTI_SWIER2_SWI41_Pos)
#define EXTI_SWIER2_SWI41 EXTI_SWIER2_SWI41_Msk

/*******************  Bit definition for EXTI_PR2 register  *******************/
#define EXTI_PR2_PIF32_Pos (0U)
#define EXTI_PR2_PIF32_Msk (0x1UL << EXTI_PR2_PIF32_Pos)
#define EXTI_PR2_PIF32 EXTI_PR2_PIF32_Msk
#define EXTI_PR2_PIF33_Pos (1U)
#define EXTI_PR2_PIF33_Msk (0x1UL << EXTI_PR2_PIF33_Pos)
#define EXTI_PR2_PIF33 EXTI_PR2_PIF33_Msk
#define EXTI_PR2_PIF38_Pos (6U)
#define EXTI_PR2_PIF38_Msk (0x1UL << EXTI_PR2_PIF38_Pos)
#define EXTI_PR2_PIF38 EXTI_PR2_PIF38_Msk
#define EXTI_PR2_PIF39_Pos (7U)
#define EXTI_PR2_PIF39_Msk (0x1UL << EXTI_PR2_PIF39_Pos)
#define EXTI_PR2_PIF39 EXTI_PR2_PIF39_Msk
#define EXTI_PR2_PIF40_Pos (8U)
#define EXTI_PR2_PIF40_Msk (0x1UL << EXTI_PR2_PIF40_Pos)
#define EXTI_PR2_PIF40 EXTI_PR2_PIF40_Msk
#define EXTI_PR2_PIF41_Pos (9U)
#define EXTI_PR2_PIF41_Msk (0x1UL << EXTI_PR2_PIF41_Pos)
#define EXTI_PR2_PIF41 EXTI_PR2_PIF41_Msk

/******************************************************************************/
/*                                                                            */
/*                 Flexible Datarate Controller Area Network                  */
/*                                                                            */
/******************************************************************************/
/*!<FDCAN control and status registers */
/*****************  Bit definition for FDCAN_CREL register  *******************/
#define FDCAN_CREL_DAY_Pos (0U)
#define FDCAN_CREL_DAY_Msk (0xFFUL << FDCAN_CREL_DAY_Pos)
#define FDCAN_CREL_DAY FDCAN_CREL_DAY_Msk
#define FDCAN_CREL_MON_Pos (8U)
#define FDCAN_CREL_MON_Msk (0xFFUL << FDCAN_CREL_MON_Pos)
#define FDCAN_CREL_MON FDCAN_CREL_MON_Msk
#define FDCAN_CREL_YEAR_Pos (16U)
#define FDCAN_CREL_YEAR_Msk (0xFUL << FDCAN_CREL_YEAR_Pos)
#define FDCAN_CREL_YEAR FDCAN_CREL_YEAR_Msk
#define FDCAN_CREL_SUBSTEP_Pos (20U)
#define FDCAN_CREL_SUBSTEP_Msk (0xFUL << FDCAN_CREL_SUBSTEP_Pos)
#define FDCAN_CREL_SUBSTEP FDCAN_CREL_SUBSTEP_Msk
#define FDCAN_CREL_STEP_Pos (24U)
#define FDCAN_CREL_STEP_Msk (0xFUL << FDCAN_CREL_STEP_Pos)
#define FDCAN_CREL_STEP FDCAN_CREL_STEP_Msk
#define FDCAN_CREL_REL_Pos (28U)
#define FDCAN_CREL_REL_Msk (0xFUL << FDCAN_CREL_REL_Pos)
#define FDCAN_CREL_REL FDCAN_CREL_REL_Msk

/*****************  Bit definition for FDCAN_ENDN register  *******************/
#define FDCAN_ENDN_ETV_Pos (0U)
#define FDCAN_ENDN_ETV_Msk (0xFFFFFFFFUL << FDCAN_ENDN_ETV_Pos)
#define FDCAN_ENDN_ETV FDCAN_ENDN_ETV_Msk

/*****************  Bit definition for FDCAN_DBTP register  *******************/
#define FDCAN_DBTP_DSJW_Pos (0U)
#define FDCAN_DBTP_DSJW_Msk (0xFUL << FDCAN_DBTP_DSJW_Pos)
#define FDCAN_DBTP_DSJW FDCAN_DBTP_DSJW_Msk
#define FDCAN_DBTP_DTSEG2_Pos (4U)
#define FDCAN_DBTP_DTSEG2_Msk (0xFUL << FDCAN_DBTP_DTSEG2_Pos)
#define FDCAN_DBTP_DTSEG2 FDCAN_DBTP_DTSEG2_Msk
#define FDCAN_DBTP_DTSEG1_Pos (8U)
#define FDCAN_DBTP_DTSEG1_Msk (0x1FUL << FDCAN_DBTP_DTSEG1_Pos)
#define FDCAN_DBTP_DTSEG1 FDCAN_DBTP_DTSEG1_Msk
#define FDCAN_DBTP_DBRP_Pos (16U)
#define FDCAN_DBTP_DBRP_Msk (0x1FUL << FDCAN_DBTP_DBRP_Pos)
#define FDCAN_DBTP_DBRP FDCAN_DBTP_DBRP_Msk
#define FDCAN_DBTP_TDC_Pos (23U)
#define FDCAN_DBTP_TDC_Msk (0x1UL << FDCAN_DBTP_TDC_Pos)
#define FDCAN_DBTP_TDC FDCAN_DBTP_TDC_Msk

/*****************  Bit definition for FDCAN_TEST register  *******************/
#define FDCAN_TEST_LBCK_Pos (4U)
#define FDCAN_TEST_LBCK_Msk (0x1UL << FDCAN_TEST_LBCK_Pos)
#define FDCAN_TEST_LBCK FDCAN_TEST_LBCK_Msk
#define FDCAN_TEST_TX_Pos (5U)
#define FDCAN_TEST_TX_Msk (0x3UL << FDCAN_TEST_TX_Pos)
#define FDCAN_TEST_TX FDCAN_TEST_TX_Msk
#define FDCAN_TEST_RX_Pos (7U)
#define FDCAN_TEST_RX_Msk (0x1UL << FDCAN_TEST_RX_Pos)
#define FDCAN_TEST_RX FDCAN_TEST_RX_Msk

/*****************  Bit definition for FDCAN_RWD register  ********************/
#define FDCAN_RWD_WDC_Pos (0U)
#define FDCAN_RWD_WDC_Msk (0xFFUL << FDCAN_RWD_WDC_Pos)
#define FDCAN_RWD_WDC FDCAN_RWD_WDC_Msk
#define FDCAN_RWD_WDV_Pos (8U)
#define FDCAN_RWD_WDV_Msk (0xFFUL << FDCAN_RWD_WDV_Pos)
#define FDCAN_RWD_WDV FDCAN_RWD_WDV_Msk

/*****************  Bit definition for FDCAN_CCCR register  ********************/
#define FDCAN_CCCR_INIT_Pos (0U)
#define FDCAN_CCCR_INIT_Msk (0x1UL << FDCAN_CCCR_INIT_Pos)
#define FDCAN_CCCR_INIT FDCAN_CCCR_INIT_Msk
#define FDCAN_CCCR_CCE_Pos (1U)
#define FDCAN_CCCR_CCE_Msk (0x1UL << FDCAN_CCCR_CCE_Pos)
#define FDCAN_CCCR_CCE FDCAN_CCCR_CCE_Msk
#define FDCAN_CCCR_ASM_Pos (2U)
#define FDCAN_CCCR_ASM_Msk (0x1UL << FDCAN_CCCR_ASM_Pos)
#define FDCAN_CCCR_ASM FDCAN_CCCR_ASM_Msk
#define FDCAN_CCCR_CSA_Pos (3U)
#define FDCAN_CCCR_CSA_Msk (0x1UL << FDCAN_CCCR_CSA_Pos)
#define FDCAN_CCCR_CSA FDCAN_CCCR_CSA_Msk
#define FDCAN_CCCR_CSR_Pos (4U)
#define FDCAN_CCCR_CSR_Msk (0x1UL << FDCAN_CCCR_CSR_Pos)
#define FDCAN_CCCR_CSR FDCAN_CCCR_CSR_Msk
#define FDCAN_CCCR_MON_Pos (5U)
#define FDCAN_CCCR_MON_Msk (0x1UL << FDCAN_CCCR_MON_Pos)
#define FDCAN_CCCR_MON FDCAN_CCCR_MON_Msk
#define FDCAN_CCCR_DAR_Pos (6U)
#define FDCAN_CCCR_DAR_Msk (0x1UL << FDCAN_CCCR_DAR_Pos)
#define FDCAN_CCCR_DAR FDCAN_CCCR_DAR_Msk
#define FDCAN_CCCR_TEST_Pos (7U)
#define FDCAN_CCCR_TEST_Msk (0x1UL << FDCAN_CCCR_TEST_Pos)
#define FDCAN_CCCR_TEST FDCAN_CCCR_TEST_Msk
#define FDCAN_CCCR_FDOE_Pos (8U)
#define FDCAN_CCCR_FDOE_Msk (0x1UL << FDCAN_CCCR_FDOE_Pos)
#define FDCAN_CCCR_FDOE FDCAN_CCCR_FDOE_Msk
#define FDCAN_CCCR_BRSE_Pos (9U)
#define FDCAN_CCCR_BRSE_Msk (0x1UL << FDCAN_CCCR_BRSE_Pos)
#define FDCAN_CCCR_BRSE FDCAN_CCCR_BRSE_Msk
#define FDCAN_CCCR_PXHD_Pos (12U)
#define FDCAN_CCCR_PXHD_Msk (0x1UL << FDCAN_CCCR_PXHD_Pos)
#define FDCAN_CCCR_PXHD FDCAN_CCCR_PXHD_Msk
#define FDCAN_CCCR_EFBI_Pos (13U)
#define FDCAN_CCCR_EFBI_Msk (0x1UL << FDCAN_CCCR_EFBI_Pos)
#define FDCAN_CCCR_EFBI FDCAN_CCCR_EFBI_Msk
#define FDCAN_CCCR_TXP_Pos (14U)
#define FDCAN_CCCR_TXP_Msk (0x1UL << FDCAN_CCCR_TXP_Pos)
#define FDCAN_CCCR_TXP FDCAN_CCCR_TXP_Msk
#define FDCAN_CCCR_NISO_Pos (15U)
#define FDCAN_CCCR_NISO_Msk (0x1UL << FDCAN_CCCR_NISO_Pos)
#define FDCAN_CCCR_NISO FDCAN_CCCR_NISO_Msk

/*****************  Bit definition for FDCAN_NBTP register  ********************/
#define FDCAN_NBTP_NTSEG2_Pos (0U)
#define FDCAN_NBTP_NTSEG2_Msk (0x7FUL << FDCAN_NBTP_NTSEG2_Pos)
#define FDCAN_NBTP_NTSEG2 FDCAN_NBTP_NTSEG2_Msk
#define FDCAN_NBTP_NTSEG1_Pos (8U)
#define FDCAN_NBTP_NTSEG1_Msk (0xFFUL << FDCAN_NBTP_NTSEG1_Pos)
#define FDCAN_NBTP_NTSEG1 FDCAN_NBTP_NTSEG1_Msk
#define FDCAN_NBTP_NBRP_Pos (16U)
#define FDCAN_NBTP_NBRP_Msk (0x1FFUL << FDCAN_NBTP_NBRP_Pos)
#define FDCAN_NBTP_NBRP FDCAN_NBTP_NBRP_Msk
#define FDCAN_NBTP_NSJW_Pos (25U)
#define FDCAN_NBTP_NSJW_Msk (0x7FUL << FDCAN_NBTP_NSJW_Pos)
#define FDCAN_NBTP_NSJW FDCAN_NBTP_NSJW_Msk

/*****************  Bit definition for FDCAN_TSCC register  ********************/
#define FDCAN_TSCC_TSS_Pos (0U)
#define FDCAN_TSCC_TSS_Msk (0x3UL << FDCAN_TSCC_TSS_Pos)
#define FDCAN_TSCC_TSS FDCAN_TSCC_TSS_Msk
#define FDCAN_TSCC_TCP_Pos (16U)
#define FDCAN_TSCC_TCP_Msk (0xFUL << FDCAN_TSCC_TCP_Pos)
#define FDCAN_TSCC_TCP FDCAN_TSCC_TCP_Msk

/*****************  Bit definition for FDCAN_TSCV register  ********************/
#define FDCAN_TSCV_TSC_Pos (0U)
#define FDCAN_TSCV_TSC_Msk (0xFFFFUL << FDCAN_TSCV_TSC_Pos)
#define FDCAN_TSCV_TSC FDCAN_TSCV_TSC_Msk

/*****************  Bit definition for FDCAN_TOCC register  ********************/
#define FDCAN_TOCC_ETOC_Pos (0U)
#define FDCAN_TOCC_ETOC_Msk (0x1UL << FDCAN_TOCC_ETOC_Pos)
#define FDCAN_TOCC_ETOC FDCAN_TOCC_ETOC_Msk
#define FDCAN_TOCC_TOS_Pos (1U)
#define FDCAN_TOCC_TOS_Msk (0x3UL << FDCAN_TOCC_TOS_Pos)
#define FDCAN_TOCC_TOS FDCAN_TOCC_TOS_Msk
#define FDCAN_TOCC_TOP_Pos (16U)
#define FDCAN_TOCC_TOP_Msk (0xFFFFUL << FDCAN_TOCC_TOP_Pos)
#define FDCAN_TOCC_TOP FDCAN_TOCC_TOP_Msk

/*****************  Bit definition for FDCAN_TOCV register  ********************/
#define FDCAN_TOCV_TOC_Pos (0U)
#define FDCAN_TOCV_TOC_Msk (0xFFFFUL << FDCAN_TOCV_TOC_Pos)
#define FDCAN_TOCV_TOC FDCAN_TOCV_TOC_Msk

/*****************  Bit definition for FDCAN_ECR register  *********************/
#define FDCAN_ECR_TEC_Pos (0U)
#define FDCAN_ECR_TEC_Msk (0xFFUL << FDCAN_ECR_TEC_Pos)
#define FDCAN_ECR_TEC FDCAN_ECR_TEC_Msk
#define FDCAN_ECR_REC_Pos (8U)
#define FDCAN_ECR_REC_Msk (0x7FUL << FDCAN_ECR_REC_Pos)
#define FDCAN_ECR_REC FDCAN_ECR_REC_Msk
#define FDCAN_ECR_RP_Pos (15U)
#define FDCAN_ECR_RP_Msk (0x1UL << FDCAN_ECR_RP_Pos)
#define FDCAN_ECR_RP FDCAN_ECR_RP_Msk
#define FDCAN_ECR_CEL_Pos (16U)
#define FDCAN_ECR_CEL_Msk (0xFFUL << FDCAN_ECR_CEL_Pos)
#define FDCAN_ECR_CEL FDCAN_ECR_CEL_Msk

/*****************  Bit definition for FDCAN_PSR register  *********************/
#define FDCAN_PSR_LEC_Pos (0U)
#define FDCAN_PSR_LEC_Msk (0x7UL << FDCAN_PSR_LEC_Pos)
#define FDCAN_PSR_LEC FDCAN_PSR_LEC_Msk
#define FDCAN_PSR_ACT_Pos (3U)
#define FDCAN_PSR_ACT_Msk (0x3UL << FDCAN_PSR_ACT_Pos)
#define FDCAN_PSR_ACT FDCAN_PSR_ACT_Msk
#define FDCAN_PSR_EP_Pos (5U)
#define FDCAN_PSR_EP_Msk (0x1UL << FDCAN_PSR_EP_Pos)
#define FDCAN_PSR_EP FDCAN_PSR_EP_Msk
#define FDCAN_PSR_EW_Pos (6U)
#define FDCAN_PSR_EW_Msk (0x1UL << FDCAN_PSR_EW_Pos)
#define FDCAN_PSR_EW FDCAN_PSR_EW_Msk
#define FDCAN_PSR_BO_Pos (7U)
#define FDCAN_PSR_BO_Msk (0x1UL << FDCAN_PSR_BO_Pos)
#define FDCAN_PSR_BO FDCAN_PSR_BO_Msk
#define FDCAN_PSR_DLEC_Pos (8U)
#define FDCAN_PSR_DLEC_Msk (0x7UL << FDCAN_PSR_DLEC_Pos)
#define FDCAN_PSR_DLEC FDCAN_PSR_DLEC_Msk
#define FDCAN_PSR_RESI_Pos (11U)
#define FDCAN_PSR_RESI_Msk (0x1UL << FDCAN_PSR_RESI_Pos)
#define FDCAN_PSR_RESI FDCAN_PSR_RESI_Msk
#define FDCAN_PSR_RBRS_Pos (12U)
#define FDCAN_PSR_RBRS_Msk (0x1UL << FDCAN_PSR_RBRS_Pos)
#define FDCAN_PSR_RBRS FDCAN_PSR_RBRS_Msk
#define FDCAN_PSR_REDL_Pos (13U)
#define FDCAN_PSR_REDL_Msk (0x1UL << FDCAN_PSR_REDL_Pos)
#define FDCAN_PSR_REDL FDCAN_PSR_REDL_Msk
#define FDCAN_PSR_PXE_Pos (14U)
#define FDCAN_PSR_PXE_Msk (0x1UL << FDCAN_PSR_PXE_Pos)
#define FDCAN_PSR_PXE FDCAN_PSR_PXE_Msk
#define FDCAN_PSR_TDCV_Pos (16U)
#define FDCAN_PSR_TDCV_Msk (0x7FUL << FDCAN_PSR_TDCV_Pos)
#define FDCAN_PSR_TDCV FDCAN_PSR_TDCV_Msk

/*****************  Bit definition for FDCAN_TDCR register  ********************/
#define FDCAN_TDCR_TDCF_Pos (0U)
#define FDCAN_TDCR_TDCF_Msk (0x7FUL << FDCAN_TDCR_TDCF_Pos)
#define FDCAN_TDCR_TDCF FDCAN_TDCR_TDCF_Msk
#define FDCAN_TDCR_TDCO_Pos (8U)
#define FDCAN_TDCR_TDCO_Msk (0x7FUL << FDCAN_TDCR_TDCO_Pos)
#define FDCAN_TDCR_TDCO FDCAN_TDCR_TDCO_Msk

/*****************  Bit definition for FDCAN_IR register  **********************/
#define FDCAN_IR_RF0N_Pos (0U)
#define FDCAN_IR_RF0N_Msk (0x1UL << FDCAN_IR_RF0N_Pos)
#define FDCAN_IR_RF0N FDCAN_IR_RF0N_Msk
#define FDCAN_IR_RF0F_Pos (1U)
#define FDCAN_IR_RF0F_Msk (0x1UL << FDCAN_IR_RF0F_Pos)
#define FDCAN_IR_RF0F FDCAN_IR_RF0F_Msk
#define FDCAN_IR_RF0L_Pos (2U)
#define FDCAN_IR_RF0L_Msk (0x1UL << FDCAN_IR_RF0L_Pos)
#define FDCAN_IR_RF0L FDCAN_IR_RF0L_Msk
#define FDCAN_IR_RF1N_Pos (3U)
#define FDCAN_IR_RF1N_Msk (0x1UL << FDCAN_IR_RF1N_Pos)
#define FDCAN_IR_RF1N FDCAN_IR_RF1N_Msk
#define FDCAN_IR_RF1F_Pos (4U)
#define FDCAN_IR_RF1F_Msk (0x1UL << FDCAN_IR_RF1F_Pos)
#define FDCAN_IR_RF1F FDCAN_IR_RF1F_Msk
#define FDCAN_IR_RF1L_Pos (5U)
#define FDCAN_IR_RF1L_Msk (0x1UL << FDCAN_IR_RF1L_Pos)
#define FDCAN_IR_RF1L FDCAN_IR_RF1L_Msk
#define FDCAN_IR_HPM_Pos (6U)
#define FDCAN_IR_HPM_Msk (0x1UL << FDCAN_IR_HPM_Pos)
#define FDCAN_IR_HPM FDCAN_IR_HPM_Msk
#define FDCAN_IR_TC_Pos (7U)
#define FDCAN_IR_TC_Msk (0x1UL << FDCAN_IR_TC_Pos)
#define FDCAN_IR_TC FDCAN_IR_TC_Msk
#define FDCAN_IR_TCF_Pos (8U)
#define FDCAN_IR_TCF_Msk (0x1UL << FDCAN_IR_TCF_Pos)
#define FDCAN_IR_TCF FDCAN_IR_TCF_Msk
#define FDCAN_IR_TFE_Pos (9U)
#define FDCAN_IR_TFE_Msk (0x1UL << FDCAN_IR_TFE_Pos)
#define FDCAN_IR_TFE FDCAN_IR_TFE_Msk
#define FDCAN_IR_TEFN_Pos (10U)
#define FDCAN_IR_TEFN_Msk (0x1UL << FDCAN_IR_TEFN_Pos)
#define FDCAN_IR_TEFN FDCAN_IR_TEFN_Msk
#define FDCAN_IR_TEFF_Pos (11U)
#define FDCAN_IR_TEFF_Msk (0x1UL << FDCAN_IR_TEFF_Pos)
#define FDCAN_IR_TEFF FDCAN_IR_TEFF_Msk
#define FDCAN_IR_TEFL_Pos (12U)
#define FDCAN_IR_TEFL_Msk (0x1UL << FDCAN_IR_TEFL_Pos)
#define FDCAN_IR_TEFL FDCAN_IR_TEFL_Msk
#define FDCAN_IR_TSW_Pos (13U)
#define FDCAN_IR_TSW_Msk (0x1UL << FDCAN_IR_TSW_Pos)
#define FDCAN_IR_TSW FDCAN_IR_TSW_Msk
#define FDCAN_IR_MRAF_Pos (14U)
#define FDCAN_IR_MRAF_Msk (0x1UL << FDCAN_IR_MRAF_Pos)
#define FDCAN_IR_MRAF FDCAN_IR_MRAF_Msk
#define FDCAN_IR_TOO_Pos (15U)
#define FDCAN_IR_TOO_Msk (0x1UL << FDCAN_IR_TOO_Pos)
#define FDCAN_IR_TOO FDCAN_IR_TOO_Msk
#define FDCAN_IR_ELO_Pos (16U)
#define FDCAN_IR_ELO_Msk (0x1UL << FDCAN_IR_ELO_Pos)
#define FDCAN_IR_ELO FDCAN_IR_ELO_Msk
#define FDCAN_IR_EP_Pos (17U)
#define FDCAN_IR_EP_Msk (0x1UL << FDCAN_IR_EP_Pos)
#define FDCAN_IR_EP FDCAN_IR_EP_Msk
#define FDCAN_IR_EW_Pos (18U)
#define FDCAN_IR_EW_Msk (0x1UL << FDCAN_IR_EW_Pos)
#define FDCAN_IR_EW FDCAN_IR_EW_Msk
#define FDCAN_IR_BO_Pos (19U)
#define FDCAN_IR_BO_Msk (0x1UL << FDCAN_IR_BO_Pos)
#define FDCAN_IR_BO FDCAN_IR_BO_Msk
#define FDCAN_IR_WDI_Pos (20U)
#define FDCAN_IR_WDI_Msk (0x1UL << FDCAN_IR_WDI_Pos)
#define FDCAN_IR_WDI FDCAN_IR_WDI_Msk
#define FDCAN_IR_PEA_Pos (21U)
#define FDCAN_IR_PEA_Msk (0x1UL << FDCAN_IR_PEA_Pos)
#define FDCAN_IR_PEA FDCAN_IR_PEA_Msk
#define FDCAN_IR_PED_Pos (22U)
#define FDCAN_IR_PED_Msk (0x1UL << FDCAN_IR_PED_Pos)
#define FDCAN_IR_PED FDCAN_IR_PED_Msk
#define FDCAN_IR_ARA_Pos (23U)
#define FDCAN_IR_ARA_Msk (0x1UL << FDCAN_IR_ARA_Pos)
#define FDCAN_IR_ARA FDCAN_IR_ARA_Msk

/*****************  Bit definition for FDCAN_IE register  **********************/
#define FDCAN_IE_RF0NE_Pos (0U)
#define FDCAN_IE_RF0NE_Msk (0x1UL << FDCAN_IE_RF0NE_Pos)
#define FDCAN_IE_RF0NE FDCAN_IE_RF0NE_Msk
#define FDCAN_IE_RF0FE_Pos (1U)
#define FDCAN_IE_RF0FE_Msk (0x1UL << FDCAN_IE_RF0FE_Pos)
#define FDCAN_IE_RF0FE FDCAN_IE_RF0FE_Msk
#define FDCAN_IE_RF0LE_Pos (2U)
#define FDCAN_IE_RF0LE_Msk (0x1UL << FDCAN_IE_RF0LE_Pos)
#define FDCAN_IE_RF0LE FDCAN_IE_RF0LE_Msk
#define FDCAN_IE_RF1NE_Pos (3U)
#define FDCAN_IE_RF1NE_Msk (0x1UL << FDCAN_IE_RF1NE_Pos)
#define FDCAN_IE_RF1NE FDCAN_IE_RF1NE_Msk
#define FDCAN_IE_RF1FE_Pos (4U)
#define FDCAN_IE_RF1FE_Msk (0x1UL << FDCAN_IE_RF1FE_Pos)
#define FDCAN_IE_RF1FE FDCAN_IE_RF1FE_Msk
#define FDCAN_IE_RF1LE_Pos (5U)
#define FDCAN_IE_RF1LE_Msk (0x1UL << FDCAN_IE_RF1LE_Pos)
#define FDCAN_IE_RF1LE FDCAN_IE_RF1LE_Msk
#define FDCAN_IE_HPME_Pos (6U)
#define FDCAN_IE_HPME_Msk (0x1UL << FDCAN_IE_HPME_Pos)
#define FDCAN_IE_HPME FDCAN_IE_HPME_Msk
#define FDCAN_IE_TCE_Pos (7U)
#define FDCAN_IE_TCE_Msk (0x1UL << FDCAN_IE_TCE_Pos)
#define FDCAN_IE_TCE FDCAN_IE_TCE_Msk
#define FDCAN_IE_TCFE_Pos (8U)
#define FDCAN_IE_TCFE_Msk (0x1UL << FDCAN_IE_TCFE_Pos)
#define FDCAN_IE_TCFE FDCAN_IE_TCFE_Msk
#define FDCAN_IE_TFEE_Pos (9U)
#define FDCAN_IE_TFEE_Msk (0x1UL << FDCAN_IE_TFEE_Pos)
#define FDCAN_IE_TFEE FDCAN_IE_TFEE_Msk
#define FDCAN_IE_TEFNE_Pos (10U)
#define FDCAN_IE_TEFNE_Msk (0x1UL << FDCAN_IE_TEFNE_Pos)
#define FDCAN_IE_TEFNE FDCAN_IE_TEFNE_Msk
#define FDCAN_IE_TEFFE_Pos (11U)
#define FDCAN_IE_TEFFE_Msk (0x1UL << FDCAN_IE_TEFFE_Pos)
#define FDCAN_IE_TEFFE FDCAN_IE_TEFFE_Msk
#define FDCAN_IE_TEFLE_Pos (12U)
#define FDCAN_IE_TEFLE_Msk (0x1UL << FDCAN_IE_TEFLE_Pos)
#define FDCAN_IE_TEFLE FDCAN_IE_TEFLE_Msk
#define FDCAN_IE_TSWE_Pos (13U)
#define FDCAN_IE_TSWE_Msk (0x1UL << FDCAN_IE_TSWE_Pos)
#define FDCAN_IE_TSWE FDCAN_IE_TSWE_Msk
#define FDCAN_IE_MRAFE_Pos (14U)
#define FDCAN_IE_MRAFE_Msk (0x1UL << FDCAN_IE_MRAFE_Pos)
#define FDCAN_IE_MRAFE FDCAN_IE_MRAFE_Msk
#define FDCAN_IE_TOOE_Pos (15U)
#define FDCAN_IE_TOOE_Msk (0x1UL << FDCAN_IE_TOOE_Pos)
#define FDCAN_IE_TOOE FDCAN_IE_TOOE_Msk
#define FDCAN_IE_ELOE_Pos (16U)
#define FDCAN_IE_ELOE_Msk (0x1UL << FDCAN_IE_ELOE_Pos)
#define FDCAN_IE_ELOE FDCAN_IE_ELOE_Msk
#define FDCAN_IE_EPE_Pos (17U)
#define FDCAN_IE_EPE_Msk (0x1UL << FDCAN_IE_EPE_Pos)
#define FDCAN_IE_EPE FDCAN_IE_EPE_Msk
#define FDCAN_IE_EWE_Pos (18U)
#define FDCAN_IE_EWE_Msk (0x1UL << FDCAN_IE_EWE_Pos)
#define FDCAN_IE_EWE FDCAN_IE_EWE_Msk
#define FDCAN_IE_BOE_Pos (19U)
#define FDCAN_IE_BOE_Msk (0x1UL << FDCAN_IE_BOE_Pos)
#define FDCAN_IE_BOE FDCAN_IE_BOE_Msk
#define FDCAN_IE_WDIE_Pos (20U)
#define FDCAN_IE_WDIE_Msk (0x1UL << FDCAN_IE_WDIE_Pos)
#define FDCAN_IE_WDIE FDCAN_IE_WDIE_Msk
#define FDCAN_IE_PEAE_Pos (21U)
#define FDCAN_IE_PEAE_Msk (0x1UL << FDCAN_IE_PEAE_Pos)
#define FDCAN_IE_PEAE FDCAN_IE_PEAE_Msk
#define FDCAN_IE_PEDE_Pos (22U)
#define FDCAN_IE_PEDE_Msk (0x1UL << FDCAN_IE_PEDE_Pos)
#define FDCAN_IE_PEDE FDCAN_IE_PEDE_Msk
#define FDCAN_IE_ARAE_Pos (23U)
#define FDCAN_IE_ARAE_Msk (0x1UL << FDCAN_IE_ARAE_Pos)
#define FDCAN_IE_ARAE FDCAN_IE_ARAE_Msk

/*****************  Bit definition for FDCAN_ILS register  **********************/
#define FDCAN_ILS_RXFIFO0_Pos (0U)
#define FDCAN_ILS_RXFIFO0_Msk (0x1UL << FDCAN_ILS_RXFIFO0_Pos)
#define FDCAN_ILS_RXFIFO0 FDCAN_ILS_RXFIFO0_Msk


#define FDCAN_ILS_RXFIFO1_Pos (1U)
#define FDCAN_ILS_RXFIFO1_Msk (0x1UL << FDCAN_ILS_RXFIFO1_Pos)
#define FDCAN_ILS_RXFIFO1 FDCAN_ILS_RXFIFO1_Msk


#define FDCAN_ILS_SMSG_Pos (2U)
#define FDCAN_ILS_SMSG_Msk (0x1UL << FDCAN_ILS_SMSG_Pos)
#define FDCAN_ILS_SMSG FDCAN_ILS_SMSG_Msk


#define FDCAN_ILS_TFERR_Pos (3U)
#define FDCAN_ILS_TFERR_Msk (0x1UL << FDCAN_ILS_TFERR_Pos)
#define FDCAN_ILS_TFERR FDCAN_ILS_TFERR_Msk



#define FDCAN_ILS_MISC_Pos (4U)
#define FDCAN_ILS_MISC_Msk (0x1UL << FDCAN_ILS_MISC_Pos)
#define FDCAN_ILS_MISC FDCAN_ILS_MISC_Msk


#define FDCAN_ILS_BERR_Pos (5U)
#define FDCAN_ILS_BERR_Msk (0x1UL << FDCAN_ILS_BERR_Pos)
#define FDCAN_ILS_BERR FDCAN_ILS_BERR_Msk

#define FDCAN_ILS_PERR_Pos (6U)
#define FDCAN_ILS_PERR_Msk (0x1UL << FDCAN_ILS_PERR_Pos)
#define FDCAN_ILS_PERR FDCAN_ILS_PERR_Msk






/*****************  Bit definition for FDCAN_ILE register  **********************/
#define FDCAN_ILE_EINT0_Pos (0U)
#define FDCAN_ILE_EINT0_Msk (0x1UL << FDCAN_ILE_EINT0_Pos)
#define FDCAN_ILE_EINT0 FDCAN_ILE_EINT0_Msk
#define FDCAN_ILE_EINT1_Pos (1U)
#define FDCAN_ILE_EINT1_Msk (0x1UL << FDCAN_ILE_EINT1_Pos)
#define FDCAN_ILE_EINT1 FDCAN_ILE_EINT1_Msk

/*****************  Bit definition for FDCAN_RXGFC register  ********************/
#define FDCAN_RXGFC_RRFE_Pos (0U)
#define FDCAN_RXGFC_RRFE_Msk (0x1UL << FDCAN_RXGFC_RRFE_Pos)
#define FDCAN_RXGFC_RRFE FDCAN_RXGFC_RRFE_Msk
#define FDCAN_RXGFC_RRFS_Pos (1U)
#define FDCAN_RXGFC_RRFS_Msk (0x1UL << FDCAN_RXGFC_RRFS_Pos)
#define FDCAN_RXGFC_RRFS FDCAN_RXGFC_RRFS_Msk
#define FDCAN_RXGFC_ANFE_Pos (2U)
#define FDCAN_RXGFC_ANFE_Msk (0x3UL << FDCAN_RXGFC_ANFE_Pos)
#define FDCAN_RXGFC_ANFE FDCAN_RXGFC_ANFE_Msk
#define FDCAN_RXGFC_ANFS_Pos (4U)
#define FDCAN_RXGFC_ANFS_Msk (0x3UL << FDCAN_RXGFC_ANFS_Pos)
#define FDCAN_RXGFC_ANFS FDCAN_RXGFC_ANFS_Msk
#define FDCAN_RXGFC_F1OM_Pos (8U)
#define FDCAN_RXGFC_F1OM_Msk (0x1UL << FDCAN_RXGFC_F1OM_Pos)
#define FDCAN_RXGFC_F1OM FDCAN_RXGFC_F1OM_Msk
#define FDCAN_RXGFC_F0OM_Pos (9U)
#define FDCAN_RXGFC_F0OM_Msk (0x1UL << FDCAN_RXGFC_F0OM_Pos)
#define FDCAN_RXGFC_F0OM FDCAN_RXGFC_F0OM_Msk
#define FDCAN_RXGFC_LSS_Pos (16U)
#define FDCAN_RXGFC_LSS_Msk (0x1FUL << FDCAN_RXGFC_LSS_Pos)
#define FDCAN_RXGFC_LSS FDCAN_RXGFC_LSS_Msk
#define FDCAN_RXGFC_LSE_Pos (24U)
#define FDCAN_RXGFC_LSE_Msk (0xFUL << FDCAN_RXGFC_LSE_Pos)
#define FDCAN_RXGFC_LSE FDCAN_RXGFC_LSE_Msk

/*****************  Bit definition for FDCAN_XIDAM register  ********************/
#define FDCAN_XIDAM_EIDM_Pos (0U)
#define FDCAN_XIDAM_EIDM_Msk (0x1FFFFFFFUL << FDCAN_XIDAM_EIDM_Pos)
#define FDCAN_XIDAM_EIDM FDCAN_XIDAM_EIDM_Msk

/*****************  Bit definition for FDCAN_HPMS register  *********************/
#define FDCAN_HPMS_BIDX_Pos (0U)
#define FDCAN_HPMS_BIDX_Msk (0x7UL << FDCAN_HPMS_BIDX_Pos)
#define FDCAN_HPMS_BIDX FDCAN_HPMS_BIDX_Msk
#define FDCAN_HPMS_MSI_Pos (6U)
#define FDCAN_HPMS_MSI_Msk (0x3UL << FDCAN_HPMS_MSI_Pos)
#define FDCAN_HPMS_MSI FDCAN_HPMS_MSI_Msk
#define FDCAN_HPMS_FIDX_Pos (8U)
#define FDCAN_HPMS_FIDX_Msk (0x1FUL << FDCAN_HPMS_FIDX_Pos)
#define FDCAN_HPMS_FIDX FDCAN_HPMS_FIDX_Msk
#define FDCAN_HPMS_FLST_Pos (15U)
#define FDCAN_HPMS_FLST_Msk (0x1UL << FDCAN_HPMS_FLST_Pos)
#define FDCAN_HPMS_FLST FDCAN_HPMS_FLST_Msk

/*****************  Bit definition for FDCAN_RXF0S register  ********************/
#define FDCAN_RXF0S_F0FL_Pos (0U)
#define FDCAN_RXF0S_F0FL_Msk (0xFUL << FDCAN_RXF0S_F0FL_Pos)
#define FDCAN_RXF0S_F0FL FDCAN_RXF0S_F0FL_Msk
#define FDCAN_RXF0S_F0GI_Pos (8U)
#define FDCAN_RXF0S_F0GI_Msk (0x3UL << FDCAN_RXF0S_F0GI_Pos)
#define FDCAN_RXF0S_F0GI FDCAN_RXF0S_F0GI_Msk
#define FDCAN_RXF0S_F0PI_Pos (16U)
#define FDCAN_RXF0S_F0PI_Msk (0x3UL << FDCAN_RXF0S_F0PI_Pos)
#define FDCAN_RXF0S_F0PI FDCAN_RXF0S_F0PI_Msk
#define FDCAN_RXF0S_F0F_Pos (24U)
#define FDCAN_RXF0S_F0F_Msk (0x1UL << FDCAN_RXF0S_F0F_Pos)
#define FDCAN_RXF0S_F0F FDCAN_RXF0S_F0F_Msk
#define FDCAN_RXF0S_RF0L_Pos (25U)
#define FDCAN_RXF0S_RF0L_Msk (0x1UL << FDCAN_RXF0S_RF0L_Pos)
#define FDCAN_RXF0S_RF0L FDCAN_RXF0S_RF0L_Msk

/*****************  Bit definition for FDCAN_RXF0A register  ********************/
#define FDCAN_RXF0A_F0AI_Pos (0U)
#define FDCAN_RXF0A_F0AI_Msk (0x7UL << FDCAN_RXF0A_F0AI_Pos)
#define FDCAN_RXF0A_F0AI FDCAN_RXF0A_F0AI_Msk

/*****************  Bit definition for FDCAN_RXF1S register  ********************/
#define FDCAN_RXF1S_F1FL_Pos (0U)
#define FDCAN_RXF1S_F1FL_Msk (0xFUL << FDCAN_RXF1S_F1FL_Pos)
#define FDCAN_RXF1S_F1FL FDCAN_RXF1S_F1FL_Msk
#define FDCAN_RXF1S_F1GI_Pos (8U)
#define FDCAN_RXF1S_F1GI_Msk (0x3UL << FDCAN_RXF1S_F1GI_Pos)
#define FDCAN_RXF1S_F1GI FDCAN_RXF1S_F1GI_Msk
#define FDCAN_RXF1S_F1PI_Pos (16U)
#define FDCAN_RXF1S_F1PI_Msk (0x3UL << FDCAN_RXF1S_F1PI_Pos)
#define FDCAN_RXF1S_F1PI FDCAN_RXF1S_F1PI_Msk
#define FDCAN_RXF1S_F1F_Pos (24U)
#define FDCAN_RXF1S_F1F_Msk (0x1UL << FDCAN_RXF1S_F1F_Pos)
#define FDCAN_RXF1S_F1F FDCAN_RXF1S_F1F_Msk
#define FDCAN_RXF1S_RF1L_Pos (25U)
#define FDCAN_RXF1S_RF1L_Msk (0x1UL << FDCAN_RXF1S_RF1L_Pos)
#define FDCAN_RXF1S_RF1L FDCAN_RXF1S_RF1L_Msk

/*****************  Bit definition for FDCAN_RXF1A register  ********************/
#define FDCAN_RXF1A_F1AI_Pos (0U)
#define FDCAN_RXF1A_F1AI_Msk (0x7UL << FDCAN_RXF1A_F1AI_Pos)
#define FDCAN_RXF1A_F1AI FDCAN_RXF1A_F1AI_Msk

/*****************  Bit definition for FDCAN_TXBC register  *********************/
#define FDCAN_TXBC_TFQM_Pos (24U)
#define FDCAN_TXBC_TFQM_Msk (0x1UL << FDCAN_TXBC_TFQM_Pos)
#define FDCAN_TXBC_TFQM FDCAN_TXBC_TFQM_Msk

/*****************  Bit definition for FDCAN_TXFQS register  *********************/
#define FDCAN_TXFQS_TFFL_Pos (0U)
#define FDCAN_TXFQS_TFFL_Msk (0x7UL << FDCAN_TXFQS_TFFL_Pos)
#define FDCAN_TXFQS_TFFL FDCAN_TXFQS_TFFL_Msk
#define FDCAN_TXFQS_TFGI_Pos (8U)
#define FDCAN_TXFQS_TFGI_Msk (0x3UL << FDCAN_TXFQS_TFGI_Pos)
#define FDCAN_TXFQS_TFGI FDCAN_TXFQS_TFGI_Msk
#define FDCAN_TXFQS_TFQPI_Pos (16U)
#define FDCAN_TXFQS_TFQPI_Msk (0x3UL << FDCAN_TXFQS_TFQPI_Pos)
#define FDCAN_TXFQS_TFQPI FDCAN_TXFQS_TFQPI_Msk
#define FDCAN_TXFQS_TFQF_Pos (21U)
#define FDCAN_TXFQS_TFQF_Msk (0x1UL << FDCAN_TXFQS_TFQF_Pos)
#define FDCAN_TXFQS_TFQF FDCAN_TXFQS_TFQF_Msk

/*****************  Bit definition for FDCAN_TXBRP register  *********************/
#define FDCAN_TXBRP_TRP_Pos (0U)
#define FDCAN_TXBRP_TRP_Msk (0x7UL << FDCAN_TXBRP_TRP_Pos)
#define FDCAN_TXBRP_TRP FDCAN_TXBRP_TRP_Msk

/*****************  Bit definition for FDCAN_TXBAR register  *********************/
#define FDCAN_TXBAR_AR_Pos (0U)
#define FDCAN_TXBAR_AR_Msk (0x7UL << FDCAN_TXBAR_AR_Pos)
#define FDCAN_TXBAR_AR FDCAN_TXBAR_AR_Msk

/*****************  Bit definition for FDCAN_TXBCR register  *********************/
#define FDCAN_TXBCR_CR_Pos (0U)
#define FDCAN_TXBCR_CR_Msk (0x7UL << FDCAN_TXBCR_CR_Pos)
#define FDCAN_TXBCR_CR FDCAN_TXBCR_CR_Msk

/*****************  Bit definition for FDCAN_TXBTO register  *********************/
#define FDCAN_TXBTO_TO_Pos (0U)
#define FDCAN_TXBTO_TO_Msk (0x7UL << FDCAN_TXBTO_TO_Pos)
#define FDCAN_TXBTO_TO FDCAN_TXBTO_TO_Msk

/*****************  Bit definition for FDCAN_TXBCF register  *********************/
#define FDCAN_TXBCF_CF_Pos (0U)
#define FDCAN_TXBCF_CF_Msk (0x7UL << FDCAN_TXBCF_CF_Pos)
#define FDCAN_TXBCF_CF FDCAN_TXBCF_CF_Msk

/*****************  Bit definition for FDCAN_TXBTIE register  ********************/
#define FDCAN_TXBTIE_TIE_Pos (0U)
#define FDCAN_TXBTIE_TIE_Msk (0x7UL << FDCAN_TXBTIE_TIE_Pos)
#define FDCAN_TXBTIE_TIE FDCAN_TXBTIE_TIE_Msk

/*****************  Bit definition for FDCAN_ TXBCIE register  *******************/
#define FDCAN_TXBCIE_CFIE_Pos (0U)
#define FDCAN_TXBCIE_CFIE_Msk (0x7UL << FDCAN_TXBCIE_CFIE_Pos)
#define FDCAN_TXBCIE_CFIE FDCAN_TXBCIE_CFIE_Msk

/*****************  Bit definition for FDCAN_TXEFS register  *********************/
#define FDCAN_TXEFS_EFFL_Pos (0U)
#define FDCAN_TXEFS_EFFL_Msk (0x7UL << FDCAN_TXEFS_EFFL_Pos)
#define FDCAN_TXEFS_EFFL FDCAN_TXEFS_EFFL_Msk
#define FDCAN_TXEFS_EFGI_Pos (8U)
#define FDCAN_TXEFS_EFGI_Msk (0x3UL << FDCAN_TXEFS_EFGI_Pos)
#define FDCAN_TXEFS_EFGI FDCAN_TXEFS_EFGI_Msk
#define FDCAN_TXEFS_EFPI_Pos (16U)
#define FDCAN_TXEFS_EFPI_Msk (0x3UL << FDCAN_TXEFS_EFPI_Pos)
#define FDCAN_TXEFS_EFPI FDCAN_TXEFS_EFPI_Msk
#define FDCAN_TXEFS_EFF_Pos (24U)
#define FDCAN_TXEFS_EFF_Msk (0x1UL << FDCAN_TXEFS_EFF_Pos)
#define FDCAN_TXEFS_EFF FDCAN_TXEFS_EFF_Msk
#define FDCAN_TXEFS_TEFL_Pos (25U)
#define FDCAN_TXEFS_TEFL_Msk (0x1UL << FDCAN_TXEFS_TEFL_Pos)
#define FDCAN_TXEFS_TEFL FDCAN_TXEFS_TEFL_Msk

/*****************  Bit definition for FDCAN_TXEFA register  *********************/
#define FDCAN_TXEFA_EFAI_Pos (0U)
#define FDCAN_TXEFA_EFAI_Msk (0x3UL << FDCAN_TXEFA_EFAI_Pos)
#define FDCAN_TXEFA_EFAI FDCAN_TXEFA_EFAI_Msk


/*!<FDCAN config registers */
/*****************  Bit definition for FDCAN_CKDIV register  *********************/
#define FDCAN_CKDIV_PDIV_Pos (0U)
#define FDCAN_CKDIV_PDIV_Msk (0xFUL << FDCAN_CKDIV_PDIV_Pos)
#define FDCAN_CKDIV_PDIV FDCAN_CKDIV_PDIV_Msk

/******************************************************************************/
/*                                                                            */
/*                                    FLASH                                   */
/*                                                                            */
/******************************************************************************/
/*******************  Bits definition for FLASH_ACR register  *****************/
#define FLASH_ACR_LATENCY_Pos (0U)
#define FLASH_ACR_LATENCY_Msk (0xFUL << FLASH_ACR_LATENCY_Pos)
#define FLASH_ACR_LATENCY FLASH_ACR_LATENCY_Msk
#define FLASH_ACR_LATENCY_0WS (0x00000000U)
#define FLASH_ACR_LATENCY_1WS (0x00000001U)
#define FLASH_ACR_LATENCY_2WS (0x00000002U)
#define FLASH_ACR_LATENCY_3WS (0x00000003U)
#define FLASH_ACR_LATENCY_4WS (0x00000004U)
#define FLASH_ACR_LATENCY_5WS (0x00000005U)
#define FLASH_ACR_LATENCY_6WS (0x00000006U)
#define FLASH_ACR_LATENCY_7WS (0x00000007U)
#define FLASH_ACR_LATENCY_8WS (0x00000008U)
#define FLASH_ACR_LATENCY_9WS (0x00000009U)
#define FLASH_ACR_LATENCY_10WS (0x0000000AU)
#define FLASH_ACR_LATENCY_11WS (0x0000000BU)
#define FLASH_ACR_LATENCY_12WS (0x0000000CU)
#define FLASH_ACR_LATENCY_13WS (0x0000000DU)
#define FLASH_ACR_LATENCY_14WS (0x0000000EU)
#define FLASH_ACR_LATENCY_15WS (0x0000000FU)
#define FLASH_ACR_PRFTEN_Pos (8U)
#define FLASH_ACR_PRFTEN_Msk (0x1UL << FLASH_ACR_PRFTEN_Pos)
#define FLASH_ACR_PRFTEN FLASH_ACR_PRFTEN_Msk
#define FLASH_ACR_ICEN_Pos (9U)
#define FLASH_ACR_ICEN_Msk (0x1UL << FLASH_ACR_ICEN_Pos)
#define FLASH_ACR_ICEN FLASH_ACR_ICEN_Msk
#define FLASH_ACR_DCEN_Pos (10U)
#define FLASH_ACR_DCEN_Msk (0x1UL << FLASH_ACR_DCEN_Pos)
#define FLASH_ACR_DCEN FLASH_ACR_DCEN_Msk
#define FLASH_ACR_ICRST_Pos (11U)
#define FLASH_ACR_ICRST_Msk (0x1UL << FLASH_ACR_ICRST_Pos)
#define FLASH_ACR_ICRST FLASH_ACR_ICRST_Msk
#define FLASH_ACR_DCRST_Pos (12U)
#define FLASH_ACR_DCRST_Msk (0x1UL << FLASH_ACR_DCRST_Pos)
#define FLASH_ACR_DCRST FLASH_ACR_DCRST_Msk
#define FLASH_ACR_RUN_PD_Pos (13U)
#define FLASH_ACR_RUN_PD_Msk (0x1UL << FLASH_ACR_RUN_PD_Pos)
#define FLASH_ACR_RUN_PD FLASH_ACR_RUN_PD_Msk
#define FLASH_ACR_SLEEP_PD_Pos (14U)
#define FLASH_ACR_SLEEP_PD_Msk (0x1UL << FLASH_ACR_SLEEP_PD_Pos)
#define FLASH_ACR_SLEEP_PD FLASH_ACR_SLEEP_PD_Msk
#define FLASH_ACR_DBG_SWEN_Pos (18U)
#define FLASH_ACR_DBG_SWEN_Msk (0x1UL << FLASH_ACR_DBG_SWEN_Pos)
#define FLASH_ACR_DBG_SWEN FLASH_ACR_DBG_SWEN_Msk

/*******************  Bits definition for FLASH_SR register  ******************/
#define FLASH_SR_EOP_Pos (0U)
#define FLASH_SR_EOP_Msk (0x1UL << FLASH_SR_EOP_Pos)
#define FLASH_SR_EOP FLASH_SR_EOP_Msk
#define FLASH_SR_OPERR_Pos (1U)
#define FLASH_SR_OPERR_Msk (0x1UL << FLASH_SR_OPERR_Pos)
#define FLASH_SR_OPERR FLASH_SR_OPERR_Msk
#define FLASH_SR_PROGERR_Pos (3U)
#define FLASH_SR_PROGERR_Msk (0x1UL << FLASH_SR_PROGERR_Pos)
#define FLASH_SR_PROGERR FLASH_SR_PROGERR_Msk
#define FLASH_SR_WRPERR_Pos (4U)
#define FLASH_SR_WRPERR_Msk (0x1UL << FLASH_SR_WRPERR_Pos)
#define FLASH_SR_WRPERR FLASH_SR_WRPERR_Msk
#define FLASH_SR_PGAERR_Pos (5U)
#define FLASH_SR_PGAERR_Msk (0x1UL << FLASH_SR_PGAERR_Pos)
#define FLASH_SR_PGAERR FLASH_SR_PGAERR_Msk
#define FLASH_SR_SIZERR_Pos (6U)
#define FLASH_SR_SIZERR_Msk (0x1UL << FLASH_SR_SIZERR_Pos)
#define FLASH_SR_SIZERR FLASH_SR_SIZERR_Msk
#define FLASH_SR_PGSERR_Pos (7U)
#define FLASH_SR_PGSERR_Msk (0x1UL << FLASH_SR_PGSERR_Pos)
#define FLASH_SR_PGSERR FLASH_SR_PGSERR_Msk
#define FLASH_SR_MISERR_Pos (8U)
#define FLASH_SR_MISERR_Msk (0x1UL << FLASH_SR_MISERR_Pos)
#define FLASH_SR_MISERR FLASH_SR_MISERR_Msk
#define FLASH_SR_FASTERR_Pos (9U)
#define FLASH_SR_FASTERR_Msk (0x1UL << FLASH_SR_FASTERR_Pos)
#define FLASH_SR_FASTERR FLASH_SR_FASTERR_Msk
#define FLASH_SR_RDERR_Pos (14U)
#define FLASH_SR_RDERR_Msk (0x1UL << FLASH_SR_RDERR_Pos)
#define FLASH_SR_RDERR FLASH_SR_RDERR_Msk
#define FLASH_SR_OPTVERR_Pos (15U)
#define FLASH_SR_OPTVERR_Msk (0x1UL << FLASH_SR_OPTVERR_Pos)
#define FLASH_SR_OPTVERR FLASH_SR_OPTVERR_Msk
#define FLASH_SR_BSY_Pos (16U)
#define FLASH_SR_BSY_Msk (0x1UL << FLASH_SR_BSY_Pos)
#define FLASH_SR_BSY FLASH_SR_BSY_Msk

/*******************  Bits definition for FLASH_CR register  ******************/
#define FLASH_CR_PG_Pos (0U)
#define FLASH_CR_PG_Msk (0x1UL << FLASH_CR_PG_Pos)
#define FLASH_CR_PG FLASH_CR_PG_Msk
#define FLASH_CR_PER_Pos (1U)
#define FLASH_CR_PER_Msk (0x1UL << FLASH_CR_PER_Pos)
#define FLASH_CR_PER FLASH_CR_PER_Msk
#define FLASH_CR_MER1_Pos (2U)
#define FLASH_CR_MER1_Msk (0x1UL << FLASH_CR_MER1_Pos)
#define FLASH_CR_MER1 FLASH_CR_MER1_Msk
#define FLASH_CR_PNB_Pos (3U)
#define FLASH_CR_PNB_Msk (0x7FUL << FLASH_CR_PNB_Pos)
#define FLASH_CR_PNB FLASH_CR_PNB_Msk
#define FLASH_CR_BKER_Pos (11U)
#define FLASH_CR_BKER_Msk (0x1UL << FLASH_CR_BKER_Pos)
#define FLASH_CR_BKER FLASH_CR_BKER_Msk
#define FLASH_CR_MER2_Pos (15U)
#define FLASH_CR_MER2_Msk (0x1UL << FLASH_CR_MER2_Pos)
#define FLASH_CR_MER2 FLASH_CR_MER2_Msk
#define FLASH_CR_STRT_Pos (16U)
#define FLASH_CR_STRT_Msk (0x1UL << FLASH_CR_STRT_Pos)
#define FLASH_CR_STRT FLASH_CR_STRT_Msk
#define FLASH_CR_OPTSTRT_Pos (17U)
#define FLASH_CR_OPTSTRT_Msk (0x1UL << FLASH_CR_OPTSTRT_Pos)
#define FLASH_CR_OPTSTRT FLASH_CR_OPTSTRT_Msk
#define FLASH_CR_FSTPG_Pos (18U)
#define FLASH_CR_FSTPG_Msk (0x1UL << FLASH_CR_FSTPG_Pos)
#define FLASH_CR_FSTPG FLASH_CR_FSTPG_Msk
#define FLASH_CR_EOPIE_Pos (24U)
#define FLASH_CR_EOPIE_Msk (0x1UL << FLASH_CR_EOPIE_Pos)
#define FLASH_CR_EOPIE FLASH_CR_EOPIE_Msk
#define FLASH_CR_ERRIE_Pos (25U)
#define FLASH_CR_ERRIE_Msk (0x1UL << FLASH_CR_ERRIE_Pos)
#define FLASH_CR_ERRIE FLASH_CR_ERRIE_Msk
#define FLASH_CR_RDERRIE_Pos (26U)
#define FLASH_CR_RDERRIE_Msk (0x1UL << FLASH_CR_RDERRIE_Pos)
#define FLASH_CR_RDERRIE FLASH_CR_RDERRIE_Msk
#define FLASH_CR_OBL_LAUNCH_Pos (27U)
#define FLASH_CR_OBL_LAUNCH_Msk (0x1UL << FLASH_CR_OBL_LAUNCH_Pos)
#define FLASH_CR_OBL_LAUNCH FLASH_CR_OBL_LAUNCH_Msk
#define FLASH_CR_SEC_PROT1_Pos (28U)
#define FLASH_CR_SEC_PROT1_Msk (0x1UL << FLASH_CR_SEC_PROT1_Pos)
#define FLASH_CR_SEC_PROT1 FLASH_CR_SEC_PROT1_Msk
#define FLASH_CR_SEC_PROT2_Pos (29U)
#define FLASH_CR_SEC_PROT2_Msk (0x1UL << FLASH_CR_SEC_PROT2_Pos)
#define FLASH_CR_SEC_PROT2 FLASH_CR_SEC_PROT2_Msk
#define FLASH_CR_OPTLOCK_Pos (30U)
#define FLASH_CR_OPTLOCK_Msk (0x1UL << FLASH_CR_OPTLOCK_Pos)
#define FLASH_CR_OPTLOCK FLASH_CR_OPTLOCK_Msk
#define FLASH_CR_LOCK_Pos (31U)
#define FLASH_CR_LOCK_Msk (0x1UL << FLASH_CR_LOCK_Pos)
#define FLASH_CR_LOCK FLASH_CR_LOCK_Msk

/*******************  Bits definition for FLASH_ECCR register  ***************/
#define FLASH_ECCR_ADDR_ECC_Pos (0U)
#define FLASH_ECCR_ADDR_ECC_Msk (0x7FFFFUL << FLASH_ECCR_ADDR_ECC_Pos)
#define FLASH_ECCR_ADDR_ECC FLASH_ECCR_ADDR_ECC_Msk
#define FLASH_ECCR_BK_ECC_Pos (21U)
#define FLASH_ECCR_BK_ECC_Msk (0x1UL << FLASH_ECCR_BK_ECC_Pos)
#define FLASH_ECCR_BK_ECC FLASH_ECCR_BK_ECC_Msk
#define FLASH_ECCR_SYSF_ECC_Pos (22U)
#define FLASH_ECCR_SYSF_ECC_Msk (0x1UL << FLASH_ECCR_SYSF_ECC_Pos)
#define FLASH_ECCR_SYSF_ECC FLASH_ECCR_SYSF_ECC_Msk
#define FLASH_ECCR_ECCIE_Pos (24U)
#define FLASH_ECCR_ECCIE_Msk (0x1UL << FLASH_ECCR_ECCIE_Pos)
#define FLASH_ECCR_ECCIE FLASH_ECCR_ECCIE_Msk
#define FLASH_ECCR_ECCC2_Pos (28U)
#define FLASH_ECCR_ECCC2_Msk (0x1UL << FLASH_ECCR_ECCC2_Pos)
#define FLASH_ECCR_ECCC2 FLASH_ECCR_ECCC2_Msk
#define FLASH_ECCR_ECCD2_Pos (29U)
#define FLASH_ECCR_ECCD2_Msk (0x1UL << FLASH_ECCR_ECCD2_Pos)
#define FLASH_ECCR_ECCD2 FLASH_ECCR_ECCD2_Msk
#define FLASH_ECCR_ECCC_Pos (30U)
#define FLASH_ECCR_ECCC_Msk (0x1UL << FLASH_ECCR_ECCC_Pos)
#define FLASH_ECCR_ECCC FLASH_ECCR_ECCC_Msk
#define FLASH_ECCR_ECCD_Pos (31U)
#define FLASH_ECCR_ECCD_Msk (0x1UL << FLASH_ECCR_ECCD_Pos)
#define FLASH_ECCR_ECCD FLASH_ECCR_ECCD_Msk

/*******************  Bits definition for FLASH_OPTR register  ***************/
#define FLASH_OPTR_RDP_Pos (0U)
#define FLASH_OPTR_RDP_Msk (0xFFUL << FLASH_OPTR_RDP_Pos)
#define FLASH_OPTR_RDP FLASH_OPTR_RDP_Msk
#define FLASH_OPTR_BOR_LEV_Pos (8U)
#define FLASH_OPTR_BOR_LEV_Msk (0x7UL << FLASH_OPTR_BOR_LEV_Pos)
#define FLASH_OPTR_BOR_LEV FLASH_OPTR_BOR_LEV_Msk
#define FLASH_OPTR_BOR_LEV_0 (0x0UL << FLASH_OPTR_BOR_LEV_Pos)
#define FLASH_OPTR_BOR_LEV_1 (0x1UL << FLASH_OPTR_BOR_LEV_Pos)
#define FLASH_OPTR_BOR_LEV_2 (0x2UL << FLASH_OPTR_BOR_LEV_Pos)
#define FLASH_OPTR_BOR_LEV_3 (0x3UL << FLASH_OPTR_BOR_LEV_Pos)
#define FLASH_OPTR_BOR_LEV_4 (0x4UL << FLASH_OPTR_BOR_LEV_Pos)
#define FLASH_OPTR_nRST_STOP_Pos (12U)
#define FLASH_OPTR_nRST_STOP_Msk (0x1UL << FLASH_OPTR_nRST_STOP_Pos)
#define FLASH_OPTR_nRST_STOP FLASH_OPTR_nRST_STOP_Msk
#define FLASH_OPTR_nRST_STDBY_Pos (13U)
#define FLASH_OPTR_nRST_STDBY_Msk (0x1UL << FLASH_OPTR_nRST_STDBY_Pos)
#define FLASH_OPTR_nRST_STDBY FLASH_OPTR_nRST_STDBY_Msk
#define FLASH_OPTR_nRST_SHDW_Pos (14U)
#define FLASH_OPTR_nRST_SHDW_Msk (0x1UL << FLASH_OPTR_nRST_SHDW_Pos)
#define FLASH_OPTR_nRST_SHDW FLASH_OPTR_nRST_SHDW_Msk
#define FLASH_OPTR_IWDG_SW_Pos (16U)
#define FLASH_OPTR_IWDG_SW_Msk (0x1UL << FLASH_OPTR_IWDG_SW_Pos)
#define FLASH_OPTR_IWDG_SW FLASH_OPTR_IWDG_SW_Msk
#define FLASH_OPTR_IWDG_STOP_Pos (17U)
#define FLASH_OPTR_IWDG_STOP_Msk (0x1UL << FLASH_OPTR_IWDG_STOP_Pos)
#define FLASH_OPTR_IWDG_STOP FLASH_OPTR_IWDG_STOP_Msk
#define FLASH_OPTR_IWDG_STDBY_Pos (18U)
#define FLASH_OPTR_IWDG_STDBY_Msk (0x1UL << FLASH_OPTR_IWDG_STDBY_Pos)
#define FLASH_OPTR_IWDG_STDBY FLASH_OPTR_IWDG_STDBY_Msk
#define FLASH_OPTR_WWDG_SW_Pos (19U)
#define FLASH_OPTR_WWDG_SW_Msk (0x1UL << FLASH_OPTR_WWDG_SW_Pos)
#define FLASH_OPTR_WWDG_SW FLASH_OPTR_WWDG_SW_Msk
#define FLASH_OPTR_BFB2_Pos (20U)
#define FLASH_OPTR_BFB2_Msk (0x1UL << FLASH_OPTR_BFB2_Pos)
#define FLASH_OPTR_BFB2 FLASH_OPTR_BFB2_Msk
#define FLASH_OPTR_DBANK_Pos (22U)
#define FLASH_OPTR_DBANK_Msk (0x1UL << FLASH_OPTR_DBANK_Pos)
#define FLASH_OPTR_DBANK FLASH_OPTR_DBANK_Msk
#define FLASH_OPTR_nBOOT1_Pos (23U)
#define FLASH_OPTR_nBOOT1_Msk (0x1UL << FLASH_OPTR_nBOOT1_Pos)
#define FLASH_OPTR_nBOOT1 FLASH_OPTR_nBOOT1_Msk
#define FLASH_OPTR_SRAM_PE_Pos (24U)
#define FLASH_OPTR_SRAM_PE_Msk (0x1UL << FLASH_OPTR_SRAM_PE_Pos)
#define FLASH_OPTR_SRAM_PE FLASH_OPTR_SRAM_PE_Msk
#define FLASH_OPTR_CCMSRAM_RST_Pos (25U)
#define FLASH_OPTR_CCMSRAM_RST_Msk (0x1UL << FLASH_OPTR_CCMSRAM_RST_Pos)
#define FLASH_OPTR_CCMSRAM_RST FLASH_OPTR_CCMSRAM_RST_Msk
#define FLASH_OPTR_nSWBOOT0_Pos (26U)
#define FLASH_OPTR_nSWBOOT0_Msk (0x1UL << FLASH_OPTR_nSWBOOT0_Pos)
#define FLASH_OPTR_nSWBOOT0 FLASH_OPTR_nSWBOOT0_Msk
#define FLASH_OPTR_nBOOT0_Pos (27U)
#define FLASH_OPTR_nBOOT0_Msk (0x1UL << FLASH_OPTR_nBOOT0_Pos)
#define FLASH_OPTR_nBOOT0 FLASH_OPTR_nBOOT0_Msk
#define FLASH_OPTR_NRST_MODE_Pos (28U)
#define FLASH_OPTR_NRST_MODE_Msk (0x3UL << FLASH_OPTR_NRST_MODE_Pos)
#define FLASH_OPTR_NRST_MODE FLASH_OPTR_NRST_MODE_Msk
#define FLASH_OPTR_NRST_MODE_0 (0x1UL << FLASH_OPTR_NRST_MODE_Pos)
#define FLASH_OPTR_NRST_MODE_1 (0x2UL << FLASH_OPTR_NRST_MODE_Pos)
#define FLASH_OPTR_IRHEN_Pos (30U)
#define FLASH_OPTR_IRHEN_Msk (0x1UL << FLASH_OPTR_IRHEN_Pos)
#define FLASH_OPTR_IRHEN FLASH_OPTR_IRHEN_Msk

/******************  Bits definition for FLASH_PCROP1SR register  **********/
#define FLASH_PCROP1SR_PCROP1_STRT_Pos (0U)
#define FLASH_PCROP1SR_PCROP1_STRT_Msk (0x7FFFUL << FLASH_PCROP1SR_PCROP1_STRT_Pos)
#define FLASH_PCROP1SR_PCROP1_STRT FLASH_PCROP1SR_PCROP1_STRT_Msk

/******************  Bits definition for FLASH_PCROP1ER register  ***********/
#define FLASH_PCROP1ER_PCROP1_END_Pos (0U)
#define FLASH_PCROP1ER_PCROP1_END_Msk (0x7FFFUL << FLASH_PCROP1ER_PCROP1_END_Pos)
#define FLASH_PCROP1ER_PCROP1_END FLASH_PCROP1ER_PCROP1_END_Msk
#define FLASH_PCROP1ER_PCROP_RDP_Pos (31U)
#define FLASH_PCROP1ER_PCROP_RDP_Msk (0x1UL << FLASH_PCROP1ER_PCROP_RDP_Pos)
#define FLASH_PCROP1ER_PCROP_RDP FLASH_PCROP1ER_PCROP_RDP_Msk

/******************  Bits definition for FLASH_WRP1AR register  ***************/
#define FLASH_WRP1AR_WRP1A_STRT_Pos (0U)
#define FLASH_WRP1AR_WRP1A_STRT_Msk (0x7FUL << FLASH_WRP1AR_WRP1A_STRT_Pos)
#define FLASH_WRP1AR_WRP1A_STRT FLASH_WRP1AR_WRP1A_STRT_Msk
#define FLASH_WRP1AR_WRP1A_END_Pos (16U)
#define FLASH_WRP1AR_WRP1A_END_Msk (0x7FUL << FLASH_WRP1AR_WRP1A_END_Pos)
#define FLASH_WRP1AR_WRP1A_END FLASH_WRP1AR_WRP1A_END_Msk

/******************  Bits definition for FLASH_WRPB1R register  ***************/
#define FLASH_WRP1BR_WRP1B_STRT_Pos (0U)
#define FLASH_WRP1BR_WRP1B_STRT_Msk (0x7FUL << FLASH_WRP1BR_WRP1B_STRT_Pos)
#define FLASH_WRP1BR_WRP1B_STRT FLASH_WRP1BR_WRP1B_STRT_Msk
#define FLASH_WRP1BR_WRP1B_END_Pos (16U)
#define FLASH_WRP1BR_WRP1B_END_Msk (0x7FUL << FLASH_WRP1BR_WRP1B_END_Pos)
#define FLASH_WRP1BR_WRP1B_END FLASH_WRP1BR_WRP1B_END_Msk

/******************  Bits definition for FLASH_PCROP2SR register  **********/
#define FLASH_PCROP2SR_PCROP2_STRT_Pos (0U)
#define FLASH_PCROP2SR_PCROP2_STRT_Msk (0x07FFFUL << FLASH_PCROP2SR_PCROP2_STRT_Pos)
#define FLASH_PCROP2SR_PCROP2_STRT FLASH_PCROP2SR_PCROP2_STRT_Msk

/******************  Bits definition for FLASH_PCROP2ER register  ***********/
#define FLASH_PCROP2ER_PCROP2_END_Pos (0U)
#define FLASH_PCROP2ER_PCROP2_END_Msk (0x07FFFUL << FLASH_PCROP2ER_PCROP2_END_Pos)
#define FLASH_PCROP2ER_PCROP2_END FLASH_PCROP2ER_PCROP2_END_Msk

/******************  Bits definition for FLASH_WRP2AR register  ***************/
#define FLASH_WRP2AR_WRP2A_STRT_Pos (0U)
#define FLASH_WRP2AR_WRP2A_STRT_Msk (0x7FUL << FLASH_WRP2AR_WRP2A_STRT_Pos)
#define FLASH_WRP2AR_WRP2A_STRT FLASH_WRP2AR_WRP2A_STRT_Msk
#define FLASH_WRP2AR_WRP2A_END_Pos (16U)
#define FLASH_WRP2AR_WRP2A_END_Msk (0x7FUL << FLASH_WRP2AR_WRP2A_END_Pos)
#define FLASH_WRP2AR_WRP2A_END FLASH_WRP2AR_WRP2A_END_Msk

/******************  Bits definition for FLASH_WRP2BR register  ***************/
#define FLASH_WRP2BR_WRP2B_STRT_Pos (0U)
#define FLASH_WRP2BR_WRP2B_STRT_Msk (0x7FUL << FLASH_WRP2BR_WRP2B_STRT_Pos)
#define FLASH_WRP2BR_WRP2B_STRT FLASH_WRP2BR_WRP2B_STRT_Msk
#define FLASH_WRP2BR_WRP2B_END_Pos (16U)
#define FLASH_WRP2BR_WRP2B_END_Msk (0x7FUL << FLASH_WRP2BR_WRP2B_END_Pos)
#define FLASH_WRP2BR_WRP2B_END FLASH_WRP2BR_WRP2B_END_Msk

/******************  Bits definition for FLASH_SEC1R register  **************/
#define FLASH_SEC1R_SEC_SIZE1_Pos (0U)
#define FLASH_SEC1R_SEC_SIZE1_Msk (0xFFUL << FLASH_SEC1R_SEC_SIZE1_Pos)
#define FLASH_SEC1R_SEC_SIZE1 FLASH_SEC1R_SEC_SIZE1_Msk
#define FLASH_SEC1R_BOOT_LOCK_Pos (16U)
#define FLASH_SEC1R_BOOT_LOCK_Msk (0x1UL << FLASH_SEC1R_BOOT_LOCK_Pos)
#define FLASH_SEC1R_BOOT_LOCK FLASH_SEC1R_BOOT_LOCK_Msk

/******************  Bits definition for FLASH_SEC2R register  **************/
#define FLASH_SEC2R_SEC_SIZE2_Pos (0U)
#define FLASH_SEC2R_SEC_SIZE2_Msk (0xFFUL << FLASH_SEC2R_SEC_SIZE2_Pos)
#define FLASH_SEC2R_SEC_SIZE2 FLASH_SEC2R_SEC_SIZE2_Msk

/******************************************************************************/
/*                                                                            */
/*                Filter Mathematical ACcelerator unit (FMAC)                 */
/*                                                                            */
/******************************************************************************/
/*****************  Bit definition for FMAC_X1BUFCFG register  ****************/
#define FMAC_X1BUFCFG_X1_BASE_Pos (0U)
#define FMAC_X1BUFCFG_X1_BASE_Msk (0xFFUL << FMAC_X1BUFCFG_X1_BASE_Pos)
#define FMAC_X1BUFCFG_X1_BASE FMAC_X1BUFCFG_X1_BASE_Msk
#define FMAC_X1BUFCFG_X1_BUF_SIZE_Pos (8U)
#define FMAC_X1BUFCFG_X1_BUF_SIZE_Msk (0xFFUL << FMAC_X1BUFCFG_X1_BUF_SIZE_Pos)
#define FMAC_X1BUFCFG_X1_BUF_SIZE FMAC_X1BUFCFG_X1_BUF_SIZE_Msk
#define FMAC_X1BUFCFG_FULL_WM_Pos (24U)
#define FMAC_X1BUFCFG_FULL_WM_Msk (0x3UL << FMAC_X1BUFCFG_FULL_WM_Pos)
#define FMAC_X1BUFCFG_FULL_WM FMAC_X1BUFCFG_FULL_WM_Msk
/*****************  Bit definition for FMAC_X2BUFCFG register  ****************/
#define FMAC_X2BUFCFG_X2_BASE_Pos (0U)
#define FMAC_X2BUFCFG_X2_BASE_Msk (0xFFUL << FMAC_X2BUFCFG_X2_BASE_Pos)
#define FMAC_X2BUFCFG_X2_BASE FMAC_X2BUFCFG_X2_BASE_Msk
#define FMAC_X2BUFCFG_X2_BUF_SIZE_Pos (8U)
#define FMAC_X2BUFCFG_X2_BUF_SIZE_Msk (0xFFUL << FMAC_X2BUFCFG_X2_BUF_SIZE_Pos)
#define FMAC_X2BUFCFG_X2_BUF_SIZE FMAC_X2BUFCFG_X2_BUF_SIZE_Msk
/*****************  Bit definition for FMAC_YBUFCFG register  *****************/
#define FMAC_YBUFCFG_Y_BASE_Pos (0U)
#define FMAC_YBUFCFG_Y_BASE_Msk (0xFFUL << FMAC_YBUFCFG_Y_BASE_Pos)
#define FMAC_YBUFCFG_Y_BASE FMAC_YBUFCFG_Y_BASE_Msk
#define FMAC_YBUFCFG_Y_BUF_SIZE_Pos (8U)
#define FMAC_YBUFCFG_Y_BUF_SIZE_Msk (0xFFUL << FMAC_YBUFCFG_Y_BUF_SIZE_Pos)
#define FMAC_YBUFCFG_Y_BUF_SIZE FMAC_YBUFCFG_Y_BUF_SIZE_Msk
#define FMAC_YBUFCFG_EMPTY_WM_Pos (24U)
#define FMAC_YBUFCFG_EMPTY_WM_Msk (0x3UL << FMAC_YBUFCFG_EMPTY_WM_Pos)
#define FMAC_YBUFCFG_EMPTY_WM FMAC_YBUFCFG_EMPTY_WM_Msk
/******************  Bit definition for FMAC_PARAM register  ******************/
#define FMAC_PARAM_P_Pos (0U)
#define FMAC_PARAM_P_Msk (0xFFUL << FMAC_PARAM_P_Pos)
#define FMAC_PARAM_P FMAC_PARAM_P_Msk
#define FMAC_PARAM_Q_Pos (8U)
#define FMAC_PARAM_Q_Msk (0xFFUL << FMAC_PARAM_Q_Pos)
#define FMAC_PARAM_Q FMAC_PARAM_Q_Msk
#define FMAC_PARAM_R_Pos (16U)
#define FMAC_PARAM_R_Msk (0xFFUL << FMAC_PARAM_R_Pos)
#define FMAC_PARAM_R FMAC_PARAM_R_Msk
#define FMAC_PARAM_FUNC_Pos (24U)
#define FMAC_PARAM_FUNC_Msk (0x7FUL << FMAC_PARAM_FUNC_Pos)
#define FMAC_PARAM_FUNC FMAC_PARAM_FUNC_Msk
#define FMAC_PARAM_FUNC_0 (0x1UL << FMAC_PARAM_FUNC_Pos)
#define FMAC_PARAM_FUNC_1 (0x2UL << FMAC_PARAM_FUNC_Pos)
#define FMAC_PARAM_FUNC_2 (0x4UL << FMAC_PARAM_FUNC_Pos)
#define FMAC_PARAM_FUNC_3 (0x8UL << FMAC_PARAM_FUNC_Pos)
#define FMAC_PARAM_FUNC_4 (0x10UL << FMAC_PARAM_FUNC_Pos)
#define FMAC_PARAM_FUNC_5 (0x20UL << FMAC_PARAM_FUNC_Pos)
#define FMAC_PARAM_FUNC_6 (0x40UL << FMAC_PARAM_FUNC_Pos)
#define FMAC_PARAM_START_Pos (31U)
#define FMAC_PARAM_START_Msk (0x1UL << FMAC_PARAM_START_Pos)
#define FMAC_PARAM_START FMAC_PARAM_START_Msk
/********************  Bit definition for FMAC_CR register  *******************/
#define FMAC_CR_RIEN_Pos (0U)
#define FMAC_CR_RIEN_Msk (0x1UL << FMAC_CR_RIEN_Pos)
#define FMAC_CR_RIEN FMAC_CR_RIEN_Msk
#define FMAC_CR_WIEN_Pos (1U)
#define FMAC_CR_WIEN_Msk (0x1UL << FMAC_CR_WIEN_Pos)
#define FMAC_CR_WIEN FMAC_CR_WIEN_Msk
#define FMAC_CR_OVFLIEN_Pos (2U)
#define FMAC_CR_OVFLIEN_Msk (0x1UL << FMAC_CR_OVFLIEN_Pos)
#define FMAC_CR_OVFLIEN FMAC_CR_OVFLIEN_Msk
#define FMAC_CR_UNFLIEN_Pos (3U)
#define FMAC_CR_UNFLIEN_Msk (0x1UL << FMAC_CR_UNFLIEN_Pos)
#define FMAC_CR_UNFLIEN FMAC_CR_UNFLIEN_Msk
#define FMAC_CR_SATIEN_Pos (4U)
#define FMAC_CR_SATIEN_Msk (0x1UL << FMAC_CR_SATIEN_Pos)
#define FMAC_CR_SATIEN FMAC_CR_SATIEN_Msk
#define FMAC_CR_DMAREN_Pos (8U)
#define FMAC_CR_DMAREN_Msk (0x1UL << FMAC_CR_DMAREN_Pos)
#define FMAC_CR_DMAREN FMAC_CR_DMAREN_Msk
#define FMAC_CR_DMAWEN_Pos (9U)
#define FMAC_CR_DMAWEN_Msk (0x1UL << FMAC_CR_DMAWEN_Pos)
#define FMAC_CR_DMAWEN FMAC_CR_DMAWEN_Msk
#define FMAC_CR_CLIPEN_Pos (15U)
#define FMAC_CR_CLIPEN_Msk (0x1UL << FMAC_CR_CLIPEN_Pos)
#define FMAC_CR_CLIPEN FMAC_CR_CLIPEN_Msk
#define FMAC_CR_RESET_Pos (16U)
#define FMAC_CR_RESET_Msk (0x1UL << FMAC_CR_RESET_Pos)
#define FMAC_CR_RESET FMAC_CR_RESET_Msk
/*******************  Bit definition for FMAC_SR register  ********************/
#define FMAC_SR_YEMPTY_Pos (0U)
#define FMAC_SR_YEMPTY_Msk (0x1UL << FMAC_SR_YEMPTY_Pos)
#define FMAC_SR_YEMPTY FMAC_SR_YEMPTY_Msk
#define FMAC_SR_X1FULL_Pos (1U)
#define FMAC_SR_X1FULL_Msk (0x1UL << FMAC_SR_X1FULL_Pos)
#define FMAC_SR_X1FULL FMAC_SR_X1FULL_Msk
#define FMAC_SR_OVFL_Pos (8U)
#define FMAC_SR_OVFL_Msk (0x1UL << FMAC_SR_OVFL_Pos)
#define FMAC_SR_OVFL FMAC_SR_OVFL_Msk
#define FMAC_SR_UNFL_Pos (9U)
#define FMAC_SR_UNFL_Msk (0x1UL << FMAC_SR_UNFL_Pos)
#define FMAC_SR_UNFL FMAC_SR_UNFL_Msk
#define FMAC_SR_SAT_Pos (10U)
#define FMAC_SR_SAT_Msk (0x1UL << FMAC_SR_SAT_Pos)
#define FMAC_SR_SAT FMAC_SR_SAT_Msk
/******************  Bit definition for FMAC_WDATA register  ******************/
#define FMAC_WDATA_WDATA_Pos (0U)
#define FMAC_WDATA_WDATA_Msk (0xFFFFUL << FMAC_WDATA_WDATA_Pos)
#define FMAC_WDATA_WDATA FMAC_WDATA_WDATA_Msk
/******************  Bit definition for FMACX_RDATA register  *****************/
#define FMAC_RDATA_RDATA_Pos (0U)
#define FMAC_RDATA_RDATA_Msk (0xFFFFUL << FMAC_RDATA_RDATA_Pos)
#define FMAC_RDATA_RDATA FMAC_RDATA_RDATA_Msk

/******************************************************************************/
/*                                                                            */
/*                          Flexible Memory Controller                        */
/*                                                                            */
/******************************************************************************/
/******************  Bit definition for FMC_BCR1 register  *******************/
#define FMC_BCR1_CCLKEN_Pos (20U)
#define FMC_BCR1_CCLKEN_Msk (0x1UL << FMC_BCR1_CCLKEN_Pos)
#define FMC_BCR1_CCLKEN FMC_BCR1_CCLKEN_Msk
#define FMC_BCR1_WFDIS_Pos (21U)
#define FMC_BCR1_WFDIS_Msk (0x1UL << FMC_BCR1_WFDIS_Pos)
#define FMC_BCR1_WFDIS FMC_BCR1_WFDIS_Msk

/******************  Bit definition for FMC_BCRx registers (x=1..4)  *********/
#define FMC_BCRx_MBKEN_Pos (0U)
#define FMC_BCRx_MBKEN_Msk (0x1UL << FMC_BCRx_MBKEN_Pos)
#define FMC_BCRx_MBKEN FMC_BCRx_MBKEN_Msk
#define FMC_BCRx_MUXEN_Pos (1U)
#define FMC_BCRx_MUXEN_Msk (0x1UL << FMC_BCRx_MUXEN_Pos)
#define FMC_BCRx_MUXEN FMC_BCRx_MUXEN_Msk

#define FMC_BCRx_MTYP_Pos (2U)
#define FMC_BCRx_MTYP_Msk (0x3UL << FMC_BCRx_MTYP_Pos)
#define FMC_BCRx_MTYP FMC_BCRx_MTYP_Msk
#define FMC_BCRx_MTYP_0 (0x1UL << FMC_BCRx_MTYP_Pos)
#define FMC_BCRx_MTYP_1 (0x2UL << FMC_BCRx_MTYP_Pos)

#define FMC_BCRx_MWID_Pos (4U)
#define FMC_BCRx_MWID_Msk (0x3UL << FMC_BCRx_MWID_Pos)
#define FMC_BCRx_MWID FMC_BCRx_MWID_Msk
#define FMC_BCRx_MWID_0 (0x1UL << FMC_BCRx_MWID_Pos)
#define FMC_BCRx_MWID_1 (0x2UL << FMC_BCRx_MWID_Pos)

#define FMC_BCRx_FACCEN_Pos (6U)
#define FMC_BCRx_FACCEN_Msk (0x1UL << FMC_BCRx_FACCEN_Pos)
#define FMC_BCRx_FACCEN FMC_BCRx_FACCEN_Msk
#define FMC_BCRx_BURSTEN_Pos (8U)
#define FMC_BCRx_BURSTEN_Msk (0x1UL << FMC_BCRx_BURSTEN_Pos)
#define FMC_BCRx_BURSTEN FMC_BCRx_BURSTEN_Msk
#define FMC_BCRx_WAITPOL_Pos (9U)
#define FMC_BCRx_WAITPOL_Msk (0x1UL << FMC_BCRx_WAITPOL_Pos)
#define FMC_BCRx_WAITPOL FMC_BCRx_WAITPOL_Msk
#define FMC_BCRx_WAITCFG_Pos (11U)
#define FMC_BCRx_WAITCFG_Msk (0x1UL << FMC_BCRx_WAITCFG_Pos)
#define FMC_BCRx_WAITCFG FMC_BCRx_WAITCFG_Msk
#define FMC_BCRx_WREN_Pos (12U)
#define FMC_BCRx_WREN_Msk (0x1UL << FMC_BCRx_WREN_Pos)
#define FMC_BCRx_WREN FMC_BCRx_WREN_Msk
#define FMC_BCRx_WAITEN_Pos (13U)
#define FMC_BCRx_WAITEN_Msk (0x1UL << FMC_BCRx_WAITEN_Pos)
#define FMC_BCRx_WAITEN FMC_BCRx_WAITEN_Msk
#define FMC_BCRx_EXTMOD_Pos (14U)
#define FMC_BCRx_EXTMOD_Msk (0x1UL << FMC_BCRx_EXTMOD_Pos)
#define FMC_BCRx_EXTMOD FMC_BCRx_EXTMOD_Msk
#define FMC_BCRx_ASYNCWAIT_Pos (15U)
#define FMC_BCRx_ASYNCWAIT_Msk (0x1UL << FMC_BCRx_ASYNCWAIT_Pos)
#define FMC_BCRx_ASYNCWAIT FMC_BCRx_ASYNCWAIT_Msk

#define FMC_BCRx_CPSIZE_Pos (16U)
#define FMC_BCRx_CPSIZE_Msk (0x7UL << FMC_BCRx_CPSIZE_Pos)
#define FMC_BCRx_CPSIZE FMC_BCRx_CPSIZE_Msk
#define FMC_BCRx_CPSIZE_0 (0x1UL << FMC_BCRx_CPSIZE_Pos)
#define FMC_BCRx_CPSIZE_1 (0x2UL << FMC_BCRx_CPSIZE_Pos)
#define FMC_BCRx_CPSIZE_2 (0x4UL << FMC_BCRx_CPSIZE_Pos)

#define FMC_BCRx_CBURSTRW_Pos (19U)
#define FMC_BCRx_CBURSTRW_Msk (0x1UL << FMC_BCRx_CBURSTRW_Pos)
#define FMC_BCRx_CBURSTRW FMC_BCRx_CBURSTRW_Msk

#define FMC_BCRx_NBLSET_Pos (22U)
#define FMC_BCRx_NBLSET_Msk (0x3UL << FMC_BCRx_NBLSET_Pos)
#define FMC_BCRx_NBLSET FMC_BCRx_NBLSET_Msk
#define FMC_BCRx_NBLSET_0 (0x1UL << FMC_BCRx_NBLSET_Pos)
#define FMC_BCRx_NBLSET_1 (0x2UL << FMC_BCRx_NBLSET_Pos)

/******************  Bit definition for FMC_BTRx registers (x=1..4)  *********/
#define FMC_BTRx_ADDSET_Pos (0U)
#define FMC_BTRx_ADDSET_Msk (0xFUL << FMC_BTRx_ADDSET_Pos)
#define FMC_BTRx_ADDSET FMC_BTRx_ADDSET_Msk
#define FMC_BTRx_ADDSET_0 (0x1UL << FMC_BTRx_ADDSET_Pos)
#define FMC_BTRx_ADDSET_1 (0x2UL << FMC_BTRx_ADDSET_Pos)
#define FMC_BTRx_ADDSET_2 (0x4UL << FMC_BTRx_ADDSET_Pos)
#define FMC_BTRx_ADDSET_3 (0x8UL << FMC_BTRx_ADDSET_Pos)

#define FMC_BTRx_ADDHLD_Pos (4U)
#define FMC_BTRx_ADDHLD_Msk (0xFUL << FMC_BTRx_ADDHLD_Pos)
#define FMC_BTRx_ADDHLD FMC_BTRx_ADDHLD_Msk
#define FMC_BTRx_ADDHLD_0 (0x1UL << FMC_BTRx_ADDHLD_Pos)
#define FMC_BTRx_ADDHLD_1 (0x2UL << FMC_BTRx_ADDHLD_Pos)
#define FMC_BTRx_ADDHLD_2 (0x4UL << FMC_BTRx_ADDHLD_Pos)
#define FMC_BTRx_ADDHLD_3 (0x8UL << FMC_BTRx_ADDHLD_Pos)

#define FMC_BTRx_DATAST_Pos (8U)
#define FMC_BTRx_DATAST_Msk (0xFFUL << FMC_BTRx_DATAST_Pos)
#define FMC_BTRx_DATAST FMC_BTRx_DATAST_Msk
#define FMC_BTRx_DATAST_0 (0x01UL << FMC_BTRx_DATAST_Pos)
#define FMC_BTRx_DATAST_1 (0x02UL << FMC_BTRx_DATAST_Pos)
#define FMC_BTRx_DATAST_2 (0x04UL << FMC_BTRx_DATAST_Pos)
#define FMC_BTRx_DATAST_3 (0x08UL << FMC_BTRx_DATAST_Pos)
#define FMC_BTRx_DATAST_4 (0x10UL << FMC_BTRx_DATAST_Pos)
#define FMC_BTRx_DATAST_5 (0x20UL << FMC_BTRx_DATAST_Pos)
#define FMC_BTRx_DATAST_6 (0x40UL << FMC_BTRx_DATAST_Pos)
#define FMC_BTRx_DATAST_7 (0x80UL << FMC_BTRx_DATAST_Pos)

#define FMC_BTRx_BUSTURN_Pos (16U)
#define FMC_BTRx_BUSTURN_Msk (0xFUL << FMC_BTRx_BUSTURN_Pos)
#define FMC_BTRx_BUSTURN FMC_BTRx_BUSTURN_Msk
#define FMC_BTRx_BUSTURN_0 (0x1UL << FMC_BTRx_BUSTURN_Pos)
#define FMC_BTRx_BUSTURN_1 (0x2UL << FMC_BTRx_BUSTURN_Pos)
#define FMC_BTRx_BUSTURN_2 (0x4UL << FMC_BTRx_BUSTURN_Pos)
#define FMC_BTRx_BUSTURN_3 (0x8UL << FMC_BTRx_BUSTURN_Pos)

#define FMC_BTRx_CLKDIV_Pos (20U)
#define FMC_BTRx_CLKDIV_Msk (0xFUL << FMC_BTRx_CLKDIV_Pos)
#define FMC_BTRx_CLKDIV FMC_BTRx_CLKDIV_Msk
#define FMC_BTRx_CLKDIV_0 (0x1UL << FMC_BTRx_CLKDIV_Pos)
#define FMC_BTRx_CLKDIV_1 (0x2UL << FMC_BTRx_CLKDIV_Pos)
#define FMC_BTRx_CLKDIV_2 (0x4UL << FMC_BTRx_CLKDIV_Pos)
#define FMC_BTRx_CLKDIV_3 (0x8UL << FMC_BTRx_CLKDIV_Pos)

#define FMC_BTRx_DATLAT_Pos (24U)
#define FMC_BTRx_DATLAT_Msk (0xFUL << FMC_BTRx_DATLAT_Pos)
#define FMC_BTRx_DATLAT FMC_BTRx_DATLAT_Msk
#define FMC_BTRx_DATLAT_0 (0x1UL << FMC_BTRx_DATLAT_Pos)
#define FMC_BTRx_DATLAT_1 (0x2UL << FMC_BTRx_DATLAT_Pos)
#define FMC_BTRx_DATLAT_2 (0x4UL << FMC_BTRx_DATLAT_Pos)
#define FMC_BTRx_DATLAT_3 (0x8UL << FMC_BTRx_DATLAT_Pos)

#define FMC_BTRx_ACCMOD_Pos (28U)
#define FMC_BTRx_ACCMOD_Msk (0x3UL << FMC_BTRx_ACCMOD_Pos)
#define FMC_BTRx_ACCMOD FMC_BTRx_ACCMOD_Msk
#define FMC_BTRx_ACCMOD_0 (0x1UL << FMC_BTRx_ACCMOD_Pos)
#define FMC_BTRx_ACCMOD_1 (0x2UL << FMC_BTRx_ACCMOD_Pos)

#define FMC_BTRx_DATAHLD_Pos (30U)
#define FMC_BTRx_DATAHLD_Msk (0x3UL << FMC_BTRx_DATAHLD_Pos)
#define FMC_BTRx_DATAHLD FMC_BTRx_DATAHLD_Msk
#define FMC_BTRx_DATAHLD_0 (0x1UL << FMC_BTRx_DATAHLD_Pos)
#define FMC_BTRx_DATAHLD_1 (0x2UL << FMC_BTRx_DATAHLD_Pos)

/******************  Bit definition for FMC_BWTRx registers (x=1..4)  *********/
#define FMC_BWTRx_ADDSET_Pos (0U)
#define FMC_BWTRx_ADDSET_Msk (0xFUL << FMC_BWTRx_ADDSET_Pos)
#define FMC_BWTRx_ADDSET FMC_BWTRx_ADDSET_Msk
#define FMC_BWTRx_ADDSET_0 (0x1UL << FMC_BWTRx_ADDSET_Pos)
#define FMC_BWTRx_ADDSET_1 (0x2UL << FMC_BWTRx_ADDSET_Pos)
#define FMC_BWTRx_ADDSET_2 (0x4UL << FMC_BWTRx_ADDSET_Pos)
#define FMC_BWTRx_ADDSET_3 (0x8UL << FMC_BWTRx_ADDSET_Pos)

#define FMC_BWTRx_ADDHLD_Pos (4U)
#define FMC_BWTRx_ADDHLD_Msk (0xFUL << FMC_BWTRx_ADDHLD_Pos)
#define FMC_BWTRx_ADDHLD FMC_BWTRx_ADDHLD_Msk
#define FMC_BWTRx_ADDHLD_0 (0x1UL << FMC_BWTRx_ADDHLD_Pos)
#define FMC_BWTRx_ADDHLD_1 (0x2UL << FMC_BWTRx_ADDHLD_Pos)
#define FMC_BWTRx_ADDHLD_2 (0x4UL << FMC_BWTRx_ADDHLD_Pos)
#define FMC_BWTRx_ADDHLD_3 (0x8UL << FMC_BWTRx_ADDHLD_Pos)

#define FMC_BWTRx_DATAST_Pos (8U)
#define FMC_BWTRx_DATAST_Msk (0xFFUL << FMC_BWTRx_DATAST_Pos)
#define FMC_BWTRx_DATAST FMC_BWTRx_DATAST_Msk
#define FMC_BWTRx_DATAST_0 (0x01UL << FMC_BWTRx_DATAST_Pos)
#define FMC_BWTRx_DATAST_1 (0x02UL << FMC_BWTRx_DATAST_Pos)
#define FMC_BWTRx_DATAST_2 (0x04UL << FMC_BWTRx_DATAST_Pos)
#define FMC_BWTRx_DATAST_3 (0x08UL << FMC_BWTRx_DATAST_Pos)
#define FMC_BWTRx_DATAST_4 (0x10UL << FMC_BWTRx_DATAST_Pos)
#define FMC_BWTRx_DATAST_5 (0x20UL << FMC_BWTRx_DATAST_Pos)
#define FMC_BWTRx_DATAST_6 (0x40UL << FMC_BWTRx_DATAST_Pos)
#define FMC_BWTRx_DATAST_7 (0x80UL << FMC_BWTRx_DATAST_Pos)

#define FMC_BWTRx_BUSTURN_Pos (16U)
#define FMC_BWTRx_BUSTURN_Msk (0xFUL << FMC_BWTRx_BUSTURN_Pos)
#define FMC_BWTRx_BUSTURN FMC_BWTRx_BUSTURN_Msk
#define FMC_BWTRx_BUSTURN_0 (0x1UL << FMC_BWTRx_BUSTURN_Pos)
#define FMC_BWTRx_BUSTURN_1 (0x2UL << FMC_BWTRx_BUSTURN_Pos)
#define FMC_BWTRx_BUSTURN_2 (0x4UL << FMC_BWTRx_BUSTURN_Pos)
#define FMC_BWTRx_BUSTURN_3 (0x8UL << FMC_BWTRx_BUSTURN_Pos)

#define FMC_BWTRx_ACCMOD_Pos (28U)
#define FMC_BWTRx_ACCMOD_Msk (0x3UL << FMC_BWTRx_ACCMOD_Pos)
#define FMC_BWTRx_ACCMOD FMC_BWTRx_ACCMOD_Msk
#define FMC_BWTRx_ACCMOD_0 (0x1UL << FMC_BWTRx_ACCMOD_Pos)
#define FMC_BWTRx_ACCMOD_1 (0x2UL << FMC_BWTRx_ACCMOD_Pos)

#define FMC_BWTRx_DATAHLD_Pos (30U)
#define FMC_BWTRx_DATAHLD_Msk (0x3UL << FMC_BWTRx_DATAHLD_Pos)
#define FMC_BWTRx_DATAHLD FMC_BWTRx_DATAHLD_Msk
#define FMC_BWTRx_DATAHLD_0 (0x1UL << FMC_BWTRx_DATAHLD_Pos)
#define FMC_BWTRx_DATAHLD_1 (0x2UL << FMC_BWTRx_DATAHLD_Pos)

/******************  Bit definition for FMC_PCSCNTR register ******************/
#define FMC_PCSCNTR_CSCOUNT_Pos (0U)
#define FMC_PCSCNTR_CSCOUNT_Msk (0xFFFFUL << FMC_PCSCNTR_CSCOUNT_Pos)
#define FMC_PCSCNTR_CSCOUNT FMC_PCSCNTR_CSCOUNT_Msk

#define FMC_PCSCNTR_CNTB1EN_Pos (16U)
#define FMC_PCSCNTR_CNTB1EN_Msk (0x1UL << FMC_PCSCNTR_CNTB1EN_Pos)
#define FMC_PCSCNTR_CNTB1EN FMC_PCSCNTR_CNTB1EN_Msk

#define FMC_PCSCNTR_CNTB2EN_Pos (17U)
#define FMC_PCSCNTR_CNTB2EN_Msk (0x1UL << FMC_PCSCNTR_CNTB2EN_Pos)
#define FMC_PCSCNTR_CNTB2EN FMC_PCSCNTR_CNTB2EN_Msk

#define FMC_PCSCNTR_CNTB3EN_Pos (18U)
#define FMC_PCSCNTR_CNTB3EN_Msk (0x1UL << FMC_PCSCNTR_CNTB3EN_Pos)
#define FMC_PCSCNTR_CNTB3EN FMC_PCSCNTR_CNTB3EN_Msk

#define FMC_PCSCNTR_CNTB4EN_Pos (19U)
#define FMC_PCSCNTR_CNTB4EN_Msk (0x1UL << FMC_PCSCNTR_CNTB4EN_Pos)
#define FMC_PCSCNTR_CNTB4EN FMC_PCSCNTR_CNTB4EN_Msk

/******************  Bit definition for FMC_PCR register  ********************/
#define FMC_PCR_PWAITEN_Pos (1U)
#define FMC_PCR_PWAITEN_Msk (0x1UL << FMC_PCR_PWAITEN_Pos)
#define FMC_PCR_PWAITEN FMC_PCR_PWAITEN_Msk
#define FMC_PCR_PBKEN_Pos (2U)
#define FMC_PCR_PBKEN_Msk (0x1UL << FMC_PCR_PBKEN_Pos)
#define FMC_PCR_PBKEN FMC_PCR_PBKEN_Msk
#define FMC_PCR_PTYP_Pos (3U)
#define FMC_PCR_PTYP_Msk (0x1UL << FMC_PCR_PTYP_Pos)
#define FMC_PCR_PTYP FMC_PCR_PTYP_Msk

#define FMC_PCR_PWID_Pos (4U)
#define FMC_PCR_PWID_Msk (0x3UL << FMC_PCR_PWID_Pos)
#define FMC_PCR_PWID FMC_PCR_PWID_Msk
#define FMC_PCR_PWID_0 (0x1UL << FMC_PCR_PWID_Pos)
#define FMC_PCR_PWID_1 (0x2UL << FMC_PCR_PWID_Pos)

#define FMC_PCR_ECCEN_Pos (6U)
#define FMC_PCR_ECCEN_Msk (0x1UL << FMC_PCR_ECCEN_Pos)
#define FMC_PCR_ECCEN FMC_PCR_ECCEN_Msk

#define FMC_PCR_TCLR_Pos (9U)
#define FMC_PCR_TCLR_Msk (0xFUL << FMC_PCR_TCLR_Pos)
#define FMC_PCR_TCLR FMC_PCR_TCLR_Msk
#define FMC_PCR_TCLR_0 (0x1UL << FMC_PCR_TCLR_Pos)
#define FMC_PCR_TCLR_1 (0x2UL << FMC_PCR_TCLR_Pos)
#define FMC_PCR_TCLR_2 (0x4UL << FMC_PCR_TCLR_Pos)
#define FMC_PCR_TCLR_3 (0x8UL << FMC_PCR_TCLR_Pos)

#define FMC_PCR_TAR_Pos (13U)
#define FMC_PCR_TAR_Msk (0xFUL << FMC_PCR_TAR_Pos)
#define FMC_PCR_TAR FMC_PCR_TAR_Msk
#define FMC_PCR_TAR_0 (0x1UL << FMC_PCR_TAR_Pos)
#define FMC_PCR_TAR_1 (0x2UL << FMC_PCR_TAR_Pos)
#define FMC_PCR_TAR_2 (0x4UL << FMC_PCR_TAR_Pos)
#define FMC_PCR_TAR_3 (0x8UL << FMC_PCR_TAR_Pos)

#define FMC_PCR_ECCPS_Pos (17U)
#define FMC_PCR_ECCPS_Msk (0x7UL << FMC_PCR_ECCPS_Pos)
#define FMC_PCR_ECCPS FMC_PCR_ECCPS_Msk
#define FMC_PCR_ECCPS_0 (0x1UL << FMC_PCR_ECCPS_Pos)
#define FMC_PCR_ECCPS_1 (0x2UL << FMC_PCR_ECCPS_Pos)
#define FMC_PCR_ECCPS_2 (0x4UL << FMC_PCR_ECCPS_Pos)

/*******************  Bit definition for FMC_SR register  ********************/
#define FMC_SR_IRS_Pos (0U)
#define FMC_SR_IRS_Msk (0x1UL << FMC_SR_IRS_Pos)
#define FMC_SR_IRS FMC_SR_IRS_Msk
#define FMC_SR_ILS_Pos (1U)
#define FMC_SR_ILS_Msk (0x1UL << FMC_SR_ILS_Pos)
#define FMC_SR_ILS FMC_SR_ILS_Msk
#define FMC_SR_IFS_Pos (2U)
#define FMC_SR_IFS_Msk (0x1UL << FMC_SR_IFS_Pos)
#define FMC_SR_IFS FMC_SR_IFS_Msk
#define FMC_SR_IREN_Pos (3U)
#define FMC_SR_IREN_Msk (0x1UL << FMC_SR_IREN_Pos)
#define FMC_SR_IREN FMC_SR_IREN_Msk
#define FMC_SR_ILEN_Pos (4U)
#define FMC_SR_ILEN_Msk (0x1UL << FMC_SR_ILEN_Pos)
#define FMC_SR_ILEN FMC_SR_ILEN_Msk
#define FMC_SR_IFEN_Pos (5U)
#define FMC_SR_IFEN_Msk (0x1UL << FMC_SR_IFEN_Pos)
#define FMC_SR_IFEN FMC_SR_IFEN_Msk
#define FMC_SR_FEMPT_Pos (6U)
#define FMC_SR_FEMPT_Msk (0x1UL << FMC_SR_FEMPT_Pos)
#define FMC_SR_FEMPT FMC_SR_FEMPT_Msk

/******************  Bit definition for FMC_PMEM register  ******************/
#define FMC_PMEM_MEMSET_Pos (0U)
#define FMC_PMEM_MEMSET_Msk (0xFFUL << FMC_PMEM_MEMSET_Pos)
#define FMC_PMEM_MEMSET FMC_PMEM_MEMSET_Msk
#define FMC_PMEM_MEMSET_0 (0x01UL << FMC_PMEM_MEMSET_Pos)
#define FMC_PMEM_MEMSET_1 (0x02UL << FMC_PMEM_MEMSET_Pos)
#define FMC_PMEM_MEMSET_2 (0x04UL << FMC_PMEM_MEMSET_Pos)
#define FMC_PMEM_MEMSET_3 (0x08UL << FMC_PMEM_MEMSET_Pos)
#define FMC_PMEM_MEMSET_4 (0x10UL << FMC_PMEM_MEMSET_Pos)
#define FMC_PMEM_MEMSET_5 (0x20UL << FMC_PMEM_MEMSET_Pos)
#define FMC_PMEM_MEMSET_6 (0x40UL << FMC_PMEM_MEMSET_Pos)
#define FMC_PMEM_MEMSET_7 (0x80UL << FMC_PMEM_MEMSET_Pos)

#define FMC_PMEM_MEMWAIT_Pos (8U)
#define FMC_PMEM_MEMWAIT_Msk (0xFFUL << FMC_PMEM_MEMWAIT_Pos)
#define FMC_PMEM_MEMWAIT FMC_PMEM_MEMWAIT_Msk
#define FMC_PMEM_MEMWAIT_0 (0x01UL << FMC_PMEM_MEMWAIT_Pos)
#define FMC_PMEM_MEMWAIT_1 (0x02UL << FMC_PMEM_MEMWAIT_Pos)
#define FMC_PMEM_MEMWAIT_2 (0x04UL << FMC_PMEM_MEMWAIT_Pos)
#define FMC_PMEM_MEMWAIT_3 (0x08UL << FMC_PMEM_MEMWAIT_Pos)
#define FMC_PMEM_MEMWAIT_4 (0x10UL << FMC_PMEM_MEMWAIT_Pos)
#define FMC_PMEM_MEMWAIT_5 (0x20UL << FMC_PMEM_MEMWAIT_Pos)
#define FMC_PMEM_MEMWAIT_6 (0x40UL << FMC_PMEM_MEMWAIT_Pos)
#define FMC_PMEM_MEMWAIT_7 (0x80UL << FMC_PMEM_MEMWAIT_Pos)

#define FMC_PMEM_MEMHOLD_Pos (16U)
#define FMC_PMEM_MEMHOLD_Msk (0xFFUL << FMC_PMEM_MEMHOLD_Pos)
#define FMC_PMEM_MEMHOLD FMC_PMEM_MEMHOLD_Msk
#define FMC_PMEM_MEMHOLD_0 (0x01UL << FMC_PMEM_MEMHOLD_Pos)
#define FMC_PMEM_MEMHOLD_1 (0x02UL << FMC_PMEM_MEMHOLD_Pos)
#define FMC_PMEM_MEMHOLD_2 (0x04UL << FMC_PMEM_MEMHOLD_Pos)
#define FMC_PMEM_MEMHOLD_3 (0x08UL << FMC_PMEM_MEMHOLD_Pos)
#define FMC_PMEM_MEMHOLD_4 (0x10UL << FMC_PMEM_MEMHOLD_Pos)
#define FMC_PMEM_MEMHOLD_5 (0x20UL << FMC_PMEM_MEMHOLD_Pos)
#define FMC_PMEM_MEMHOLD_6 (0x40UL << FMC_PMEM_MEMHOLD_Pos)
#define FMC_PMEM_MEMHOLD_7 (0x80UL << FMC_PMEM_MEMHOLD_Pos)

#define FMC_PMEM_MEMHIZ_Pos (24U)
#define FMC_PMEM_MEMHIZ_Msk (0xFFUL << FMC_PMEM_MEMHIZ_Pos)
#define FMC_PMEM_MEMHIZ FMC_PMEM_MEMHIZ_Msk
#define FMC_PMEM_MEMHIZ_0 (0x01UL << FMC_PMEM_MEMHIZ_Pos)
#define FMC_PMEM_MEMHIZ_1 (0x02UL << FMC_PMEM_MEMHIZ_Pos)
#define FMC_PMEM_MEMHIZ_2 (0x04UL << FMC_PMEM_MEMHIZ_Pos)
#define FMC_PMEM_MEMHIZ_3 (0x08UL << FMC_PMEM_MEMHIZ_Pos)
#define FMC_PMEM_MEMHIZ_4 (0x10UL << FMC_PMEM_MEMHIZ_Pos)
#define FMC_PMEM_MEMHIZ_5 (0x20UL << FMC_PMEM_MEMHIZ_Pos)
#define FMC_PMEM_MEMHIZ_6 (0x40UL << FMC_PMEM_MEMHIZ_Pos)
#define FMC_PMEM_MEMHIZ_7 (0x80UL << FMC_PMEM_MEMHIZ_Pos)

/******************  Bit definition for FMC_PATT register  *******************/
#define FMC_PATT_ATTSET_Pos (0U)
#define FMC_PATT_ATTSET_Msk (0xFFUL << FMC_PATT_ATTSET_Pos)
#define FMC_PATT_ATTSET FMC_PATT_ATTSET_Msk
#define FMC_PATT_ATTSET_0 (0x01UL << FMC_PATT_ATTSET_Pos)
#define FMC_PATT_ATTSET_1 (0x02UL << FMC_PATT_ATTSET_Pos)
#define FMC_PATT_ATTSET_2 (0x04UL << FMC_PATT_ATTSET_Pos)
#define FMC_PATT_ATTSET_3 (0x08UL << FMC_PATT_ATTSET_Pos)
#define FMC_PATT_ATTSET_4 (0x10UL << FMC_PATT_ATTSET_Pos)
#define FMC_PATT_ATTSET_5 (0x20UL << FMC_PATT_ATTSET_Pos)
#define FMC_PATT_ATTSET_6 (0x40UL << FMC_PATT_ATTSET_Pos)
#define FMC_PATT_ATTSET_7 (0x80UL << FMC_PATT_ATTSET_Pos)

#define FMC_PATT_ATTWAIT_Pos (8U)
#define FMC_PATT_ATTWAIT_Msk (0xFFUL << FMC_PATT_ATTWAIT_Pos)
#define FMC_PATT_ATTWAIT FMC_PATT_ATTWAIT_Msk
#define FMC_PATT_ATTWAIT_0 (0x01UL << FMC_PATT_ATTWAIT_Pos)
#define FMC_PATT_ATTWAIT_1 (0x02UL << FMC_PATT_ATTWAIT_Pos)
#define FMC_PATT_ATTWAIT_2 (0x04UL << FMC_PATT_ATTWAIT_Pos)
#define FMC_PATT_ATTWAIT_3 (0x08UL << FMC_PATT_ATTWAIT_Pos)
#define FMC_PATT_ATTWAIT_4 (0x10UL << FMC_PATT_ATTWAIT_Pos)
#define FMC_PATT_ATTWAIT_5 (0x20UL << FMC_PATT_ATTWAIT_Pos)
#define FMC_PATT_ATTWAIT_6 (0x40UL << FMC_PATT_ATTWAIT_Pos)
#define FMC_PATT_ATTWAIT_7 (0x80UL << FMC_PATT_ATTWAIT_Pos)

#define FMC_PATT_ATTHOLD_Pos (16U)
#define FMC_PATT_ATTHOLD_Msk (0xFFUL << FMC_PATT_ATTHOLD_Pos)
#define FMC_PATT_ATTHOLD FMC_PATT_ATTHOLD_Msk
#define FMC_PATT_ATTHOLD_0 (0x01UL << FMC_PATT_ATTHOLD_Pos)
#define FMC_PATT_ATTHOLD_1 (0x02UL << FMC_PATT_ATTHOLD_Pos)
#define FMC_PATT_ATTHOLD_2 (0x04UL << FMC_PATT_ATTHOLD_Pos)
#define FMC_PATT_ATTHOLD_3 (0x08UL << FMC_PATT_ATTHOLD_Pos)
#define FMC_PATT_ATTHOLD_4 (0x10UL << FMC_PATT_ATTHOLD_Pos)
#define FMC_PATT_ATTHOLD_5 (0x20UL << FMC_PATT_ATTHOLD_Pos)
#define FMC_PATT_ATTHOLD_6 (0x40UL << FMC_PATT_ATTHOLD_Pos)
#define FMC_PATT_ATTHOLD_7 (0x80UL << FMC_PATT_ATTHOLD_Pos)

#define FMC_PATT_ATTHIZ_Pos (24U)
#define FMC_PATT_ATTHIZ_Msk (0xFFUL << FMC_PATT_ATTHIZ_Pos)
#define FMC_PATT_ATTHIZ FMC_PATT_ATTHIZ_Msk
#define FMC_PATT_ATTHIZ_0 (0x01UL << FMC_PATT_ATTHIZ_Pos)
#define FMC_PATT_ATTHIZ_1 (0x02UL << FMC_PATT_ATTHIZ_Pos)
#define FMC_PATT_ATTHIZ_2 (0x04UL << FMC_PATT_ATTHIZ_Pos)
#define FMC_PATT_ATTHIZ_3 (0x08UL << FMC_PATT_ATTHIZ_Pos)
#define FMC_PATT_ATTHIZ_4 (0x10UL << FMC_PATT_ATTHIZ_Pos)
#define FMC_PATT_ATTHIZ_5 (0x20UL << FMC_PATT_ATTHIZ_Pos)
#define FMC_PATT_ATTHIZ_6 (0x40UL << FMC_PATT_ATTHIZ_Pos)
#define FMC_PATT_ATTHIZ_7 (0x80UL << FMC_PATT_ATTHIZ_Pos)

/******************  Bit definition for FMC_ECCR register  *******************/
#define FMC_ECCR_ECC_Pos (0U)
#define FMC_ECCR_ECC_Msk (0xFFFFFFFFUL << FMC_ECCR_ECC_Pos)
#define FMC_ECCR_ECC FMC_ECCR_ECC_Msk

/******************************************************************************/
/*                                                                            */
/*                       General Purpose IOs (GPIO)                           */
/*                                                                            */
/******************************************************************************/
/******************  Bits definition for GPIO_MODER register  *****************/
#define GPIO_MODER_MODE0_Pos (0U)
#define GPIO_MODER_MODE0_Msk (0x3UL << GPIO_MODER_MODE0_Pos)
#define GPIO_MODER_MODE0 GPIO_MODER_MODE0_Msk
#define GPIO_MODER_MODE0_0 (0x1UL << GPIO_MODER_MODE0_Pos)
#define GPIO_MODER_MODE0_1 (0x2UL << GPIO_MODER_MODE0_Pos)
#define GPIO_MODER_MODE1_Pos (2U)
#define GPIO_MODER_MODE1_Msk (0x3UL << GPIO_MODER_MODE1_Pos)
#define GPIO_MODER_MODE1 GPIO_MODER_MODE1_Msk
#define GPIO_MODER_MODE1_0 (0x1UL << GPIO_MODER_MODE1_Pos)
#define GPIO_MODER_MODE1_1 (0x2UL << GPIO_MODER_MODE1_Pos)
#define GPIO_MODER_MODE2_Pos (4U)
#define GPIO_MODER_MODE2_Msk (0x3UL << GPIO_MODER_MODE2_Pos)
#define GPIO_MODER_MODE2 GPIO_MODER_MODE2_Msk
#define GPIO_MODER_MODE2_0 (0x1UL << GPIO_MODER_MODE2_Pos)
#define GPIO_MODER_MODE2_1 (0x2UL << GPIO_MODER_MODE2_Pos)
#define GPIO_MODER_MODE3_Pos (6U)
#define GPIO_MODER_MODE3_Msk (0x3UL << GPIO_MODER_MODE3_Pos)
#define GPIO_MODER_MODE3 GPIO_MODER_MODE3_Msk
#define GPIO_MODER_MODE3_0 (0x1UL << GPIO_MODER_MODE3_Pos)
#define GPIO_MODER_MODE3_1 (0x2UL << GPIO_MODER_MODE3_Pos)
#define GPIO_MODER_MODE4_Pos (8U)
#define GPIO_MODER_MODE4_Msk (0x3UL << GPIO_MODER_MODE4_Pos)
#define GPIO_MODER_MODE4 GPIO_MODER_MODE4_Msk
#define GPIO_MODER_MODE4_0 (0x1UL << GPIO_MODER_MODE4_Pos)
#define GPIO_MODER_MODE4_1 (0x2UL << GPIO_MODER_MODE4_Pos)
#define GPIO_MODER_MODE5_Pos (10U)
#define GPIO_MODER_MODE5_Msk (0x3UL << GPIO_MODER_MODE5_Pos)
#define GPIO_MODER_MODE5 GPIO_MODER_MODE5_Msk
#define GPIO_MODER_MODE5_0 (0x1UL << GPIO_MODER_MODE5_Pos)
#define GPIO_MODER_MODE5_1 (0x2UL << GPIO_MODER_MODE5_Pos)
#define GPIO_MODER_MODE6_Pos (12U)
#define GPIO_MODER_MODE6_Msk (0x3UL << GPIO_MODER_MODE6_Pos)
#define GPIO_MODER_MODE6 GPIO_MODER_MODE6_Msk
#define GPIO_MODER_MODE6_0 (0x1UL << GPIO_MODER_MODE6_Pos)
#define GPIO_MODER_MODE6_1 (0x2UL << GPIO_MODER_MODE6_Pos)
#define GPIO_MODER_MODE7_Pos (14U)
#define GPIO_MODER_MODE7_Msk (0x3UL << GPIO_MODER_MODE7_Pos)
#define GPIO_MODER_MODE7 GPIO_MODER_MODE7_Msk
#define GPIO_MODER_MODE7_0 (0x1UL << GPIO_MODER_MODE7_Pos)
#define GPIO_MODER_MODE7_1 (0x2UL << GPIO_MODER_MODE7_Pos)
#define GPIO_MODER_MODE8_Pos (16U)
#define GPIO_MODER_MODE8_Msk (0x3UL << GPIO_MODER_MODE8_Pos)
#define GPIO_MODER_MODE8 GPIO_MODER_MODE8_Msk
#define GPIO_MODER_MODE8_0 (0x1UL << GPIO_MODER_MODE8_Pos)
#define GPIO_MODER_MODE8_1 (0x2UL << GPIO_MODER_MODE8_Pos)
#define GPIO_MODER_MODE9_Pos (18U)
#define GPIO_MODER_MODE9_Msk (0x3UL << GPIO_MODER_MODE9_Pos)
#define GPIO_MODER_MODE9 GPIO_MODER_MODE9_Msk
#define GPIO_MODER_MODE9_0 (0x1UL << GPIO_MODER_MODE9_Pos)
#define GPIO_MODER_MODE9_1 (0x2UL << GPIO_MODER_MODE9_Pos)
#define GPIO_MODER_MODE10_Pos (20U)
#define GPIO_MODER_MODE10_Msk (0x3UL << GPIO_MODER_MODE10_Pos)
#define GPIO_MODER_MODE10 GPIO_MODER_MODE10_Msk
#define GPIO_MODER_MODE10_0 (0x1UL << GPIO_MODER_MODE10_Pos)
#define GPIO_MODER_MODE10_1 (0x2UL << GPIO_MODER_MODE10_Pos)
#define GPIO_MODER_MODE11_Pos (22U)
#define GPIO_MODER_MODE11_Msk (0x3UL << GPIO_MODER_MODE11_Pos)
#define GPIO_MODER_MODE11 GPIO_MODER_MODE11_Msk
#define GPIO_MODER_MODE11_0 (0x1UL << GPIO_MODER_MODE11_Pos)
#define GPIO_MODER_MODE11_1 (0x2UL << GPIO_MODER_MODE11_Pos)
#define GPIO_MODER_MODE12_Pos (24U)
#define GPIO_MODER_MODE12_Msk (0x3UL << GPIO_MODER_MODE12_Pos)
#define GPIO_MODER_MODE12 GPIO_MODER_MODE12_Msk
#define GPIO_MODER_MODE12_0 (0x1UL << GPIO_MODER_MODE12_Pos)
#define GPIO_MODER_MODE12_1 (0x2UL << GPIO_MODER_MODE12_Pos)
#define GPIO_MODER_MODE13_Pos (26U)
#define GPIO_MODER_MODE13_Msk (0x3UL << GPIO_MODER_MODE13_Pos)
#define GPIO_MODER_MODE13 GPIO_MODER_MODE13_Msk
#define GPIO_MODER_MODE13_0 (0x1UL << GPIO_MODER_MODE13_Pos)
#define GPIO_MODER_MODE13_1 (0x2UL << GPIO_MODER_MODE13_Pos)
#define GPIO_MODER_MODE14_Pos (28U)
#define GPIO_MODER_MODE14_Msk (0x3UL << GPIO_MODER_MODE14_Pos)
#define GPIO_MODER_MODE14 GPIO_MODER_MODE14_Msk
#define GPIO_MODER_MODE14_0 (0x1UL << GPIO_MODER_MODE14_Pos)
#define GPIO_MODER_MODE14_1 (0x2UL << GPIO_MODER_MODE14_Pos)
#define GPIO_MODER_MODE15_Pos (30U)
#define GPIO_MODER_MODE15_Msk (0x3UL << GPIO_MODER_MODE15_Pos)
#define GPIO_MODER_MODE15 GPIO_MODER_MODE15_Msk
#define GPIO_MODER_MODE15_0 (0x1UL << GPIO_MODER_MODE15_Pos)
#define GPIO_MODER_MODE15_1 (0x2UL << GPIO_MODER_MODE15_Pos)

/* Legacy defines */
#define GPIO_MODER_MODER0 GPIO_MODER_MODE0
#define GPIO_MODER_MODER0_0 GPIO_MODER_MODE0_0
#define GPIO_MODER_MODER0_1 GPIO_MODER_MODE0_1
#define GPIO_MODER_MODER1 GPIO_MODER_MODE1
#define GPIO_MODER_MODER1_0 GPIO_MODER_MODE1_0
#define GPIO_MODER_MODER1_1 GPIO_MODER_MODE1_1
#define GPIO_MODER_MODER2 GPIO_MODER_MODE2
#define GPIO_MODER_MODER2_0 GPIO_MODER_MODE2_0
#define GPIO_MODER_MODER2_1 GPIO_MODER_MODE2_1
#define GPIO_MODER_MODER3 GPIO_MODER_MODE3
#define GPIO_MODER_MODER3_0 GPIO_MODER_MODE3_0
#define GPIO_MODER_MODER3_1 GPIO_MODER_MODE3_1
#define GPIO_MODER_MODER4 GPIO_MODER_MODE4
#define GPIO_MODER_MODER4_0 GPIO_MODER_MODE4_0
#define GPIO_MODER_MODER4_1 GPIO_MODER_MODE4_1
#define GPIO_MODER_MODER5 GPIO_MODER_MODE5
#define GPIO_MODER_MODER5_0 GPIO_MODER_MODE5_0
#define GPIO_MODER_MODER5_1 GPIO_MODER_MODE5_1
#define GPIO_MODER_MODER6 GPIO_MODER_MODE6
#define GPIO_MODER_MODER6_0 GPIO_MODER_MODE6_0
#define GPIO_MODER_MODER6_1 GPIO_MODER_MODE6_1
#define GPIO_MODER_MODER7 GPIO_MODER_MODE7
#define GPIO_MODER_MODER7_0 GPIO_MODER_MODE7_0
#define GPIO_MODER_MODER7_1 GPIO_MODER_MODE7_1
#define GPIO_MODER_MODER8 GPIO_MODER_MODE8
#define GPIO_MODER_MODER8_0 GPIO_MODER_MODE8_0
#define GPIO_MODER_MODER8_1 GPIO_MODER_MODE8_1
#define GPIO_MODER_MODER9 GPIO_MODER_MODE9
#define GPIO_MODER_MODER9_0 GPIO_MODER_MODE9_0
#define GPIO_MODER_MODER9_1 GPIO_MODER_MODE9_1
#define GPIO_MODER_MODER10 GPIO_MODER_MODE10
#define GPIO_MODER_MODER10_0 GPIO_MODER_MODE10_0
#define GPIO_MODER_MODER10_1 GPIO_MODER_MODE10_1
#define GPIO_MODER_MODER11 GPIO_MODER_MODE11
#define GPIO_MODER_MODER11_0 GPIO_MODER_MODE11_0
#define GPIO_MODER_MODER11_1 GPIO_MODER_MODE11_1
#define GPIO_MODER_MODER12 GPIO_MODER_MODE12
#define GPIO_MODER_MODER12_0 GPIO_MODER_MODE12_0
#define GPIO_MODER_MODER12_1 GPIO_MODER_MODE12_1
#define GPIO_MODER_MODER13 GPIO_MODER_MODE13
#define GPIO_MODER_MODER13_0 GPIO_MODER_MODE13_0
#define GPIO_MODER_MODER13_1 GPIO_MODER_MODE13_1
#define GPIO_MODER_MODER14 GPIO_MODER_MODE14
#define GPIO_MODER_MODER14_0 GPIO_MODER_MODE14_0
#define GPIO_MODER_MODER14_1 GPIO_MODER_MODE14_1
#define GPIO_MODER_MODER15 GPIO_MODER_MODE15
#define GPIO_MODER_MODER15_0 GPIO_MODER_MODE15_0
#define GPIO_MODER_MODER15_1 GPIO_MODER_MODE15_1

/******************  Bits definition for GPIO_OTYPER register  ****************/
#define GPIO_OTYPER_OT0_Pos (0U)
#define GPIO_OTYPER_OT0_Msk (0x1UL << GPIO_OTYPER_OT0_Pos)
#define GPIO_OTYPER_OT0 GPIO_OTYPER_OT0_Msk
#define GPIO_OTYPER_OT1_Pos (1U)
#define GPIO_OTYPER_OT1_Msk (0x1UL << GPIO_OTYPER_OT1_Pos)
#define GPIO_OTYPER_OT1 GPIO_OTYPER_OT1_Msk
#define GPIO_OTYPER_OT2_Pos (2U)
#define GPIO_OTYPER_OT2_Msk (0x1UL << GPIO_OTYPER_OT2_Pos)
#define GPIO_OTYPER_OT2 GPIO_OTYPER_OT2_Msk
#define GPIO_OTYPER_OT3_Pos (3U)
#define GPIO_OTYPER_OT3_Msk (0x1UL << GPIO_OTYPER_OT3_Pos)
#define GPIO_OTYPER_OT3 GPIO_OTYPER_OT3_Msk
#define GPIO_OTYPER_OT4_Pos (4U)
#define GPIO_OTYPER_OT4_Msk (0x1UL << GPIO_OTYPER_OT4_Pos)
#define GPIO_OTYPER_OT4 GPIO_OTYPER_OT4_Msk
#define GPIO_OTYPER_OT5_Pos (5U)
#define GPIO_OTYPER_OT5_Msk (0x1UL << GPIO_OTYPER_OT5_Pos)
#define GPIO_OTYPER_OT5 GPIO_OTYPER_OT5_Msk
#define GPIO_OTYPER_OT6_Pos (6U)
#define GPIO_OTYPER_OT6_Msk (0x1UL << GPIO_OTYPER_OT6_Pos)
#define GPIO_OTYPER_OT6 GPIO_OTYPER_OT6_Msk
#define GPIO_OTYPER_OT7_Pos (7U)
#define GPIO_OTYPER_OT7_Msk (0x1UL << GPIO_OTYPER_OT7_Pos)
#define GPIO_OTYPER_OT7 GPIO_OTYPER_OT7_Msk
#define GPIO_OTYPER_OT8_Pos (8U)
#define GPIO_OTYPER_OT8_Msk (0x1UL << GPIO_OTYPER_OT8_Pos)
#define GPIO_OTYPER_OT8 GPIO_OTYPER_OT8_Msk
#define GPIO_OTYPER_OT9_Pos (9U)
#define GPIO_OTYPER_OT9_Msk (0x1UL << GPIO_OTYPER_OT9_Pos)
#define GPIO_OTYPER_OT9 GPIO_OTYPER_OT9_Msk
#define GPIO_OTYPER_OT10_Pos (10U)
#define GPIO_OTYPER_OT10_Msk (0x1UL << GPIO_OTYPER_OT10_Pos)
#define GPIO_OTYPER_OT10 GPIO_OTYPER_OT10_Msk
#define GPIO_OTYPER_OT11_Pos (11U)
#define GPIO_OTYPER_OT11_Msk (0x1UL << GPIO_OTYPER_OT11_Pos)
#define GPIO_OTYPER_OT11 GPIO_OTYPER_OT11_Msk
#define GPIO_OTYPER_OT12_Pos (12U)
#define GPIO_OTYPER_OT12_Msk (0x1UL << GPIO_OTYPER_OT12_Pos)
#define GPIO_OTYPER_OT12 GPIO_OTYPER_OT12_Msk
#define GPIO_OTYPER_OT13_Pos (13U)
#define GPIO_OTYPER_OT13_Msk (0x1UL << GPIO_OTYPER_OT13_Pos)
#define GPIO_OTYPER_OT13 GPIO_OTYPER_OT13_Msk
#define GPIO_OTYPER_OT14_Pos (14U)
#define GPIO_OTYPER_OT14_Msk (0x1UL << GPIO_OTYPER_OT14_Pos)
#define GPIO_OTYPER_OT14 GPIO_OTYPER_OT14_Msk
#define GPIO_OTYPER_OT15_Pos (15U)
#define GPIO_OTYPER_OT15_Msk (0x1UL << GPIO_OTYPER_OT15_Pos)
#define GPIO_OTYPER_OT15 GPIO_OTYPER_OT15_Msk

/* Legacy defines */
#define GPIO_OTYPER_OT_0 GPIO_OTYPER_OT0
#define GPIO_OTYPER_OT_1 GPIO_OTYPER_OT1
#define GPIO_OTYPER_OT_2 GPIO_OTYPER_OT2
#define GPIO_OTYPER_OT_3 GPIO_OTYPER_OT3
#define GPIO_OTYPER_OT_4 GPIO_OTYPER_OT4
#define GPIO_OTYPER_OT_5 GPIO_OTYPER_OT5
#define GPIO_OTYPER_OT_6 GPIO_OTYPER_OT6
#define GPIO_OTYPER_OT_7 GPIO_OTYPER_OT7
#define GPIO_OTYPER_OT_8 GPIO_OTYPER_OT8
#define GPIO_OTYPER_OT_9 GPIO_OTYPER_OT9
#define GPIO_OTYPER_OT_10 GPIO_OTYPER_OT10
#define GPIO_OTYPER_OT_11 GPIO_OTYPER_OT11
#define GPIO_OTYPER_OT_12 GPIO_OTYPER_OT12
#define GPIO_OTYPER_OT_13 GPIO_OTYPER_OT13
#define GPIO_OTYPER_OT_14 GPIO_OTYPER_OT14
#define GPIO_OTYPER_OT_15 GPIO_OTYPER_OT15

/******************  Bits definition for GPIO_OSPEEDR register  ***************/
#define GPIO_OSPEEDR_OSPEED0_Pos (0U)
#define GPIO_OSPEEDR_OSPEED0_Msk (0x3UL << GPIO_OSPEEDR_OSPEED0_Pos)
#define GPIO_OSPEEDR_OSPEED0 GPIO_OSPEEDR_OSPEED0_Msk
#define GPIO_OSPEEDR_OSPEED0_0 (0x1UL << GPIO_OSPEEDR_OSPEED0_Pos)
#define GPIO_OSPEEDR_OSPEED0_1 (0x2UL << GPIO_OSPEEDR_OSPEED0_Pos)
#define GPIO_OSPEEDR_OSPEED1_Pos (2U)
#define GPIO_OSPEEDR_OSPEED1_Msk (0x3UL << GPIO_OSPEEDR_OSPEED1_Pos)
#define GPIO_OSPEEDR_OSPEED1 GPIO_OSPEEDR_OSPEED1_Msk
#define GPIO_OSPEEDR_OSPEED1_0 (0x1UL << GPIO_OSPEEDR_OSPEED1_Pos)
#define GPIO_OSPEEDR_OSPEED1_1 (0x2UL << GPIO_OSPEEDR_OSPEED1_Pos)
#define GPIO_OSPEEDR_OSPEED2_Pos (4U)
#define GPIO_OSPEEDR_OSPEED2_Msk (0x3UL << GPIO_OSPEEDR_OSPEED2_Pos)
#define GPIO_OSPEEDR_OSPEED2 GPIO_OSPEEDR_OSPEED2_Msk
#define GPIO_OSPEEDR_OSPEED2_0 (0x1UL << GPIO_OSPEEDR_OSPEED2_Pos)
#define GPIO_OSPEEDR_OSPEED2_1 (0x2UL << GPIO_OSPEEDR_OSPEED2_Pos)
#define GPIO_OSPEEDR_OSPEED3_Pos (6U)
#define GPIO_OSPEEDR_OSPEED3_Msk (0x3UL << GPIO_OSPEEDR_OSPEED3_Pos)
#define GPIO_OSPEEDR_OSPEED3 GPIO_OSPEEDR_OSPEED3_Msk
#define GPIO_OSPEEDR_OSPEED3_0 (0x1UL << GPIO_OSPEEDR_OSPEED3_Pos)
#define GPIO_OSPEEDR_OSPEED3_1 (0x2UL << GPIO_OSPEEDR_OSPEED3_Pos)
#define GPIO_OSPEEDR_OSPEED4_Pos (8U)
#define GPIO_OSPEEDR_OSPEED4_Msk (0x3UL << GPIO_OSPEEDR_OSPEED4_Pos)
#define GPIO_OSPEEDR_OSPEED4 GPIO_OSPEEDR_OSPEED4_Msk
#define GPIO_OSPEEDR_OSPEED4_0 (0x1UL << GPIO_OSPEEDR_OSPEED4_Pos)
#define GPIO_OSPEEDR_OSPEED4_1 (0x2UL << GPIO_OSPEEDR_OSPEED4_Pos)
#define GPIO_OSPEEDR_OSPEED5_Pos (10U)
#define GPIO_OSPEEDR_OSPEED5_Msk (0x3UL << GPIO_OSPEEDR_OSPEED5_Pos)
#define GPIO_OSPEEDR_OSPEED5 GPIO_OSPEEDR_OSPEED5_Msk
#define GPIO_OSPEEDR_OSPEED5_0 (0x1UL << GPIO_OSPEEDR_OSPEED5_Pos)
#define GPIO_OSPEEDR_OSPEED5_1 (0x2UL << GPIO_OSPEEDR_OSPEED5_Pos)
#define GPIO_OSPEEDR_OSPEED6_Pos (12U)
#define GPIO_OSPEEDR_OSPEED6_Msk (0x3UL << GPIO_OSPEEDR_OSPEED6_Pos)
#define GPIO_OSPEEDR_OSPEED6 GPIO_OSPEEDR_OSPEED6_Msk
#define GPIO_OSPEEDR_OSPEED6_0 (0x1UL << GPIO_OSPEEDR_OSPEED6_Pos)
#define GPIO_OSPEEDR_OSPEED6_1 (0x2UL << GPIO_OSPEEDR_OSPEED6_Pos)
#define GPIO_OSPEEDR_OSPEED7_Pos (14U)
#define GPIO_OSPEEDR_OSPEED7_Msk (0x3UL << GPIO_OSPEEDR_OSPEED7_Pos)
#define GPIO_OSPEEDR_OSPEED7 GPIO_OSPEEDR_OSPEED7_Msk
#define GPIO_OSPEEDR_OSPEED7_0 (0x1UL << GPIO_OSPEEDR_OSPEED7_Pos)
#define GPIO_OSPEEDR_OSPEED7_1 (0x2UL << GPIO_OSPEEDR_OSPEED7_Pos)
#define GPIO_OSPEEDR_OSPEED8_Pos (16U)
#define GPIO_OSPEEDR_OSPEED8_Msk (0x3UL << GPIO_OSPEEDR_OSPEED8_Pos)
#define GPIO_OSPEEDR_OSPEED8 GPIO_OSPEEDR_OSPEED8_Msk
#define GPIO_OSPEEDR_OSPEED8_0 (0x1UL << GPIO_OSPEEDR_OSPEED8_Pos)
#define GPIO_OSPEEDR_OSPEED8_1 (0x2UL << GPIO_OSPEEDR_OSPEED8_Pos)
#define GPIO_OSPEEDR_OSPEED9_Pos (18U)
#define GPIO_OSPEEDR_OSPEED9_Msk (0x3UL << GPIO_OSPEEDR_OSPEED9_Pos)
#define GPIO_OSPEEDR_OSPEED9 GPIO_OSPEEDR_OSPEED9_Msk
#define GPIO_OSPEEDR_OSPEED9_0 (0x1UL << GPIO_OSPEEDR_OSPEED9_Pos)
#define GPIO_OSPEEDR_OSPEED9_1 (0x2UL << GPIO_OSPEEDR_OSPEED9_Pos)
#define GPIO_OSPEEDR_OSPEED10_Pos (20U)
#define GPIO_OSPEEDR_OSPEED10_Msk (0x3UL << GPIO_OSPEEDR_OSPEED10_Pos)
#define GPIO_OSPEEDR_OSPEED10 GPIO_OSPEEDR_OSPEED10_Msk
#define GPIO_OSPEEDR_OSPEED10_0 (0x1UL << GPIO_OSPEEDR_OSPEED10_Pos)
#define GPIO_OSPEEDR_OSPEED10_1 (0x2UL << GPIO_OSPEEDR_OSPEED10_Pos)
#define GPIO_OSPEEDR_OSPEED11_Pos (22U)
#define GPIO_OSPEEDR_OSPEED11_Msk (0x3UL << GPIO_OSPEEDR_OSPEED11_Pos)
#define GPIO_OSPEEDR_OSPEED11 GPIO_OSPEEDR_OSPEED11_Msk
#define GPIO_OSPEEDR_OSPEED11_0 (0x1UL << GPIO_OSPEEDR_OSPEED11_Pos)
#define GPIO_OSPEEDR_OSPEED11_1 (0x2UL << GPIO_OSPEEDR_OSPEED11_Pos)
#define GPIO_OSPEEDR_OSPEED12_Pos (24U)
#define GPIO_OSPEEDR_OSPEED12_Msk (0x3UL << GPIO_OSPEEDR_OSPEED12_Pos)
#define GPIO_OSPEEDR_OSPEED12 GPIO_OSPEEDR_OSPEED12_Msk
#define GPIO_OSPEEDR_OSPEED12_0 (0x1UL << GPIO_OSPEEDR_OSPEED12_Pos)
#define GPIO_OSPEEDR_OSPEED12_1 (0x2UL << GPIO_OSPEEDR_OSPEED12_Pos)
#define GPIO_OSPEEDR_OSPEED13_Pos (26U)
#define GPIO_OSPEEDR_OSPEED13_Msk (0x3UL << GPIO_OSPEEDR_OSPEED13_Pos)
#define GPIO_OSPEEDR_OSPEED13 GPIO_OSPEEDR_OSPEED13_Msk
#define GPIO_OSPEEDR_OSPEED13_0 (0x1UL << GPIO_OSPEEDR_OSPEED13_Pos)
#define GPIO_OSPEEDR_OSPEED13_1 (0x2UL << GPIO_OSPEEDR_OSPEED13_Pos)
#define GPIO_OSPEEDR_OSPEED14_Pos (28U)
#define GPIO_OSPEEDR_OSPEED14_Msk (0x3UL << GPIO_OSPEEDR_OSPEED14_Pos)
#define GPIO_OSPEEDR_OSPEED14 GPIO_OSPEEDR_OSPEED14_Msk
#define GPIO_OSPEEDR_OSPEED14_0 (0x1UL << GPIO_OSPEEDR_OSPEED14_Pos)
#define GPIO_OSPEEDR_OSPEED14_1 (0x2UL << GPIO_OSPEEDR_OSPEED14_Pos)
#define GPIO_OSPEEDR_OSPEED15_Pos (30U)
#define GPIO_OSPEEDR_OSPEED15_Msk (0x3UL << GPIO_OSPEEDR_OSPEED15_Pos)
#define GPIO_OSPEEDR_OSPEED15 GPIO_OSPEEDR_OSPEED15_Msk
#define GPIO_OSPEEDR_OSPEED15_0 (0x1UL << GPIO_OSPEEDR_OSPEED15_Pos)
#define GPIO_OSPEEDR_OSPEED15_1 (0x2UL << GPIO_OSPEEDR_OSPEED15_Pos)

/* Legacy defines */
#define GPIO_OSPEEDER_OSPEEDR0 GPIO_OSPEEDR_OSPEED0
#define GPIO_OSPEEDER_OSPEEDR0_0 GPIO_OSPEEDR_OSPEED0_0
#define GPIO_OSPEEDER_OSPEEDR0_1 GPIO_OSPEEDR_OSPEED0_1
#define GPIO_OSPEEDER_OSPEEDR1 GPIO_OSPEEDR_OSPEED1
#define GPIO_OSPEEDER_OSPEEDR1_0 GPIO_OSPEEDR_OSPEED1_0
#define GPIO_OSPEEDER_OSPEEDR1_1 GPIO_OSPEEDR_OSPEED1_1
#define GPIO_OSPEEDER_OSPEEDR2 GPIO_OSPEEDR_OSPEED2
#define GPIO_OSPEEDER_OSPEEDR2_0 GPIO_OSPEEDR_OSPEED2_0
#define GPIO_OSPEEDER_OSPEEDR2_1 GPIO_OSPEEDR_OSPEED2_1
#define GPIO_OSPEEDER_OSPEEDR3 GPIO_OSPEEDR_OSPEED3
#define GPIO_OSPEEDER_OSPEEDR3_0 GPIO_OSPEEDR_OSPEED3_0
#define GPIO_OSPEEDER_OSPEEDR3_1 GPIO_OSPEEDR_OSPEED3_1
#define GPIO_OSPEEDER_OSPEEDR4 GPIO_OSPEEDR_OSPEED4
#define GPIO_OSPEEDER_OSPEEDR4_0 GPIO_OSPEEDR_OSPEED4_0
#define GPIO_OSPEEDER_OSPEEDR4_1 GPIO_OSPEEDR_OSPEED4_1
#define GPIO_OSPEEDER_OSPEEDR5 GPIO_OSPEEDR_OSPEED5
#define GPIO_OSPEEDER_OSPEEDR5_0 GPIO_OSPEEDR_OSPEED5_0
#define GPIO_OSPEEDER_OSPEEDR5_1 GPIO_OSPEEDR_OSPEED5_1
#define GPIO_OSPEEDER_OSPEEDR6 GPIO_OSPEEDR_OSPEED6
#define GPIO_OSPEEDER_OSPEEDR6_0 GPIO_OSPEEDR_OSPEED6_0
#define GPIO_OSPEEDER_OSPEEDR6_1 GPIO_OSPEEDR_OSPEED6_1
#define GPIO_OSPEEDER_OSPEEDR7 GPIO_OSPEEDR_OSPEED7
#define GPIO_OSPEEDER_OSPEEDR7_0 GPIO_OSPEEDR_OSPEED7_0
#define GPIO_OSPEEDER_OSPEEDR7_1 GPIO_OSPEEDR_OSPEED7_1
#define GPIO_OSPEEDER_OSPEEDR8 GPIO_OSPEEDR_OSPEED8
#define GPIO_OSPEEDER_OSPEEDR8_0 GPIO_OSPEEDR_OSPEED8_0
#define GPIO_OSPEEDER_OSPEEDR8_1 GPIO_OSPEEDR_OSPEED8_1
#define GPIO_OSPEEDER_OSPEEDR9 GPIO_OSPEEDR_OSPEED9
#define GPIO_OSPEEDER_OSPEEDR9_0 GPIO_OSPEEDR_OSPEED9_0
#define GPIO_OSPEEDER_OSPEEDR9_1 GPIO_OSPEEDR_OSPEED9_1
#define GPIO_OSPEEDER_OSPEEDR10 GPIO_OSPEEDR_OSPEED10
#define GPIO_OSPEEDER_OSPEEDR10_0 GPIO_OSPEEDR_OSPEED10_0
#define GPIO_OSPEEDER_OSPEEDR10_1 GPIO_OSPEEDR_OSPEED10_1
#define GPIO_OSPEEDER_OSPEEDR11 GPIO_OSPEEDR_OSPEED11
#define GPIO_OSPEEDER_OSPEEDR11_0 GPIO_OSPEEDR_OSPEED11_0
#define GPIO_OSPEEDER_OSPEEDR11_1 GPIO_OSPEEDR_OSPEED11_1
#define GPIO_OSPEEDER_OSPEEDR12 GPIO_OSPEEDR_OSPEED12
#define GPIO_OSPEEDER_OSPEEDR12_0 GPIO_OSPEEDR_OSPEED12_0
#define GPIO_OSPEEDER_OSPEEDR12_1 GPIO_OSPEEDR_OSPEED12_1
#define GPIO_OSPEEDER_OSPEEDR13 GPIO_OSPEEDR_OSPEED13
#define GPIO_OSPEEDER_OSPEEDR13_0 GPIO_OSPEEDR_OSPEED13_0
#define GPIO_OSPEEDER_OSPEEDR13_1 GPIO_OSPEEDR_OSPEED13_1
#define GPIO_OSPEEDER_OSPEEDR14 GPIO_OSPEEDR_OSPEED14
#define GPIO_OSPEEDER_OSPEEDR14_0 GPIO_OSPEEDR_OSPEED14_0
#define GPIO_OSPEEDER_OSPEEDR14_1 GPIO_OSPEEDR_OSPEED14_1
#define GPIO_OSPEEDER_OSPEEDR15 GPIO_OSPEEDR_OSPEED15
#define GPIO_OSPEEDER_OSPEEDR15_0 GPIO_OSPEEDR_OSPEED15_0
#define GPIO_OSPEEDER_OSPEEDR15_1 GPIO_OSPEEDR_OSPEED15_1

/******************  Bits definition for GPIO_PUPDR register  *****************/
#define GPIO_PUPDR_PUPD0_Pos (0U)
#define GPIO_PUPDR_PUPD0_Msk (0x3UL << GPIO_PUPDR_PUPD0_Pos)
#define GPIO_PUPDR_PUPD0 GPIO_PUPDR_PUPD0_Msk
#define GPIO_PUPDR_PUPD0_0 (0x1UL << GPIO_PUPDR_PUPD0_Pos)
#define GPIO_PUPDR_PUPD0_1 (0x2UL << GPIO_PUPDR_PUPD0_Pos)
#define GPIO_PUPDR_PUPD1_Pos (2U)
#define GPIO_PUPDR_PUPD1_Msk (0x3UL << GPIO_PUPDR_PUPD1_Pos)
#define GPIO_PUPDR_PUPD1 GPIO_PUPDR_PUPD1_Msk
#define GPIO_PUPDR_PUPD1_0 (0x1UL << GPIO_PUPDR_PUPD1_Pos)
#define GPIO_PUPDR_PUPD1_1 (0x2UL << GPIO_PUPDR_PUPD1_Pos)
#define GPIO_PUPDR_PUPD2_Pos (4U)
#define GPIO_PUPDR_PUPD2_Msk (0x3UL << GPIO_PUPDR_PUPD2_Pos)
#define GPIO_PUPDR_PUPD2 GPIO_PUPDR_PUPD2_Msk
#define GPIO_PUPDR_PUPD2_0 (0x1UL << GPIO_PUPDR_PUPD2_Pos)
#define GPIO_PUPDR_PUPD2_1 (0x2UL << GPIO_PUPDR_PUPD2_Pos)
#define GPIO_PUPDR_PUPD3_Pos (6U)
#define GPIO_PUPDR_PUPD3_Msk (0x3UL << GPIO_PUPDR_PUPD3_Pos)
#define GPIO_PUPDR_PUPD3 GPIO_PUPDR_PUPD3_Msk
#define GPIO_PUPDR_PUPD3_0 (0x1UL << GPIO_PUPDR_PUPD3_Pos)
#define GPIO_PUPDR_PUPD3_1 (0x2UL << GPIO_PUPDR_PUPD3_Pos)
#define GPIO_PUPDR_PUPD4_Pos (8U)
#define GPIO_PUPDR_PUPD4_Msk (0x3UL << GPIO_PUPDR_PUPD4_Pos)
#define GPIO_PUPDR_PUPD4 GPIO_PUPDR_PUPD4_Msk
#define GPIO_PUPDR_PUPD4_0 (0x1UL << GPIO_PUPDR_PUPD4_Pos)
#define GPIO_PUPDR_PUPD4_1 (0x2UL << GPIO_PUPDR_PUPD4_Pos)
#define GPIO_PUPDR_PUPD5_Pos (10U)
#define GPIO_PUPDR_PUPD5_Msk (0x3UL << GPIO_PUPDR_PUPD5_Pos)
#define GPIO_PUPDR_PUPD5 GPIO_PUPDR_PUPD5_Msk
#define GPIO_PUPDR_PUPD5_0 (0x1UL << GPIO_PUPDR_PUPD5_Pos)
#define GPIO_PUPDR_PUPD5_1 (0x2UL << GPIO_PUPDR_PUPD5_Pos)
#define GPIO_PUPDR_PUPD6_Pos (12U)
#define GPIO_PUPDR_PUPD6_Msk (0x3UL << GPIO_PUPDR_PUPD6_Pos)
#define GPIO_PUPDR_PUPD6 GPIO_PUPDR_PUPD6_Msk
#define GPIO_PUPDR_PUPD6_0 (0x1UL << GPIO_PUPDR_PUPD6_Pos)
#define GPIO_PUPDR_PUPD6_1 (0x2UL << GPIO_PUPDR_PUPD6_Pos)
#define GPIO_PUPDR_PUPD7_Pos (14U)
#define GPIO_PUPDR_PUPD7_Msk (0x3UL << GPIO_PUPDR_PUPD7_Pos)
#define GPIO_PUPDR_PUPD7 GPIO_PUPDR_PUPD7_Msk
#define GPIO_PUPDR_PUPD7_0 (0x1UL << GPIO_PUPDR_PUPD7_Pos)
#define GPIO_PUPDR_PUPD7_1 (0x2UL << GPIO_PUPDR_PUPD7_Pos)
#define GPIO_PUPDR_PUPD8_Pos (16U)
#define GPIO_PUPDR_PUPD8_Msk (0x3UL << GPIO_PUPDR_PUPD8_Pos)
#define GPIO_PUPDR_PUPD8 GPIO_PUPDR_PUPD8_Msk
#define GPIO_PUPDR_PUPD8_0 (0x1UL << GPIO_PUPDR_PUPD8_Pos)
#define GPIO_PUPDR_PUPD8_1 (0x2UL << GPIO_PUPDR_PUPD8_Pos)
#define GPIO_PUPDR_PUPD9_Pos (18U)
#define GPIO_PUPDR_PUPD9_Msk (0x3UL << GPIO_PUPDR_PUPD9_Pos)
#define GPIO_PUPDR_PUPD9 GPIO_PUPDR_PUPD9_Msk
#define GPIO_PUPDR_PUPD9_0 (0x1UL << GPIO_PUPDR_PUPD9_Pos)
#define GPIO_PUPDR_PUPD9_1 (0x2UL << GPIO_PUPDR_PUPD9_Pos)
#define GPIO_PUPDR_PUPD10_Pos (20U)
#define GPIO_PUPDR_PUPD10_Msk (0x3UL << GPIO_PUPDR_PUPD10_Pos)
#define GPIO_PUPDR_PUPD10 GPIO_PUPDR_PUPD10_Msk
#define GPIO_PUPDR_PUPD10_0 (0x1UL << GPIO_PUPDR_PUPD10_Pos)
#define GPIO_PUPDR_PUPD10_1 (0x2UL << GPIO_PUPDR_PUPD10_Pos)
#define GPIO_PUPDR_PUPD11_Pos (22U)
#define GPIO_PUPDR_PUPD11_Msk (0x3UL << GPIO_PUPDR_PUPD11_Pos)
#define GPIO_PUPDR_PUPD11 GPIO_PUPDR_PUPD11_Msk
#define GPIO_PUPDR_PUPD11_0 (0x1UL << GPIO_PUPDR_PUPD11_Pos)
#define GPIO_PUPDR_PUPD11_1 (0x2UL << GPIO_PUPDR_PUPD11_Pos)
#define GPIO_PUPDR_PUPD12_Pos (24U)
#define GPIO_PUPDR_PUPD12_Msk (0x3UL << GPIO_PUPDR_PUPD12_Pos)
#define GPIO_PUPDR_PUPD12 GPIO_PUPDR_PUPD12_Msk
#define GPIO_PUPDR_PUPD12_0 (0x1UL << GPIO_PUPDR_PUPD12_Pos)
#define GPIO_PUPDR_PUPD12_1 (0x2UL << GPIO_PUPDR_PUPD12_Pos)
#define GPIO_PUPDR_PUPD13_Pos (26U)
#define GPIO_PUPDR_PUPD13_Msk (0x3UL << GPIO_PUPDR_PUPD13_Pos)
#define GPIO_PUPDR_PUPD13 GPIO_PUPDR_PUPD13_Msk
#define GPIO_PUPDR_PUPD13_0 (0x1UL << GPIO_PUPDR_PUPD13_Pos)
#define GPIO_PUPDR_PUPD13_1 (0x2UL << GPIO_PUPDR_PUPD13_Pos)
#define GPIO_PUPDR_PUPD14_Pos (28U)
#define GPIO_PUPDR_PUPD14_Msk (0x3UL << GPIO_PUPDR_PUPD14_Pos)
#define GPIO_PUPDR_PUPD14 GPIO_PUPDR_PUPD14_Msk
#define GPIO_PUPDR_PUPD14_0 (0x1UL << GPIO_PUPDR_PUPD14_Pos)
#define GPIO_PUPDR_PUPD14_1 (0x2UL << GPIO_PUPDR_PUPD14_Pos)
#define GPIO_PUPDR_PUPD15_Pos (30U)
#define GPIO_PUPDR_PUPD15_Msk (0x3UL << GPIO_PUPDR_PUPD15_Pos)
#define GPIO_PUPDR_PUPD15 GPIO_PUPDR_PUPD15_Msk
#define GPIO_PUPDR_PUPD15_0 (0x1UL << GPIO_PUPDR_PUPD15_Pos)
#define GPIO_PUPDR_PUPD15_1 (0x2UL << GPIO_PUPDR_PUPD15_Pos)

/* Legacy defines */
#define GPIO_PUPDR_PUPDR0 GPIO_PUPDR_PUPD0
#define GPIO_PUPDR_PUPDR0_0 GPIO_PUPDR_PUPD0_0
#define GPIO_PUPDR_PUPDR0_1 GPIO_PUPDR_PUPD0_1
#define GPIO_PUPDR_PUPDR1 GPIO_PUPDR_PUPD1
#define GPIO_PUPDR_PUPDR1_0 GPIO_PUPDR_PUPD1_0
#define GPIO_PUPDR_PUPDR1_1 GPIO_PUPDR_PUPD1_1
#define GPIO_PUPDR_PUPDR2 GPIO_PUPDR_PUPD2
#define GPIO_PUPDR_PUPDR2_0 GPIO_PUPDR_PUPD2_0
#define GPIO_PUPDR_PUPDR2_1 GPIO_PUPDR_PUPD2_1
#define GPIO_PUPDR_PUPDR3 GPIO_PUPDR_PUPD3
#define GPIO_PUPDR_PUPDR3_0 GPIO_PUPDR_PUPD3_0
#define GPIO_PUPDR_PUPDR3_1 GPIO_PUPDR_PUPD3_1
#define GPIO_PUPDR_PUPDR4 GPIO_PUPDR_PUPD4
#define GPIO_PUPDR_PUPDR4_0 GPIO_PUPDR_PUPD4_0
#define GPIO_PUPDR_PUPDR4_1 GPIO_PUPDR_PUPD4_1
#define GPIO_PUPDR_PUPDR5 GPIO_PUPDR_PUPD5
#define GPIO_PUPDR_PUPDR5_0 GPIO_PUPDR_PUPD5_0
#define GPIO_PUPDR_PUPDR5_1 GPIO_PUPDR_PUPD5_1
#define GPIO_PUPDR_PUPDR6 GPIO_PUPDR_PUPD6
#define GPIO_PUPDR_PUPDR6_0 GPIO_PUPDR_PUPD6_0
#define GPIO_PUPDR_PUPDR6_1 GPIO_PUPDR_PUPD6_1
#define GPIO_PUPDR_PUPDR7 GPIO_PUPDR_PUPD7
#define GPIO_PUPDR_PUPDR7_0 GPIO_PUPDR_PUPD7_0
#define GPIO_PUPDR_PUPDR7_1 GPIO_PUPDR_PUPD7_1
#define GPIO_PUPDR_PUPDR8 GPIO_PUPDR_PUPD8
#define GPIO_PUPDR_PUPDR8_0 GPIO_PUPDR_PUPD8_0
#define GPIO_PUPDR_PUPDR8_1 GPIO_PUPDR_PUPD8_1
#define GPIO_PUPDR_PUPDR9 GPIO_PUPDR_PUPD9
#define GPIO_PUPDR_PUPDR9_0 GPIO_PUPDR_PUPD9_0
#define GPIO_PUPDR_PUPDR9_1 GPIO_PUPDR_PUPD9_1
#define GPIO_PUPDR_PUPDR10 GPIO_PUPDR_PUPD10
#define GPIO_PUPDR_PUPDR10_0 GPIO_PUPDR_PUPD10_0
#define GPIO_PUPDR_PUPDR10_1 GPIO_PUPDR_PUPD10_1
#define GPIO_PUPDR_PUPDR11 GPIO_PUPDR_PUPD11
#define GPIO_PUPDR_PUPDR11_0 GPIO_PUPDR_PUPD11_0
#define GPIO_PUPDR_PUPDR11_1 GPIO_PUPDR_PUPD11_1
#define GPIO_PUPDR_PUPDR12 GPIO_PUPDR_PUPD12
#define GPIO_PUPDR_PUPDR12_0 GPIO_PUPDR_PUPD12_0
#define GPIO_PUPDR_PUPDR12_1 GPIO_PUPDR_PUPD12_1
#define GPIO_PUPDR_PUPDR13 GPIO_PUPDR_PUPD13
#define GPIO_PUPDR_PUPDR13_0 GPIO_PUPDR_PUPD13_0
#define GPIO_PUPDR_PUPDR13_1 GPIO_PUPDR_PUPD13_1
#define GPIO_PUPDR_PUPDR14 GPIO_PUPDR_PUPD14
#define GPIO_PUPDR_PUPDR14_0 GPIO_PUPDR_PUPD14_0
#define GPIO_PUPDR_PUPDR14_1 GPIO_PUPDR_PUPD14_1
#define GPIO_PUPDR_PUPDR15 GPIO_PUPDR_PUPD15
#define GPIO_PUPDR_PUPDR15_0 GPIO_PUPDR_PUPD15_0
#define GPIO_PUPDR_PUPDR15_1 GPIO_PUPDR_PUPD15_1

/******************  Bits definition for GPIO_IDR register  *******************/
#define GPIO_IDR_ID0_Pos (0U)
#define GPIO_IDR_ID0_Msk (0x1UL << GPIO_IDR_ID0_Pos)
#define GPIO_IDR_ID0 GPIO_IDR_ID0_Msk
#define GPIO_IDR_ID1_Pos (1U)
#define GPIO_IDR_ID1_Msk (0x1UL << GPIO_IDR_ID1_Pos)
#define GPIO_IDR_ID1 GPIO_IDR_ID1_Msk
#define GPIO_IDR_ID2_Pos (2U)
#define GPIO_IDR_ID2_Msk (0x1UL << GPIO_IDR_ID2_Pos)
#define GPIO_IDR_ID2 GPIO_IDR_ID2_Msk
#define GPIO_IDR_ID3_Pos (3U)
#define GPIO_IDR_ID3_Msk (0x1UL << GPIO_IDR_ID3_Pos)
#define GPIO_IDR_ID3 GPIO_IDR_ID3_Msk
#define GPIO_IDR_ID4_Pos (4U)
#define GPIO_IDR_ID4_Msk (0x1UL << GPIO_IDR_ID4_Pos)
#define GPIO_IDR_ID4 GPIO_IDR_ID4_Msk
#define GPIO_IDR_ID5_Pos (5U)
#define GPIO_IDR_ID5_Msk (0x1UL << GPIO_IDR_ID5_Pos)
#define GPIO_IDR_ID5 GPIO_IDR_ID5_Msk
#define GPIO_IDR_ID6_Pos (6U)
#define GPIO_IDR_ID6_Msk (0x1UL << GPIO_IDR_ID6_Pos)
#define GPIO_IDR_ID6 GPIO_IDR_ID6_Msk
#define GPIO_IDR_ID7_Pos (7U)
#define GPIO_IDR_ID7_Msk (0x1UL << GPIO_IDR_ID7_Pos)
#define GPIO_IDR_ID7 GPIO_IDR_ID7_Msk
#define GPIO_IDR_ID8_Pos (8U)
#define GPIO_IDR_ID8_Msk (0x1UL << GPIO_IDR_ID8_Pos)
#define GPIO_IDR_ID8 GPIO_IDR_ID8_Msk
#define GPIO_IDR_ID9_Pos (9U)
#define GPIO_IDR_ID9_Msk (0x1UL << GPIO_IDR_ID9_Pos)
#define GPIO_IDR_ID9 GPIO_IDR_ID9_Msk
#define GPIO_IDR_ID10_Pos (10U)
#define GPIO_IDR_ID10_Msk (0x1UL << GPIO_IDR_ID10_Pos)
#define GPIO_IDR_ID10 GPIO_IDR_ID10_Msk
#define GPIO_IDR_ID11_Pos (11U)
#define GPIO_IDR_ID11_Msk (0x1UL << GPIO_IDR_ID11_Pos)
#define GPIO_IDR_ID11 GPIO_IDR_ID11_Msk
#define GPIO_IDR_ID12_Pos (12U)
#define GPIO_IDR_ID12_Msk (0x1UL << GPIO_IDR_ID12_Pos)
#define GPIO_IDR_ID12 GPIO_IDR_ID12_Msk
#define GPIO_IDR_ID13_Pos (13U)
#define GPIO_IDR_ID13_Msk (0x1UL << GPIO_IDR_ID13_Pos)
#define GPIO_IDR_ID13 GPIO_IDR_ID13_Msk
#define GPIO_IDR_ID14_Pos (14U)
#define GPIO_IDR_ID14_Msk (0x1UL << GPIO_IDR_ID14_Pos)
#define GPIO_IDR_ID14 GPIO_IDR_ID14_Msk
#define GPIO_IDR_ID15_Pos (15U)
#define GPIO_IDR_ID15_Msk (0x1UL << GPIO_IDR_ID15_Pos)
#define GPIO_IDR_ID15 GPIO_IDR_ID15_Msk

/* Legacy defines */
#define GPIO_IDR_IDR_0 GPIO_IDR_ID0
#define GPIO_IDR_IDR_1 GPIO_IDR_ID1
#define GPIO_IDR_IDR_2 GPIO_IDR_ID2
#define GPIO_IDR_IDR_3 GPIO_IDR_ID3
#define GPIO_IDR_IDR_4 GPIO_IDR_ID4
#define GPIO_IDR_IDR_5 GPIO_IDR_ID5
#define GPIO_IDR_IDR_6 GPIO_IDR_ID6
#define GPIO_IDR_IDR_7 GPIO_IDR_ID7
#define GPIO_IDR_IDR_8 GPIO_IDR_ID8
#define GPIO_IDR_IDR_9 GPIO_IDR_ID9
#define GPIO_IDR_IDR_10 GPIO_IDR_ID10
#define GPIO_IDR_IDR_11 GPIO_IDR_ID11
#define GPIO_IDR_IDR_12 GPIO_IDR_ID12
#define GPIO_IDR_IDR_13 GPIO_IDR_ID13
#define GPIO_IDR_IDR_14 GPIO_IDR_ID14
#define GPIO_IDR_IDR_15 GPIO_IDR_ID15

/* Old GPIO_IDR register bits definition, maintained for legacy purpose */
#define GPIO_OTYPER_IDR_0 GPIO_IDR_ID0
#define GPIO_OTYPER_IDR_1 GPIO_IDR_ID1
#define GPIO_OTYPER_IDR_2 GPIO_IDR_ID2
#define GPIO_OTYPER_IDR_3 GPIO_IDR_ID3
#define GPIO_OTYPER_IDR_4 GPIO_IDR_ID4
#define GPIO_OTYPER_IDR_5 GPIO_IDR_ID5
#define GPIO_OTYPER_IDR_6 GPIO_IDR_ID6
#define GPIO_OTYPER_IDR_7 GPIO_IDR_ID7
#define GPIO_OTYPER_IDR_8 GPIO_IDR_ID8
#define GPIO_OTYPER_IDR_9 GPIO_IDR_ID9
#define GPIO_OTYPER_IDR_10 GPIO_IDR_ID10
#define GPIO_OTYPER_IDR_11 GPIO_IDR_ID11
#define GPIO_OTYPER_IDR_12 GPIO_IDR_ID12
#define GPIO_OTYPER_IDR_13 GPIO_IDR_ID13
#define GPIO_OTYPER_IDR_14 GPIO_IDR_ID14
#define GPIO_OTYPER_IDR_15 GPIO_IDR_ID15

/******************  Bits definition for GPIO_ODR register  *******************/
#define GPIO_ODR_OD0_Pos (0U)
#define GPIO_ODR_OD0_Msk (0x1UL << GPIO_ODR_OD0_Pos)
#define GPIO_ODR_OD0 GPIO_ODR_OD0_Msk
#define GPIO_ODR_OD1_Pos (1U)
#define GPIO_ODR_OD1_Msk (0x1UL << GPIO_ODR_OD1_Pos)
#define GPIO_ODR_OD1 GPIO_ODR_OD1_Msk
#define GPIO_ODR_OD2_Pos (2U)
#define GPIO_ODR_OD2_Msk (0x1UL << GPIO_ODR_OD2_Pos)
#define GPIO_ODR_OD2 GPIO_ODR_OD2_Msk
#define GPIO_ODR_OD3_Pos (3U)
#define GPIO_ODR_OD3_Msk (0x1UL << GPIO_ODR_OD3_Pos)
#define GPIO_ODR_OD3 GPIO_ODR_OD3_Msk
#define GPIO_ODR_OD4_Pos (4U)
#define GPIO_ODR_OD4_Msk (0x1UL << GPIO_ODR_OD4_Pos)
#define GPIO_ODR_OD4 GPIO_ODR_OD4_Msk
#define GPIO_ODR_OD5_Pos (5U)
#define GPIO_ODR_OD5_Msk (0x1UL << GPIO_ODR_OD5_Pos)
#define GPIO_ODR_OD5 GPIO_ODR_OD5_Msk
#define GPIO_ODR_OD6_Pos (6U)
#define GPIO_ODR_OD6_Msk (0x1UL << GPIO_ODR_OD6_Pos)
#define GPIO_ODR_OD6 GPIO_ODR_OD6_Msk
#define GPIO_ODR_OD7_Pos (7U)
#define GPIO_ODR_OD7_Msk (0x1UL << GPIO_ODR_OD7_Pos)
#define GPIO_ODR_OD7 GPIO_ODR_OD7_Msk
#define GPIO_ODR_OD8_Pos (8U)
#define GPIO_ODR_OD8_Msk (0x1UL << GPIO_ODR_OD8_Pos)
#define GPIO_ODR_OD8 GPIO_ODR_OD8_Msk
#define GPIO_ODR_OD9_Pos (9U)
#define GPIO_ODR_OD9_Msk (0x1UL << GPIO_ODR_OD9_Pos)
#define GPIO_ODR_OD9 GPIO_ODR_OD9_Msk
#define GPIO_ODR_OD10_Pos (10U)
#define GPIO_ODR_OD10_Msk (0x1UL << GPIO_ODR_OD10_Pos)
#define GPIO_ODR_OD10 GPIO_ODR_OD10_Msk
#define GPIO_ODR_OD11_Pos (11U)
#define GPIO_ODR_OD11_Msk (0x1UL << GPIO_ODR_OD11_Pos)
#define GPIO_ODR_OD11 GPIO_ODR_OD11_Msk
#define GPIO_ODR_OD12_Pos (12U)
#define GPIO_ODR_OD12_Msk (0x1UL << GPIO_ODR_OD12_Pos)
#define GPIO_ODR_OD12 GPIO_ODR_OD12_Msk
#define GPIO_ODR_OD13_Pos (13U)
#define GPIO_ODR_OD13_Msk (0x1UL << GPIO_ODR_OD13_Pos)
#define GPIO_ODR_OD13 GPIO_ODR_OD13_Msk
#define GPIO_ODR_OD14_Pos (14U)
#define GPIO_ODR_OD14_Msk (0x1UL << GPIO_ODR_OD14_Pos)
#define GPIO_ODR_OD14 GPIO_ODR_OD14_Msk
#define GPIO_ODR_OD15_Pos (15U)
#define GPIO_ODR_OD15_Msk (0x1UL << GPIO_ODR_OD15_Pos)
#define GPIO_ODR_OD15 GPIO_ODR_OD15_Msk

/* Legacy defines */
#define GPIO_ODR_ODR_0 GPIO_ODR_OD0
#define GPIO_ODR_ODR_1 GPIO_ODR_OD1
#define GPIO_ODR_ODR_2 GPIO_ODR_OD2
#define GPIO_ODR_ODR_3 GPIO_ODR_OD3
#define GPIO_ODR_ODR_4 GPIO_ODR_OD4
#define GPIO_ODR_ODR_5 GPIO_ODR_OD5
#define GPIO_ODR_ODR_6 GPIO_ODR_OD6
#define GPIO_ODR_ODR_7 GPIO_ODR_OD7
#define GPIO_ODR_ODR_8 GPIO_ODR_OD8
#define GPIO_ODR_ODR_9 GPIO_ODR_OD9
#define GPIO_ODR_ODR_10 GPIO_ODR_OD10
#define GPIO_ODR_ODR_11 GPIO_ODR_OD11
#define GPIO_ODR_ODR_12 GPIO_ODR_OD12
#define GPIO_ODR_ODR_13 GPIO_ODR_OD13
#define GPIO_ODR_ODR_14 GPIO_ODR_OD14
#define GPIO_ODR_ODR_15 GPIO_ODR_OD15

/* Old GPIO_ODR register bits definition, maintained for legacy purpose */
#define GPIO_OTYPER_ODR_0 GPIO_ODR_OD0
#define GPIO_OTYPER_ODR_1 GPIO_ODR_OD1
#define GPIO_OTYPER_ODR_2 GPIO_ODR_OD2
#define GPIO_OTYPER_ODR_3 GPIO_ODR_OD3
#define GPIO_OTYPER_ODR_4 GPIO_ODR_OD4
#define GPIO_OTYPER_ODR_5 GPIO_ODR_OD5
#define GPIO_OTYPER_ODR_6 GPIO_ODR_OD6
#define GPIO_OTYPER_ODR_7 GPIO_ODR_OD7
#define GPIO_OTYPER_ODR_8 GPIO_ODR_OD8
#define GPIO_OTYPER_ODR_9 GPIO_ODR_OD9
#define GPIO_OTYPER_ODR_10 GPIO_ODR_OD10
#define GPIO_OTYPER_ODR_11 GPIO_ODR_OD11
#define GPIO_OTYPER_ODR_12 GPIO_ODR_OD12
#define GPIO_OTYPER_ODR_13 GPIO_ODR_OD13
#define GPIO_OTYPER_ODR_14 GPIO_ODR_OD14
#define GPIO_OTYPER_ODR_15 GPIO_ODR_OD15

/******************  Bits definition for GPIO_BSRR register  ******************/
#define GPIO_BSRR_BS0_Pos (0U)
#define GPIO_BSRR_BS0_Msk (0x1UL << GPIO_BSRR_BS0_Pos)
#define GPIO_BSRR_BS0 GPIO_BSRR_BS0_Msk
#define GPIO_BSRR_BS1_Pos (1U)
#define GPIO_BSRR_BS1_Msk (0x1UL << GPIO_BSRR_BS1_Pos)
#define GPIO_BSRR_BS1 GPIO_BSRR_BS1_Msk
#define GPIO_BSRR_BS2_Pos (2U)
#define GPIO_BSRR_BS2_Msk (0x1UL << GPIO_BSRR_BS2_Pos)
#define GPIO_BSRR_BS2 GPIO_BSRR_BS2_Msk
#define GPIO_BSRR_BS3_Pos (3U)
#define GPIO_BSRR_BS3_Msk (0x1UL << GPIO_BSRR_BS3_Pos)
#define GPIO_BSRR_BS3 GPIO_BSRR_BS3_Msk
#define GPIO_BSRR_BS4_Pos (4U)
#define GPIO_BSRR_BS4_Msk (0x1UL << GPIO_BSRR_BS4_Pos)
#define GPIO_BSRR_BS4 GPIO_BSRR_BS4_Msk
#define GPIO_BSRR_BS5_Pos (5U)
#define GPIO_BSRR_BS5_Msk (0x1UL << GPIO_BSRR_BS5_Pos)
#define GPIO_BSRR_BS5 GPIO_BSRR_BS5_Msk
#define GPIO_BSRR_BS6_Pos (6U)
#define GPIO_BSRR_BS6_Msk (0x1UL << GPIO_BSRR_BS6_Pos)
#define GPIO_BSRR_BS6 GPIO_BSRR_BS6_Msk
#define GPIO_BSRR_BS7_Pos (7U)
#define GPIO_BSRR_BS7_Msk (0x1UL << GPIO_BSRR_BS7_Pos)
#define GPIO_BSRR_BS7 GPIO_BSRR_BS7_Msk
#define GPIO_BSRR_BS8_Pos (8U)
#define GPIO_BSRR_BS8_Msk (0x1UL << GPIO_BSRR_BS8_Pos)
#define GPIO_BSRR_BS8 GPIO_BSRR_BS8_Msk
#define GPIO_BSRR_BS9_Pos (9U)
#define GPIO_BSRR_BS9_Msk (0x1UL << GPIO_BSRR_BS9_Pos)
#define GPIO_BSRR_BS9 GPIO_BSRR_BS9_Msk
#define GPIO_BSRR_BS10_Pos (10U)
#define GPIO_BSRR_BS10_Msk (0x1UL << GPIO_BSRR_BS10_Pos)
#define GPIO_BSRR_BS10 GPIO_BSRR_BS10_Msk
#define GPIO_BSRR_BS11_Pos (11U)
#define GPIO_BSRR_BS11_Msk (0x1UL << GPIO_BSRR_BS11_Pos)
#define GPIO_BSRR_BS11 GPIO_BSRR_BS11_Msk
#define GPIO_BSRR_BS12_Pos (12U)
#define GPIO_BSRR_BS12_Msk (0x1UL << GPIO_BSRR_BS12_Pos)
#define GPIO_BSRR_BS12 GPIO_BSRR_BS12_Msk
#define GPIO_BSRR_BS13_Pos (13U)
#define GPIO_BSRR_BS13_Msk (0x1UL << GPIO_BSRR_BS13_Pos)
#define GPIO_BSRR_BS13 GPIO_BSRR_BS13_Msk
#define GPIO_BSRR_BS14_Pos (14U)
#define GPIO_BSRR_BS14_Msk (0x1UL << GPIO_BSRR_BS14_Pos)
#define GPIO_BSRR_BS14 GPIO_BSRR_BS14_Msk
#define GPIO_BSRR_BS15_Pos (15U)
#define GPIO_BSRR_BS15_Msk (0x1UL << GPIO_BSRR_BS15_Pos)
#define GPIO_BSRR_BS15 GPIO_BSRR_BS15_Msk
#define GPIO_BSRR_BR0_Pos (16U)
#define GPIO_BSRR_BR0_Msk (0x1UL << GPIO_BSRR_BR0_Pos)
#define GPIO_BSRR_BR0 GPIO_BSRR_BR0_Msk
#define GPIO_BSRR_BR1_Pos (17U)
#define GPIO_BSRR_BR1_Msk (0x1UL << GPIO_BSRR_BR1_Pos)
#define GPIO_BSRR_BR1 GPIO_BSRR_BR1_Msk
#define GPIO_BSRR_BR2_Pos (18U)
#define GPIO_BSRR_BR2_Msk (0x1UL << GPIO_BSRR_BR2_Pos)
#define GPIO_BSRR_BR2 GPIO_BSRR_BR2_Msk
#define GPIO_BSRR_BR3_Pos (19U)
#define GPIO_BSRR_BR3_Msk (0x1UL << GPIO_BSRR_BR3_Pos)
#define GPIO_BSRR_BR3 GPIO_BSRR_BR3_Msk
#define GPIO_BSRR_BR4_Pos (20U)
#define GPIO_BSRR_BR4_Msk (0x1UL << GPIO_BSRR_BR4_Pos)
#define GPIO_BSRR_BR4 GPIO_BSRR_BR4_Msk
#define GPIO_BSRR_BR5_Pos (21U)
#define GPIO_BSRR_BR5_Msk (0x1UL << GPIO_BSRR_BR5_Pos)
#define GPIO_BSRR_BR5 GPIO_BSRR_BR5_Msk
#define GPIO_BSRR_BR6_Pos (22U)
#define GPIO_BSRR_BR6_Msk (0x1UL << GPIO_BSRR_BR6_Pos)
#define GPIO_BSRR_BR6 GPIO_BSRR_BR6_Msk
#define GPIO_BSRR_BR7_Pos (23U)
#define GPIO_BSRR_BR7_Msk (0x1UL << GPIO_BSRR_BR7_Pos)
#define GPIO_BSRR_BR7 GPIO_BSRR_BR7_Msk
#define GPIO_BSRR_BR8_Pos (24U)
#define GPIO_BSRR_BR8_Msk (0x1UL << GPIO_BSRR_BR8_Pos)
#define GPIO_BSRR_BR8 GPIO_BSRR_BR8_Msk
#define GPIO_BSRR_BR9_Pos (25U)
#define GPIO_BSRR_BR9_Msk (0x1UL << GPIO_BSRR_BR9_Pos)
#define GPIO_BSRR_BR9 GPIO_BSRR_BR9_Msk
#define GPIO_BSRR_BR10_Pos (26U)
#define GPIO_BSRR_BR10_Msk (0x1UL << GPIO_BSRR_BR10_Pos)
#define GPIO_BSRR_BR10 GPIO_BSRR_BR10_Msk
#define GPIO_BSRR_BR11_Pos (27U)
#define GPIO_BSRR_BR11_Msk (0x1UL << GPIO_BSRR_BR11_Pos)
#define GPIO_BSRR_BR11 GPIO_BSRR_BR11_Msk
#define GPIO_BSRR_BR12_Pos (28U)
#define GPIO_BSRR_BR12_Msk (0x1UL << GPIO_BSRR_BR12_Pos)
#define GPIO_BSRR_BR12 GPIO_BSRR_BR12_Msk
#define GPIO_BSRR_BR13_Pos (29U)
#define GPIO_BSRR_BR13_Msk (0x1UL << GPIO_BSRR_BR13_Pos)
#define GPIO_BSRR_BR13 GPIO_BSRR_BR13_Msk
#define GPIO_BSRR_BR14_Pos (30U)
#define GPIO_BSRR_BR14_Msk (0x1UL << GPIO_BSRR_BR14_Pos)
#define GPIO_BSRR_BR14 GPIO_BSRR_BR14_Msk
#define GPIO_BSRR_BR15_Pos (31U)
#define GPIO_BSRR_BR15_Msk (0x1UL << GPIO_BSRR_BR15_Pos)
#define GPIO_BSRR_BR15 GPIO_BSRR_BR15_Msk

/* Legacy defines */
#define GPIO_BSRR_BS_0 GPIO_BSRR_BS0
#define GPIO_BSRR_BS_1 GPIO_BSRR_BS1
#define GPIO_BSRR_BS_2 GPIO_BSRR_BS2
#define GPIO_BSRR_BS_3 GPIO_BSRR_BS3
#define GPIO_BSRR_BS_4 GPIO_BSRR_BS4
#define GPIO_BSRR_BS_5 GPIO_BSRR_BS5
#define GPIO_BSRR_BS_6 GPIO_BSRR_BS6
#define GPIO_BSRR_BS_7 GPIO_BSRR_BS7
#define GPIO_BSRR_BS_8 GPIO_BSRR_BS8
#define GPIO_BSRR_BS_9 GPIO_BSRR_BS9
#define GPIO_BSRR_BS_10 GPIO_BSRR_BS10
#define GPIO_BSRR_BS_11 GPIO_BSRR_BS11
#define GPIO_BSRR_BS_12 GPIO_BSRR_BS12
#define GPIO_BSRR_BS_13 GPIO_BSRR_BS13
#define GPIO_BSRR_BS_14 GPIO_BSRR_BS14
#define GPIO_BSRR_BS_15 GPIO_BSRR_BS15
#define GPIO_BSRR_BR_0 GPIO_BSRR_BR0
#define GPIO_BSRR_BR_1 GPIO_BSRR_BR1
#define GPIO_BSRR_BR_2 GPIO_BSRR_BR2
#define GPIO_BSRR_BR_3 GPIO_BSRR_BR3
#define GPIO_BSRR_BR_4 GPIO_BSRR_BR4
#define GPIO_BSRR_BR_5 GPIO_BSRR_BR5
#define GPIO_BSRR_BR_6 GPIO_BSRR_BR6
#define GPIO_BSRR_BR_7 GPIO_BSRR_BR7
#define GPIO_BSRR_BR_8 GPIO_BSRR_BR8
#define GPIO_BSRR_BR_9 GPIO_BSRR_BR9
#define GPIO_BSRR_BR_10 GPIO_BSRR_BR10
#define GPIO_BSRR_BR_11 GPIO_BSRR_BR11
#define GPIO_BSRR_BR_12 GPIO_BSRR_BR12
#define GPIO_BSRR_BR_13 GPIO_BSRR_BR13
#define GPIO_BSRR_BR_14 GPIO_BSRR_BR14
#define GPIO_BSRR_BR_15 GPIO_BSRR_BR15

/****************** Bit definition for GPIO_LCKR register *********************/
#define GPIO_LCKR_LCK0_Pos (0U)
#define GPIO_LCKR_LCK0_Msk (0x1UL << GPIO_LCKR_LCK0_Pos)
#define GPIO_LCKR_LCK0 GPIO_LCKR_LCK0_Msk
#define GPIO_LCKR_LCK1_Pos (1U)
#define GPIO_LCKR_LCK1_Msk (0x1UL << GPIO_LCKR_LCK1_Pos)
#define GPIO_LCKR_LCK1 GPIO_LCKR_LCK1_Msk
#define GPIO_LCKR_LCK2_Pos (2U)
#define GPIO_LCKR_LCK2_Msk (0x1UL << GPIO_LCKR_LCK2_Pos)
#define GPIO_LCKR_LCK2 GPIO_LCKR_LCK2_Msk
#define GPIO_LCKR_LCK3_Pos (3U)
#define GPIO_LCKR_LCK3_Msk (0x1UL << GPIO_LCKR_LCK3_Pos)
#define GPIO_LCKR_LCK3 GPIO_LCKR_LCK3_Msk
#define GPIO_LCKR_LCK4_Pos (4U)
#define GPIO_LCKR_LCK4_Msk (0x1UL << GPIO_LCKR_LCK4_Pos)
#define GPIO_LCKR_LCK4 GPIO_LCKR_LCK4_Msk
#define GPIO_LCKR_LCK5_Pos (5U)
#define GPIO_LCKR_LCK5_Msk (0x1UL << GPIO_LCKR_LCK5_Pos)
#define GPIO_LCKR_LCK5 GPIO_LCKR_LCK5_Msk
#define GPIO_LCKR_LCK6_Pos (6U)
#define GPIO_LCKR_LCK6_Msk (0x1UL << GPIO_LCKR_LCK6_Pos)
#define GPIO_LCKR_LCK6 GPIO_LCKR_LCK6_Msk
#define GPIO_LCKR_LCK7_Pos (7U)
#define GPIO_LCKR_LCK7_Msk (0x1UL << GPIO_LCKR_LCK7_Pos)
#define GPIO_LCKR_LCK7 GPIO_LCKR_LCK7_Msk
#define GPIO_LCKR_LCK8_Pos (8U)
#define GPIO_LCKR_LCK8_Msk (0x1UL << GPIO_LCKR_LCK8_Pos)
#define GPIO_LCKR_LCK8 GPIO_LCKR_LCK8_Msk
#define GPIO_LCKR_LCK9_Pos (9U)
#define GPIO_LCKR_LCK9_Msk (0x1UL << GPIO_LCKR_LCK9_Pos)
#define GPIO_LCKR_LCK9 GPIO_LCKR_LCK9_Msk
#define GPIO_LCKR_LCK10_Pos (10U)
#define GPIO_LCKR_LCK10_Msk (0x1UL << GPIO_LCKR_LCK10_Pos)
#define GPIO_LCKR_LCK10 GPIO_LCKR_LCK10_Msk
#define GPIO_LCKR_LCK11_Pos (11U)
#define GPIO_LCKR_LCK11_Msk (0x1UL << GPIO_LCKR_LCK11_Pos)
#define GPIO_LCKR_LCK11 GPIO_LCKR_LCK11_Msk
#define GPIO_LCKR_LCK12_Pos (12U)
#define GPIO_LCKR_LCK12_Msk (0x1UL << GPIO_LCKR_LCK12_Pos)
#define GPIO_LCKR_LCK12 GPIO_LCKR_LCK12_Msk
#define GPIO_LCKR_LCK13_Pos (13U)
#define GPIO_LCKR_LCK13_Msk (0x1UL << GPIO_LCKR_LCK13_Pos)
#define GPIO_LCKR_LCK13 GPIO_LCKR_LCK13_Msk
#define GPIO_LCKR_LCK14_Pos (14U)
#define GPIO_LCKR_LCK14_Msk (0x1UL << GPIO_LCKR_LCK14_Pos)
#define GPIO_LCKR_LCK14 GPIO_LCKR_LCK14_Msk
#define GPIO_LCKR_LCK15_Pos (15U)
#define GPIO_LCKR_LCK15_Msk (0x1UL << GPIO_LCKR_LCK15_Pos)
#define GPIO_LCKR_LCK15 GPIO_LCKR_LCK15_Msk
#define GPIO_LCKR_LCKK_Pos (16U)
#define GPIO_LCKR_LCKK_Msk (0x1UL << GPIO_LCKR_LCKK_Pos)
#define GPIO_LCKR_LCKK GPIO_LCKR_LCKK_Msk

/****************** Bit definition for GPIO_AFRL register *********************/
#define GPIO_AFRL_AFSEL0_Pos (0U)
#define GPIO_AFRL_AFSEL0_Msk (0xFUL << GPIO_AFRL_AFSEL0_Pos)
#define GPIO_AFRL_AFSEL0 GPIO_AFRL_AFSEL0_Msk
#define GPIO_AFRL_AFSEL0_0 (0x1UL << GPIO_AFRL_AFSEL0_Pos)
#define GPIO_AFRL_AFSEL0_1 (0x2UL << GPIO_AFRL_AFSEL0_Pos)
#define GPIO_AFRL_AFSEL0_2 (0x4UL << GPIO_AFRL_AFSEL0_Pos)
#define GPIO_AFRL_AFSEL0_3 (0x8UL << GPIO_AFRL_AFSEL0_Pos)
#define GPIO_AFRL_AFSEL1_Pos (4U)
#define GPIO_AFRL_AFSEL1_Msk (0xFUL << GPIO_AFRL_AFSEL1_Pos)
#define GPIO_AFRL_AFSEL1 GPIO_AFRL_AFSEL1_Msk
#define GPIO_AFRL_AFSEL1_0 (0x1UL << GPIO_AFRL_AFSEL1_Pos)
#define GPIO_AFRL_AFSEL1_1 (0x2UL << GPIO_AFRL_AFSEL1_Pos)
#define GPIO_AFRL_AFSEL1_2 (0x4UL << GPIO_AFRL_AFSEL1_Pos)
#define GPIO_AFRL_AFSEL1_3 (0x8UL << GPIO_AFRL_AFSEL1_Pos)
#define GPIO_AFRL_AFSEL2_Pos (8U)
#define GPIO_AFRL_AFSEL2_Msk (0xFUL << GPIO_AFRL_AFSEL2_Pos)
#define GPIO_AFRL_AFSEL2 GPIO_AFRL_AFSEL2_Msk
#define GPIO_AFRL_AFSEL2_0 (0x1UL << GPIO_AFRL_AFSEL2_Pos)
#define GPIO_AFRL_AFSEL2_1 (0x2UL << GPIO_AFRL_AFSEL2_Pos)
#define GPIO_AFRL_AFSEL2_2 (0x4UL << GPIO_AFRL_AFSEL2_Pos)
#define GPIO_AFRL_AFSEL2_3 (0x8UL << GPIO_AFRL_AFSEL2_Pos)
#define GPIO_AFRL_AFSEL3_Pos (12U)
#define GPIO_AFRL_AFSEL3_Msk (0xFUL << GPIO_AFRL_AFSEL3_Pos)
#define GPIO_AFRL_AFSEL3 GPIO_AFRL_AFSEL3_Msk
#define GPIO_AFRL_AFSEL3_0 (0x1UL << GPIO_AFRL_AFSEL3_Pos)
#define GPIO_AFRL_AFSEL3_1 (0x2UL << GPIO_AFRL_AFSEL3_Pos)
#define GPIO_AFRL_AFSEL3_2 (0x4UL << GPIO_AFRL_AFSEL3_Pos)
#define GPIO_AFRL_AFSEL3_3 (0x8UL << GPIO_AFRL_AFSEL3_Pos)
#define GPIO_AFRL_AFSEL4_Pos (16U)
#define GPIO_AFRL_AFSEL4_Msk (0xFUL << GPIO_AFRL_AFSEL4_Pos)
#define GPIO_AFRL_AFSEL4 GPIO_AFRL_AFSEL4_Msk
#define GPIO_AFRL_AFSEL4_0 (0x1UL << GPIO_AFRL_AFSEL4_Pos)
#define GPIO_AFRL_AFSEL4_1 (0x2UL << GPIO_AFRL_AFSEL4_Pos)
#define GPIO_AFRL_AFSEL4_2 (0x4UL << GPIO_AFRL_AFSEL4_Pos)
#define GPIO_AFRL_AFSEL4_3 (0x8UL << GPIO_AFRL_AFSEL4_Pos)
#define GPIO_AFRL_AFSEL5_Pos (20U)
#define GPIO_AFRL_AFSEL5_Msk (0xFUL << GPIO_AFRL_AFSEL5_Pos)
#define GPIO_AFRL_AFSEL5 GPIO_AFRL_AFSEL5_Msk
#define GPIO_AFRL_AFSEL5_0 (0x1UL << GPIO_AFRL_AFSEL5_Pos)
#define GPIO_AFRL_AFSEL5_1 (0x2UL << GPIO_AFRL_AFSEL5_Pos)
#define GPIO_AFRL_AFSEL5_2 (0x4UL << GPIO_AFRL_AFSEL5_Pos)
#define GPIO_AFRL_AFSEL5_3 (0x8UL << GPIO_AFRL_AFSEL5_Pos)
#define GPIO_AFRL_AFSEL6_Pos (24U)
#define GPIO_AFRL_AFSEL6_Msk (0xFUL << GPIO_AFRL_AFSEL6_Pos)
#define GPIO_AFRL_AFSEL6 GPIO_AFRL_AFSEL6_Msk
#define GPIO_AFRL_AFSEL6_0 (0x1UL << GPIO_AFRL_AFSEL6_Pos)
#define GPIO_AFRL_AFSEL6_1 (0x2UL << GPIO_AFRL_AFSEL6_Pos)
#define GPIO_AFRL_AFSEL6_2 (0x4UL << GPIO_AFRL_AFSEL6_Pos)
#define GPIO_AFRL_AFSEL6_3 (0x8UL << GPIO_AFRL_AFSEL6_Pos)
#define GPIO_AFRL_AFSEL7_Pos (28U)
#define GPIO_AFRL_AFSEL7_Msk (0xFUL << GPIO_AFRL_AFSEL7_Pos)
#define GPIO_AFRL_AFSEL7 GPIO_AFRL_AFSEL7_Msk
#define GPIO_AFRL_AFSEL7_0 (0x1UL << GPIO_AFRL_AFSEL7_Pos)
#define GPIO_AFRL_AFSEL7_1 (0x2UL << GPIO_AFRL_AFSEL7_Pos)
#define GPIO_AFRL_AFSEL7_2 (0x4UL << GPIO_AFRL_AFSEL7_Pos)
#define GPIO_AFRL_AFSEL7_3 (0x8UL << GPIO_AFRL_AFSEL7_Pos)

/* Legacy defines */
#define GPIO_AFRL_AFRL0 GPIO_AFRL_AFSEL0
#define GPIO_AFRL_AFRL1 GPIO_AFRL_AFSEL1
#define GPIO_AFRL_AFRL2 GPIO_AFRL_AFSEL2
#define GPIO_AFRL_AFRL3 GPIO_AFRL_AFSEL3
#define GPIO_AFRL_AFRL4 GPIO_AFRL_AFSEL4
#define GPIO_AFRL_AFRL5 GPIO_AFRL_AFSEL5
#define GPIO_AFRL_AFRL6 GPIO_AFRL_AFSEL6
#define GPIO_AFRL_AFRL7 GPIO_AFRL_AFSEL7

/****************** Bit definition for GPIO_AFRH register *********************/
#define GPIO_AFRH_AFSEL8_Pos (0U)
#define GPIO_AFRH_AFSEL8_Msk (0xFUL << GPIO_AFRH_AFSEL8_Pos)
#define GPIO_AFRH_AFSEL8 GPIO_AFRH_AFSEL8_Msk
#define GPIO_AFRH_AFSEL8_0 (0x1UL << GPIO_AFRH_AFSEL8_Pos)
#define GPIO_AFRH_AFSEL8_1 (0x2UL << GPIO_AFRH_AFSEL8_Pos)
#define GPIO_AFRH_AFSEL8_2 (0x4UL << GPIO_AFRH_AFSEL8_Pos)
#define GPIO_AFRH_AFSEL8_3 (0x8UL << GPIO_AFRH_AFSEL8_Pos)
#define GPIO_AFRH_AFSEL9_Pos (4U)
#define GPIO_AFRH_AFSEL9_Msk (0xFUL << GPIO_AFRH_AFSEL9_Pos)
#define GPIO_AFRH_AFSEL9 GPIO_AFRH_AFSEL9_Msk
#define GPIO_AFRH_AFSEL9_0 (0x1UL << GPIO_AFRH_AFSEL9_Pos)
#define GPIO_AFRH_AFSEL9_1 (0x2UL << GPIO_AFRH_AFSEL9_Pos)
#define GPIO_AFRH_AFSEL9_2 (0x4UL << GPIO_AFRH_AFSEL9_Pos)
#define GPIO_AFRH_AFSEL9_3 (0x8UL << GPIO_AFRH_AFSEL9_Pos)
#define GPIO_AFRH_AFSEL10_Pos (8U)
#define GPIO_AFRH_AFSEL10_Msk (0xFUL << GPIO_AFRH_AFSEL10_Pos)
#define GPIO_AFRH_AFSEL10 GPIO_AFRH_AFSEL10_Msk
#define GPIO_AFRH_AFSEL10_0 (0x1UL << GPIO_AFRH_AFSEL10_Pos)
#define GPIO_AFRH_AFSEL10_1 (0x2UL << GPIO_AFRH_AFSEL10_Pos)
#define GPIO_AFRH_AFSEL10_2 (0x4UL << GPIO_AFRH_AFSEL10_Pos)
#define GPIO_AFRH_AFSEL10_3 (0x8UL << GPIO_AFRH_AFSEL10_Pos)
#define GPIO_AFRH_AFSEL11_Pos (12U)
#define GPIO_AFRH_AFSEL11_Msk (0xFUL << GPIO_AFRH_AFSEL11_Pos)
#define GPIO_AFRH_AFSEL11 GPIO_AFRH_AFSEL11_Msk
#define GPIO_AFRH_AFSEL11_0 (0x1UL << GPIO_AFRH_AFSEL11_Pos)
#define GPIO_AFRH_AFSEL11_1 (0x2UL << GPIO_AFRH_AFSEL11_Pos)
#define GPIO_AFRH_AFSEL11_2 (0x4UL << GPIO_AFRH_AFSEL11_Pos)
#define GPIO_AFRH_AFSEL11_3 (0x8UL << GPIO_AFRH_AFSEL11_Pos)
#define GPIO_AFRH_AFSEL12_Pos (16U)
#define GPIO_AFRH_AFSEL12_Msk (0xFUL << GPIO_AFRH_AFSEL12_Pos)
#define GPIO_AFRH_AFSEL12 GPIO_AFRH_AFSEL12_Msk
#define GPIO_AFRH_AFSEL12_0 (0x1UL << GPIO_AFRH_AFSEL12_Pos)
#define GPIO_AFRH_AFSEL12_1 (0x2UL << GPIO_AFRH_AFSEL12_Pos)
#define GPIO_AFRH_AFSEL12_2 (0x4UL << GPIO_AFRH_AFSEL12_Pos)
#define GPIO_AFRH_AFSEL12_3 (0x8UL << GPIO_AFRH_AFSEL12_Pos)
#define GPIO_AFRH_AFSEL13_Pos (20U)
#define GPIO_AFRH_AFSEL13_Msk (0xFUL << GPIO_AFRH_AFSEL13_Pos)
#define GPIO_AFRH_AFSEL13 GPIO_AFRH_AFSEL13_Msk
#define GPIO_AFRH_AFSEL13_0 (0x1UL << GPIO_AFRH_AFSEL13_Pos)
#define GPIO_AFRH_AFSEL13_1 (0x2UL << GPIO_AFRH_AFSEL13_Pos)
#define GPIO_AFRH_AFSEL13_2 (0x4UL << GPIO_AFRH_AFSEL13_Pos)
#define GPIO_AFRH_AFSEL13_3 (0x8UL << GPIO_AFRH_AFSEL13_Pos)
#define GPIO_AFRH_AFSEL14_Pos (24U)
#define GPIO_AFRH_AFSEL14_Msk (0xFUL << GPIO_AFRH_AFSEL14_Pos)
#define GPIO_AFRH_AFSEL14 GPIO_AFRH_AFSEL14_Msk
#define GPIO_AFRH_AFSEL14_0 (0x1UL << GPIO_AFRH_AFSEL14_Pos)
#define GPIO_AFRH_AFSEL14_1 (0x2UL << GPIO_AFRH_AFSEL14_Pos)
#define GPIO_AFRH_AFSEL14_2 (0x4UL << GPIO_AFRH_AFSEL14_Pos)
#define GPIO_AFRH_AFSEL14_3 (0x8UL << GPIO_AFRH_AFSEL14_Pos)
#define GPIO_AFRH_AFSEL15_Pos (28U)
#define GPIO_AFRH_AFSEL15_Msk (0xFUL << GPIO_AFRH_AFSEL15_Pos)
#define GPIO_AFRH_AFSEL15 GPIO_AFRH_AFSEL15_Msk
#define GPIO_AFRH_AFSEL15_0 (0x1UL << GPIO_AFRH_AFSEL15_Pos)
#define GPIO_AFRH_AFSEL15_1 (0x2UL << GPIO_AFRH_AFSEL15_Pos)
#define GPIO_AFRH_AFSEL15_2 (0x4UL << GPIO_AFRH_AFSEL15_Pos)
#define GPIO_AFRH_AFSEL15_3 (0x8UL << GPIO_AFRH_AFSEL15_Pos)

/* Legacy defines */
#define GPIO_AFRH_AFRH0 GPIO_AFRH_AFSEL8
#define GPIO_AFRH_AFRH1 GPIO_AFRH_AFSEL9
#define GPIO_AFRH_AFRH2 GPIO_AFRH_AFSEL10
#define GPIO_AFRH_AFRH3 GPIO_AFRH_AFSEL11
#define GPIO_AFRH_AFRH4 GPIO_AFRH_AFSEL12
#define GPIO_AFRH_AFRH5 GPIO_AFRH_AFSEL13
#define GPIO_AFRH_AFRH6 GPIO_AFRH_AFSEL14
#define GPIO_AFRH_AFRH7 GPIO_AFRH_AFSEL15

/******************  Bits definition for GPIO_BRR register  ******************/
#define GPIO_BRR_BR0_Pos (0U)
#define GPIO_BRR_BR0_Msk (0x1UL << GPIO_BRR_BR0_Pos)
#define GPIO_BRR_BR0 GPIO_BRR_BR0_Msk
#define GPIO_BRR_BR1_Pos (1U)
#define GPIO_BRR_BR1_Msk (0x1UL << GPIO_BRR_BR1_Pos)
#define GPIO_BRR_BR1 GPIO_BRR_BR1_Msk
#define GPIO_BRR_BR2_Pos (2U)
#define GPIO_BRR_BR2_Msk (0x1UL << GPIO_BRR_BR2_Pos)
#define GPIO_BRR_BR2 GPIO_BRR_BR2_Msk
#define GPIO_BRR_BR3_Pos (3U)
#define GPIO_BRR_BR3_Msk (0x1UL << GPIO_BRR_BR3_Pos)
#define GPIO_BRR_BR3 GPIO_BRR_BR3_Msk
#define GPIO_BRR_BR4_Pos (4U)
#define GPIO_BRR_BR4_Msk (0x1UL << GPIO_BRR_BR4_Pos)
#define GPIO_BRR_BR4 GPIO_BRR_BR4_Msk
#define GPIO_BRR_BR5_Pos (5U)
#define GPIO_BRR_BR5_Msk (0x1UL << GPIO_BRR_BR5_Pos)
#define GPIO_BRR_BR5 GPIO_BRR_BR5_Msk
#define GPIO_BRR_BR6_Pos (6U)
#define GPIO_BRR_BR6_Msk (0x1UL << GPIO_BRR_BR6_Pos)
#define GPIO_BRR_BR6 GPIO_BRR_BR6_Msk
#define GPIO_BRR_BR7_Pos (7U)
#define GPIO_BRR_BR7_Msk (0x1UL << GPIO_BRR_BR7_Pos)
#define GPIO_BRR_BR7 GPIO_BRR_BR7_Msk
#define GPIO_BRR_BR8_Pos (8U)
#define GPIO_BRR_BR8_Msk (0x1UL << GPIO_BRR_BR8_Pos)
#define GPIO_BRR_BR8 GPIO_BRR_BR8_Msk
#define GPIO_BRR_BR9_Pos (9U)
#define GPIO_BRR_BR9_Msk (0x1UL << GPIO_BRR_BR9_Pos)
#define GPIO_BRR_BR9 GPIO_BRR_BR9_Msk
#define GPIO_BRR_BR10_Pos (10U)
#define GPIO_BRR_BR10_Msk (0x1UL << GPIO_BRR_BR10_Pos)
#define GPIO_BRR_BR10 GPIO_BRR_BR10_Msk
#define GPIO_BRR_BR11_Pos (11U)
#define GPIO_BRR_BR11_Msk (0x1UL << GPIO_BRR_BR11_Pos)
#define GPIO_BRR_BR11 GPIO_BRR_BR11_Msk
#define GPIO_BRR_BR12_Pos (12U)
#define GPIO_BRR_BR12_Msk (0x1UL << GPIO_BRR_BR12_Pos)
#define GPIO_BRR_BR12 GPIO_BRR_BR12_Msk
#define GPIO_BRR_BR13_Pos (13U)
#define GPIO_BRR_BR13_Msk (0x1UL << GPIO_BRR_BR13_Pos)
#define GPIO_BRR_BR13 GPIO_BRR_BR13_Msk
#define GPIO_BRR_BR14_Pos (14U)
#define GPIO_BRR_BR14_Msk (0x1UL << GPIO_BRR_BR14_Pos)
#define GPIO_BRR_BR14 GPIO_BRR_BR14_Msk
#define GPIO_BRR_BR15_Pos (15U)
#define GPIO_BRR_BR15_Msk (0x1UL << GPIO_BRR_BR15_Pos)
#define GPIO_BRR_BR15 GPIO_BRR_BR15_Msk

/* Legacy defines */
#define GPIO_BRR_BR_0 GPIO_BRR_BR0
#define GPIO_BRR_BR_1 GPIO_BRR_BR1
#define GPIO_BRR_BR_2 GPIO_BRR_BR2
#define GPIO_BRR_BR_3 GPIO_BRR_BR3
#define GPIO_BRR_BR_4 GPIO_BRR_BR4
#define GPIO_BRR_BR_5 GPIO_BRR_BR5
#define GPIO_BRR_BR_6 GPIO_BRR_BR6
#define GPIO_BRR_BR_7 GPIO_BRR_BR7
#define GPIO_BRR_BR_8 GPIO_BRR_BR8
#define GPIO_BRR_BR_9 GPIO_BRR_BR9
#define GPIO_BRR_BR_10 GPIO_BRR_BR10
#define GPIO_BRR_BR_11 GPIO_BRR_BR11
#define GPIO_BRR_BR_12 GPIO_BRR_BR12
#define GPIO_BRR_BR_13 GPIO_BRR_BR13
#define GPIO_BRR_BR_14 GPIO_BRR_BR14
#define GPIO_BRR_BR_15 GPIO_BRR_BR15


/******************************************************************************/
/*                                                                            */
/*                      Inter-integrated Circuit Interface (I2C)              */
/*                                                                            */
/******************************************************************************/
/*******************  Bit definition for I2C_CR1 register  *******************/
#define I2C_CR1_PE_Pos (0U)
#define I2C_CR1_PE_Msk (0x1UL << I2C_CR1_PE_Pos)
#define I2C_CR1_PE I2C_CR1_PE_Msk
#define I2C_CR1_TXIE_Pos (1U)
#define I2C_CR1_TXIE_Msk (0x1UL << I2C_CR1_TXIE_Pos)
#define I2C_CR1_TXIE I2C_CR1_TXIE_Msk
#define I2C_CR1_RXIE_Pos (2U)
#define I2C_CR1_RXIE_Msk (0x1UL << I2C_CR1_RXIE_Pos)
#define I2C_CR1_RXIE I2C_CR1_RXIE_Msk
#define I2C_CR1_ADDRIE_Pos (3U)
#define I2C_CR1_ADDRIE_Msk (0x1UL << I2C_CR1_ADDRIE_Pos)
#define I2C_CR1_ADDRIE I2C_CR1_ADDRIE_Msk
#define I2C_CR1_NACKIE_Pos (4U)
#define I2C_CR1_NACKIE_Msk (0x1UL << I2C_CR1_NACKIE_Pos)
#define I2C_CR1_NACKIE I2C_CR1_NACKIE_Msk
#define I2C_CR1_STOPIE_Pos (5U)
#define I2C_CR1_STOPIE_Msk (0x1UL << I2C_CR1_STOPIE_Pos)
#define I2C_CR1_STOPIE I2C_CR1_STOPIE_Msk
#define I2C_CR1_TCIE_Pos (6U)
#define I2C_CR1_TCIE_Msk (0x1UL << I2C_CR1_TCIE_Pos)
#define I2C_CR1_TCIE I2C_CR1_TCIE_Msk
#define I2C_CR1_ERRIE_Pos (7U)
#define I2C_CR1_ERRIE_Msk (0x1UL << I2C_CR1_ERRIE_Pos)
#define I2C_CR1_ERRIE I2C_CR1_ERRIE_Msk
#define I2C_CR1_DNF_Pos (8U)
#define I2C_CR1_DNF_Msk (0xFUL << I2C_CR1_DNF_Pos)
#define I2C_CR1_DNF I2C_CR1_DNF_Msk
#define I2C_CR1_ANFOFF_Pos (12U)
#define I2C_CR1_ANFOFF_Msk (0x1UL << I2C_CR1_ANFOFF_Pos)
#define I2C_CR1_ANFOFF I2C_CR1_ANFOFF_Msk
#define I2C_CR1_SWRST_Pos (13U)
#define I2C_CR1_SWRST_Msk (0x1UL << I2C_CR1_SWRST_Pos)
#define I2C_CR1_SWRST I2C_CR1_SWRST_Msk
#define I2C_CR1_TXDMAEN_Pos (14U)
#define I2C_CR1_TXDMAEN_Msk (0x1UL << I2C_CR1_TXDMAEN_Pos)
#define I2C_CR1_TXDMAEN I2C_CR1_TXDMAEN_Msk
#define I2C_CR1_RXDMAEN_Pos (15U)
#define I2C_CR1_RXDMAEN_Msk (0x1UL << I2C_CR1_RXDMAEN_Pos)
#define I2C_CR1_RXDMAEN I2C_CR1_RXDMAEN_Msk
#define I2C_CR1_SBC_Pos (16U)
#define I2C_CR1_SBC_Msk (0x1UL << I2C_CR1_SBC_Pos)
#define I2C_CR1_SBC I2C_CR1_SBC_Msk
#define I2C_CR1_NOSTRETCH_Pos (17U)
#define I2C_CR1_NOSTRETCH_Msk (0x1UL << I2C_CR1_NOSTRETCH_Pos)
#define I2C_CR1_NOSTRETCH I2C_CR1_NOSTRETCH_Msk
#define I2C_CR1_WUPEN_Pos (18U)
#define I2C_CR1_WUPEN_Msk (0x1UL << I2C_CR1_WUPEN_Pos)
#define I2C_CR1_WUPEN I2C_CR1_WUPEN_Msk
#define I2C_CR1_GCEN_Pos (19U)
#define I2C_CR1_GCEN_Msk (0x1UL << I2C_CR1_GCEN_Pos)
#define I2C_CR1_GCEN I2C_CR1_GCEN_Msk
#define I2C_CR1_SMBHEN_Pos (20U)
#define I2C_CR1_SMBHEN_Msk (0x1UL << I2C_CR1_SMBHEN_Pos)
#define I2C_CR1_SMBHEN I2C_CR1_SMBHEN_Msk
#define I2C_CR1_SMBDEN_Pos (21U)
#define I2C_CR1_SMBDEN_Msk (0x1UL << I2C_CR1_SMBDEN_Pos)
#define I2C_CR1_SMBDEN I2C_CR1_SMBDEN_Msk
#define I2C_CR1_ALERTEN_Pos (22U)
#define I2C_CR1_ALERTEN_Msk (0x1UL << I2C_CR1_ALERTEN_Pos)
#define I2C_CR1_ALERTEN I2C_CR1_ALERTEN_Msk
#define I2C_CR1_PECEN_Pos (23U)
#define I2C_CR1_PECEN_Msk (0x1UL << I2C_CR1_PECEN_Pos)
#define I2C_CR1_PECEN I2C_CR1_PECEN_Msk

/******************  Bit definition for I2C_CR2 register  ********************/
#define I2C_CR2_SADD_Pos (0U)
#define I2C_CR2_SADD_Msk (0x3FFUL << I2C_CR2_SADD_Pos)
#define I2C_CR2_SADD I2C_CR2_SADD_Msk
#define I2C_CR2_RD_WRN_Pos (10U)
#define I2C_CR2_RD_WRN_Msk (0x1UL << I2C_CR2_RD_WRN_Pos)
#define I2C_CR2_RD_WRN I2C_CR2_RD_WRN_Msk
#define I2C_CR2_ADD10_Pos (11U)
#define I2C_CR2_ADD10_Msk (0x1UL << I2C_CR2_ADD10_Pos)
#define I2C_CR2_ADD10 I2C_CR2_ADD10_Msk
#define I2C_CR2_HEAD10R_Pos (12U)
#define I2C_CR2_HEAD10R_Msk (0x1UL << I2C_CR2_HEAD10R_Pos)
#define I2C_CR2_HEAD10R I2C_CR2_HEAD10R_Msk
#define I2C_CR2_START_Pos (13U)
#define I2C_CR2_START_Msk (0x1UL << I2C_CR2_START_Pos)
#define I2C_CR2_START I2C_CR2_START_Msk
#define I2C_CR2_STOP_Pos (14U)
#define I2C_CR2_STOP_Msk (0x1UL << I2C_CR2_STOP_Pos)
#define I2C_CR2_STOP I2C_CR2_STOP_Msk
#define I2C_CR2_NACK_Pos (15U)
#define I2C_CR2_NACK_Msk (0x1UL << I2C_CR2_NACK_Pos)
#define I2C_CR2_NACK I2C_CR2_NACK_Msk
#define I2C_CR2_NBYTES_Pos (16U)
#define I2C_CR2_NBYTES_Msk (0xFFUL << I2C_CR2_NBYTES_Pos)
#define I2C_CR2_NBYTES I2C_CR2_NBYTES_Msk
#define I2C_CR2_RELOAD_Pos (24U)
#define I2C_CR2_RELOAD_Msk (0x1UL << I2C_CR2_RELOAD_Pos)
#define I2C_CR2_RELOAD I2C_CR2_RELOAD_Msk
#define I2C_CR2_AUTOEND_Pos (25U)
#define I2C_CR2_AUTOEND_Msk (0x1UL << I2C_CR2_AUTOEND_Pos)
#define I2C_CR2_AUTOEND I2C_CR2_AUTOEND_Msk
#define I2C_CR2_PECBYTE_Pos (26U)
#define I2C_CR2_PECBYTE_Msk (0x1UL << I2C_CR2_PECBYTE_Pos)
#define I2C_CR2_PECBYTE I2C_CR2_PECBYTE_Msk

/*******************  Bit definition for I2C_OAR1 register  ******************/
#define I2C_OAR1_OA1_Pos (0U)
#define I2C_OAR1_OA1_Msk (0x3FFUL << I2C_OAR1_OA1_Pos)
#define I2C_OAR1_OA1 I2C_OAR1_OA1_Msk
#define I2C_OAR1_OA1MODE_Pos (10U)
#define I2C_OAR1_OA1MODE_Msk (0x1UL << I2C_OAR1_OA1MODE_Pos)
#define I2C_OAR1_OA1MODE I2C_OAR1_OA1MODE_Msk
#define I2C_OAR1_OA1EN_Pos (15U)
#define I2C_OAR1_OA1EN_Msk (0x1UL << I2C_OAR1_OA1EN_Pos)
#define I2C_OAR1_OA1EN I2C_OAR1_OA1EN_Msk

/*******************  Bit definition for I2C_OAR2 register  ******************/
#define I2C_OAR2_OA2_Pos (1U)
#define I2C_OAR2_OA2_Msk (0x7FUL << I2C_OAR2_OA2_Pos)
#define I2C_OAR2_OA2 I2C_OAR2_OA2_Msk
#define I2C_OAR2_OA2MSK_Pos (8U)
#define I2C_OAR2_OA2MSK_Msk (0x7UL << I2C_OAR2_OA2MSK_Pos)
#define I2C_OAR2_OA2MSK I2C_OAR2_OA2MSK_Msk
#define I2C_OAR2_OA2NOMASK (0x00000000U)
#define I2C_OAR2_OA2MASK01_Pos (8U)
#define I2C_OAR2_OA2MASK01_Msk (0x1UL << I2C_OAR2_OA2MASK01_Pos)
#define I2C_OAR2_OA2MASK01 I2C_OAR2_OA2MASK01_Msk
#define I2C_OAR2_OA2MASK02_Pos (9U)
#define I2C_OAR2_OA2MASK02_Msk (0x1UL << I2C_OAR2_OA2MASK02_Pos)
#define I2C_OAR2_OA2MASK02 I2C_OAR2_OA2MASK02_Msk
#define I2C_OAR2_OA2MASK03_Pos (8U)
#define I2C_OAR2_OA2MASK03_Msk (0x3UL << I2C_OAR2_OA2MASK03_Pos)
#define I2C_OAR2_OA2MASK03 I2C_OAR2_OA2MASK03_Msk
#define I2C_OAR2_OA2MASK04_Pos (10U)
#define I2C_OAR2_OA2MASK04_Msk (0x1UL << I2C_OAR2_OA2MASK04_Pos)
#define I2C_OAR2_OA2MASK04 I2C_OAR2_OA2MASK04_Msk
#define I2C_OAR2_OA2MASK05_Pos (8U)
#define I2C_OAR2_OA2MASK05_Msk (0x5UL << I2C_OAR2_OA2MASK05_Pos)
#define I2C_OAR2_OA2MASK05 I2C_OAR2_OA2MASK05_Msk
#define I2C_OAR2_OA2MASK06_Pos (9U)
#define I2C_OAR2_OA2MASK06_Msk (0x3UL << I2C_OAR2_OA2MASK06_Pos)
#define I2C_OAR2_OA2MASK06 I2C_OAR2_OA2MASK06_Msk
#define I2C_OAR2_OA2MASK07_Pos (8U)
#define I2C_OAR2_OA2MASK07_Msk (0x7UL << I2C_OAR2_OA2MASK07_Pos)
#define I2C_OAR2_OA2MASK07 I2C_OAR2_OA2MASK07_Msk
#define I2C_OAR2_OA2EN_Pos (15U)
#define I2C_OAR2_OA2EN_Msk (0x1UL << I2C_OAR2_OA2EN_Pos)
#define I2C_OAR2_OA2EN I2C_OAR2_OA2EN_Msk

/*******************  Bit definition for I2C_TIMINGR register *******************/
#define I2C_TIMINGR_SCLL_Pos (0U)
#define I2C_TIMINGR_SCLL_Msk (0xFFUL << I2C_TIMINGR_SCLL_Pos)
#define I2C_TIMINGR_SCLL I2C_TIMINGR_SCLL_Msk
#define I2C_TIMINGR_SCLH_Pos (8U)
#define I2C_TIMINGR_SCLH_Msk (0xFFUL << I2C_TIMINGR_SCLH_Pos)
#define I2C_TIMINGR_SCLH I2C_TIMINGR_SCLH_Msk
#define I2C_TIMINGR_SDADEL_Pos (16U)
#define I2C_TIMINGR_SDADEL_Msk (0xFUL << I2C_TIMINGR_SDADEL_Pos)
#define I2C_TIMINGR_SDADEL I2C_TIMINGR_SDADEL_Msk
#define I2C_TIMINGR_SCLDEL_Pos (20U)
#define I2C_TIMINGR_SCLDEL_Msk (0xFUL << I2C_TIMINGR_SCLDEL_Pos)
#define I2C_TIMINGR_SCLDEL I2C_TIMINGR_SCLDEL_Msk
#define I2C_TIMINGR_PRESC_Pos (28U)
#define I2C_TIMINGR_PRESC_Msk (0xFUL << I2C_TIMINGR_PRESC_Pos)
#define I2C_TIMINGR_PRESC I2C_TIMINGR_PRESC_Msk

/******************* Bit definition for I2C_TIMEOUTR register *******************/
#define I2C_TIMEOUTR_TIMEOUTA_Pos (0U)
#define I2C_TIMEOUTR_TIMEOUTA_Msk (0xFFFUL << I2C_TIMEOUTR_TIMEOUTA_Pos)
#define I2C_TIMEOUTR_TIMEOUTA I2C_TIMEOUTR_TIMEOUTA_Msk
#define I2C_TIMEOUTR_TIDLE_Pos (12U)
#define I2C_TIMEOUTR_TIDLE_Msk (0x1UL << I2C_TIMEOUTR_TIDLE_Pos)
#define I2C_TIMEOUTR_TIDLE I2C_TIMEOUTR_TIDLE_Msk
#define I2C_TIMEOUTR_TIMOUTEN_Pos (15U)
#define I2C_TIMEOUTR_TIMOUTEN_Msk (0x1UL << I2C_TIMEOUTR_TIMOUTEN_Pos)
#define I2C_TIMEOUTR_TIMOUTEN I2C_TIMEOUTR_TIMOUTEN_Msk
#define I2C_TIMEOUTR_TIMEOUTB_Pos (16U)
#define I2C_TIMEOUTR_TIMEOUTB_Msk (0xFFFUL << I2C_TIMEOUTR_TIMEOUTB_Pos)
#define I2C_TIMEOUTR_TIMEOUTB I2C_TIMEOUTR_TIMEOUTB_Msk
#define I2C_TIMEOUTR_TEXTEN_Pos (31U)
#define I2C_TIMEOUTR_TEXTEN_Msk (0x1UL << I2C_TIMEOUTR_TEXTEN_Pos)
#define I2C_TIMEOUTR_TEXTEN I2C_TIMEOUTR_TEXTEN_Msk

/******************  Bit definition for I2C_ISR register  *********************/
#define I2C_ISR_TXE_Pos (0U)
#define I2C_ISR_TXE_Msk (0x1UL << I2C_ISR_TXE_Pos)
#define I2C_ISR_TXE I2C_ISR_TXE_Msk
#define I2C_ISR_TXIS_Pos (1U)
#define I2C_ISR_TXIS_Msk (0x1UL << I2C_ISR_TXIS_Pos)
#define I2C_ISR_TXIS I2C_ISR_TXIS_Msk
#define I2C_ISR_RXNE_Pos (2U)
#define I2C_ISR_RXNE_Msk (0x1UL << I2C_ISR_RXNE_Pos)
#define I2C_ISR_RXNE I2C_ISR_RXNE_Msk
#define I2C_ISR_ADDR_Pos (3U)
#define I2C_ISR_ADDR_Msk (0x1UL << I2C_ISR_ADDR_Pos)
#define I2C_ISR_ADDR I2C_ISR_ADDR_Msk
#define I2C_ISR_NACKF_Pos (4U)
#define I2C_ISR_NACKF_Msk (0x1UL << I2C_ISR_NACKF_Pos)
#define I2C_ISR_NACKF I2C_ISR_NACKF_Msk
#define I2C_ISR_STOPF_Pos (5U)
#define I2C_ISR_STOPF_Msk (0x1UL << I2C_ISR_STOPF_Pos)
#define I2C_ISR_STOPF I2C_ISR_STOPF_Msk
#define I2C_ISR_TC_Pos (6U)
#define I2C_ISR_TC_Msk (0x1UL << I2C_ISR_TC_Pos)
#define I2C_ISR_TC I2C_ISR_TC_Msk
#define I2C_ISR_TCR_Pos (7U)
#define I2C_ISR_TCR_Msk (0x1UL << I2C_ISR_TCR_Pos)
#define I2C_ISR_TCR I2C_ISR_TCR_Msk
#define I2C_ISR_BERR_Pos (8U)
#define I2C_ISR_BERR_Msk (0x1UL << I2C_ISR_BERR_Pos)
#define I2C_ISR_BERR I2C_ISR_BERR_Msk
#define I2C_ISR_ARLO_Pos (9U)
#define I2C_ISR_ARLO_Msk (0x1UL << I2C_ISR_ARLO_Pos)
#define I2C_ISR_ARLO I2C_ISR_ARLO_Msk
#define I2C_ISR_OVR_Pos (10U)
#define I2C_ISR_OVR_Msk (0x1UL << I2C_ISR_OVR_Pos)
#define I2C_ISR_OVR I2C_ISR_OVR_Msk
#define I2C_ISR_PECERR_Pos (11U)
#define I2C_ISR_PECERR_Msk (0x1UL << I2C_ISR_PECERR_Pos)
#define I2C_ISR_PECERR I2C_ISR_PECERR_Msk
#define I2C_ISR_TIMEOUT_Pos (12U)
#define I2C_ISR_TIMEOUT_Msk (0x1UL << I2C_ISR_TIMEOUT_Pos)
#define I2C_ISR_TIMEOUT I2C_ISR_TIMEOUT_Msk
#define I2C_ISR_ALERT_Pos (13U)
#define I2C_ISR_ALERT_Msk (0x1UL << I2C_ISR_ALERT_Pos)
#define I2C_ISR_ALERT I2C_ISR_ALERT_Msk
#define I2C_ISR_BUSY_Pos (15U)
#define I2C_ISR_BUSY_Msk (0x1UL << I2C_ISR_BUSY_Pos)
#define I2C_ISR_BUSY I2C_ISR_BUSY_Msk
#define I2C_ISR_DIR_Pos (16U)
#define I2C_ISR_DIR_Msk (0x1UL << I2C_ISR_DIR_Pos)
#define I2C_ISR_DIR I2C_ISR_DIR_Msk
#define I2C_ISR_ADDCODE_Pos (17U)
#define I2C_ISR_ADDCODE_Msk (0x7FUL << I2C_ISR_ADDCODE_Pos)
#define I2C_ISR_ADDCODE I2C_ISR_ADDCODE_Msk

/******************  Bit definition for I2C_ICR register  *********************/
#define I2C_ICR_ADDRCF_Pos (3U)
#define I2C_ICR_ADDRCF_Msk (0x1UL << I2C_ICR_ADDRCF_Pos)
#define I2C_ICR_ADDRCF I2C_ICR_ADDRCF_Msk
#define I2C_ICR_NACKCF_Pos (4U)
#define I2C_ICR_NACKCF_Msk (0x1UL << I2C_ICR_NACKCF_Pos)
#define I2C_ICR_NACKCF I2C_ICR_NACKCF_Msk
#define I2C_ICR_STOPCF_Pos (5U)
#define I2C_ICR_STOPCF_Msk (0x1UL << I2C_ICR_STOPCF_Pos)
#define I2C_ICR_STOPCF I2C_ICR_STOPCF_Msk
#define I2C_ICR_BERRCF_Pos (8U)
#define I2C_ICR_BERRCF_Msk (0x1UL << I2C_ICR_BERRCF_Pos)
#define I2C_ICR_BERRCF I2C_ICR_BERRCF_Msk
#define I2C_ICR_ARLOCF_Pos (9U)
#define I2C_ICR_ARLOCF_Msk (0x1UL << I2C_ICR_ARLOCF_Pos)
#define I2C_ICR_ARLOCF I2C_ICR_ARLOCF_Msk
#define I2C_ICR_OVRCF_Pos (10U)
#define I2C_ICR_OVRCF_Msk (0x1UL << I2C_ICR_OVRCF_Pos)
#define I2C_ICR_OVRCF I2C_ICR_OVRCF_Msk
#define I2C_ICR_PECCF_Pos (11U)
#define I2C_ICR_PECCF_Msk (0x1UL << I2C_ICR_PECCF_Pos)
#define I2C_ICR_PECCF I2C_ICR_PECCF_Msk
#define I2C_ICR_TIMOUTCF_Pos (12U)
#define I2C_ICR_TIMOUTCF_Msk (0x1UL << I2C_ICR_TIMOUTCF_Pos)
#define I2C_ICR_TIMOUTCF I2C_ICR_TIMOUTCF_Msk
#define I2C_ICR_ALERTCF_Pos (13U)
#define I2C_ICR_ALERTCF_Msk (0x1UL << I2C_ICR_ALERTCF_Pos)
#define I2C_ICR_ALERTCF I2C_ICR_ALERTCF_Msk

/******************  Bit definition for I2C_PECR register  *********************/
#define I2C_PECR_PEC_Pos (0U)
#define I2C_PECR_PEC_Msk (0xFFUL << I2C_PECR_PEC_Pos)
#define I2C_PECR_PEC I2C_PECR_PEC_Msk

/******************  Bit definition for I2C_RXDR register  *********************/
#define I2C_RXDR_RXDATA_Pos (0U)
#define I2C_RXDR_RXDATA_Msk (0xFFUL << I2C_RXDR_RXDATA_Pos)
#define I2C_RXDR_RXDATA I2C_RXDR_RXDATA_Msk

/******************  Bit definition for I2C_TXDR register  *********************/
#define I2C_TXDR_TXDATA_Pos (0U)
#define I2C_TXDR_TXDATA_Msk (0xFFUL << I2C_TXDR_TXDATA_Pos)
#define I2C_TXDR_TXDATA I2C_TXDR_TXDATA_Msk

/******************************************************************************/
/*                                                                            */
/*                           Independent WATCHDOG                             */
/*                                                                            */
/******************************************************************************/
/*******************  Bit definition for IWDG_KR register  ********************/
#define IWDG_KR_KEY_Pos (0U)
#define IWDG_KR_KEY_Msk (0xFFFFUL << IWDG_KR_KEY_Pos)
#define IWDG_KR_KEY IWDG_KR_KEY_Msk

/*******************  Bit definition for IWDG_PR register  ********************/
#define IWDG_PR_PR_Pos (0U)
#define IWDG_PR_PR_Msk (0x7UL << IWDG_PR_PR_Pos)
#define IWDG_PR_PR IWDG_PR_PR_Msk
#define IWDG_PR_PR_0 (0x1UL << IWDG_PR_PR_Pos)
#define IWDG_PR_PR_1 (0x2UL << IWDG_PR_PR_Pos)
#define IWDG_PR_PR_2 (0x4UL << IWDG_PR_PR_Pos)

/*******************  Bit definition for IWDG_RLR register  *******************/
#define IWDG_RLR_RL_Pos (0U)
#define IWDG_RLR_RL_Msk (0xFFFUL << IWDG_RLR_RL_Pos)
#define IWDG_RLR_RL IWDG_RLR_RL_Msk

/*******************  Bit definition for IWDG_SR register  ********************/
#define IWDG_SR_PVU_Pos (0U)
#define IWDG_SR_PVU_Msk (0x1UL << IWDG_SR_PVU_Pos)
#define IWDG_SR_PVU IWDG_SR_PVU_Msk
#define IWDG_SR_RVU_Pos (1U)
#define IWDG_SR_RVU_Msk (0x1UL << IWDG_SR_RVU_Pos)
#define IWDG_SR_RVU IWDG_SR_RVU_Msk
#define IWDG_SR_WVU_Pos (2U)
#define IWDG_SR_WVU_Msk (0x1UL << IWDG_SR_WVU_Pos)
#define IWDG_SR_WVU IWDG_SR_WVU_Msk

/*******************  Bit definition for IWDG_KR register  ********************/
#define IWDG_WINR_WIN_Pos (0U)
#define IWDG_WINR_WIN_Msk (0xFFFUL << IWDG_WINR_WIN_Pos)
#define IWDG_WINR_WIN IWDG_WINR_WIN_Msk

/******************************************************************************/
/*                                                                            */
/*                         Operational Amplifier (OPAMP)                      */
/*                                                                            */
/******************************************************************************/
/*********************  Bit definition for OPAMPx_CSR register  ***************/
#define OPAMP_CSR_OPAMPxEN_Pos (0U)
#define OPAMP_CSR_OPAMPxEN_Msk (0x1UL << OPAMP_CSR_OPAMPxEN_Pos)
#define OPAMP_CSR_OPAMPxEN OPAMP_CSR_OPAMPxEN_Msk
#define OPAMP_CSR_FORCEVP_Pos (1U)
#define OPAMP_CSR_FORCEVP_Msk (0x1UL << OPAMP_CSR_FORCEVP_Pos)
#define OPAMP_CSR_FORCEVP OPAMP_CSR_FORCEVP_Msk
#define OPAMP_CSR_VPSEL_Pos (2U)
#define OPAMP_CSR_VPSEL_Msk (0x3UL << OPAMP_CSR_VPSEL_Pos)
#define OPAMP_CSR_VPSEL OPAMP_CSR_VPSEL_Msk
#define OPAMP_CSR_VPSEL_0 (0x1UL << OPAMP_CSR_VPSEL_Pos)
#define OPAMP_CSR_VPSEL_1 (0x2UL << OPAMP_CSR_VPSEL_Pos)
#define OPAMP_CSR_USERTRIM_Pos (4U)
#define OPAMP_CSR_USERTRIM_Msk (0x1UL << OPAMP_CSR_USERTRIM_Pos)
#define OPAMP_CSR_USERTRIM OPAMP_CSR_USERTRIM_Msk
#define OPAMP_CSR_VMSEL_Pos (5U)
#define OPAMP_CSR_VMSEL_Msk (0x3UL << OPAMP_CSR_VMSEL_Pos)
#define OPAMP_CSR_VMSEL OPAMP_CSR_VMSEL_Msk
#define OPAMP_CSR_VMSEL_0 (0x1UL << OPAMP_CSR_VMSEL_Pos)
#define OPAMP_CSR_VMSEL_1 (0x2UL << OPAMP_CSR_VMSEL_Pos)
#define OPAMP_CSR_HIGHSPEEDEN_Pos (7U)
#define OPAMP_CSR_HIGHSPEEDEN_Msk (0x1UL << OPAMP_CSR_HIGHSPEEDEN_Pos)
#define OPAMP_CSR_HIGHSPEEDEN OPAMP_CSR_HIGHSPEEDEN_Msk
#define OPAMP_CSR_OPAMPINTEN_Pos (8U)
#define OPAMP_CSR_OPAMPINTEN_Msk (0x1UL << OPAMP_CSR_OPAMPINTEN_Pos)
#define OPAMP_CSR_OPAMPINTEN OPAMP_CSR_OPAMPINTEN_Msk
#define OPAMP_CSR_CALON_Pos (11U)
#define OPAMP_CSR_CALON_Msk (0x1UL << OPAMP_CSR_CALON_Pos)
#define OPAMP_CSR_CALON OPAMP_CSR_CALON_Msk
#define OPAMP_CSR_CALSEL_Pos (12U)
#define OPAMP_CSR_CALSEL_Msk (0x3UL << OPAMP_CSR_CALSEL_Pos)
#define OPAMP_CSR_CALSEL OPAMP_CSR_CALSEL_Msk
#define OPAMP_CSR_CALSEL_0 (0x1UL << OPAMP_CSR_CALSEL_Pos)
#define OPAMP_CSR_CALSEL_1 (0x2UL << OPAMP_CSR_CALSEL_Pos)
#define OPAMP_CSR_PGGAIN_Pos (14U)
#define OPAMP_CSR_PGGAIN_Msk (0x1FUL << OPAMP_CSR_PGGAIN_Pos)
#define OPAMP_CSR_PGGAIN OPAMP_CSR_PGGAIN_Msk
#define OPAMP_CSR_PGGAIN_0 (0x1UL << OPAMP_CSR_PGGAIN_Pos)
#define OPAMP_CSR_PGGAIN_1 (0x2UL << OPAMP_CSR_PGGAIN_Pos)
#define OPAMP_CSR_PGGAIN_2 (0x4UL << OPAMP_CSR_PGGAIN_Pos)
#define OPAMP_CSR_PGGAIN_3 (0x8UL << OPAMP_CSR_PGGAIN_Pos)
#define OPAMP_CSR_PGGAIN_4 (0x10UL << OPAMP_CSR_PGGAIN_Pos)
#define OPAMP_CSR_TRIMOFFSETP_Pos (19U)
#define OPAMP_CSR_TRIMOFFSETP_Msk (0x1FUL << OPAMP_CSR_TRIMOFFSETP_Pos)
#define OPAMP_CSR_TRIMOFFSETP OPAMP_CSR_TRIMOFFSETP_Msk
#define OPAMP_CSR_TRIMOFFSETN_Pos (24U)
#define OPAMP_CSR_TRIMOFFSETN_Msk (0x1FUL << OPAMP_CSR_TRIMOFFSETN_Pos)
#define OPAMP_CSR_TRIMOFFSETN OPAMP_CSR_TRIMOFFSETN_Msk
#define OPAMP_CSR_OUTCAL_Pos (30U)
#define OPAMP_CSR_OUTCAL_Msk (0x1UL << OPAMP_CSR_OUTCAL_Pos)
#define OPAMP_CSR_OUTCAL OPAMP_CSR_OUTCAL_Msk
#define OPAMP_CSR_LOCK_Pos (31U)
#define OPAMP_CSR_LOCK_Msk (0x1UL << OPAMP_CSR_LOCK_Pos)
#define OPAMP_CSR_LOCK OPAMP_CSR_LOCK_Msk

/*********************  Bit definition for OPAMPx_TCMR register  ***************/

#define OPAMP_TCMR_VMSSEL_Pos (0U)
#define OPAMP_TCMR_VMSSEL_Msk (0x1UL << OPAMP_TCMR_VMSSEL_Pos)
#define OPAMP_TCMR_VMSSEL OPAMP_TCMR_VMSSEL_Msk
#define OPAMP_TCMR_VPSSEL_Pos (1U)
#define OPAMP_TCMR_VPSSEL_Msk (0x3UL << OPAMP_TCMR_VPSSEL_Pos)
#define OPAMP_TCMR_VPSSEL OPAMP_TCMR_VPSSEL_Msk
#define OPAMP_TCMR_VPSSEL_0 (0x1UL << OPAMP_TCMR_VPSSEL_Pos)
#define OPAMP_TCMR_VPSSEL_1 (0x2UL << OPAMP_TCMR_VPSSEL_Pos)
#define OPAMP_TCMR_T1CMEN_Pos (3U)
#define OPAMP_TCMR_T1CMEN_Msk (0x1UL << OPAMP_TCMR_T1CMEN_Pos)
#define OPAMP_TCMR_T1CMEN OPAMP_TCMR_T1CMEN_Msk
#define OPAMP_TCMR_T8CMEN_Pos (4U)
#define OPAMP_TCMR_T8CMEN_Msk (0x1UL << OPAMP_TCMR_T8CMEN_Pos)
#define OPAMP_TCMR_T8CMEN OPAMP_TCMR_T8CMEN_Msk
#define OPAMP_TCMR_T20CMEN_Pos (5U)
#define OPAMP_TCMR_T20CMEN_Msk (0x1UL << OPAMP_TCMR_T20CMEN_Pos)
#define OPAMP_TCMR_T20CMEN OPAMP_TCMR_T20CMEN_Msk
#define OPAMP_TCMR_LOCK_Pos (31U)
#define OPAMP_TCMR_LOCK_Msk (0x1UL << OPAMP_TCMR_LOCK_Pos)
#define OPAMP_TCMR_LOCK OPAMP_TCMR_LOCK_Msk


/******************************************************************************/
/*                                                                            */
/*                             Power Control                                  */
/*                                                                            */
/******************************************************************************/

/********************  Bit definition for PWR_CR1 register  ********************/

#define PWR_CR1_LPR_Pos (14U)
#define PWR_CR1_LPR_Msk (0x1UL << PWR_CR1_LPR_Pos)
#define PWR_CR1_LPR PWR_CR1_LPR_Msk
#define PWR_CR1_VOS_Pos (9U)
#define PWR_CR1_VOS_Msk (0x3UL << PWR_CR1_VOS_Pos)
#define PWR_CR1_VOS PWR_CR1_VOS_Msk
#define PWR_CR1_VOS_0 (0x1UL << PWR_CR1_VOS_Pos)
#define PWR_CR1_VOS_1 (0x2UL << PWR_CR1_VOS_Pos)
#define PWR_CR1_DBP_Pos (8U)
#define PWR_CR1_DBP_Msk (0x1UL << PWR_CR1_DBP_Pos)
#define PWR_CR1_DBP PWR_CR1_DBP_Msk
#define PWR_CR1_LPMS_Pos (0U)
#define PWR_CR1_LPMS_Msk (0x7UL << PWR_CR1_LPMS_Pos)
#define PWR_CR1_LPMS PWR_CR1_LPMS_Msk
#define PWR_CR1_LPMS_STOP0 (0x00000000U)
#define PWR_CR1_LPMS_STOP1_Pos (0U)
#define PWR_CR1_LPMS_STOP1_Msk (0x1UL << PWR_CR1_LPMS_STOP1_Pos)
#define PWR_CR1_LPMS_STOP1 PWR_CR1_LPMS_STOP1_Msk
#define PWR_CR1_LPMS_STANDBY_Pos (0U)
#define PWR_CR1_LPMS_STANDBY_Msk (0x3UL << PWR_CR1_LPMS_STANDBY_Pos)
#define PWR_CR1_LPMS_STANDBY PWR_CR1_LPMS_STANDBY_Msk
#define PWR_CR1_LPMS_SHUTDOWN_Pos (2U)
#define PWR_CR1_LPMS_SHUTDOWN_Msk (0x1UL << PWR_CR1_LPMS_SHUTDOWN_Pos)
#define PWR_CR1_LPMS_SHUTDOWN PWR_CR1_LPMS_SHUTDOWN_Msk


/********************  Bit definition for PWR_CR2 register  ********************/

/*!< PVME  Peripheral Voltage Monitor Enable */
#define PWR_CR2_PVME_Pos (4U)
#define PWR_CR2_PVME_Msk (0xFUL << PWR_CR2_PVME_Pos)
#define PWR_CR2_PVME PWR_CR2_PVME_Msk
#define PWR_CR2_PVME4_Pos (7U)
#define PWR_CR2_PVME4_Msk (0x1UL << PWR_CR2_PVME4_Pos)
#define PWR_CR2_PVME4 PWR_CR2_PVME4_Msk
#define PWR_CR2_PVME3_Pos (6U)
#define PWR_CR2_PVME3_Msk (0x1UL << PWR_CR2_PVME3_Pos)
#define PWR_CR2_PVME3 PWR_CR2_PVME3_Msk
#define PWR_CR2_PVME2_Pos (5U)
#define PWR_CR2_PVME2_Msk (0x1UL << PWR_CR2_PVME2_Pos)
#define PWR_CR2_PVME2 PWR_CR2_PVME2_Msk
#define PWR_CR2_PVME1_Pos (4U)
#define PWR_CR2_PVME1_Msk (0x1UL << PWR_CR2_PVME1_Pos)
#define PWR_CR2_PVME1 PWR_CR2_PVME1_Msk

/*!< PVD level configuration */
#define PWR_CR2_PLS_Pos (1U)
#define PWR_CR2_PLS_Msk (0x7UL << PWR_CR2_PLS_Pos)
#define PWR_CR2_PLS PWR_CR2_PLS_Msk
#define PWR_CR2_PLS_LEV0 (0x00000000U)
#define PWR_CR2_PLS_LEV1_Pos (1U)
#define PWR_CR2_PLS_LEV1_Msk (0x1UL << PWR_CR2_PLS_LEV1_Pos)
#define PWR_CR2_PLS_LEV1 PWR_CR2_PLS_LEV1_Msk
#define PWR_CR2_PLS_LEV2_Pos (2U)
#define PWR_CR2_PLS_LEV2_Msk (0x1UL << PWR_CR2_PLS_LEV2_Pos)
#define PWR_CR2_PLS_LEV2 PWR_CR2_PLS_LEV2_Msk
#define PWR_CR2_PLS_LEV3_Pos (1U)
#define PWR_CR2_PLS_LEV3_Msk (0x3UL << PWR_CR2_PLS_LEV3_Pos)
#define PWR_CR2_PLS_LEV3 PWR_CR2_PLS_LEV3_Msk
#define PWR_CR2_PLS_LEV4_Pos (3U)
#define PWR_CR2_PLS_LEV4_Msk (0x1UL << PWR_CR2_PLS_LEV4_Pos)
#define PWR_CR2_PLS_LEV4 PWR_CR2_PLS_LEV4_Msk
#define PWR_CR2_PLS_LEV5_Pos (1U)
#define PWR_CR2_PLS_LEV5_Msk (0x5UL << PWR_CR2_PLS_LEV5_Pos)
#define PWR_CR2_PLS_LEV5 PWR_CR2_PLS_LEV5_Msk
#define PWR_CR2_PLS_LEV6_Pos (2U)
#define PWR_CR2_PLS_LEV6_Msk (0x3UL << PWR_CR2_PLS_LEV6_Pos)
#define PWR_CR2_PLS_LEV6 PWR_CR2_PLS_LEV6_Msk
#define PWR_CR2_PLS_LEV7_Pos (1U)
#define PWR_CR2_PLS_LEV7_Msk (0x7UL << PWR_CR2_PLS_LEV7_Pos)
#define PWR_CR2_PLS_LEV7 PWR_CR2_PLS_LEV7_Msk
#define PWR_CR2_PVDE_Pos (0U)
#define PWR_CR2_PVDE_Msk (0x1UL << PWR_CR2_PVDE_Pos)
#define PWR_CR2_PVDE PWR_CR2_PVDE_Msk

/********************  Bit definition for PWR_CR3 register  ********************/
#define PWR_CR3_EIWF_Pos (15U)
#define PWR_CR3_EIWF_Msk (0x1UL << PWR_CR3_EIWF_Pos)
#define PWR_CR3_EIWF PWR_CR3_EIWF_Msk
#define PWR_CR3_UCPD_DBDIS_Pos (14U)
#define PWR_CR3_UCPD_DBDIS_Msk (0x1UL << PWR_CR3_UCPD_DBDIS_Pos)
#define PWR_CR3_UCPD_DBDIS PWR_CR3_UCPD_DBDIS_Msk
#define PWR_CR3_UCPD_STDBY_Pos (13U)
#define PWR_CR3_UCPD_STDBY_Msk (0x1UL << PWR_CR3_UCPD_STDBY_Pos)
#define PWR_CR3_UCPD_STDBY PWR_CR3_UCPD_STDBY_Msk
#define PWR_CR3_APC_Pos (10U)
#define PWR_CR3_APC_Msk (0x1UL << PWR_CR3_APC_Pos)
#define PWR_CR3_APC PWR_CR3_APC_Msk
#define PWR_CR3_RRS_Pos (8U)
#define PWR_CR3_RRS_Msk (0x1UL << PWR_CR3_RRS_Pos)
#define PWR_CR3_RRS PWR_CR3_RRS_Msk
#define PWR_CR3_EWUP5_Pos (4U)
#define PWR_CR3_EWUP5_Msk (0x1UL << PWR_CR3_EWUP5_Pos)
#define PWR_CR3_EWUP5 PWR_CR3_EWUP5_Msk
#define PWR_CR3_EWUP4_Pos (3U)
#define PWR_CR3_EWUP4_Msk (0x1UL << PWR_CR3_EWUP4_Pos)
#define PWR_CR3_EWUP4 PWR_CR3_EWUP4_Msk
#define PWR_CR3_EWUP3_Pos (2U)
#define PWR_CR3_EWUP3_Msk (0x1UL << PWR_CR3_EWUP3_Pos)
#define PWR_CR3_EWUP3 PWR_CR3_EWUP3_Msk
#define PWR_CR3_EWUP2_Pos (1U)
#define PWR_CR3_EWUP2_Msk (0x1UL << PWR_CR3_EWUP2_Pos)
#define PWR_CR3_EWUP2 PWR_CR3_EWUP2_Msk
#define PWR_CR3_EWUP1_Pos (0U)
#define PWR_CR3_EWUP1_Msk (0x1UL << PWR_CR3_EWUP1_Pos)
#define PWR_CR3_EWUP1 PWR_CR3_EWUP1_Msk
#define PWR_CR3_EWUP_Pos (0U)
#define PWR_CR3_EWUP_Msk (0x1FUL << PWR_CR3_EWUP_Pos)
#define PWR_CR3_EWUP PWR_CR3_EWUP_Msk

/********************  Bit definition for PWR_CR4 register  ********************/
#define PWR_CR4_VBRS_Pos (9U)
#define PWR_CR4_VBRS_Msk (0x1UL << PWR_CR4_VBRS_Pos)
#define PWR_CR4_VBRS PWR_CR4_VBRS_Msk
#define PWR_CR4_VBE_Pos (8U)
#define PWR_CR4_VBE_Msk (0x1UL << PWR_CR4_VBE_Pos)
#define PWR_CR4_VBE PWR_CR4_VBE_Msk
#define PWR_CR4_WP5_Pos (4U)
#define PWR_CR4_WP5_Msk (0x1UL << PWR_CR4_WP5_Pos)
#define PWR_CR4_WP5 PWR_CR4_WP5_Msk
#define PWR_CR4_WP4_Pos (3U)
#define PWR_CR4_WP4_Msk (0x1UL << PWR_CR4_WP4_Pos)
#define PWR_CR4_WP4 PWR_CR4_WP4_Msk
#define PWR_CR4_WP3_Pos (2U)
#define PWR_CR4_WP3_Msk (0x1UL << PWR_CR4_WP3_Pos)
#define PWR_CR4_WP3 PWR_CR4_WP3_Msk
#define PWR_CR4_WP2_Pos (1U)
#define PWR_CR4_WP2_Msk (0x1UL << PWR_CR4_WP2_Pos)
#define PWR_CR4_WP2 PWR_CR4_WP2_Msk
#define PWR_CR4_WP1_Pos (0U)
#define PWR_CR4_WP1_Msk (0x1UL << PWR_CR4_WP1_Pos)
#define PWR_CR4_WP1 PWR_CR4_WP1_Msk

/********************  Bit definition for PWR_SR1 register  ********************/
#define PWR_SR1_WUFI_Pos (15U)
#define PWR_SR1_WUFI_Msk (0x1UL << PWR_SR1_WUFI_Pos)
#define PWR_SR1_WUFI PWR_SR1_WUFI_Msk
#define PWR_SR1_SBF_Pos (8U)
#define PWR_SR1_SBF_Msk (0x1UL << PWR_SR1_SBF_Pos)
#define PWR_SR1_SBF PWR_SR1_SBF_Msk
#define PWR_SR1_WUF_Pos (0U)
#define PWR_SR1_WUF_Msk (0x1FUL << PWR_SR1_WUF_Pos)
#define PWR_SR1_WUF PWR_SR1_WUF_Msk
#define PWR_SR1_WUF5_Pos (4U)
#define PWR_SR1_WUF5_Msk (0x1UL << PWR_SR1_WUF5_Pos)
#define PWR_SR1_WUF5 PWR_SR1_WUF5_Msk
#define PWR_SR1_WUF4_Pos (3U)
#define PWR_SR1_WUF4_Msk (0x1UL << PWR_SR1_WUF4_Pos)
#define PWR_SR1_WUF4 PWR_SR1_WUF4_Msk
#define PWR_SR1_WUF3_Pos (2U)
#define PWR_SR1_WUF3_Msk (0x1UL << PWR_SR1_WUF3_Pos)
#define PWR_SR1_WUF3 PWR_SR1_WUF3_Msk
#define PWR_SR1_WUF2_Pos (1U)
#define PWR_SR1_WUF2_Msk (0x1UL << PWR_SR1_WUF2_Pos)
#define PWR_SR1_WUF2 PWR_SR1_WUF2_Msk
#define PWR_SR1_WUF1_Pos (0U)
#define PWR_SR1_WUF1_Msk (0x1UL << PWR_SR1_WUF1_Pos)
#define PWR_SR1_WUF1 PWR_SR1_WUF1_Msk

/********************  Bit definition for PWR_SR2 register  ********************/
#define PWR_SR2_PVMO4_Pos (15U)
#define PWR_SR2_PVMO4_Msk (0x1UL << PWR_SR2_PVMO4_Pos)
#define PWR_SR2_PVMO4 PWR_SR2_PVMO4_Msk
#define PWR_SR2_PVMO3_Pos (14U)
#define PWR_SR2_PVMO3_Msk (0x1UL << PWR_SR2_PVMO3_Pos)
#define PWR_SR2_PVMO3 PWR_SR2_PVMO3_Msk
#define PWR_SR2_PVMO2_Pos (13U)
#define PWR_SR2_PVMO2_Msk (0x1UL << PWR_SR2_PVMO2_Pos)
#define PWR_SR2_PVMO2 PWR_SR2_PVMO2_Msk
#define PWR_SR2_PVMO1_Pos (12U)
#define PWR_SR2_PVMO1_Msk (0x1UL << PWR_SR2_PVMO1_Pos)
#define PWR_SR2_PVMO1 PWR_SR2_PVMO1_Msk
#define PWR_SR2_PVDO_Pos (11U)
#define PWR_SR2_PVDO_Msk (0x1UL << PWR_SR2_PVDO_Pos)
#define PWR_SR2_PVDO PWR_SR2_PVDO_Msk
#define PWR_SR2_VOSF_Pos (10U)
#define PWR_SR2_VOSF_Msk (0x1UL << PWR_SR2_VOSF_Pos)
#define PWR_SR2_VOSF PWR_SR2_VOSF_Msk
#define PWR_SR2_REGLPF_Pos (9U)
#define PWR_SR2_REGLPF_Msk (0x1UL << PWR_SR2_REGLPF_Pos)
#define PWR_SR2_REGLPF PWR_SR2_REGLPF_Msk
#define PWR_SR2_REGLPS_Pos (8U)
#define PWR_SR2_REGLPS_Msk (0x1UL << PWR_SR2_REGLPS_Pos)
#define PWR_SR2_REGLPS PWR_SR2_REGLPS_Msk

/********************  Bit definition for PWR_SCR register  ********************/
#define PWR_SCR_CSBF_Pos (8U)
#define PWR_SCR_CSBF_Msk (0x1UL << PWR_SCR_CSBF_Pos)
#define PWR_SCR_CSBF PWR_SCR_CSBF_Msk
#define PWR_SCR_CWUF_Pos (0U)
#define PWR_SCR_CWUF_Msk (0x1FUL << PWR_SCR_CWUF_Pos)
#define PWR_SCR_CWUF PWR_SCR_CWUF_Msk
#define PWR_SCR_CWUF5_Pos (4U)
#define PWR_SCR_CWUF5_Msk (0x1UL << PWR_SCR_CWUF5_Pos)
#define PWR_SCR_CWUF5 PWR_SCR_CWUF5_Msk
#define PWR_SCR_CWUF4_Pos (3U)
#define PWR_SCR_CWUF4_Msk (0x1UL << PWR_SCR_CWUF4_Pos)
#define PWR_SCR_CWUF4 PWR_SCR_CWUF4_Msk
#define PWR_SCR_CWUF3_Pos (2U)
#define PWR_SCR_CWUF3_Msk (0x1UL << PWR_SCR_CWUF3_Pos)
#define PWR_SCR_CWUF3 PWR_SCR_CWUF3_Msk
#define PWR_SCR_CWUF2_Pos (1U)
#define PWR_SCR_CWUF2_Msk (0x1UL << PWR_SCR_CWUF2_Pos)
#define PWR_SCR_CWUF2 PWR_SCR_CWUF2_Msk
#define PWR_SCR_CWUF1_Pos (0U)
#define PWR_SCR_CWUF1_Msk (0x1UL << PWR_SCR_CWUF1_Pos)
#define PWR_SCR_CWUF1 PWR_SCR_CWUF1_Msk

/********************  Bit definition for PWR_PUCRA register  ********************/
#define PWR_PUCRA_PA15_Pos (15U)
#define PWR_PUCRA_PA15_Msk (0x1UL << PWR_PUCRA_PA15_Pos)
#define PWR_PUCRA_PA15 PWR_PUCRA_PA15_Msk
#define PWR_PUCRA_PA13_Pos (13U)
#define PWR_PUCRA_PA13_Msk (0x1UL << PWR_PUCRA_PA13_Pos)
#define PWR_PUCRA_PA13 PWR_PUCRA_PA13_Msk
#define PWR_PUCRA_PA12_Pos (12U)
#define PWR_PUCRA_PA12_Msk (0x1UL << PWR_PUCRA_PA12_Pos)
#define PWR_PUCRA_PA12 PWR_PUCRA_PA12_Msk
#define PWR_PUCRA_PA11_Pos (11U)
#define PWR_PUCRA_PA11_Msk (0x1UL << PWR_PUCRA_PA11_Pos)
#define PWR_PUCRA_PA11 PWR_PUCRA_PA11_Msk
#define PWR_PUCRA_PA10_Pos (10U)
#define PWR_PUCRA_PA10_Msk (0x1UL << PWR_PUCRA_PA10_Pos)
#define PWR_PUCRA_PA10 PWR_PUCRA_PA10_Msk
#define PWR_PUCRA_PA9_Pos (9U)
#define PWR_PUCRA_PA9_Msk (0x1UL << PWR_PUCRA_PA9_Pos)
#define PWR_PUCRA_PA9 PWR_PUCRA_PA9_Msk
#define PWR_PUCRA_PA8_Pos (8U)
#define PWR_PUCRA_PA8_Msk (0x1UL << PWR_PUCRA_PA8_Pos)
#define PWR_PUCRA_PA8 PWR_PUCRA_PA8_Msk
#define PWR_PUCRA_PA7_Pos (7U)
#define PWR_PUCRA_PA7_Msk (0x1UL << PWR_PUCRA_PA7_Pos)
#define PWR_PUCRA_PA7 PWR_PUCRA_PA7_Msk
#define PWR_PUCRA_PA6_Pos (6U)
#define PWR_PUCRA_PA6_Msk (0x1UL << PWR_PUCRA_PA6_Pos)
#define PWR_PUCRA_PA6 PWR_PUCRA_PA6_Msk
#define PWR_PUCRA_PA5_Pos (5U)
#define PWR_PUCRA_PA5_Msk (0x1UL << PWR_PUCRA_PA5_Pos)
#define PWR_PUCRA_PA5 PWR_PUCRA_PA5_Msk
#define PWR_PUCRA_PA4_Pos (4U)
#define PWR_PUCRA_PA4_Msk (0x1UL << PWR_PUCRA_PA4_Pos)
#define PWR_PUCRA_PA4 PWR_PUCRA_PA4_Msk
#define PWR_PUCRA_PA3_Pos (3U)
#define PWR_PUCRA_PA3_Msk (0x1UL << PWR_PUCRA_PA3_Pos)
#define PWR_PUCRA_PA3 PWR_PUCRA_PA3_Msk
#define PWR_PUCRA_PA2_Pos (2U)
#define PWR_PUCRA_PA2_Msk (0x1UL << PWR_PUCRA_PA2_Pos)
#define PWR_PUCRA_PA2 PWR_PUCRA_PA2_Msk
#define PWR_PUCRA_PA1_Pos (1U)
#define PWR_PUCRA_PA1_Msk (0x1UL << PWR_PUCRA_PA1_Pos)
#define PWR_PUCRA_PA1 PWR_PUCRA_PA1_Msk
#define PWR_PUCRA_PA0_Pos (0U)
#define PWR_PUCRA_PA0_Msk (0x1UL << PWR_PUCRA_PA0_Pos)
#define PWR_PUCRA_PA0 PWR_PUCRA_PA0_Msk

/********************  Bit definition for PWR_PDCRA register  ********************/
#define PWR_PDCRA_PA14_Pos (14U)
#define PWR_PDCRA_PA14_Msk (0x1UL << PWR_PDCRA_PA14_Pos)
#define PWR_PDCRA_PA14 PWR_PDCRA_PA14_Msk
#define PWR_PDCRA_PA12_Pos (12U)
#define PWR_PDCRA_PA12_Msk (0x1UL << PWR_PDCRA_PA12_Pos)
#define PWR_PDCRA_PA12 PWR_PDCRA_PA12_Msk
#define PWR_PDCRA_PA11_Pos (11U)
#define PWR_PDCRA_PA11_Msk (0x1UL << PWR_PDCRA_PA11_Pos)
#define PWR_PDCRA_PA11 PWR_PDCRA_PA11_Msk
#define PWR_PDCRA_PA10_Pos (10U)
#define PWR_PDCRA_PA10_Msk (0x1UL << PWR_PDCRA_PA10_Pos)
#define PWR_PDCRA_PA10 PWR_PDCRA_PA10_Msk
#define PWR_PDCRA_PA9_Pos (9U)
#define PWR_PDCRA_PA9_Msk (0x1UL << PWR_PDCRA_PA9_Pos)
#define PWR_PDCRA_PA9 PWR_PDCRA_PA9_Msk
#define PWR_PDCRA_PA8_Pos (8U)
#define PWR_PDCRA_PA8_Msk (0x1UL << PWR_PDCRA_PA8_Pos)
#define PWR_PDCRA_PA8 PWR_PDCRA_PA8_Msk
#define PWR_PDCRA_PA7_Pos (7U)
#define PWR_PDCRA_PA7_Msk (0x1UL << PWR_PDCRA_PA7_Pos)
#define PWR_PDCRA_PA7 PWR_PDCRA_PA7_Msk
#define PWR_PDCRA_PA6_Pos (6U)
#define PWR_PDCRA_PA6_Msk (0x1UL << PWR_PDCRA_PA6_Pos)
#define PWR_PDCRA_PA6 PWR_PDCRA_PA6_Msk
#define PWR_PDCRA_PA5_Pos (5U)
#define PWR_PDCRA_PA5_Msk (0x1UL << PWR_PDCRA_PA5_Pos)
#define PWR_PDCRA_PA5 PWR_PDCRA_PA5_Msk
#define PWR_PDCRA_PA4_Pos (4U)
#define PWR_PDCRA_PA4_Msk (0x1UL << PWR_PDCRA_PA4_Pos)
#define PWR_PDCRA_PA4 PWR_PDCRA_PA4_Msk
#define PWR_PDCRA_PA3_Pos (3U)
#define PWR_PDCRA_PA3_Msk (0x1UL << PWR_PDCRA_PA3_Pos)
#define PWR_PDCRA_PA3 PWR_PDCRA_PA3_Msk
#define PWR_PDCRA_PA2_Pos (2U)
#define PWR_PDCRA_PA2_Msk (0x1UL << PWR_PDCRA_PA2_Pos)
#define PWR_PDCRA_PA2 PWR_PDCRA_PA2_Msk
#define PWR_PDCRA_PA1_Pos (1U)
#define PWR_PDCRA_PA1_Msk (0x1UL << PWR_PDCRA_PA1_Pos)
#define PWR_PDCRA_PA1 PWR_PDCRA_PA1_Msk
#define PWR_PDCRA_PA0_Pos (0U)
#define PWR_PDCRA_PA0_Msk (0x1UL << PWR_PDCRA_PA0_Pos)
#define PWR_PDCRA_PA0 PWR_PDCRA_PA0_Msk

/********************  Bit definition for PWR_PUCRB register  ********************/

#define PWR_PUCRB_PB15_Pos (15U)
#define PWR_PUCRB_PB15_Msk (0x1UL << PWR_PUCRB_PB15_Pos)
#define PWR_PUCRB_PB15 PWR_PUCRB_PB15_Msk
#define PWR_PUCRB_PB14_Pos (14U)
#define PWR_PUCRB_PB14_Msk (0x1UL << PWR_PUCRB_PB14_Pos)
#define PWR_PUCRB_PB14 PWR_PUCRB_PB14_Msk
#define PWR_PUCRB_PB13_Pos (13U)
#define PWR_PUCRB_PB13_Msk (0x1UL << PWR_PUCRB_PB13_Pos)
#define PWR_PUCRB_PB13 PWR_PUCRB_PB13_Msk
#define PWR_PUCRB_PB12_Pos (12U)
#define PWR_PUCRB_PB12_Msk (0x1UL << PWR_PUCRB_PB12_Pos)
#define PWR_PUCRB_PB12 PWR_PUCRB_PB12_Msk
#define PWR_PUCRB_PB11_Pos (11U)
#define PWR_PUCRB_PB11_Msk (0x1UL << PWR_PUCRB_PB11_Pos)
#define PWR_PUCRB_PB11 PWR_PUCRB_PB11_Msk
#define PWR_PUCRB_PB10_Pos (10U)
#define PWR_PUCRB_PB10_Msk (0x1UL << PWR_PUCRB_PB10_Pos)
#define PWR_PUCRB_PB10 PWR_PUCRB_PB10_Msk
#define PWR_PUCRB_PB9_Pos (9U)
#define PWR_PUCRB_PB9_Msk (0x1UL << PWR_PUCRB_PB9_Pos)
#define PWR_PUCRB_PB9 PWR_PUCRB_PB9_Msk
#define PWR_PUCRB_PB8_Pos (8U)
#define PWR_PUCRB_PB8_Msk (0x1UL << PWR_PUCRB_PB8_Pos)
#define PWR_PUCRB_PB8 PWR_PUCRB_PB8_Msk
#define PWR_PUCRB_PB7_Pos (7U)
#define PWR_PUCRB_PB7_Msk (0x1UL << PWR_PUCRB_PB7_Pos)
#define PWR_PUCRB_PB7 PWR_PUCRB_PB7_Msk
#define PWR_PUCRB_PB6_Pos (6U)
#define PWR_PUCRB_PB6_Msk (0x1UL << PWR_PUCRB_PB6_Pos)
#define PWR_PUCRB_PB6 PWR_PUCRB_PB6_Msk
#define PWR_PUCRB_PB5_Pos (5U)
#define PWR_PUCRB_PB5_Msk (0x1UL << PWR_PUCRB_PB5_Pos)
#define PWR_PUCRB_PB5 PWR_PUCRB_PB5_Msk
#define PWR_PUCRB_PB4_Pos (4U)
#define PWR_PUCRB_PB4_Msk (0x1UL << PWR_PUCRB_PB4_Pos)
#define PWR_PUCRB_PB4 PWR_PUCRB_PB4_Msk
#define PWR_PUCRB_PB3_Pos (3U)
#define PWR_PUCRB_PB3_Msk (0x1UL << PWR_PUCRB_PB3_Pos)
#define PWR_PUCRB_PB3 PWR_PUCRB_PB3_Msk
#define PWR_PUCRB_PB2_Pos (2U)
#define PWR_PUCRB_PB2_Msk (0x1UL << PWR_PUCRB_PB2_Pos)
#define PWR_PUCRB_PB2 PWR_PUCRB_PB2_Msk
#define PWR_PUCRB_PB1_Pos (1U)
#define PWR_PUCRB_PB1_Msk (0x1UL << PWR_PUCRB_PB1_Pos)
#define PWR_PUCRB_PB1 PWR_PUCRB_PB1_Msk
#define PWR_PUCRB_PB0_Pos (0U)
#define PWR_PUCRB_PB0_Msk (0x1UL << PWR_PUCRB_PB0_Pos)
#define PWR_PUCRB_PB0 PWR_PUCRB_PB0_Msk

/********************  Bit definition for PWR_PDCRB register  ********************/
#define PWR_PDCRB_PB15_Pos (15U)
#define PWR_PDCRB_PB15_Msk (0x1UL << PWR_PDCRB_PB15_Pos)
#define PWR_PDCRB_PB15 PWR_PDCRB_PB15_Msk
#define PWR_PDCRB_PB14_Pos (14U)
#define PWR_PDCRB_PB14_Msk (0x1UL << PWR_PDCRB_PB14_Pos)
#define PWR_PDCRB_PB14 PWR_PDCRB_PB14_Msk
#define PWR_PDCRB_PB13_Pos (13U)
#define PWR_PDCRB_PB13_Msk (0x1UL << PWR_PDCRB_PB13_Pos)
#define PWR_PDCRB_PB13 PWR_PDCRB_PB13_Msk
#define PWR_PDCRB_PB12_Pos (12U)
#define PWR_PDCRB_PB12_Msk (0x1UL << PWR_PDCRB_PB12_Pos)
#define PWR_PDCRB_PB12 PWR_PDCRB_PB12_Msk
#define PWR_PDCRB_PB11_Pos (11U)
#define PWR_PDCRB_PB11_Msk (0x1UL << PWR_PDCRB_PB11_Pos)
#define PWR_PDCRB_PB11 PWR_PDCRB_PB11_Msk
#define PWR_PDCRB_PB10_Pos (10U)
#define PWR_PDCRB_PB10_Msk (0x1UL << PWR_PDCRB_PB10_Pos)
#define PWR_PDCRB_PB10 PWR_PDCRB_PB10_Msk
#define PWR_PDCRB_PB9_Pos (9U)
#define PWR_PDCRB_PB9_Msk (0x1UL << PWR_PDCRB_PB9_Pos)
#define PWR_PDCRB_PB9 PWR_PDCRB_PB9_Msk
#define PWR_PDCRB_PB8_Pos (8U)
#define PWR_PDCRB_PB8_Msk (0x1UL << PWR_PDCRB_PB8_Pos)
#define PWR_PDCRB_PB8 PWR_PDCRB_PB8_Msk
#define PWR_PDCRB_PB7_Pos (7U)
#define PWR_PDCRB_PB7_Msk (0x1UL << PWR_PDCRB_PB7_Pos)
#define PWR_PDCRB_PB7 PWR_PDCRB_PB7_Msk
#define PWR_PDCRB_PB6_Pos (6U)
#define PWR_PDCRB_PB6_Msk (0x1UL << PWR_PDCRB_PB6_Pos)
#define PWR_PDCRB_PB6 PWR_PDCRB_PB6_Msk
#define PWR_PDCRB_PB5_Pos (5U)
#define PWR_PDCRB_PB5_Msk (0x1UL << PWR_PDCRB_PB5_Pos)
#define PWR_PDCRB_PB5 PWR_PDCRB_PB5_Msk
#define PWR_PDCRB_PB3_Pos (3U)
#define PWR_PDCRB_PB3_Msk (0x1UL << PWR_PDCRB_PB3_Pos)
#define PWR_PDCRB_PB3 PWR_PDCRB_PB3_Msk
#define PWR_PDCRB_PB2_Pos (2U)
#define PWR_PDCRB_PB2_Msk (0x1UL << PWR_PDCRB_PB2_Pos)
#define PWR_PDCRB_PB2 PWR_PDCRB_PB2_Msk
#define PWR_PDCRB_PB1_Pos (1U)
#define PWR_PDCRB_PB1_Msk (0x1UL << PWR_PDCRB_PB1_Pos)
#define PWR_PDCRB_PB1 PWR_PDCRB_PB1_Msk
#define PWR_PDCRB_PB0_Pos (0U)
#define PWR_PDCRB_PB0_Msk (0x1UL << PWR_PDCRB_PB0_Pos)
#define PWR_PDCRB_PB0 PWR_PDCRB_PB0_Msk

/********************  Bit definition for PWR_PUCRC register  ********************/
#define PWR_PUCRC_PC15_Pos (15U)
#define PWR_PUCRC_PC15_Msk (0x1UL << PWR_PUCRC_PC15_Pos)
#define PWR_PUCRC_PC15 PWR_PUCRC_PC15_Msk
#define PWR_PUCRC_PC14_Pos (14U)
#define PWR_PUCRC_PC14_Msk (0x1UL << PWR_PUCRC_PC14_Pos)
#define PWR_PUCRC_PC14 PWR_PUCRC_PC14_Msk
#define PWR_PUCRC_PC13_Pos (13U)
#define PWR_PUCRC_PC13_Msk (0x1UL << PWR_PUCRC_PC13_Pos)
#define PWR_PUCRC_PC13 PWR_PUCRC_PC13_Msk
#define PWR_PUCRC_PC12_Pos (12U)
#define PWR_PUCRC_PC12_Msk (0x1UL << PWR_PUCRC_PC12_Pos)
#define PWR_PUCRC_PC12 PWR_PUCRC_PC12_Msk
#define PWR_PUCRC_PC11_Pos (11U)
#define PWR_PUCRC_PC11_Msk (0x1UL << PWR_PUCRC_PC11_Pos)
#define PWR_PUCRC_PC11 PWR_PUCRC_PC11_Msk
#define PWR_PUCRC_PC10_Pos (10U)
#define PWR_PUCRC_PC10_Msk (0x1UL << PWR_PUCRC_PC10_Pos)
#define PWR_PUCRC_PC10 PWR_PUCRC_PC10_Msk
#define PWR_PUCRC_PC9_Pos (9U)
#define PWR_PUCRC_PC9_Msk (0x1UL << PWR_PUCRC_PC9_Pos)
#define PWR_PUCRC_PC9 PWR_PUCRC_PC9_Msk
#define PWR_PUCRC_PC8_Pos (8U)
#define PWR_PUCRC_PC8_Msk (0x1UL << PWR_PUCRC_PC8_Pos)
#define PWR_PUCRC_PC8 PWR_PUCRC_PC8_Msk
#define PWR_PUCRC_PC7_Pos (7U)
#define PWR_PUCRC_PC7_Msk (0x1UL << PWR_PUCRC_PC7_Pos)
#define PWR_PUCRC_PC7 PWR_PUCRC_PC7_Msk
#define PWR_PUCRC_PC6_Pos (6U)
#define PWR_PUCRC_PC6_Msk (0x1UL << PWR_PUCRC_PC6_Pos)
#define PWR_PUCRC_PC6 PWR_PUCRC_PC6_Msk
#define PWR_PUCRC_PC5_Pos (5U)
#define PWR_PUCRC_PC5_Msk (0x1UL << PWR_PUCRC_PC5_Pos)
#define PWR_PUCRC_PC5 PWR_PUCRC_PC5_Msk
#define PWR_PUCRC_PC4_Pos (4U)
#define PWR_PUCRC_PC4_Msk (0x1UL << PWR_PUCRC_PC4_Pos)
#define PWR_PUCRC_PC4 PWR_PUCRC_PC4_Msk
#define PWR_PUCRC_PC3_Pos (3U)
#define PWR_PUCRC_PC3_Msk (0x1UL << PWR_PUCRC_PC3_Pos)
#define PWR_PUCRC_PC3 PWR_PUCRC_PC3_Msk
#define PWR_PUCRC_PC2_Pos (2U)
#define PWR_PUCRC_PC2_Msk (0x1UL << PWR_PUCRC_PC2_Pos)
#define PWR_PUCRC_PC2 PWR_PUCRC_PC2_Msk
#define PWR_PUCRC_PC1_Pos (1U)
#define PWR_PUCRC_PC1_Msk (0x1UL << PWR_PUCRC_PC1_Pos)
#define PWR_PUCRC_PC1 PWR_PUCRC_PC1_Msk
#define PWR_PUCRC_PC0_Pos (0U)
#define PWR_PUCRC_PC0_Msk (0x1UL << PWR_PUCRC_PC0_Pos)
#define PWR_PUCRC_PC0 PWR_PUCRC_PC0_Msk

/********************  Bit definition for PWR_PDCRC register  ********************/
#define PWR_PDCRC_PC15_Pos (15U)
#define PWR_PDCRC_PC15_Msk (0x1UL << PWR_PDCRC_PC15_Pos)
#define PWR_PDCRC_PC15 PWR_PDCRC_PC15_Msk
#define PWR_PDCRC_PC14_Pos (14U)
#define PWR_PDCRC_PC14_Msk (0x1UL << PWR_PDCRC_PC14_Pos)
#define PWR_PDCRC_PC14 PWR_PDCRC_PC14_Msk
#define PWR_PDCRC_PC13_Pos (13U)
#define PWR_PDCRC_PC13_Msk (0x1UL << PWR_PDCRC_PC13_Pos)
#define PWR_PDCRC_PC13 PWR_PDCRC_PC13_Msk
#define PWR_PDCRC_PC12_Pos (12U)
#define PWR_PDCRC_PC12_Msk (0x1UL << PWR_PDCRC_PC12_Pos)
#define PWR_PDCRC_PC12 PWR_PDCRC_PC12_Msk
#define PWR_PDCRC_PC11_Pos (11U)
#define PWR_PDCRC_PC11_Msk (0x1UL << PWR_PDCRC_PC11_Pos)
#define PWR_PDCRC_PC11 PWR_PDCRC_PC11_Msk
#define PWR_PDCRC_PC10_Pos (10U)
#define PWR_PDCRC_PC10_Msk (0x1UL << PWR_PDCRC_PC10_Pos)
#define PWR_PDCRC_PC10 PWR_PDCRC_PC10_Msk
#define PWR_PDCRC_PC9_Pos (9U)
#define PWR_PDCRC_PC9_Msk (0x1UL << PWR_PDCRC_PC9_Pos)
#define PWR_PDCRC_PC9 PWR_PDCRC_PC9_Msk
#define PWR_PDCRC_PC8_Pos (8U)
#define PWR_PDCRC_PC8_Msk (0x1UL << PWR_PDCRC_PC8_Pos)
#define PWR_PDCRC_PC8 PWR_PDCRC_PC8_Msk
#define PWR_PDCRC_PC7_Pos (7U)
#define PWR_PDCRC_PC7_Msk (0x1UL << PWR_PDCRC_PC7_Pos)
#define PWR_PDCRC_PC7 PWR_PDCRC_PC7_Msk
#define PWR_PDCRC_PC6_Pos (6U)
#define PWR_PDCRC_PC6_Msk (0x1UL << PWR_PDCRC_PC6_Pos)
#define PWR_PDCRC_PC6 PWR_PDCRC_PC6_Msk
#define PWR_PDCRC_PC5_Pos (5U)
#define PWR_PDCRC_PC5_Msk (0x1UL << PWR_PDCRC_PC5_Pos)
#define PWR_PDCRC_PC5 PWR_PDCRC_PC5_Msk
#define PWR_PDCRC_PC4_Pos (4U)
#define PWR_PDCRC_PC4_Msk (0x1UL << PWR_PDCRC_PC4_Pos)
#define PWR_PDCRC_PC4 PWR_PDCRC_PC4_Msk
#define PWR_PDCRC_PC3_Pos (3U)
#define PWR_PDCRC_PC3_Msk (0x1UL << PWR_PDCRC_PC3_Pos)
#define PWR_PDCRC_PC3 PWR_PDCRC_PC3_Msk
#define PWR_PDCRC_PC2_Pos (2U)
#define PWR_PDCRC_PC2_Msk (0x1UL << PWR_PDCRC_PC2_Pos)
#define PWR_PDCRC_PC2 PWR_PDCRC_PC2_Msk
#define PWR_PDCRC_PC1_Pos (1U)
#define PWR_PDCRC_PC1_Msk (0x1UL << PWR_PDCRC_PC1_Pos)
#define PWR_PDCRC_PC1 PWR_PDCRC_PC1_Msk
#define PWR_PDCRC_PC0_Pos (0U)
#define PWR_PDCRC_PC0_Msk (0x1UL << PWR_PDCRC_PC0_Pos)
#define PWR_PDCRC_PC0 PWR_PDCRC_PC0_Msk

/********************  Bit definition for PWR_PUCRD register  ********************/
#define PWR_PUCRD_PD15_Pos (15U)
#define PWR_PUCRD_PD15_Msk (0x1UL << PWR_PUCRD_PD15_Pos)
#define PWR_PUCRD_PD15 PWR_PUCRD_PD15_Msk
#define PWR_PUCRD_PD14_Pos (14U)
#define PWR_PUCRD_PD14_Msk (0x1UL << PWR_PUCRD_PD14_Pos)
#define PWR_PUCRD_PD14 PWR_PUCRD_PD14_Msk
#define PWR_PUCRD_PD13_Pos (13U)
#define PWR_PUCRD_PD13_Msk (0x1UL << PWR_PUCRD_PD13_Pos)
#define PWR_PUCRD_PD13 PWR_PUCRD_PD13_Msk
#define PWR_PUCRD_PD12_Pos (12U)
#define PWR_PUCRD_PD12_Msk (0x1UL << PWR_PUCRD_PD12_Pos)
#define PWR_PUCRD_PD12 PWR_PUCRD_PD12_Msk
#define PWR_PUCRD_PD11_Pos (11U)
#define PWR_PUCRD_PD11_Msk (0x1UL << PWR_PUCRD_PD11_Pos)
#define PWR_PUCRD_PD11 PWR_PUCRD_PD11_Msk
#define PWR_PUCRD_PD10_Pos (10U)
#define PWR_PUCRD_PD10_Msk (0x1UL << PWR_PUCRD_PD10_Pos)
#define PWR_PUCRD_PD10 PWR_PUCRD_PD10_Msk
#define PWR_PUCRD_PD9_Pos (9U)
#define PWR_PUCRD_PD9_Msk (0x1UL << PWR_PUCRD_PD9_Pos)
#define PWR_PUCRD_PD9 PWR_PUCRD_PD9_Msk
#define PWR_PUCRD_PD8_Pos (8U)
#define PWR_PUCRD_PD8_Msk (0x1UL << PWR_PUCRD_PD8_Pos)
#define PWR_PUCRD_PD8 PWR_PUCRD_PD8_Msk
#define PWR_PUCRD_PD7_Pos (7U)
#define PWR_PUCRD_PD7_Msk (0x1UL << PWR_PUCRD_PD7_Pos)
#define PWR_PUCRD_PD7 PWR_PUCRD_PD7_Msk
#define PWR_PUCRD_PD6_Pos (6U)
#define PWR_PUCRD_PD6_Msk (0x1UL << PWR_PUCRD_PD6_Pos)
#define PWR_PUCRD_PD6 PWR_PUCRD_PD6_Msk
#define PWR_PUCRD_PD5_Pos (5U)
#define PWR_PUCRD_PD5_Msk (0x1UL << PWR_PUCRD_PD5_Pos)
#define PWR_PUCRD_PD5 PWR_PUCRD_PD5_Msk
#define PWR_PUCRD_PD4_Pos (4U)
#define PWR_PUCRD_PD4_Msk (0x1UL << PWR_PUCRD_PD4_Pos)
#define PWR_PUCRD_PD4 PWR_PUCRD_PD4_Msk
#define PWR_PUCRD_PD3_Pos (3U)
#define PWR_PUCRD_PD3_Msk (0x1UL << PWR_PUCRD_PD3_Pos)
#define PWR_PUCRD_PD3 PWR_PUCRD_PD3_Msk
#define PWR_PUCRD_PD2_Pos (2U)
#define PWR_PUCRD_PD2_Msk (0x1UL << PWR_PUCRD_PD2_Pos)
#define PWR_PUCRD_PD2 PWR_PUCRD_PD2_Msk
#define PWR_PUCRD_PD1_Pos (1U)
#define PWR_PUCRD_PD1_Msk (0x1UL << PWR_PUCRD_PD1_Pos)
#define PWR_PUCRD_PD1 PWR_PUCRD_PD1_Msk
#define PWR_PUCRD_PD0_Pos (0U)
#define PWR_PUCRD_PD0_Msk (0x1UL << PWR_PUCRD_PD0_Pos)
#define PWR_PUCRD_PD0 PWR_PUCRD_PD0_Msk

/********************  Bit definition for PWR_PDCRD register  ********************/
#define PWR_PDCRD_PD15_Pos (15U)
#define PWR_PDCRD_PD15_Msk (0x1UL << PWR_PDCRD_PD15_Pos)
#define PWR_PDCRD_PD15 PWR_PDCRD_PD15_Msk
#define PWR_PDCRD_PD14_Pos (14U)
#define PWR_PDCRD_PD14_Msk (0x1UL << PWR_PDCRD_PD14_Pos)
#define PWR_PDCRD_PD14 PWR_PDCRD_PD14_Msk
#define PWR_PDCRD_PD13_Pos (13U)
#define PWR_PDCRD_PD13_Msk (0x1UL << PWR_PDCRD_PD13_Pos)
#define PWR_PDCRD_PD13 PWR_PDCRD_PD13_Msk
#define PWR_PDCRD_PD12_Pos (12U)
#define PWR_PDCRD_PD12_Msk (0x1UL << PWR_PDCRD_PD12_Pos)
#define PWR_PDCRD_PD12 PWR_PDCRD_PD12_Msk
#define PWR_PDCRD_PD11_Pos (11U)
#define PWR_PDCRD_PD11_Msk (0x1UL << PWR_PDCRD_PD11_Pos)
#define PWR_PDCRD_PD11 PWR_PDCRD_PD11_Msk
#define PWR_PDCRD_PD10_Pos (10U)
#define PWR_PDCRD_PD10_Msk (0x1UL << PWR_PDCRD_PD10_Pos)
#define PWR_PDCRD_PD10 PWR_PDCRD_PD10_Msk
#define PWR_PDCRD_PD9_Pos (9U)
#define PWR_PDCRD_PD9_Msk (0x1UL << PWR_PDCRD_PD9_Pos)
#define PWR_PDCRD_PD9 PWR_PDCRD_PD9_Msk
#define PWR_PDCRD_PD8_Pos (8U)
#define PWR_PDCRD_PD8_Msk (0x1UL << PWR_PDCRD_PD8_Pos)
#define PWR_PDCRD_PD8 PWR_PDCRD_PD8_Msk
#define PWR_PDCRD_PD7_Pos (7U)
#define PWR_PDCRD_PD7_Msk (0x1UL << PWR_PDCRD_PD7_Pos)
#define PWR_PDCRD_PD7 PWR_PDCRD_PD7_Msk
#define PWR_PDCRD_PD6_Pos (6U)
#define PWR_PDCRD_PD6_Msk (0x1UL << PWR_PDCRD_PD6_Pos)
#define PWR_PDCRD_PD6 PWR_PDCRD_PD6_Msk
#define PWR_PDCRD_PD5_Pos (5U)
#define PWR_PDCRD_PD5_Msk (0x1UL << PWR_PDCRD_PD5_Pos)
#define PWR_PDCRD_PD5 PWR_PDCRD_PD5_Msk
#define PWR_PDCRD_PD4_Pos (4U)
#define PWR_PDCRD_PD4_Msk (0x1UL << PWR_PDCRD_PD4_Pos)
#define PWR_PDCRD_PD4 PWR_PDCRD_PD4_Msk
#define PWR_PDCRD_PD3_Pos (3U)
#define PWR_PDCRD_PD3_Msk (0x1UL << PWR_PDCRD_PD3_Pos)
#define PWR_PDCRD_PD3 PWR_PDCRD_PD3_Msk
#define PWR_PDCRD_PD2_Pos (2U)
#define PWR_PDCRD_PD2_Msk (0x1UL << PWR_PDCRD_PD2_Pos)
#define PWR_PDCRD_PD2 PWR_PDCRD_PD2_Msk
#define PWR_PDCRD_PD1_Pos (1U)
#define PWR_PDCRD_PD1_Msk (0x1UL << PWR_PDCRD_PD1_Pos)
#define PWR_PDCRD_PD1 PWR_PDCRD_PD1_Msk
#define PWR_PDCRD_PD0_Pos (0U)
#define PWR_PDCRD_PD0_Msk (0x1UL << PWR_PDCRD_PD0_Pos)
#define PWR_PDCRD_PD0 PWR_PDCRD_PD0_Msk

/********************  Bit definition for PWR_PUCRE register  ********************/
#define PWR_PUCRE_PE15_Pos (15U)
#define PWR_PUCRE_PE15_Msk (0x1UL << PWR_PUCRE_PE15_Pos)
#define PWR_PUCRE_PE15 PWR_PUCRE_PE15_Msk
#define PWR_PUCRE_PE14_Pos (14U)
#define PWR_PUCRE_PE14_Msk (0x1UL << PWR_PUCRE_PE14_Pos)
#define PWR_PUCRE_PE14 PWR_PUCRE_PE14_Msk
#define PWR_PUCRE_PE13_Pos (13U)
#define PWR_PUCRE_PE13_Msk (0x1UL << PWR_PUCRE_PE13_Pos)
#define PWR_PUCRE_PE13 PWR_PUCRE_PE13_Msk
#define PWR_PUCRE_PE12_Pos (12U)
#define PWR_PUCRE_PE12_Msk (0x1UL << PWR_PUCRE_PE12_Pos)
#define PWR_PUCRE_PE12 PWR_PUCRE_PE12_Msk
#define PWR_PUCRE_PE11_Pos (11U)
#define PWR_PUCRE_PE11_Msk (0x1UL << PWR_PUCRE_PE11_Pos)
#define PWR_PUCRE_PE11 PWR_PUCRE_PE11_Msk
#define PWR_PUCRE_PE10_Pos (10U)
#define PWR_PUCRE_PE10_Msk (0x1UL << PWR_PUCRE_PE10_Pos)
#define PWR_PUCRE_PE10 PWR_PUCRE_PE10_Msk
#define PWR_PUCRE_PE9_Pos (9U)
#define PWR_PUCRE_PE9_Msk (0x1UL << PWR_PUCRE_PE9_Pos)
#define PWR_PUCRE_PE9 PWR_PUCRE_PE9_Msk
#define PWR_PUCRE_PE8_Pos (8U)
#define PWR_PUCRE_PE8_Msk (0x1UL << PWR_PUCRE_PE8_Pos)
#define PWR_PUCRE_PE8 PWR_PUCRE_PE8_Msk
#define PWR_PUCRE_PE7_Pos (7U)
#define PWR_PUCRE_PE7_Msk (0x1UL << PWR_PUCRE_PE7_Pos)
#define PWR_PUCRE_PE7 PWR_PUCRE_PE7_Msk
#define PWR_PUCRE_PE6_Pos (6U)
#define PWR_PUCRE_PE6_Msk (0x1UL << PWR_PUCRE_PE6_Pos)
#define PWR_PUCRE_PE6 PWR_PUCRE_PE6_Msk
#define PWR_PUCRE_PE5_Pos (5U)
#define PWR_PUCRE_PE5_Msk (0x1UL << PWR_PUCRE_PE5_Pos)
#define PWR_PUCRE_PE5 PWR_PUCRE_PE5_Msk
#define PWR_PUCRE_PE4_Pos (4U)
#define PWR_PUCRE_PE4_Msk (0x1UL << PWR_PUCRE_PE4_Pos)
#define PWR_PUCRE_PE4 PWR_PUCRE_PE4_Msk
#define PWR_PUCRE_PE3_Pos (3U)
#define PWR_PUCRE_PE3_Msk (0x1UL << PWR_PUCRE_PE3_Pos)
#define PWR_PUCRE_PE3 PWR_PUCRE_PE3_Msk
#define PWR_PUCRE_PE2_Pos (2U)
#define PWR_PUCRE_PE2_Msk (0x1UL << PWR_PUCRE_PE2_Pos)
#define PWR_PUCRE_PE2 PWR_PUCRE_PE2_Msk
#define PWR_PUCRE_PE1_Pos (1U)
#define PWR_PUCRE_PE1_Msk (0x1UL << PWR_PUCRE_PE1_Pos)
#define PWR_PUCRE_PE1 PWR_PUCRE_PE1_Msk
#define PWR_PUCRE_PE0_Pos (0U)
#define PWR_PUCRE_PE0_Msk (0x1UL << PWR_PUCRE_PE0_Pos)
#define PWR_PUCRE_PE0 PWR_PUCRE_PE0_Msk

/********************  Bit definition for PWR_PDCRE register  ********************/
#define PWR_PDCRE_PE15_Pos (15U)
#define PWR_PDCRE_PE15_Msk (0x1UL << PWR_PDCRE_PE15_Pos)
#define PWR_PDCRE_PE15 PWR_PDCRE_PE15_Msk
#define PWR_PDCRE_PE14_Pos (14U)
#define PWR_PDCRE_PE14_Msk (0x1UL << PWR_PDCRE_PE14_Pos)
#define PWR_PDCRE_PE14 PWR_PDCRE_PE14_Msk
#define PWR_PDCRE_PE13_Pos (13U)
#define PWR_PDCRE_PE13_Msk (0x1UL << PWR_PDCRE_PE13_Pos)
#define PWR_PDCRE_PE13 PWR_PDCRE_PE13_Msk
#define PWR_PDCRE_PE12_Pos (12U)
#define PWR_PDCRE_PE12_Msk (0x1UL << PWR_PDCRE_PE12_Pos)
#define PWR_PDCRE_PE12 PWR_PDCRE_PE12_Msk
#define PWR_PDCRE_PE11_Pos (11U)
#define PWR_PDCRE_PE11_Msk (0x1UL << PWR_PDCRE_PE11_Pos)
#define PWR_PDCRE_PE11 PWR_PDCRE_PE11_Msk
#define PWR_PDCRE_PE10_Pos (10U)
#define PWR_PDCRE_PE10_Msk (0x1UL << PWR_PDCRE_PE10_Pos)
#define PWR_PDCRE_PE10 PWR_PDCRE_PE10_Msk
#define PWR_PDCRE_PE9_Pos (9U)
#define PWR_PDCRE_PE9_Msk (0x1UL << PWR_PDCRE_PE9_Pos)
#define PWR_PDCRE_PE9 PWR_PDCRE_PE9_Msk
#define PWR_PDCRE_PE8_Pos (8U)
#define PWR_PDCRE_PE8_Msk (0x1UL << PWR_PDCRE_PE8_Pos)
#define PWR_PDCRE_PE8 PWR_PDCRE_PE8_Msk
#define PWR_PDCRE_PE7_Pos (7U)
#define PWR_PDCRE_PE7_Msk (0x1UL << PWR_PDCRE_PE7_Pos)
#define PWR_PDCRE_PE7 PWR_PDCRE_PE7_Msk
#define PWR_PDCRE_PE6_Pos (6U)
#define PWR_PDCRE_PE6_Msk (0x1UL << PWR_PDCRE_PE6_Pos)
#define PWR_PDCRE_PE6 PWR_PDCRE_PE6_Msk
#define PWR_PDCRE_PE5_Pos (5U)
#define PWR_PDCRE_PE5_Msk (0x1UL << PWR_PDCRE_PE5_Pos)
#define PWR_PDCRE_PE5 PWR_PDCRE_PE5_Msk
#define PWR_PDCRE_PE4_Pos (4U)
#define PWR_PDCRE_PE4_Msk (0x1UL << PWR_PDCRE_PE4_Pos)
#define PWR_PDCRE_PE4 PWR_PDCRE_PE4_Msk
#define PWR_PDCRE_PE3_Pos (3U)
#define PWR_PDCRE_PE3_Msk (0x1UL << PWR_PDCRE_PE3_Pos)
#define PWR_PDCRE_PE3 PWR_PDCRE_PE3_Msk
#define PWR_PDCRE_PE2_Pos (2U)
#define PWR_PDCRE_PE2_Msk (0x1UL << PWR_PDCRE_PE2_Pos)
#define PWR_PDCRE_PE2 PWR_PDCRE_PE2_Msk
#define PWR_PDCRE_PE1_Pos (1U)
#define PWR_PDCRE_PE1_Msk (0x1UL << PWR_PDCRE_PE1_Pos)
#define PWR_PDCRE_PE1 PWR_PDCRE_PE1_Msk
#define PWR_PDCRE_PE0_Pos (0U)
#define PWR_PDCRE_PE0_Msk (0x1UL << PWR_PDCRE_PE0_Pos)
#define PWR_PDCRE_PE0 PWR_PDCRE_PE0_Msk

/********************  Bit definition for PWR_PUCRF register  ********************/
#define PWR_PUCRF_PF15_Pos (15U)
#define PWR_PUCRF_PF15_Msk (0x1UL << PWR_PUCRF_PF15_Pos)
#define PWR_PUCRF_PF15 PWR_PUCRF_PF15_Msk
#define PWR_PUCRF_PF14_Pos (14U)
#define PWR_PUCRF_PF14_Msk (0x1UL << PWR_PUCRF_PF14_Pos)
#define PWR_PUCRF_PF14 PWR_PUCRF_PF14_Msk
#define PWR_PUCRF_PF13_Pos (13U)
#define PWR_PUCRF_PF13_Msk (0x1UL << PWR_PUCRF_PF13_Pos)
#define PWR_PUCRF_PF13 PWR_PUCRF_PF13_Msk
#define PWR_PUCRF_PF12_Pos (12U)
#define PWR_PUCRF_PF12_Msk (0x1UL << PWR_PUCRF_PF12_Pos)
#define PWR_PUCRF_PF12 PWR_PUCRF_PF12_Msk
#define PWR_PUCRF_PF11_Pos (11U)
#define PWR_PUCRF_PF11_Msk (0x1UL << PWR_PUCRF_PF11_Pos)
#define PWR_PUCRF_PF11 PWR_PUCRF_PF11_Msk
#define PWR_PUCRF_PF10_Pos (10U)
#define PWR_PUCRF_PF10_Msk (0x1UL << PWR_PUCRF_PF10_Pos)
#define PWR_PUCRF_PF10 PWR_PUCRF_PF10_Msk
#define PWR_PUCRF_PF9_Pos (9U)
#define PWR_PUCRF_PF9_Msk (0x1UL << PWR_PUCRF_PF9_Pos)
#define PWR_PUCRF_PF9 PWR_PUCRF_PF9_Msk
#define PWR_PUCRF_PF8_Pos (8U)
#define PWR_PUCRF_PF8_Msk (0x1UL << PWR_PUCRF_PF8_Pos)
#define PWR_PUCRF_PF8 PWR_PUCRF_PF8_Msk
#define PWR_PUCRF_PF7_Pos (7U)
#define PWR_PUCRF_PF7_Msk (0x1UL << PWR_PUCRF_PF7_Pos)
#define PWR_PUCRF_PF7 PWR_PUCRF_PF7_Msk
#define PWR_PUCRF_PF6_Pos (6U)
#define PWR_PUCRF_PF6_Msk (0x1UL << PWR_PUCRF_PF6_Pos)
#define PWR_PUCRF_PF6 PWR_PUCRF_PF6_Msk
#define PWR_PUCRF_PF5_Pos (5U)
#define PWR_PUCRF_PF5_Msk (0x1UL << PWR_PUCRF_PF5_Pos)
#define PWR_PUCRF_PF5 PWR_PUCRF_PF5_Msk
#define PWR_PUCRF_PF4_Pos (4U)
#define PWR_PUCRF_PF4_Msk (0x1UL << PWR_PUCRF_PF4_Pos)
#define PWR_PUCRF_PF4 PWR_PUCRF_PF4_Msk
#define PWR_PUCRF_PF3_Pos (3U)
#define PWR_PUCRF_PF3_Msk (0x1UL << PWR_PUCRF_PF3_Pos)
#define PWR_PUCRF_PF3 PWR_PUCRF_PF3_Msk
#define PWR_PUCRF_PF2_Pos (2U)
#define PWR_PUCRF_PF2_Msk (0x1UL << PWR_PUCRF_PF2_Pos)
#define PWR_PUCRF_PF2 PWR_PUCRF_PF2_Msk
#define PWR_PUCRF_PF1_Pos (1U)
#define PWR_PUCRF_PF1_Msk (0x1UL << PWR_PUCRF_PF1_Pos)
#define PWR_PUCRF_PF1 PWR_PUCRF_PF1_Msk
#define PWR_PUCRF_PF0_Pos (0U)
#define PWR_PUCRF_PF0_Msk (0x1UL << PWR_PUCRF_PF0_Pos)
#define PWR_PUCRF_PF0 PWR_PUCRF_PF0_Msk

/********************  Bit definition for PWR_PDCRF register  ********************/
#define PWR_PDCRF_PF15_Pos (15U)
#define PWR_PDCRF_PF15_Msk (0x1UL << PWR_PDCRF_PF15_Pos)
#define PWR_PDCRF_PF15 PWR_PDCRF_PF15_Msk
#define PWR_PDCRF_PF14_Pos (14U)
#define PWR_PDCRF_PF14_Msk (0x1UL << PWR_PDCRF_PF14_Pos)
#define PWR_PDCRF_PF14 PWR_PDCRF_PF14_Msk
#define PWR_PDCRF_PF13_Pos (13U)
#define PWR_PDCRF_PF13_Msk (0x1UL << PWR_PDCRF_PF13_Pos)
#define PWR_PDCRF_PF13 PWR_PDCRF_PF13_Msk
#define PWR_PDCRF_PF12_Pos (12U)
#define PWR_PDCRF_PF12_Msk (0x1UL << PWR_PDCRF_PF12_Pos)
#define PWR_PDCRF_PF12 PWR_PDCRF_PF12_Msk
#define PWR_PDCRF_PF11_Pos (11U)
#define PWR_PDCRF_PF11_Msk (0x1UL << PWR_PDCRF_PF11_Pos)
#define PWR_PDCRF_PF11 PWR_PDCRF_PF11_Msk
#define PWR_PDCRF_PF10_Pos (10U)
#define PWR_PDCRF_PF10_Msk (0x1UL << PWR_PDCRF_PF10_Pos)
#define PWR_PDCRF_PF10 PWR_PDCRF_PF10_Msk
#define PWR_PDCRF_PF9_Pos (9U)
#define PWR_PDCRF_PF9_Msk (0x1UL << PWR_PDCRF_PF9_Pos)
#define PWR_PDCRF_PF9 PWR_PDCRF_PF9_Msk
#define PWR_PDCRF_PF8_Pos (8U)
#define PWR_PDCRF_PF8_Msk (0x1UL << PWR_PDCRF_PF8_Pos)
#define PWR_PDCRF_PF8 PWR_PDCRF_PF8_Msk
#define PWR_PDCRF_PF7_Pos (7U)
#define PWR_PDCRF_PF7_Msk (0x1UL << PWR_PDCRF_PF7_Pos)
#define PWR_PDCRF_PF7 PWR_PDCRF_PF7_Msk
#define PWR_PDCRF_PF6_Pos (6U)
#define PWR_PDCRF_PF6_Msk (0x1UL << PWR_PDCRF_PF6_Pos)
#define PWR_PDCRF_PF6 PWR_PDCRF_PF6_Msk
#define PWR_PDCRF_PF5_Pos (5U)
#define PWR_PDCRF_PF5_Msk (0x1UL << PWR_PDCRF_PF5_Pos)
#define PWR_PDCRF_PF5 PWR_PDCRF_PF5_Msk
#define PWR_PDCRF_PF4_Pos (4U)
#define PWR_PDCRF_PF4_Msk (0x1UL << PWR_PDCRF_PF4_Pos)
#define PWR_PDCRF_PF4 PWR_PDCRF_PF4_Msk
#define PWR_PDCRF_PF3_Pos (3U)
#define PWR_PDCRF_PF3_Msk (0x1UL << PWR_PDCRF_PF3_Pos)
#define PWR_PDCRF_PF3 PWR_PDCRF_PF3_Msk
#define PWR_PDCRF_PF2_Pos (2U)
#define PWR_PDCRF_PF2_Msk (0x1UL << PWR_PDCRF_PF2_Pos)
#define PWR_PDCRF_PF2 PWR_PDCRF_PF2_Msk
#define PWR_PDCRF_PF1_Pos (1U)
#define PWR_PDCRF_PF1_Msk (0x1UL << PWR_PDCRF_PF1_Pos)
#define PWR_PDCRF_PF1 PWR_PDCRF_PF1_Msk
#define PWR_PDCRF_PF0_Pos (0U)
#define PWR_PDCRF_PF0_Msk (0x1UL << PWR_PDCRF_PF0_Pos)
#define PWR_PDCRF_PF0 PWR_PDCRF_PF0_Msk

/********************  Bit definition for PWR_PUCRG register  ********************/
#define PWR_PUCRG_PG15_Pos (15U)
#define PWR_PUCRG_PG15_Msk (0x1UL << PWR_PUCRG_PG15_Pos)
#define PWR_PUCRG_PG15 PWR_PUCRG_PG15_Msk
#define PWR_PUCRG_PG14_Pos (14U)
#define PWR_PUCRG_PG14_Msk (0x1UL << PWR_PUCRG_PG14_Pos)
#define PWR_PUCRG_PG14 PWR_PUCRG_PG14_Msk
#define PWR_PUCRG_PG13_Pos (13U)
#define PWR_PUCRG_PG13_Msk (0x1UL << PWR_PUCRG_PG13_Pos)
#define PWR_PUCRG_PG13 PWR_PUCRG_PG13_Msk
#define PWR_PUCRG_PG12_Pos (12U)
#define PWR_PUCRG_PG12_Msk (0x1UL << PWR_PUCRG_PG12_Pos)
#define PWR_PUCRG_PG12 PWR_PUCRG_PG12_Msk
#define PWR_PUCRG_PG11_Pos (11U)
#define PWR_PUCRG_PG11_Msk (0x1UL << PWR_PUCRG_PG11_Pos)
#define PWR_PUCRG_PG11 PWR_PUCRG_PG11_Msk
#define PWR_PUCRG_PG10_Pos (10U)
#define PWR_PUCRG_PG10_Msk (0x1UL << PWR_PUCRG_PG10_Pos)
#define PWR_PUCRG_PG10 PWR_PUCRG_PG10_Msk
#define PWR_PUCRG_PG9_Pos (9U)
#define PWR_PUCRG_PG9_Msk (0x1UL << PWR_PUCRG_PG9_Pos)
#define PWR_PUCRG_PG9 PWR_PUCRG_PG9_Msk
#define PWR_PUCRG_PG8_Pos (8U)
#define PWR_PUCRG_PG8_Msk (0x1UL << PWR_PUCRG_PG8_Pos)
#define PWR_PUCRG_PG8 PWR_PUCRG_PG8_Msk
#define PWR_PUCRG_PG7_Pos (7U)
#define PWR_PUCRG_PG7_Msk (0x1UL << PWR_PUCRG_PG7_Pos)
#define PWR_PUCRG_PG7 PWR_PUCRG_PG7_Msk
#define PWR_PUCRG_PG6_Pos (6U)
#define PWR_PUCRG_PG6_Msk (0x1UL << PWR_PUCRG_PG6_Pos)
#define PWR_PUCRG_PG6 PWR_PUCRG_PG6_Msk
#define PWR_PUCRG_PG5_Pos (5U)
#define PWR_PUCRG_PG5_Msk (0x1UL << PWR_PUCRG_PG5_Pos)
#define PWR_PUCRG_PG5 PWR_PUCRG_PG5_Msk
#define PWR_PUCRG_PG4_Pos (4U)
#define PWR_PUCRG_PG4_Msk (0x1UL << PWR_PUCRG_PG4_Pos)
#define PWR_PUCRG_PG4 PWR_PUCRG_PG4_Msk
#define PWR_PUCRG_PG3_Pos (3U)
#define PWR_PUCRG_PG3_Msk (0x1UL << PWR_PUCRG_PG3_Pos)
#define PWR_PUCRG_PG3 PWR_PUCRG_PG3_Msk
#define PWR_PUCRG_PG2_Pos (2U)
#define PWR_PUCRG_PG2_Msk (0x1UL << PWR_PUCRG_PG2_Pos)
#define PWR_PUCRG_PG2 PWR_PUCRG_PG2_Msk
#define PWR_PUCRG_PG1_Pos (1U)
#define PWR_PUCRG_PG1_Msk (0x1UL << PWR_PUCRG_PG1_Pos)
#define PWR_PUCRG_PG1 PWR_PUCRG_PG1_Msk
#define PWR_PUCRG_PG0_Pos (0U)
#define PWR_PUCRG_PG0_Msk (0x1UL << PWR_PUCRG_PG0_Pos)
#define PWR_PUCRG_PG0 PWR_PUCRG_PG0_Msk

/********************  Bit definition for PWR_PDCRG register  ********************/
#define PWR_PDCRG_PG10_Pos (10U)
#define PWR_PDCRG_PG10_Msk (0x1UL << PWR_PDCRG_PG10_Pos)
#define PWR_PDCRG_PG10 PWR_PDCRG_PG10_Msk
#define PWR_PDCRG_PG9_Pos (9U)
#define PWR_PDCRG_PG9_Msk (0x1UL << PWR_PDCRG_PG9_Pos)
#define PWR_PDCRG_PG9 PWR_PDCRG_PG9_Msk
#define PWR_PDCRG_PG8_Pos (8U)
#define PWR_PDCRG_PG8_Msk (0x1UL << PWR_PDCRG_PG8_Pos)
#define PWR_PDCRG_PG8 PWR_PDCRG_PG8_Msk
#define PWR_PDCRG_PG7_Pos (7U)
#define PWR_PDCRG_PG7_Msk (0x1UL << PWR_PDCRG_PG7_Pos)
#define PWR_PDCRG_PG7 PWR_PDCRG_PG7_Msk
#define PWR_PDCRG_PG6_Pos (6U)
#define PWR_PDCRG_PG6_Msk (0x1UL << PWR_PDCRG_PG6_Pos)
#define PWR_PDCRG_PG6 PWR_PDCRG_PG6_Msk
#define PWR_PDCRG_PG5_Pos (5U)
#define PWR_PDCRG_PG5_Msk (0x1UL << PWR_PDCRG_PG5_Pos)
#define PWR_PDCRG_PG5 PWR_PDCRG_PG5_Msk
#define PWR_PDCRG_PG4_Pos (4U)
#define PWR_PDCRG_PG4_Msk (0x1UL << PWR_PDCRG_PG4_Pos)
#define PWR_PDCRG_PG4 PWR_PDCRG_PG4_Msk
#define PWR_PDCRG_PG3_Pos (3U)
#define PWR_PDCRG_PG3_Msk (0x1UL << PWR_PDCRG_PG3_Pos)
#define PWR_PDCRG_PG3 PWR_PDCRG_PG3_Msk
#define PWR_PDCRG_PG2_Pos (2U)
#define PWR_PDCRG_PG2_Msk (0x1UL << PWR_PDCRG_PG2_Pos)
#define PWR_PDCRG_PG2 PWR_PDCRG_PG2_Msk
#define PWR_PDCRG_PG1_Pos (1U)
#define PWR_PDCRG_PG1_Msk (0x1UL << PWR_PDCRG_PG1_Pos)
#define PWR_PDCRG_PG1 PWR_PDCRG_PG1_Msk
#define PWR_PDCRG_PG0_Pos (0U)
#define PWR_PDCRG_PG0_Msk (0x1UL << PWR_PDCRG_PG0_Pos)
#define PWR_PDCRG_PG0 PWR_PDCRG_PG0_Msk

/********************  Bit definition for PWR_CR5 register  ********************/
#define PWR_CR5_R1MODE_Pos (8U)
#define PWR_CR5_R1MODE_Msk (0x1U << PWR_CR5_R1MODE_Pos)
#define PWR_CR5_R1MODE PWR_CR5_R1MODE_Msk

/******************************************************************************/
/*                                                                            */
/*                                    QUADSPI                                 */
/*                                                                            */
/******************************************************************************/
/*****************  Bit definition for QUADSPI_CR register  *******************/
#define QUADSPI_CR_EN_Pos (0U)
#define QUADSPI_CR_EN_Msk (0x1UL << QUADSPI_CR_EN_Pos)
#define QUADSPI_CR_EN QUADSPI_CR_EN_Msk
#define QUADSPI_CR_ABORT_Pos (1U)
#define QUADSPI_CR_ABORT_Msk (0x1UL << QUADSPI_CR_ABORT_Pos)
#define QUADSPI_CR_ABORT QUADSPI_CR_ABORT_Msk
#define QUADSPI_CR_DMAEN_Pos (2U)
#define QUADSPI_CR_DMAEN_Msk (0x1UL << QUADSPI_CR_DMAEN_Pos)
#define QUADSPI_CR_DMAEN QUADSPI_CR_DMAEN_Msk
#define QUADSPI_CR_TCEN_Pos (3U)
#define QUADSPI_CR_TCEN_Msk (0x1UL << QUADSPI_CR_TCEN_Pos)
#define QUADSPI_CR_TCEN QUADSPI_CR_TCEN_Msk
#define QUADSPI_CR_SSHIFT_Pos (4U)
#define QUADSPI_CR_SSHIFT_Msk (0x1UL << QUADSPI_CR_SSHIFT_Pos)
#define QUADSPI_CR_SSHIFT QUADSPI_CR_SSHIFT_Msk
#define QUADSPI_CR_DFM_Pos (6U)
#define QUADSPI_CR_DFM_Msk (0x1UL << QUADSPI_CR_DFM_Pos)
#define QUADSPI_CR_DFM QUADSPI_CR_DFM_Msk
#define QUADSPI_CR_FSEL_Pos (7U)
#define QUADSPI_CR_FSEL_Msk (0x1UL << QUADSPI_CR_FSEL_Pos)
#define QUADSPI_CR_FSEL QUADSPI_CR_FSEL_Msk
#define QUADSPI_CR_FTHRES_Pos (8U)
#define QUADSPI_CR_FTHRES_Msk (0xFUL << QUADSPI_CR_FTHRES_Pos)
#define QUADSPI_CR_FTHRES QUADSPI_CR_FTHRES_Msk
#define QUADSPI_CR_TEIE_Pos (16U)
#define QUADSPI_CR_TEIE_Msk (0x1UL << QUADSPI_CR_TEIE_Pos)
#define QUADSPI_CR_TEIE QUADSPI_CR_TEIE_Msk
#define QUADSPI_CR_TCIE_Pos (17U)
#define QUADSPI_CR_TCIE_Msk (0x1UL << QUADSPI_CR_TCIE_Pos)
#define QUADSPI_CR_TCIE QUADSPI_CR_TCIE_Msk
#define QUADSPI_CR_FTIE_Pos (18U)
#define QUADSPI_CR_FTIE_Msk (0x1UL << QUADSPI_CR_FTIE_Pos)
#define QUADSPI_CR_FTIE QUADSPI_CR_FTIE_Msk
#define QUADSPI_CR_SMIE_Pos (19U)
#define QUADSPI_CR_SMIE_Msk (0x1UL << QUADSPI_CR_SMIE_Pos)
#define QUADSPI_CR_SMIE QUADSPI_CR_SMIE_Msk
#define QUADSPI_CR_TOIE_Pos (20U)
#define QUADSPI_CR_TOIE_Msk (0x1UL << QUADSPI_CR_TOIE_Pos)
#define QUADSPI_CR_TOIE QUADSPI_CR_TOIE_Msk
#define QUADSPI_CR_APMS_Pos (22U)
#define QUADSPI_CR_APMS_Msk (0x1UL << QUADSPI_CR_APMS_Pos)
#define QUADSPI_CR_APMS QUADSPI_CR_APMS_Msk
#define QUADSPI_CR_PMM_Pos (23U)
#define QUADSPI_CR_PMM_Msk (0x1UL << QUADSPI_CR_PMM_Pos)
#define QUADSPI_CR_PMM QUADSPI_CR_PMM_Msk
#define QUADSPI_CR_PRESCALER_Pos (24U)
#define QUADSPI_CR_PRESCALER_Msk (0xFFUL << QUADSPI_CR_PRESCALER_Pos)
#define QUADSPI_CR_PRESCALER QUADSPI_CR_PRESCALER_Msk

/*****************  Bit definition for QUADSPI_DCR register  ******************/
#define QUADSPI_DCR_CKMODE_Pos (0U)
#define QUADSPI_DCR_CKMODE_Msk (0x1UL << QUADSPI_DCR_CKMODE_Pos)
#define QUADSPI_DCR_CKMODE QUADSPI_DCR_CKMODE_Msk
#define QUADSPI_DCR_CSHT_Pos (8U)
#define QUADSPI_DCR_CSHT_Msk (0x7UL << QUADSPI_DCR_CSHT_Pos)
#define QUADSPI_DCR_CSHT QUADSPI_DCR_CSHT_Msk
#define QUADSPI_DCR_CSHT_0 (0x1UL << QUADSPI_DCR_CSHT_Pos)
#define QUADSPI_DCR_CSHT_1 (0x2UL << QUADSPI_DCR_CSHT_Pos)
#define QUADSPI_DCR_CSHT_2 (0x4UL << QUADSPI_DCR_CSHT_Pos)
#define QUADSPI_DCR_FSIZE_Pos (16U)
#define QUADSPI_DCR_FSIZE_Msk (0x1FUL << QUADSPI_DCR_FSIZE_Pos)
#define QUADSPI_DCR_FSIZE QUADSPI_DCR_FSIZE_Msk

/******************  Bit definition for QUADSPI_SR register  *******************/
#define QUADSPI_SR_TEF_Pos (0U)
#define QUADSPI_SR_TEF_Msk (0x1UL << QUADSPI_SR_TEF_Pos)
#define QUADSPI_SR_TEF QUADSPI_SR_TEF_Msk
#define QUADSPI_SR_TCF_Pos (1U)
#define QUADSPI_SR_TCF_Msk (0x1UL << QUADSPI_SR_TCF_Pos)
#define QUADSPI_SR_TCF QUADSPI_SR_TCF_Msk
#define QUADSPI_SR_FTF_Pos (2U)
#define QUADSPI_SR_FTF_Msk (0x1UL << QUADSPI_SR_FTF_Pos)
#define QUADSPI_SR_FTF QUADSPI_SR_FTF_Msk
#define QUADSPI_SR_SMF_Pos (3U)
#define QUADSPI_SR_SMF_Msk (0x1UL << QUADSPI_SR_SMF_Pos)
#define QUADSPI_SR_SMF QUADSPI_SR_SMF_Msk
#define QUADSPI_SR_TOF_Pos (4U)
#define QUADSPI_SR_TOF_Msk (0x1UL << QUADSPI_SR_TOF_Pos)
#define QUADSPI_SR_TOF QUADSPI_SR_TOF_Msk
#define QUADSPI_SR_BUSY_Pos (5U)
#define QUADSPI_SR_BUSY_Msk (0x1UL << QUADSPI_SR_BUSY_Pos)
#define QUADSPI_SR_BUSY QUADSPI_SR_BUSY_Msk
#define QUADSPI_SR_FLEVEL_Pos (8U)
#define QUADSPI_SR_FLEVEL_Msk (0x1FUL << QUADSPI_SR_FLEVEL_Pos)
#define QUADSPI_SR_FLEVEL QUADSPI_SR_FLEVEL_Msk

/******************  Bit definition for QUADSPI_FCR register  ******************/
#define QUADSPI_FCR_CTEF_Pos (0U)
#define QUADSPI_FCR_CTEF_Msk (0x1UL << QUADSPI_FCR_CTEF_Pos)
#define QUADSPI_FCR_CTEF QUADSPI_FCR_CTEF_Msk
#define QUADSPI_FCR_CTCF_Pos (1U)
#define QUADSPI_FCR_CTCF_Msk (0x1UL << QUADSPI_FCR_CTCF_Pos)
#define QUADSPI_FCR_CTCF QUADSPI_FCR_CTCF_Msk
#define QUADSPI_FCR_CSMF_Pos (3U)
#define QUADSPI_FCR_CSMF_Msk (0x1UL << QUADSPI_FCR_CSMF_Pos)
#define QUADSPI_FCR_CSMF QUADSPI_FCR_CSMF_Msk
#define QUADSPI_FCR_CTOF_Pos (4U)
#define QUADSPI_FCR_CTOF_Msk (0x1UL << QUADSPI_FCR_CTOF_Pos)
#define QUADSPI_FCR_CTOF QUADSPI_FCR_CTOF_Msk

/******************  Bit definition for QUADSPI_DLR register  ******************/
#define QUADSPI_DLR_DL_Pos (0U)
#define QUADSPI_DLR_DL_Msk (0xFFFFFFFFUL << QUADSPI_DLR_DL_Pos)
#define QUADSPI_DLR_DL QUADSPI_DLR_DL_Msk

/******************  Bit definition for QUADSPI_CCR register  ******************/
#define QUADSPI_CCR_INSTRUCTION_Pos (0U)
#define QUADSPI_CCR_INSTRUCTION_Msk (0xFFUL << QUADSPI_CCR_INSTRUCTION_Pos)
#define QUADSPI_CCR_INSTRUCTION QUADSPI_CCR_INSTRUCTION_Msk
#define QUADSPI_CCR_IMODE_Pos (8U)
#define QUADSPI_CCR_IMODE_Msk (0x3UL << QUADSPI_CCR_IMODE_Pos)
#define QUADSPI_CCR_IMODE QUADSPI_CCR_IMODE_Msk
#define QUADSPI_CCR_IMODE_0 (0x1UL << QUADSPI_CCR_IMODE_Pos)
#define QUADSPI_CCR_IMODE_1 (0x2UL << QUADSPI_CCR_IMODE_Pos)
#define QUADSPI_CCR_ADMODE_Pos (10U)
#define QUADSPI_CCR_ADMODE_Msk (0x3UL << QUADSPI_CCR_ADMODE_Pos)
#define QUADSPI_CCR_ADMODE QUADSPI_CCR_ADMODE_Msk
#define QUADSPI_CCR_ADMODE_0 (0x1UL << QUADSPI_CCR_ADMODE_Pos)
#define QUADSPI_CCR_ADMODE_1 (0x2UL << QUADSPI_CCR_ADMODE_Pos)
#define QUADSPI_CCR_ADSIZE_Pos (12U)
#define QUADSPI_CCR_ADSIZE_Msk (0x3UL << QUADSPI_CCR_ADSIZE_Pos)
#define QUADSPI_CCR_ADSIZE QUADSPI_CCR_ADSIZE_Msk
#define QUADSPI_CCR_ADSIZE_0 (0x1UL << QUADSPI_CCR_ADSIZE_Pos)
#define QUADSPI_CCR_ADSIZE_1 (0x2UL << QUADSPI_CCR_ADSIZE_Pos)
#define QUADSPI_CCR_ABMODE_Pos (14U)
#define QUADSPI_CCR_ABMODE_Msk (0x3UL << QUADSPI_CCR_ABMODE_Pos)
#define QUADSPI_CCR_ABMODE QUADSPI_CCR_ABMODE_Msk
#define QUADSPI_CCR_ABMODE_0 (0x1UL << QUADSPI_CCR_ABMODE_Pos)
#define QUADSPI_CCR_ABMODE_1 (0x2UL << QUADSPI_CCR_ABMODE_Pos)
#define QUADSPI_CCR_ABSIZE_Pos (16U)
#define QUADSPI_CCR_ABSIZE_Msk (0x3UL << QUADSPI_CCR_ABSIZE_Pos)
#define QUADSPI_CCR_ABSIZE QUADSPI_CCR_ABSIZE_Msk
#define QUADSPI_CCR_ABSIZE_0 (0x1UL << QUADSPI_CCR_ABSIZE_Pos)
#define QUADSPI_CCR_ABSIZE_1 (0x2UL << QUADSPI_CCR_ABSIZE_Pos)
#define QUADSPI_CCR_DCYC_Pos (18U)
#define QUADSPI_CCR_DCYC_Msk (0x1FUL << QUADSPI_CCR_DCYC_Pos)
#define QUADSPI_CCR_DCYC QUADSPI_CCR_DCYC_Msk
#define QUADSPI_CCR_DMODE_Pos (24U)
#define QUADSPI_CCR_DMODE_Msk (0x3UL << QUADSPI_CCR_DMODE_Pos)
#define QUADSPI_CCR_DMODE QUADSPI_CCR_DMODE_Msk
#define QUADSPI_CCR_DMODE_0 (0x1UL << QUADSPI_CCR_DMODE_Pos)
#define QUADSPI_CCR_DMODE_1 (0x2UL << QUADSPI_CCR_DMODE_Pos)
#define QUADSPI_CCR_FMODE_Pos (26U)
#define QUADSPI_CCR_FMODE_Msk (0x3UL << QUADSPI_CCR_FMODE_Pos)
#define QUADSPI_CCR_FMODE QUADSPI_CCR_FMODE_Msk
#define QUADSPI_CCR_FMODE_0 (0x1UL << QUADSPI_CCR_FMODE_Pos)
#define QUADSPI_CCR_FMODE_1 (0x2UL << QUADSPI_CCR_FMODE_Pos)
#define QUADSPI_CCR_SIOO_Pos (28U)
#define QUADSPI_CCR_SIOO_Msk (0x1UL << QUADSPI_CCR_SIOO_Pos)
#define QUADSPI_CCR_SIOO QUADSPI_CCR_SIOO_Msk
#define QUADSPI_CCR_DHHC_Pos (30U)
#define QUADSPI_CCR_DHHC_Msk (0x1UL << QUADSPI_CCR_DHHC_Pos)
#define QUADSPI_CCR_DHHC QUADSPI_CCR_DHHC_Msk
#define QUADSPI_CCR_DDRM_Pos (31U)
#define QUADSPI_CCR_DDRM_Msk (0x1UL << QUADSPI_CCR_DDRM_Pos)
#define QUADSPI_CCR_DDRM QUADSPI_CCR_DDRM_Msk

/******************  Bit definition for QUADSPI_AR register  *******************/
#define QUADSPI_AR_ADDRESS_Pos (0U)
#define QUADSPI_AR_ADDRESS_Msk (0xFFFFFFFFUL << QUADSPI_AR_ADDRESS_Pos)
#define QUADSPI_AR_ADDRESS QUADSPI_AR_ADDRESS_Msk

/******************  Bit definition for QUADSPI_ABR register  ******************/
#define QUADSPI_ABR_ALTERNATE_Pos (0U)
#define QUADSPI_ABR_ALTERNATE_Msk (0xFFFFFFFFUL << QUADSPI_ABR_ALTERNATE_Pos)
#define QUADSPI_ABR_ALTERNATE QUADSPI_ABR_ALTERNATE_Msk

/******************  Bit definition for QUADSPI_DR register  *******************/
#define QUADSPI_DR_DATA_Pos (0U)
#define QUADSPI_DR_DATA_Msk (0xFFFFFFFFUL << QUADSPI_DR_DATA_Pos)
#define QUADSPI_DR_DATA QUADSPI_DR_DATA_Msk

/******************  Bit definition for QUADSPI_PSMKR register  ****************/
#define QUADSPI_PSMKR_MASK_Pos (0U)
#define QUADSPI_PSMKR_MASK_Msk (0xFFFFFFFFUL << QUADSPI_PSMKR_MASK_Pos)
#define QUADSPI_PSMKR_MASK QUADSPI_PSMKR_MASK_Msk

/******************  Bit definition for QUADSPI_PSMAR register  ****************/
#define QUADSPI_PSMAR_MATCH_Pos (0U)
#define QUADSPI_PSMAR_MATCH_Msk (0xFFFFFFFFUL << QUADSPI_PSMAR_MATCH_Pos)
#define QUADSPI_PSMAR_MATCH QUADSPI_PSMAR_MATCH_Msk

/******************  Bit definition for QUADSPI_PIR register  *****************/
#define QUADSPI_PIR_INTERVAL_Pos (0U)
#define QUADSPI_PIR_INTERVAL_Msk (0xFFFFUL << QUADSPI_PIR_INTERVAL_Pos)
#define QUADSPI_PIR_INTERVAL QUADSPI_PIR_INTERVAL_Msk

/******************  Bit definition for QUADSPI_LPTR register  *****************/
#define QUADSPI_LPTR_TIMEOUT_Pos (0U)
#define QUADSPI_LPTR_TIMEOUT_Msk (0xFFFFUL << QUADSPI_LPTR_TIMEOUT_Pos)
#define QUADSPI_LPTR_TIMEOUT QUADSPI_LPTR_TIMEOUT_Msk

/******************************************************************************/
/*                                                                            */
/*                         Reset and Clock Control                            */
/*                                                                            */
/******************************************************************************/
/*
* @brief Specific device feature definitions  (not present on all devices in the STM32G4 series)
*/

#define RCC_HSI48_SUPPORT 
#define RCC_PLLP_DIV_2_31_SUPPORT 

/********************  Bit definition for RCC_CR register  ********************/
#define RCC_CR_HSION_Pos (8U)
#define RCC_CR_HSION_Msk (0x1UL << RCC_CR_HSION_Pos)
#define RCC_CR_HSION RCC_CR_HSION_Msk
#define RCC_CR_HSIKERON_Pos (9U)
#define RCC_CR_HSIKERON_Msk (0x1UL << RCC_CR_HSIKERON_Pos)
#define RCC_CR_HSIKERON RCC_CR_HSIKERON_Msk
#define RCC_CR_HSIRDY_Pos (10U)
#define RCC_CR_HSIRDY_Msk (0x1UL << RCC_CR_HSIRDY_Pos)
#define RCC_CR_HSIRDY RCC_CR_HSIRDY_Msk

#define RCC_CR_HSEON_Pos (16U)
#define RCC_CR_HSEON_Msk (0x1UL << RCC_CR_HSEON_Pos)
#define RCC_CR_HSEON RCC_CR_HSEON_Msk
#define RCC_CR_HSERDY_Pos (17U)
#define RCC_CR_HSERDY_Msk (0x1UL << RCC_CR_HSERDY_Pos)
#define RCC_CR_HSERDY RCC_CR_HSERDY_Msk
#define RCC_CR_HSEBYP_Pos (18U)
#define RCC_CR_HSEBYP_Msk (0x1UL << RCC_CR_HSEBYP_Pos)
#define RCC_CR_HSEBYP RCC_CR_HSEBYP_Msk
#define RCC_CR_CSSON_Pos (19U)
#define RCC_CR_CSSON_Msk (0x1UL << RCC_CR_CSSON_Pos)
#define RCC_CR_CSSON RCC_CR_CSSON_Msk

#define RCC_CR_PLLON_Pos (24U)
#define RCC_CR_PLLON_Msk (0x1UL << RCC_CR_PLLON_Pos)
#define RCC_CR_PLLON RCC_CR_PLLON_Msk
#define RCC_CR_PLLRDY_Pos (25U)
#define RCC_CR_PLLRDY_Msk (0x1UL << RCC_CR_PLLRDY_Pos)
#define RCC_CR_PLLRDY RCC_CR_PLLRDY_Msk

/********************  Bit definition for RCC_ICSCR register  ***************/
/*!< HSICAL configuration */
#define RCC_ICSCR_HSICAL_Pos (16U)
#define RCC_ICSCR_HSICAL_Msk (0xFFUL << RCC_ICSCR_HSICAL_Pos)
#define RCC_ICSCR_HSICAL RCC_ICSCR_HSICAL_Msk
#define RCC_ICSCR_HSICAL_0 (0x01UL << RCC_ICSCR_HSICAL_Pos)
#define RCC_ICSCR_HSICAL_1 (0x02UL << RCC_ICSCR_HSICAL_Pos)
#define RCC_ICSCR_HSICAL_2 (0x04UL << RCC_ICSCR_HSICAL_Pos)
#define RCC_ICSCR_HSICAL_3 (0x08UL << RCC_ICSCR_HSICAL_Pos)
#define RCC_ICSCR_HSICAL_4 (0x10UL << RCC_ICSCR_HSICAL_Pos)
#define RCC_ICSCR_HSICAL_5 (0x20UL << RCC_ICSCR_HSICAL_Pos)
#define RCC_ICSCR_HSICAL_6 (0x40UL << RCC_ICSCR_HSICAL_Pos)
#define RCC_ICSCR_HSICAL_7 (0x80UL << RCC_ICSCR_HSICAL_Pos)

/*!< HSITRIM configuration */
#define RCC_ICSCR_HSITRIM_Pos (24U)
#define RCC_ICSCR_HSITRIM_Msk (0x7FUL << RCC_ICSCR_HSITRIM_Pos)
#define RCC_ICSCR_HSITRIM RCC_ICSCR_HSITRIM_Msk
#define RCC_ICSCR_HSITRIM_0 (0x01UL << RCC_ICSCR_HSITRIM_Pos)
#define RCC_ICSCR_HSITRIM_1 (0x02UL << RCC_ICSCR_HSITRIM_Pos)
#define RCC_ICSCR_HSITRIM_2 (0x04UL << RCC_ICSCR_HSITRIM_Pos)
#define RCC_ICSCR_HSITRIM_3 (0x08UL << RCC_ICSCR_HSITRIM_Pos)
#define RCC_ICSCR_HSITRIM_4 (0x10UL << RCC_ICSCR_HSITRIM_Pos)
#define RCC_ICSCR_HSITRIM_5 (0x20UL << RCC_ICSCR_HSITRIM_Pos)
#define RCC_ICSCR_HSITRIM_6 (0x40UL << RCC_ICSCR_HSITRIM_Pos)

/********************  Bit definition for RCC_CFGR register  ******************/
/*!< SW configuration */
#define RCC_CFGR_SW_Pos (0U)
#define RCC_CFGR_SW_Msk (0x3UL << RCC_CFGR_SW_Pos)
#define RCC_CFGR_SW RCC_CFGR_SW_Msk
#define RCC_CFGR_SW_0 (0x1UL << RCC_CFGR_SW_Pos)
#define RCC_CFGR_SW_1 (0x2UL << RCC_CFGR_SW_Pos)

#define RCC_CFGR_SW_HSI (0x00000001U)
#define RCC_CFGR_SW_HSE (0x00000002U)
#define RCC_CFGR_SW_PLL (0x00000003U)

/*!< SWS configuration */
#define RCC_CFGR_SWS_Pos (2U)
#define RCC_CFGR_SWS_Msk (0x3UL << RCC_CFGR_SWS_Pos)
#define RCC_CFGR_SWS RCC_CFGR_SWS_Msk
#define RCC_CFGR_SWS_0 (0x1UL << RCC_CFGR_SWS_Pos)
#define RCC_CFGR_SWS_1 (0x2UL << RCC_CFGR_SWS_Pos)

#define RCC_CFGR_SWS_HSI (0x00000004U)
#define RCC_CFGR_SWS_HSE (0x00000008U)
#define RCC_CFGR_SWS_PLL (0x0000000CU)

/*!< HPRE configuration */
#define RCC_CFGR_HPRE_Pos (4U)
#define RCC_CFGR_HPRE_Msk (0xFUL << RCC_CFGR_HPRE_Pos)
#define RCC_CFGR_HPRE RCC_CFGR_HPRE_Msk
#define RCC_CFGR_HPRE_0 (0x1UL << RCC_CFGR_HPRE_Pos)
#define RCC_CFGR_HPRE_1 (0x2UL << RCC_CFGR_HPRE_Pos)
#define RCC_CFGR_HPRE_2 (0x4UL << RCC_CFGR_HPRE_Pos)
#define RCC_CFGR_HPRE_3 (0x8UL << RCC_CFGR_HPRE_Pos)

#define RCC_CFGR_HPRE_DIV1 (0x00000000U)
#define RCC_CFGR_HPRE_DIV2 (0x00000080U)
#define RCC_CFGR_HPRE_DIV4 (0x00000090U)
#define RCC_CFGR_HPRE_DIV8 (0x000000A0U)
#define RCC_CFGR_HPRE_DIV16 (0x000000B0U)
#define RCC_CFGR_HPRE_DIV64 (0x000000C0U)
#define RCC_CFGR_HPRE_DIV128 (0x000000D0U)
#define RCC_CFGR_HPRE_DIV256 (0x000000E0U)
#define RCC_CFGR_HPRE_DIV512 (0x000000F0U)

/*!< PPRE1 configuration */
#define RCC_CFGR_PPRE1_Pos (8U)
#define RCC_CFGR_PPRE1_Msk (0x7UL << RCC_CFGR_PPRE1_Pos)
#define RCC_CFGR_PPRE1 RCC_CFGR_PPRE1_Msk
#define RCC_CFGR_PPRE1_0 (0x1UL << RCC_CFGR_PPRE1_Pos)
#define RCC_CFGR_PPRE1_1 (0x2UL << RCC_CFGR_PPRE1_Pos)
#define RCC_CFGR_PPRE1_2 (0x4UL << RCC_CFGR_PPRE1_Pos)

#define RCC_CFGR_PPRE1_DIV1 (0x00000000U)
#define RCC_CFGR_PPRE1_DIV2 (0x00000400U)
#define RCC_CFGR_PPRE1_DIV4 (0x00000500U)
#define RCC_CFGR_PPRE1_DIV8 (0x00000600U)
#define RCC_CFGR_PPRE1_DIV16 (0x00000700U)

/*!< PPRE2 configuration */
#define RCC_CFGR_PPRE2_Pos (11U)
#define RCC_CFGR_PPRE2_Msk (0x7UL << RCC_CFGR_PPRE2_Pos)
#define RCC_CFGR_PPRE2 RCC_CFGR_PPRE2_Msk
#define RCC_CFGR_PPRE2_0 (0x1UL << RCC_CFGR_PPRE2_Pos)
#define RCC_CFGR_PPRE2_1 (0x2UL << RCC_CFGR_PPRE2_Pos)
#define RCC_CFGR_PPRE2_2 (0x4UL << RCC_CFGR_PPRE2_Pos)

#define RCC_CFGR_PPRE2_DIV1 (0x00000000U)
#define RCC_CFGR_PPRE2_DIV2 (0x00002000U)
#define RCC_CFGR_PPRE2_DIV4 (0x00002800U)
#define RCC_CFGR_PPRE2_DIV8 (0x00003000U)
#define RCC_CFGR_PPRE2_DIV16 (0x00003800U)

/*!< MCOSEL configuration */
#define RCC_CFGR_MCOSEL_Pos (24U)
#define RCC_CFGR_MCOSEL_Msk (0xFUL << RCC_CFGR_MCOSEL_Pos)
#define RCC_CFGR_MCOSEL RCC_CFGR_MCOSEL_Msk
#define RCC_CFGR_MCOSEL_0 (0x1UL << RCC_CFGR_MCOSEL_Pos)
#define RCC_CFGR_MCOSEL_1 (0x2UL << RCC_CFGR_MCOSEL_Pos)
#define RCC_CFGR_MCOSEL_2 (0x4UL << RCC_CFGR_MCOSEL_Pos)
#define RCC_CFGR_MCOSEL_3 (0x8UL << RCC_CFGR_MCOSEL_Pos)

#define RCC_CFGR_MCOPRE_Pos (28U)
#define RCC_CFGR_MCOPRE_Msk (0x7UL << RCC_CFGR_MCOPRE_Pos)
#define RCC_CFGR_MCOPRE RCC_CFGR_MCOPRE_Msk
#define RCC_CFGR_MCOPRE_0 (0x1UL << RCC_CFGR_MCOPRE_Pos)
#define RCC_CFGR_MCOPRE_1 (0x2UL << RCC_CFGR_MCOPRE_Pos)
#define RCC_CFGR_MCOPRE_2 (0x4UL << RCC_CFGR_MCOPRE_Pos)

#define RCC_CFGR_MCOPRE_DIV1 (0x00000000U)
#define RCC_CFGR_MCOPRE_DIV2 (0x10000000U)
#define RCC_CFGR_MCOPRE_DIV4 (0x20000000U)
#define RCC_CFGR_MCOPRE_DIV8 (0x30000000U)
#define RCC_CFGR_MCOPRE_DIV16 (0x40000000U)

/* Legacy aliases */
#define RCC_CFGR_MCO_PRE RCC_CFGR_MCOPRE
#define RCC_CFGR_MCO_PRE_1 RCC_CFGR_MCOPRE_DIV1
#define RCC_CFGR_MCO_PRE_2 RCC_CFGR_MCOPRE_DIV2
#define RCC_CFGR_MCO_PRE_4 RCC_CFGR_MCOPRE_DIV4
#define RCC_CFGR_MCO_PRE_8 RCC_CFGR_MCOPRE_DIV8
#define RCC_CFGR_MCO_PRE_16 RCC_CFGR_MCOPRE_DIV16

/********************  Bit definition for RCC_PLLCFGR register  ***************/
#define RCC_PLLCFGR_PLLSRC_Pos (0U)
#define RCC_PLLCFGR_PLLSRC_Msk (0x3UL << RCC_PLLCFGR_PLLSRC_Pos)
#define RCC_PLLCFGR_PLLSRC RCC_PLLCFGR_PLLSRC_Msk
#define RCC_PLLCFGR_PLLSRC_0 (0x1UL << RCC_PLLCFGR_PLLSRC_Pos)
#define RCC_PLLCFGR_PLLSRC_1 (0x2UL << RCC_PLLCFGR_PLLSRC_Pos)

#define RCC_PLLCFGR_PLLSRC_HSI_Pos (1U)
#define RCC_PLLCFGR_PLLSRC_HSI_Msk (0x1UL << RCC_PLLCFGR_PLLSRC_HSI_Pos)
#define RCC_PLLCFGR_PLLSRC_HSI RCC_PLLCFGR_PLLSRC_HSI_Msk
#define RCC_PLLCFGR_PLLSRC_HSE_Pos (0U)
#define RCC_PLLCFGR_PLLSRC_HSE_Msk (0x3UL << RCC_PLLCFGR_PLLSRC_HSE_Pos)
#define RCC_PLLCFGR_PLLSRC_HSE RCC_PLLCFGR_PLLSRC_HSE_Msk

#define RCC_PLLCFGR_PLLM_Pos (4U)
#define RCC_PLLCFGR_PLLM_Msk (0xFUL << RCC_PLLCFGR_PLLM_Pos)
#define RCC_PLLCFGR_PLLM RCC_PLLCFGR_PLLM_Msk
#define RCC_PLLCFGR_PLLM_0 (0x1UL << RCC_PLLCFGR_PLLM_Pos)
#define RCC_PLLCFGR_PLLM_1 (0x2UL << RCC_PLLCFGR_PLLM_Pos)
#define RCC_PLLCFGR_PLLM_2 (0x4UL << RCC_PLLCFGR_PLLM_Pos)
#define RCC_PLLCFGR_PLLM_3 (0x8UL << RCC_PLLCFGR_PLLM_Pos)

#define RCC_PLLCFGR_PLLN_Pos (8U)
#define RCC_PLLCFGR_PLLN_Msk (0x7FUL << RCC_PLLCFGR_PLLN_Pos)
#define RCC_PLLCFGR_PLLN RCC_PLLCFGR_PLLN_Msk
#define RCC_PLLCFGR_PLLN_0 (0x01UL << RCC_PLLCFGR_PLLN_Pos)
#define RCC_PLLCFGR_PLLN_1 (0x02UL << RCC_PLLCFGR_PLLN_Pos)
#define RCC_PLLCFGR_PLLN_2 (0x04UL << RCC_PLLCFGR_PLLN_Pos)
#define RCC_PLLCFGR_PLLN_3 (0x08UL << RCC_PLLCFGR_PLLN_Pos)
#define RCC_PLLCFGR_PLLN_4 (0x10UL << RCC_PLLCFGR_PLLN_Pos)
#define RCC_PLLCFGR_PLLN_5 (0x20UL << RCC_PLLCFGR_PLLN_Pos)
#define RCC_PLLCFGR_PLLN_6 (0x40UL << RCC_PLLCFGR_PLLN_Pos)

#define RCC_PLLCFGR_PLLPEN_Pos (16U)
#define RCC_PLLCFGR_PLLPEN_Msk (0x1UL << RCC_PLLCFGR_PLLPEN_Pos)
#define RCC_PLLCFGR_PLLPEN RCC_PLLCFGR_PLLPEN_Msk
#define RCC_PLLCFGR_PLLP_Pos (17U)
#define RCC_PLLCFGR_PLLP_Msk (0x1UL << RCC_PLLCFGR_PLLP_Pos)
#define RCC_PLLCFGR_PLLP RCC_PLLCFGR_PLLP_Msk
#define RCC_PLLCFGR_PLLQEN_Pos (20U)
#define RCC_PLLCFGR_PLLQEN_Msk (0x1UL << RCC_PLLCFGR_PLLQEN_Pos)
#define RCC_PLLCFGR_PLLQEN RCC_PLLCFGR_PLLQEN_Msk

#define RCC_PLLCFGR_PLLQ_Pos (21U)
#define RCC_PLLCFGR_PLLQ_Msk (0x3UL << RCC_PLLCFGR_PLLQ_Pos)
#define RCC_PLLCFGR_PLLQ RCC_PLLCFGR_PLLQ_Msk
#define RCC_PLLCFGR_PLLQ_0 (0x1UL << RCC_PLLCFGR_PLLQ_Pos)
#define RCC_PLLCFGR_PLLQ_1 (0x2UL << RCC_PLLCFGR_PLLQ_Pos)

#define RCC_PLLCFGR_PLLREN_Pos (24U)
#define RCC_PLLCFGR_PLLREN_Msk (0x1UL << RCC_PLLCFGR_PLLREN_Pos)
#define RCC_PLLCFGR_PLLREN RCC_PLLCFGR_PLLREN_Msk
#define RCC_PLLCFGR_PLLR_Pos (25U)
#define RCC_PLLCFGR_PLLR_Msk (0x3UL << RCC_PLLCFGR_PLLR_Pos)
#define RCC_PLLCFGR_PLLR RCC_PLLCFGR_PLLR_Msk
#define RCC_PLLCFGR_PLLR_0 (0x1UL << RCC_PLLCFGR_PLLR_Pos)
#define RCC_PLLCFGR_PLLR_1 (0x2UL << RCC_PLLCFGR_PLLR_Pos)

#define RCC_PLLCFGR_PLLPDIV_Pos (27U)
#define RCC_PLLCFGR_PLLPDIV_Msk (0x1FUL << RCC_PLLCFGR_PLLPDIV_Pos)
#define RCC_PLLCFGR_PLLPDIV RCC_PLLCFGR_PLLPDIV_Msk
#define RCC_PLLCFGR_PLLPDIV_0 (0x01UL << RCC_PLLCFGR_PLLPDIV_Pos)
#define RCC_PLLCFGR_PLLPDIV_1 (0x02UL << RCC_PLLCFGR_PLLPDIV_Pos)
#define RCC_PLLCFGR_PLLPDIV_2 (0x04UL << RCC_PLLCFGR_PLLPDIV_Pos)
#define RCC_PLLCFGR_PLLPDIV_3 (0x08UL << RCC_PLLCFGR_PLLPDIV_Pos)
#define RCC_PLLCFGR_PLLPDIV_4 (0x10UL << RCC_PLLCFGR_PLLPDIV_Pos)

/********************  Bit definition for RCC_CIER register  ******************/
#define RCC_CIER_LSIRDYIE_Pos (0U)
#define RCC_CIER_LSIRDYIE_Msk (0x1UL << RCC_CIER_LSIRDYIE_Pos)
#define RCC_CIER_LSIRDYIE RCC_CIER_LSIRDYIE_Msk
#define RCC_CIER_LSERDYIE_Pos (1U)
#define RCC_CIER_LSERDYIE_Msk (0x1UL << RCC_CIER_LSERDYIE_Pos)
#define RCC_CIER_LSERDYIE RCC_CIER_LSERDYIE_Msk
#define RCC_CIER_HSIRDYIE_Pos (3U)
#define RCC_CIER_HSIRDYIE_Msk (0x1UL << RCC_CIER_HSIRDYIE_Pos)
#define RCC_CIER_HSIRDYIE RCC_CIER_HSIRDYIE_Msk
#define RCC_CIER_HSERDYIE_Pos (4U)
#define RCC_CIER_HSERDYIE_Msk (0x1UL << RCC_CIER_HSERDYIE_Pos)
#define RCC_CIER_HSERDYIE RCC_CIER_HSERDYIE_Msk
#define RCC_CIER_PLLRDYIE_Pos (5U)
#define RCC_CIER_PLLRDYIE_Msk (0x1UL << RCC_CIER_PLLRDYIE_Pos)
#define RCC_CIER_PLLRDYIE RCC_CIER_PLLRDYIE_Msk
#define RCC_CIER_LSECSSIE_Pos (9U)
#define RCC_CIER_LSECSSIE_Msk (0x1UL << RCC_CIER_LSECSSIE_Pos)
#define RCC_CIER_LSECSSIE RCC_CIER_LSECSSIE_Msk
#define RCC_CIER_HSI48RDYIE_Pos (10U)
#define RCC_CIER_HSI48RDYIE_Msk (0x1UL << RCC_CIER_HSI48RDYIE_Pos)
#define RCC_CIER_HSI48RDYIE RCC_CIER_HSI48RDYIE_Msk

/********************  Bit definition for RCC_CIFR register  ******************/
#define RCC_CIFR_LSIRDYF_Pos (0U)
#define RCC_CIFR_LSIRDYF_Msk (0x1UL << RCC_CIFR_LSIRDYF_Pos)
#define RCC_CIFR_LSIRDYF RCC_CIFR_LSIRDYF_Msk
#define RCC_CIFR_LSERDYF_Pos (1U)
#define RCC_CIFR_LSERDYF_Msk (0x1UL << RCC_CIFR_LSERDYF_Pos)
#define RCC_CIFR_LSERDYF RCC_CIFR_LSERDYF_Msk
#define RCC_CIFR_HSIRDYF_Pos (3U)
#define RCC_CIFR_HSIRDYF_Msk (0x1UL << RCC_CIFR_HSIRDYF_Pos)
#define RCC_CIFR_HSIRDYF RCC_CIFR_HSIRDYF_Msk
#define RCC_CIFR_HSERDYF_Pos (4U)
#define RCC_CIFR_HSERDYF_Msk (0x1UL << RCC_CIFR_HSERDYF_Pos)
#define RCC_CIFR_HSERDYF RCC_CIFR_HSERDYF_Msk
#define RCC_CIFR_PLLRDYF_Pos (5U)
#define RCC_CIFR_PLLRDYF_Msk (0x1UL << RCC_CIFR_PLLRDYF_Pos)
#define RCC_CIFR_PLLRDYF RCC_CIFR_PLLRDYF_Msk
#define RCC_CIFR_CSSF_Pos (8U)
#define RCC_CIFR_CSSF_Msk (0x1UL << RCC_CIFR_CSSF_Pos)
#define RCC_CIFR_CSSF RCC_CIFR_CSSF_Msk
#define RCC_CIFR_LSECSSF_Pos (9U)
#define RCC_CIFR_LSECSSF_Msk (0x1UL << RCC_CIFR_LSECSSF_Pos)
#define RCC_CIFR_LSECSSF RCC_CIFR_LSECSSF_Msk
#define RCC_CIFR_HSI48RDYF_Pos (10U)
#define RCC_CIFR_HSI48RDYF_Msk (0x1UL << RCC_CIFR_HSI48RDYF_Pos)
#define RCC_CIFR_HSI48RDYF RCC_CIFR_HSI48RDYF_Msk

/********************  Bit definition for RCC_CICR register  ******************/
#define RCC_CICR_LSIRDYC_Pos (0U)
#define RCC_CICR_LSIRDYC_Msk (0x1UL << RCC_CICR_LSIRDYC_Pos)
#define RCC_CICR_LSIRDYC RCC_CICR_LSIRDYC_Msk
#define RCC_CICR_LSERDYC_Pos (1U)
#define RCC_CICR_LSERDYC_Msk (0x1UL << RCC_CICR_LSERDYC_Pos)
#define RCC_CICR_LSERDYC RCC_CICR_LSERDYC_Msk
#define RCC_CICR_HSIRDYC_Pos (3U)
#define RCC_CICR_HSIRDYC_Msk (0x1UL << RCC_CICR_HSIRDYC_Pos)
#define RCC_CICR_HSIRDYC RCC_CICR_HSIRDYC_Msk
#define RCC_CICR_HSERDYC_Pos (4U)
#define RCC_CICR_HSERDYC_Msk (0x1UL << RCC_CICR_HSERDYC_Pos)
#define RCC_CICR_HSERDYC RCC_CICR_HSERDYC_Msk
#define RCC_CICR_PLLRDYC_Pos (5U)
#define RCC_CICR_PLLRDYC_Msk (0x1UL << RCC_CICR_PLLRDYC_Pos)
#define RCC_CICR_PLLRDYC RCC_CICR_PLLRDYC_Msk
#define RCC_CICR_CSSC_Pos (8U)
#define RCC_CICR_CSSC_Msk (0x1UL << RCC_CICR_CSSC_Pos)
#define RCC_CICR_CSSC RCC_CICR_CSSC_Msk
#define RCC_CICR_LSECSSC_Pos (9U)
#define RCC_CICR_LSECSSC_Msk (0x1UL << RCC_CICR_LSECSSC_Pos)
#define RCC_CICR_LSECSSC RCC_CICR_LSECSSC_Msk
#define RCC_CICR_HSI48RDYC_Pos (10U)
#define RCC_CICR_HSI48RDYC_Msk (0x1UL << RCC_CICR_HSI48RDYC_Pos)
#define RCC_CICR_HSI48RDYC RCC_CICR_HSI48RDYC_Msk

/********************  Bit definition for RCC_AHB1RSTR register  **************/
#define RCC_AHB1RSTR_DMA1RST_Pos (0U)
#define RCC_AHB1RSTR_DMA1RST_Msk (0x1UL << RCC_AHB1RSTR_DMA1RST_Pos)
#define RCC_AHB1RSTR_DMA1RST RCC_AHB1RSTR_DMA1RST_Msk
#define RCC_AHB1RSTR_DMA2RST_Pos (1U)
#define RCC_AHB1RSTR_DMA2RST_Msk (0x1UL << RCC_AHB1RSTR_DMA2RST_Pos)
#define RCC_AHB1RSTR_DMA2RST RCC_AHB1RSTR_DMA2RST_Msk
#define RCC_AHB1RSTR_DMAMUX1RST_Pos (2U)
#define RCC_AHB1RSTR_DMAMUX1RST_Msk (0x1UL << RCC_AHB1RSTR_DMAMUX1RST_Pos)
#define RCC_AHB1RSTR_DMAMUX1RST RCC_AHB1RSTR_DMAMUX1RST_Msk
#define RCC_AHB1RSTR_CORDICRST_Pos (3U)
#define RCC_AHB1RSTR_CORDICRST_Msk (0x1UL << RCC_AHB1RSTR_CORDICRST_Pos)
#define RCC_AHB1RSTR_CORDICRST RCC_AHB1RSTR_CORDICRST_Msk
#define RCC_AHB1RSTR_FMACRST_Pos (4U)
#define RCC_AHB1RSTR_FMACRST_Msk (0x1UL << RCC_AHB1RSTR_FMACRST_Pos)
#define RCC_AHB1RSTR_FMACRST RCC_AHB1RSTR_FMACRST_Msk
#define RCC_AHB1RSTR_FLASHRST_Pos (8U)
#define RCC_AHB1RSTR_FLASHRST_Msk (0x1UL << RCC_AHB1RSTR_FLASHRST_Pos)
#define RCC_AHB1RSTR_FLASHRST RCC_AHB1RSTR_FLASHRST_Msk
#define RCC_AHB1RSTR_CRCRST_Pos (12U)
#define RCC_AHB1RSTR_CRCRST_Msk (0x1UL << RCC_AHB1RSTR_CRCRST_Pos)
#define RCC_AHB1RSTR_CRCRST RCC_AHB1RSTR_CRCRST_Msk

/********************  Bit definition for RCC_AHB2RSTR register  **************/
#define RCC_AHB2RSTR_GPIOARST_Pos (0U)
#define RCC_AHB2RSTR_GPIOARST_Msk (0x1UL << RCC_AHB2RSTR_GPIOARST_Pos)
#define RCC_AHB2RSTR_GPIOARST RCC_AHB2RSTR_GPIOARST_Msk
#define RCC_AHB2RSTR_GPIOBRST_Pos (1U)
#define RCC_AHB2RSTR_GPIOBRST_Msk (0x1UL << RCC_AHB2RSTR_GPIOBRST_Pos)
#define RCC_AHB2RSTR_GPIOBRST RCC_AHB2RSTR_GPIOBRST_Msk
#define RCC_AHB2RSTR_GPIOCRST_Pos (2U)
#define RCC_AHB2RSTR_GPIOCRST_Msk (0x1UL << RCC_AHB2RSTR_GPIOCRST_Pos)
#define RCC_AHB2RSTR_GPIOCRST RCC_AHB2RSTR_GPIOCRST_Msk
#define RCC_AHB2RSTR_GPIODRST_Pos (3U)
#define RCC_AHB2RSTR_GPIODRST_Msk (0x1UL << RCC_AHB2RSTR_GPIODRST_Pos)
#define RCC_AHB2RSTR_GPIODRST RCC_AHB2RSTR_GPIODRST_Msk
#define RCC_AHB2RSTR_GPIOERST_Pos (4U)
#define RCC_AHB2RSTR_GPIOERST_Msk (0x1UL << RCC_AHB2RSTR_GPIOERST_Pos)
#define RCC_AHB2RSTR_GPIOERST RCC_AHB2RSTR_GPIOERST_Msk
#define RCC_AHB2RSTR_GPIOFRST_Pos (5U)
#define RCC_AHB2RSTR_GPIOFRST_Msk (0x1UL << RCC_AHB2RSTR_GPIOFRST_Pos)
#define RCC_AHB2RSTR_GPIOFRST RCC_AHB2RSTR_GPIOFRST_Msk
#define RCC_AHB2RSTR_GPIOGRST_Pos (6U)
#define RCC_AHB2RSTR_GPIOGRST_Msk (0x1UL << RCC_AHB2RSTR_GPIOGRST_Pos)
#define RCC_AHB2RSTR_GPIOGRST RCC_AHB2RSTR_GPIOGRST_Msk
#define RCC_AHB2RSTR_ADC12RST_Pos (13U)
#define RCC_AHB2RSTR_ADC12RST_Msk (0x1UL << RCC_AHB2RSTR_ADC12RST_Pos)
#define RCC_AHB2RSTR_ADC12RST RCC_AHB2RSTR_ADC12RST_Msk
#define RCC_AHB2RSTR_ADC345RST_Pos (14U)
#define RCC_AHB2RSTR_ADC345RST_Msk (0x1UL << RCC_AHB2RSTR_ADC345RST_Pos)
#define RCC_AHB2RSTR_ADC345RST RCC_AHB2RSTR_ADC345RST_Msk
#define RCC_AHB2RSTR_DAC1RST_Pos (16U)
#define RCC_AHB2RSTR_DAC1RST_Msk (0x1UL << RCC_AHB2RSTR_DAC1RST_Pos)
#define RCC_AHB2RSTR_DAC1RST RCC_AHB2RSTR_DAC1RST_Msk
#define RCC_AHB2RSTR_DAC2RST_Pos (17U)
#define RCC_AHB2RSTR_DAC2RST_Msk (0x1UL << RCC_AHB2RSTR_DAC2RST_Pos)
#define RCC_AHB2RSTR_DAC2RST RCC_AHB2RSTR_DAC2RST_Msk
#define RCC_AHB2RSTR_DAC3RST_Pos (18U)
#define RCC_AHB2RSTR_DAC3RST_Msk (0x1UL << RCC_AHB2RSTR_DAC3RST_Pos)
#define RCC_AHB2RSTR_DAC3RST RCC_AHB2RSTR_DAC3RST_Msk
#define RCC_AHB2RSTR_DAC4RST_Pos (19U)
#define RCC_AHB2RSTR_DAC4RST_Msk (0x1UL << RCC_AHB2RSTR_DAC4RST_Pos)
#define RCC_AHB2RSTR_DAC4RST RCC_AHB2RSTR_DAC4RST_Msk
#define RCC_AHB2RSTR_RNGRST_Pos (26U)
#define RCC_AHB2RSTR_RNGRST_Msk (0x1UL << RCC_AHB2RSTR_RNGRST_Pos)
#define RCC_AHB2RSTR_RNGRST RCC_AHB2RSTR_RNGRST_Msk

/********************  Bit definition for RCC_AHB3RSTR register  **************/
#define RCC_AHB3RSTR_FMCRST_Pos (0U)
#define RCC_AHB3RSTR_FMCRST_Msk (0x1UL << RCC_AHB3RSTR_FMCRST_Pos)
#define RCC_AHB3RSTR_FMCRST RCC_AHB3RSTR_FMCRST_Msk
#define RCC_AHB3RSTR_QSPIRST_Pos (8U)
#define RCC_AHB3RSTR_QSPIRST_Msk (0x1UL << RCC_AHB3RSTR_QSPIRST_Pos)
#define RCC_AHB3RSTR_QSPIRST RCC_AHB3RSTR_QSPIRST_Msk

/********************  Bit definition for RCC_APB1RSTR1 register  **************/
#define RCC_APB1RSTR1_TIM2RST_Pos (0U)
#define RCC_APB1RSTR1_TIM2RST_Msk (0x1UL << RCC_APB1RSTR1_TIM2RST_Pos)
#define RCC_APB1RSTR1_TIM2RST RCC_APB1RSTR1_TIM2RST_Msk
#define RCC_APB1RSTR1_TIM3RST_Pos (1U)
#define RCC_APB1RSTR1_TIM3RST_Msk (0x1UL << RCC_APB1RSTR1_TIM3RST_Pos)
#define RCC_APB1RSTR1_TIM3RST RCC_APB1RSTR1_TIM3RST_Msk
#define RCC_APB1RSTR1_TIM4RST_Pos (2U)
#define RCC_APB1RSTR1_TIM4RST_Msk (0x1UL << RCC_APB1RSTR1_TIM4RST_Pos)
#define RCC_APB1RSTR1_TIM4RST RCC_APB1RSTR1_TIM4RST_Msk
#define RCC_APB1RSTR1_TIM5RST_Pos (3U)
#define RCC_APB1RSTR1_TIM5RST_Msk (0x1UL << RCC_APB1RSTR1_TIM5RST_Pos)
#define RCC_APB1RSTR1_TIM5RST RCC_APB1RSTR1_TIM5RST_Msk
#define RCC_APB1RSTR1_TIM6RST_Pos (4U)
#define RCC_APB1RSTR1_TIM6RST_Msk (0x1UL << RCC_APB1RSTR1_TIM6RST_Pos)
#define RCC_APB1RSTR1_TIM6RST RCC_APB1RSTR1_TIM6RST_Msk
#define RCC_APB1RSTR1_TIM7RST_Pos (5U)
#define RCC_APB1RSTR1_TIM7RST_Msk (0x1UL << RCC_APB1RSTR1_TIM7RST_Pos)
#define RCC_APB1RSTR1_TIM7RST RCC_APB1RSTR1_TIM7RST_Msk
#define RCC_APB1RSTR1_CRSRST_Pos (8U)
#define RCC_APB1RSTR1_CRSRST_Msk (0x1UL << RCC_APB1RSTR1_CRSRST_Pos)
#define RCC_APB1RSTR1_CRSRST RCC_APB1RSTR1_CRSRST_Msk
#define RCC_APB1RSTR1_SPI2RST_Pos (14U)
#define RCC_APB1RSTR1_SPI2RST_Msk (0x1UL << RCC_APB1RSTR1_SPI2RST_Pos)
#define RCC_APB1RSTR1_SPI2RST RCC_APB1RSTR1_SPI2RST_Msk
#define RCC_APB1RSTR1_SPI3RST_Pos (15U)
#define RCC_APB1RSTR1_SPI3RST_Msk (0x1UL << RCC_APB1RSTR1_SPI3RST_Pos)
#define RCC_APB1RSTR1_SPI3RST RCC_APB1RSTR1_SPI3RST_Msk
#define RCC_APB1RSTR1_USART2RST_Pos (17U)
#define RCC_APB1RSTR1_USART2RST_Msk (0x1UL << RCC_APB1RSTR1_USART2RST_Pos)
#define RCC_APB1RSTR1_USART2RST RCC_APB1RSTR1_USART2RST_Msk
#define RCC_APB1RSTR1_USART3RST_Pos (18U)
#define RCC_APB1RSTR1_USART3RST_Msk (0x1UL << RCC_APB1RSTR1_USART3RST_Pos)
#define RCC_APB1RSTR1_USART3RST RCC_APB1RSTR1_USART3RST_Msk
#define RCC_APB1RSTR1_UART4RST_Pos (19U)
#define RCC_APB1RSTR1_UART4RST_Msk (0x1UL << RCC_APB1RSTR1_UART4RST_Pos)
#define RCC_APB1RSTR1_UART4RST RCC_APB1RSTR1_UART4RST_Msk
#define RCC_APB1RSTR1_UART5RST_Pos (20U)
#define RCC_APB1RSTR1_UART5RST_Msk (0x1UL << RCC_APB1RSTR1_UART5RST_Pos)
#define RCC_APB1RSTR1_UART5RST RCC_APB1RSTR1_UART5RST_Msk
#define RCC_APB1RSTR1_I2C1RST_Pos (21U)
#define RCC_APB1RSTR1_I2C1RST_Msk (0x1UL << RCC_APB1RSTR1_I2C1RST_Pos)
#define RCC_APB1RSTR1_I2C1RST RCC_APB1RSTR1_I2C1RST_Msk
#define RCC_APB1RSTR1_I2C2RST_Pos (22U)
#define RCC_APB1RSTR1_I2C2RST_Msk (0x1UL << RCC_APB1RSTR1_I2C2RST_Pos)
#define RCC_APB1RSTR1_I2C2RST RCC_APB1RSTR1_I2C2RST_Msk
#define RCC_APB1RSTR1_USBRST_Pos (23U)
#define RCC_APB1RSTR1_USBRST_Msk (0x1UL << RCC_APB1RSTR1_USBRST_Pos)
#define RCC_APB1RSTR1_USBRST RCC_APB1RSTR1_USBRST_Msk
#define RCC_APB1RSTR1_FDCANRST_Pos (25U)
#define RCC_APB1RSTR1_FDCANRST_Msk (0x1UL << RCC_APB1RSTR1_FDCANRST_Pos)
#define RCC_APB1RSTR1_FDCANRST RCC_APB1RSTR1_FDCANRST_Msk
#define RCC_APB1RSTR1_PWRRST_Pos (28U)
#define RCC_APB1RSTR1_PWRRST_Msk (0x1UL << RCC_APB1RSTR1_PWRRST_Pos)
#define RCC_APB1RSTR1_PWRRST RCC_APB1RSTR1_PWRRST_Msk
#define RCC_APB1RSTR1_I2C3RST_Pos (30U)
#define RCC_APB1RSTR1_I2C3RST_Msk (0x1UL << RCC_APB1RSTR1_I2C3RST_Pos)
#define RCC_APB1RSTR1_I2C3RST RCC_APB1RSTR1_I2C3RST_Msk
#define RCC_APB1RSTR1_LPTIM1RST_Pos (31U)
#define RCC_APB1RSTR1_LPTIM1RST_Msk (0x1UL << RCC_APB1RSTR1_LPTIM1RST_Pos)
#define RCC_APB1RSTR1_LPTIM1RST RCC_APB1RSTR1_LPTIM1RST_Msk

/********************  Bit definition for RCC_APB1RSTR2 register  **************/
#define RCC_APB1RSTR2_LPUART1RST_Pos (0U)
#define RCC_APB1RSTR2_LPUART1RST_Msk (0x1UL << RCC_APB1RSTR2_LPUART1RST_Pos)
#define RCC_APB1RSTR2_LPUART1RST RCC_APB1RSTR2_LPUART1RST_Msk
#define RCC_APB1RSTR2_I2C4RST_Pos (1U)
#define RCC_APB1RSTR2_I2C4RST_Msk (0x1UL << RCC_APB1RSTR2_I2C4RST_Pos)
#define RCC_APB1RSTR2_I2C4RST RCC_APB1RSTR2_I2C4RST_Msk
#define RCC_APB1RSTR2_UCPD1RST_Pos (8U)
#define RCC_APB1RSTR2_UCPD1RST_Msk (0x1UL << RCC_APB1RSTR2_UCPD1RST_Pos)
#define RCC_APB1RSTR2_UCPD1RST RCC_APB1RSTR2_UCPD1RST_Msk

/********************  Bit definition for RCC_APB2RSTR register  **************/
#define RCC_APB2RSTR_SYSCFGRST_Pos (0U)
#define RCC_APB2RSTR_SYSCFGRST_Msk (0x1UL << RCC_APB2RSTR_SYSCFGRST_Pos)
#define RCC_APB2RSTR_SYSCFGRST RCC_APB2RSTR_SYSCFGRST_Msk
#define RCC_APB2RSTR_TIM1RST_Pos (11U)
#define RCC_APB2RSTR_TIM1RST_Msk (0x1UL << RCC_APB2RSTR_TIM1RST_Pos)
#define RCC_APB2RSTR_TIM1RST RCC_APB2RSTR_TIM1RST_Msk
#define RCC_APB2RSTR_SPI1RST_Pos (12U)
#define RCC_APB2RSTR_SPI1RST_Msk (0x1UL << RCC_APB2RSTR_SPI1RST_Pos)
#define RCC_APB2RSTR_SPI1RST RCC_APB2RSTR_SPI1RST_Msk
#define RCC_APB2RSTR_TIM8RST_Pos (13U)
#define RCC_APB2RSTR_TIM8RST_Msk (0x1UL << RCC_APB2RSTR_TIM8RST_Pos)
#define RCC_APB2RSTR_TIM8RST RCC_APB2RSTR_TIM8RST_Msk
#define RCC_APB2RSTR_USART1RST_Pos (14U)
#define RCC_APB2RSTR_USART1RST_Msk (0x1UL << RCC_APB2RSTR_USART1RST_Pos)
#define RCC_APB2RSTR_USART1RST RCC_APB2RSTR_USART1RST_Msk
#define RCC_APB2RSTR_SPI4RST_Pos (15U)
#define RCC_APB2RSTR_SPI4RST_Msk (0x1UL << RCC_APB2RSTR_SPI4RST_Pos)
#define RCC_APB2RSTR_SPI4RST RCC_APB2RSTR_SPI4RST_Msk
#define RCC_APB2RSTR_TIM15RST_Pos (16U)
#define RCC_APB2RSTR_TIM15RST_Msk (0x1UL << RCC_APB2RSTR_TIM15RST_Pos)
#define RCC_APB2RSTR_TIM15RST RCC_APB2RSTR_TIM15RST_Msk
#define RCC_APB2RSTR_TIM16RST_Pos (17U)
#define RCC_APB2RSTR_TIM16RST_Msk (0x1UL << RCC_APB2RSTR_TIM16RST_Pos)
#define RCC_APB2RSTR_TIM16RST RCC_APB2RSTR_TIM16RST_Msk
#define RCC_APB2RSTR_TIM17RST_Pos (18U)
#define RCC_APB2RSTR_TIM17RST_Msk (0x1UL << RCC_APB2RSTR_TIM17RST_Pos)
#define RCC_APB2RSTR_TIM17RST RCC_APB2RSTR_TIM17RST_Msk
#define RCC_APB2RSTR_TIM20RST_Pos (20U)
#define RCC_APB2RSTR_TIM20RST_Msk (0x1UL << RCC_APB2RSTR_TIM20RST_Pos)
#define RCC_APB2RSTR_TIM20RST RCC_APB2RSTR_TIM20RST_Msk
#define RCC_APB2RSTR_SAI1RST_Pos (21U)
#define RCC_APB2RSTR_SAI1RST_Msk (0x1UL << RCC_APB2RSTR_SAI1RST_Pos)
#define RCC_APB2RSTR_SAI1RST RCC_APB2RSTR_SAI1RST_Msk

/********************  Bit definition for RCC_AHB1ENR register  ***************/
#define RCC_AHB1ENR_DMA1EN_Pos (0U)
#define RCC_AHB1ENR_DMA1EN_Msk (0x1UL << RCC_AHB1ENR_DMA1EN_Pos)
#define RCC_AHB1ENR_DMA1EN RCC_AHB1ENR_DMA1EN_Msk
#define RCC_AHB1ENR_DMA2EN_Pos (1U)
#define RCC_AHB1ENR_DMA2EN_Msk (0x1UL << RCC_AHB1ENR_DMA2EN_Pos)
#define RCC_AHB1ENR_DMA2EN RCC_AHB1ENR_DMA2EN_Msk
#define RCC_AHB1ENR_DMAMUX1EN_Pos (2U)
#define RCC_AHB1ENR_DMAMUX1EN_Msk (0x1UL << RCC_AHB1ENR_DMAMUX1EN_Pos)
#define RCC_AHB1ENR_DMAMUX1EN RCC_AHB1ENR_DMAMUX1EN_Msk
#define RCC_AHB1ENR_CORDICEN_Pos (3U)
#define RCC_AHB1ENR_CORDICEN_Msk (0x1UL << RCC_AHB1ENR_CORDICEN_Pos)
#define RCC_AHB1ENR_CORDICEN RCC_AHB1ENR_CORDICEN_Msk
#define RCC_AHB1ENR_FMACEN_Pos (4U)
#define RCC_AHB1ENR_FMACEN_Msk (0x1UL << RCC_AHB1ENR_FMACEN_Pos)
#define RCC_AHB1ENR_FMACEN RCC_AHB1ENR_FMACEN_Msk
#define RCC_AHB1ENR_FLASHEN_Pos (8U)
#define RCC_AHB1ENR_FLASHEN_Msk (0x1UL << RCC_AHB1ENR_FLASHEN_Pos)
#define RCC_AHB1ENR_FLASHEN RCC_AHB1ENR_FLASHEN_Msk
#define RCC_AHB1ENR_CRCEN_Pos (12U)
#define RCC_AHB1ENR_CRCEN_Msk (0x1UL << RCC_AHB1ENR_CRCEN_Pos)
#define RCC_AHB1ENR_CRCEN RCC_AHB1ENR_CRCEN_Msk

/********************  Bit definition for RCC_AHB2ENR register  ***************/
#define RCC_AHB2ENR_GPIOAEN_Pos (0U)
#define RCC_AHB2ENR_GPIOAEN_Msk (0x1UL << RCC_AHB2ENR_GPIOAEN_Pos)
#define RCC_AHB2ENR_GPIOAEN RCC_AHB2ENR_GPIOAEN_Msk
#define RCC_AHB2ENR_GPIOBEN_Pos (1U)
#define RCC_AHB2ENR_GPIOBEN_Msk (0x1UL << RCC_AHB2ENR_GPIOBEN_Pos)
#define RCC_AHB2ENR_GPIOBEN RCC_AHB2ENR_GPIOBEN_Msk
#define RCC_AHB2ENR_GPIOCEN_Pos (2U)
#define RCC_AHB2ENR_GPIOCEN_Msk (0x1UL << RCC_AHB2ENR_GPIOCEN_Pos)
#define RCC_AHB2ENR_GPIOCEN RCC_AHB2ENR_GPIOCEN_Msk
#define RCC_AHB2ENR_GPIODEN_Pos (3U)
#define RCC_AHB2ENR_GPIODEN_Msk (0x1UL << RCC_AHB2ENR_GPIODEN_Pos)
#define RCC_AHB2ENR_GPIODEN RCC_AHB2ENR_GPIODEN_Msk
#define RCC_AHB2ENR_GPIOEEN_Pos (4U)
#define RCC_AHB2ENR_GPIOEEN_Msk (0x1UL << RCC_AHB2ENR_GPIOEEN_Pos)
#define RCC_AHB2ENR_GPIOEEN RCC_AHB2ENR_GPIOEEN_Msk
#define RCC_AHB2ENR_GPIOFEN_Pos (5U)
#define RCC_AHB2ENR_GPIOFEN_Msk (0x1UL << RCC_AHB2ENR_GPIOFEN_Pos)
#define RCC_AHB2ENR_GPIOFEN RCC_AHB2ENR_GPIOFEN_Msk
#define RCC_AHB2ENR_GPIOGEN_Pos (6U)
#define RCC_AHB2ENR_GPIOGEN_Msk (0x1UL << RCC_AHB2ENR_GPIOGEN_Pos)
#define RCC_AHB2ENR_GPIOGEN RCC_AHB2ENR_GPIOGEN_Msk
#define RCC_AHB2ENR_ADC12EN_Pos (13U)
#define RCC_AHB2ENR_ADC12EN_Msk (0x1UL << RCC_AHB2ENR_ADC12EN_Pos)
#define RCC_AHB2ENR_ADC12EN RCC_AHB2ENR_ADC12EN_Msk
#define RCC_AHB2ENR_ADC345EN_Pos (14U)
#define RCC_AHB2ENR_ADC345EN_Msk (0x1UL << RCC_AHB2ENR_ADC345EN_Pos)
#define RCC_AHB2ENR_ADC345EN RCC_AHB2ENR_ADC345EN_Msk
#define RCC_AHB2ENR_DAC1EN_Pos (16U)
#define RCC_AHB2ENR_DAC1EN_Msk (0x1UL << RCC_AHB2ENR_DAC1EN_Pos)
#define RCC_AHB2ENR_DAC1EN RCC_AHB2ENR_DAC1EN_Msk
#define RCC_AHB2ENR_DAC2EN_Pos (17U)
#define RCC_AHB2ENR_DAC2EN_Msk (0x1UL << RCC_AHB2ENR_DAC2EN_Pos)
#define RCC_AHB2ENR_DAC2EN RCC_AHB2ENR_DAC2EN_Msk
#define RCC_AHB2ENR_DAC3EN_Pos (18U)
#define RCC_AHB2ENR_DAC3EN_Msk (0x1UL << RCC_AHB2ENR_DAC3EN_Pos)
#define RCC_AHB2ENR_DAC3EN RCC_AHB2ENR_DAC3EN_Msk
#define RCC_AHB2ENR_DAC4EN_Pos (19U)
#define RCC_AHB2ENR_DAC4EN_Msk (0x1UL << RCC_AHB2ENR_DAC4EN_Pos)
#define RCC_AHB2ENR_DAC4EN RCC_AHB2ENR_DAC4EN_Msk
#define RCC_AHB2ENR_RNGEN_Pos (26U)
#define RCC_AHB2ENR_RNGEN_Msk (0x1UL << RCC_AHB2ENR_RNGEN_Pos)
#define RCC_AHB2ENR_RNGEN RCC_AHB2ENR_RNGEN_Msk

/********************  Bit definition for RCC_AHB3ENR register  ***************/
#define RCC_AHB3ENR_FMCEN_Pos (0U)
#define RCC_AHB3ENR_FMCEN_Msk (0x1UL << RCC_AHB3ENR_FMCEN_Pos)
#define RCC_AHB3ENR_FMCEN RCC_AHB3ENR_FMCEN_Msk
#define RCC_AHB3ENR_QSPIEN_Pos (8U)
#define RCC_AHB3ENR_QSPIEN_Msk (0x1UL << RCC_AHB3ENR_QSPIEN_Pos)
#define RCC_AHB3ENR_QSPIEN RCC_AHB3ENR_QSPIEN_Msk

/********************  Bit definition for RCC_APB1ENR1 register  ***************/
#define RCC_APB1ENR1_TIM2EN_Pos (0U)
#define RCC_APB1ENR1_TIM2EN_Msk (0x1UL << RCC_APB1ENR1_TIM2EN_Pos)
#define RCC_APB1ENR1_TIM2EN RCC_APB1ENR1_TIM2EN_Msk
#define RCC_APB1ENR1_TIM3EN_Pos (1U)
#define RCC_APB1ENR1_TIM3EN_Msk (0x1UL << RCC_APB1ENR1_TIM3EN_Pos)
#define RCC_APB1ENR1_TIM3EN RCC_APB1ENR1_TIM3EN_Msk
#define RCC_APB1ENR1_TIM4EN_Pos (2U)
#define RCC_APB1ENR1_TIM4EN_Msk (0x1UL << RCC_APB1ENR1_TIM4EN_Pos)
#define RCC_APB1ENR1_TIM4EN RCC_APB1ENR1_TIM4EN_Msk
#define RCC_APB1ENR1_TIM5EN_Pos (3U)
#define RCC_APB1ENR1_TIM5EN_Msk (0x1UL << RCC_APB1ENR1_TIM5EN_Pos)
#define RCC_APB1ENR1_TIM5EN RCC_APB1ENR1_TIM5EN_Msk
#define RCC_APB1ENR1_TIM6EN_Pos (4U)
#define RCC_APB1ENR1_TIM6EN_Msk (0x1UL << RCC_APB1ENR1_TIM6EN_Pos)
#define RCC_APB1ENR1_TIM6EN RCC_APB1ENR1_TIM6EN_Msk
#define RCC_APB1ENR1_TIM7EN_Pos (5U)
#define RCC_APB1ENR1_TIM7EN_Msk (0x1UL << RCC_APB1ENR1_TIM7EN_Pos)
#define RCC_APB1ENR1_TIM7EN RCC_APB1ENR1_TIM7EN_Msk
#define RCC_APB1ENR1_CRSEN_Pos (8U)
#define RCC_APB1ENR1_CRSEN_Msk (0x1UL << RCC_APB1ENR1_CRSEN_Pos)
#define RCC_APB1ENR1_CRSEN RCC_APB1ENR1_CRSEN_Msk
#define RCC_APB1ENR1_RTCAPBEN_Pos (10U)
#define RCC_APB1ENR1_RTCAPBEN_Msk (0x1UL << RCC_APB1ENR1_RTCAPBEN_Pos)
#define RCC_APB1ENR1_RTCAPBEN RCC_APB1ENR1_RTCAPBEN_Msk
#define RCC_APB1ENR1_WWDGEN_Pos (11U)
#define RCC_APB1ENR1_WWDGEN_Msk (0x1UL << RCC_APB1ENR1_WWDGEN_Pos)
#define RCC_APB1ENR1_WWDGEN RCC_APB1ENR1_WWDGEN_Msk
#define RCC_APB1ENR1_SPI2EN_Pos (14U)
#define RCC_APB1ENR1_SPI2EN_Msk (0x1UL << RCC_APB1ENR1_SPI2EN_Pos)
#define RCC_APB1ENR1_SPI2EN RCC_APB1ENR1_SPI2EN_Msk
#define RCC_APB1ENR1_SPI3EN_Pos (15U)
#define RCC_APB1ENR1_SPI3EN_Msk (0x1UL << RCC_APB1ENR1_SPI3EN_Pos)
#define RCC_APB1ENR1_SPI3EN RCC_APB1ENR1_SPI3EN_Msk
#define RCC_APB1ENR1_USART2EN_Pos (17U)
#define RCC_APB1ENR1_USART2EN_Msk (0x1UL << RCC_APB1ENR1_USART2EN_Pos)
#define RCC_APB1ENR1_USART2EN RCC_APB1ENR1_USART2EN_Msk
#define RCC_APB1ENR1_USART3EN_Pos (18U)
#define RCC_APB1ENR1_USART3EN_Msk (0x1UL << RCC_APB1ENR1_USART3EN_Pos)
#define RCC_APB1ENR1_USART3EN RCC_APB1ENR1_USART3EN_Msk
#define RCC_APB1ENR1_UART4EN_Pos (19U)
#define RCC_APB1ENR1_UART4EN_Msk (0x1UL << RCC_APB1ENR1_UART4EN_Pos)
#define RCC_APB1ENR1_UART4EN RCC_APB1ENR1_UART4EN_Msk
#define RCC_APB1ENR1_UART5EN_Pos (20U)
#define RCC_APB1ENR1_UART5EN_Msk (0x1UL << RCC_APB1ENR1_UART5EN_Pos)
#define RCC_APB1ENR1_UART5EN RCC_APB1ENR1_UART5EN_Msk
#define RCC_APB1ENR1_I2C1EN_Pos (21U)
#define RCC_APB1ENR1_I2C1EN_Msk (0x1UL << RCC_APB1ENR1_I2C1EN_Pos)
#define RCC_APB1ENR1_I2C1EN RCC_APB1ENR1_I2C1EN_Msk
#define RCC_APB1ENR1_I2C2EN_Pos (22U)
#define RCC_APB1ENR1_I2C2EN_Msk (0x1UL << RCC_APB1ENR1_I2C2EN_Pos)
#define RCC_APB1ENR1_I2C2EN RCC_APB1ENR1_I2C2EN_Msk
#define RCC_APB1ENR1_USBEN_Pos (23U)
#define RCC_APB1ENR1_USBEN_Msk (0x1UL << RCC_APB1ENR1_USBEN_Pos)
#define RCC_APB1ENR1_USBEN RCC_APB1ENR1_USBEN_Msk
#define RCC_APB1ENR1_FDCANEN_Pos (25U)
#define RCC_APB1ENR1_FDCANEN_Msk (0x1UL << RCC_APB1ENR1_FDCANEN_Pos)
#define RCC_APB1ENR1_FDCANEN RCC_APB1ENR1_FDCANEN_Msk
#define RCC_APB1ENR1_PWREN_Pos (28U)
#define RCC_APB1ENR1_PWREN_Msk (0x1UL << RCC_APB1ENR1_PWREN_Pos)
#define RCC_APB1ENR1_PWREN RCC_APB1ENR1_PWREN_Msk
#define RCC_APB1ENR1_I2C3EN_Pos (30U)
#define RCC_APB1ENR1_I2C3EN_Msk (0x1UL << RCC_APB1ENR1_I2C3EN_Pos)
#define RCC_APB1ENR1_I2C3EN RCC_APB1ENR1_I2C3EN_Msk
#define RCC_APB1ENR1_LPTIM1EN_Pos (31U)
#define RCC_APB1ENR1_LPTIM1EN_Msk (0x1UL << RCC_APB1ENR1_LPTIM1EN_Pos)
#define RCC_APB1ENR1_LPTIM1EN RCC_APB1ENR1_LPTIM1EN_Msk

/********************  Bit definition for RCC_APB1RSTR2 register  **************/
#define RCC_APB1ENR2_LPUART1EN_Pos (0U)
#define RCC_APB1ENR2_LPUART1EN_Msk (0x1UL << RCC_APB1ENR2_LPUART1EN_Pos)
#define RCC_APB1ENR2_LPUART1EN RCC_APB1ENR2_LPUART1EN_Msk
#define RCC_APB1ENR2_I2C4EN_Pos (1U)
#define RCC_APB1ENR2_I2C4EN_Msk (0x1UL << RCC_APB1ENR2_I2C4EN_Pos)
#define RCC_APB1ENR2_I2C4EN RCC_APB1ENR2_I2C4EN_Msk
#define RCC_APB1ENR2_UCPD1EN_Pos (8U)
#define RCC_APB1ENR2_UCPD1EN_Msk (0x1UL << RCC_APB1ENR2_UCPD1EN_Pos)
#define RCC_APB1ENR2_UCPD1EN RCC_APB1ENR2_UCPD1EN_Msk

/********************  Bit definition for RCC_APB2ENR register  ***************/
#define RCC_APB2ENR_SYSCFGEN_Pos (0U)
#define RCC_APB2ENR_SYSCFGEN_Msk (0x1UL << RCC_APB2ENR_SYSCFGEN_Pos)
#define RCC_APB2ENR_SYSCFGEN RCC_APB2ENR_SYSCFGEN_Msk
#define RCC_APB2ENR_TIM1EN_Pos (11U)
#define RCC_APB2ENR_TIM1EN_Msk (0x1UL << RCC_APB2ENR_TIM1EN_Pos)
#define RCC_APB2ENR_TIM1EN RCC_APB2ENR_TIM1EN_Msk
#define RCC_APB2ENR_SPI1EN_Pos (12U)
#define RCC_APB2ENR_SPI1EN_Msk (0x1UL << RCC_APB2ENR_SPI1EN_Pos)
#define RCC_APB2ENR_SPI1EN RCC_APB2ENR_SPI1EN_Msk
#define RCC_APB2ENR_TIM8EN_Pos (13U)
#define RCC_APB2ENR_TIM8EN_Msk (0x1UL << RCC_APB2ENR_TIM8EN_Pos)
#define RCC_APB2ENR_TIM8EN RCC_APB2ENR_TIM8EN_Msk
#define RCC_APB2ENR_USART1EN_Pos (14U)
#define RCC_APB2ENR_USART1EN_Msk (0x1UL << RCC_APB2ENR_USART1EN_Pos)
#define RCC_APB2ENR_USART1EN RCC_APB2ENR_USART1EN_Msk
#define RCC_APB2ENR_SPI4EN_Pos (15U)
#define RCC_APB2ENR_SPI4EN_Msk (0x1UL << RCC_APB2ENR_SPI4EN_Pos)
#define RCC_APB2ENR_SPI4EN RCC_APB2ENR_SPI4EN_Msk
#define RCC_APB2ENR_TIM15EN_Pos (16U)
#define RCC_APB2ENR_TIM15EN_Msk (0x1UL << RCC_APB2ENR_TIM15EN_Pos)
#define RCC_APB2ENR_TIM15EN RCC_APB2ENR_TIM15EN_Msk
#define RCC_APB2ENR_TIM16EN_Pos (17U)
#define RCC_APB2ENR_TIM16EN_Msk (0x1UL << RCC_APB2ENR_TIM16EN_Pos)
#define RCC_APB2ENR_TIM16EN RCC_APB2ENR_TIM16EN_Msk
#define RCC_APB2ENR_TIM17EN_Pos (18U)
#define RCC_APB2ENR_TIM17EN_Msk (0x1UL << RCC_APB2ENR_TIM17EN_Pos)
#define RCC_APB2ENR_TIM17EN RCC_APB2ENR_TIM17EN_Msk
#define RCC_APB2ENR_TIM20EN_Pos (20U)
#define RCC_APB2ENR_TIM20EN_Msk (0x1UL << RCC_APB2ENR_TIM20EN_Pos)
#define RCC_APB2ENR_TIM20EN RCC_APB2ENR_TIM20EN_Msk
#define RCC_APB2ENR_SAI1EN_Pos (21U)
#define RCC_APB2ENR_SAI1EN_Msk (0x1UL << RCC_APB2ENR_SAI1EN_Pos)
#define RCC_APB2ENR_SAI1EN RCC_APB2ENR_SAI1EN_Msk

/********************  Bit definition for RCC_AHB1SMENR register  ***************/
#define RCC_AHB1SMENR_DMA1SMEN_Pos (0U)
#define RCC_AHB1SMENR_DMA1SMEN_Msk (0x1UL << RCC_AHB1SMENR_DMA1SMEN_Pos)
#define RCC_AHB1SMENR_DMA1SMEN RCC_AHB1SMENR_DMA1SMEN_Msk
#define RCC_AHB1SMENR_DMA2SMEN_Pos (1U)
#define RCC_AHB1SMENR_DMA2SMEN_Msk (0x1UL << RCC_AHB1SMENR_DMA2SMEN_Pos)
#define RCC_AHB1SMENR_DMA2SMEN RCC_AHB1SMENR_DMA2SMEN_Msk
#define RCC_AHB1SMENR_DMAMUX1SMEN_Pos (2U)
#define RCC_AHB1SMENR_DMAMUX1SMEN_Msk (0x1UL << RCC_AHB1SMENR_DMAMUX1SMEN_Pos)
#define RCC_AHB1SMENR_DMAMUX1SMEN RCC_AHB1SMENR_DMAMUX1SMEN_Msk
#define RCC_AHB1SMENR_CORDICSMEN_Pos (3U)
#define RCC_AHB1SMENR_CORDICSMEN_Msk (0x1UL << RCC_AHB1SMENR_CORDICSMEN_Pos)
#define RCC_AHB1SMENR_CORDICSMEN RCC_AHB1SMENR_CORDICSMEN_Msk
#define RCC_AHB1SMENR_FMACSMEN_Pos (4U)
#define RCC_AHB1SMENR_FMACSMEN_Msk (0x1UL << RCC_AHB1SMENR_FMACSMEN_Pos)
#define RCC_AHB1SMENR_FMACSMEN RCC_AHB1SMENR_FMACSMEN_Msk
#define RCC_AHB1SMENR_FLASHSMEN_Pos (8U)
#define RCC_AHB1SMENR_FLASHSMEN_Msk (0x1UL << RCC_AHB1SMENR_FLASHSMEN_Pos)
#define RCC_AHB1SMENR_FLASHSMEN RCC_AHB1SMENR_FLASHSMEN_Msk
#define RCC_AHB1SMENR_SRAM1SMEN_Pos (9U)
#define RCC_AHB1SMENR_SRAM1SMEN_Msk (0x1UL << RCC_AHB1SMENR_SRAM1SMEN_Pos)
#define RCC_AHB1SMENR_SRAM1SMEN RCC_AHB1SMENR_SRAM1SMEN_Msk
#define RCC_AHB1SMENR_CRCSMEN_Pos (12U)
#define RCC_AHB1SMENR_CRCSMEN_Msk (0x1UL << RCC_AHB1SMENR_CRCSMEN_Pos)
#define RCC_AHB1SMENR_CRCSMEN RCC_AHB1SMENR_CRCSMEN_Msk

/********************  Bit definition for RCC_AHB2SMENR register  *************/
#define RCC_AHB2SMENR_GPIOASMEN_Pos (0U)
#define RCC_AHB2SMENR_GPIOASMEN_Msk (0x1UL << RCC_AHB2SMENR_GPIOASMEN_Pos)
#define RCC_AHB2SMENR_GPIOASMEN RCC_AHB2SMENR_GPIOASMEN_Msk
#define RCC_AHB2SMENR_GPIOBSMEN_Pos (1U)
#define RCC_AHB2SMENR_GPIOBSMEN_Msk (0x1UL << RCC_AHB2SMENR_GPIOBSMEN_Pos)
#define RCC_AHB2SMENR_GPIOBSMEN RCC_AHB2SMENR_GPIOBSMEN_Msk
#define RCC_AHB2SMENR_GPIOCSMEN_Pos (2U)
#define RCC_AHB2SMENR_GPIOCSMEN_Msk (0x1UL << RCC_AHB2SMENR_GPIOCSMEN_Pos)
#define RCC_AHB2SMENR_GPIOCSMEN RCC_AHB2SMENR_GPIOCSMEN_Msk
#define RCC_AHB2SMENR_GPIODSMEN_Pos (3U)
#define RCC_AHB2SMENR_GPIODSMEN_Msk (0x1UL << RCC_AHB2SMENR_GPIODSMEN_Pos)
#define RCC_AHB2SMENR_GPIODSMEN RCC_AHB2SMENR_GPIODSMEN_Msk
#define RCC_AHB2SMENR_GPIOESMEN_Pos (4U)
#define RCC_AHB2SMENR_GPIOESMEN_Msk (0x1UL << RCC_AHB2SMENR_GPIOESMEN_Pos)
#define RCC_AHB2SMENR_GPIOESMEN RCC_AHB2SMENR_GPIOESMEN_Msk
#define RCC_AHB2SMENR_GPIOFSMEN_Pos (5U)
#define RCC_AHB2SMENR_GPIOFSMEN_Msk (0x1UL << RCC_AHB2SMENR_GPIOFSMEN_Pos)
#define RCC_AHB2SMENR_GPIOFSMEN RCC_AHB2SMENR_GPIOFSMEN_Msk
#define RCC_AHB2SMENR_GPIOGSMEN_Pos (6U)
#define RCC_AHB2SMENR_GPIOGSMEN_Msk (0x1UL << RCC_AHB2SMENR_GPIOGSMEN_Pos)
#define RCC_AHB2SMENR_GPIOGSMEN RCC_AHB2SMENR_GPIOGSMEN_Msk
#define RCC_AHB2SMENR_CCMSRAMSMEN_Pos (9U)
#define RCC_AHB2SMENR_CCMSRAMSMEN_Msk (0x1UL << RCC_AHB2SMENR_CCMSRAMSMEN_Pos)
#define RCC_AHB2SMENR_CCMSRAMSMEN RCC_AHB2SMENR_CCMSRAMSMEN_Msk
#define RCC_AHB2SMENR_SRAM2SMEN_Pos (10U)
#define RCC_AHB2SMENR_SRAM2SMEN_Msk (0x1UL << RCC_AHB2SMENR_SRAM2SMEN_Pos)
#define RCC_AHB2SMENR_SRAM2SMEN RCC_AHB2SMENR_SRAM2SMEN_Msk
#define RCC_AHB2SMENR_ADC12SMEN_Pos (13U)
#define RCC_AHB2SMENR_ADC12SMEN_Msk (0x1UL << RCC_AHB2SMENR_ADC12SMEN_Pos)
#define RCC_AHB2SMENR_ADC12SMEN RCC_AHB2SMENR_ADC12SMEN_Msk
#define RCC_AHB2SMENR_ADC345SMEN_Pos (14U)
#define RCC_AHB2SMENR_ADC345SMEN_Msk (0x1UL << RCC_AHB2SMENR_ADC345SMEN_Pos)
#define RCC_AHB2SMENR_ADC345SMEN RCC_AHB2SMENR_ADC345SMEN_Msk
#define RCC_AHB2SMENR_DAC1SMEN_Pos (16U)
#define RCC_AHB2SMENR_DAC1SMEN_Msk (0x1UL << RCC_AHB2SMENR_DAC1SMEN_Pos)
#define RCC_AHB2SMENR_DAC1SMEN RCC_AHB2SMENR_DAC1SMEN_Msk
#define RCC_AHB2SMENR_DAC2SMEN_Pos (17U)
#define RCC_AHB2SMENR_DAC2SMEN_Msk (0x1UL << RCC_AHB2SMENR_DAC2SMEN_Pos)
#define RCC_AHB2SMENR_DAC2SMEN RCC_AHB2SMENR_DAC2SMEN_Msk
#define RCC_AHB2SMENR_DAC3SMEN_Pos (18U)
#define RCC_AHB2SMENR_DAC3SMEN_Msk (0x1UL << RCC_AHB2SMENR_DAC3SMEN_Pos)
#define RCC_AHB2SMENR_DAC3SMEN RCC_AHB2SMENR_DAC3SMEN_Msk
#define RCC_AHB2SMENR_DAC4SMEN_Pos (19U)
#define RCC_AHB2SMENR_DAC4SMEN_Msk (0x1UL << RCC_AHB2SMENR_DAC4SMEN_Pos)
#define RCC_AHB2SMENR_DAC4SMEN RCC_AHB2SMENR_DAC4SMEN_Msk
#define RCC_AHB2SMENR_RNGSMEN_Pos (26U)
#define RCC_AHB2SMENR_RNGSMEN_Msk (0x1UL << RCC_AHB2SMENR_RNGSMEN_Pos)
#define RCC_AHB2SMENR_RNGSMEN RCC_AHB2SMENR_RNGSMEN_Msk

/********************  Bit definition for RCC_AHB3SMENR register  *************/
#define RCC_AHB3SMENR_FMCSMEN_Pos (0U)
#define RCC_AHB3SMENR_FMCSMEN_Msk (0x1UL << RCC_AHB3SMENR_FMCSMEN_Pos)
#define RCC_AHB3SMENR_FMCSMEN RCC_AHB3SMENR_FMCSMEN_Msk
#define RCC_AHB3SMENR_QSPISMEN_Pos (8U)
#define RCC_AHB3SMENR_QSPISMEN_Msk (0x1UL << RCC_AHB3SMENR_QSPISMEN_Pos)
#define RCC_AHB3SMENR_QSPISMEN RCC_AHB3SMENR_QSPISMEN_Msk

/********************  Bit definition for RCC_APB1SMENR1 register  *************/
#define RCC_APB1SMENR1_TIM2SMEN_Pos (0U)
#define RCC_APB1SMENR1_TIM2SMEN_Msk (0x1UL << RCC_APB1SMENR1_TIM2SMEN_Pos)
#define RCC_APB1SMENR1_TIM2SMEN RCC_APB1SMENR1_TIM2SMEN_Msk
#define RCC_APB1SMENR1_TIM3SMEN_Pos (1U)
#define RCC_APB1SMENR1_TIM3SMEN_Msk (0x1UL << RCC_APB1SMENR1_TIM3SMEN_Pos)
#define RCC_APB1SMENR1_TIM3SMEN RCC_APB1SMENR1_TIM3SMEN_Msk
#define RCC_APB1SMENR1_TIM4SMEN_Pos (2U)
#define RCC_APB1SMENR1_TIM4SMEN_Msk (0x1UL << RCC_APB1SMENR1_TIM4SMEN_Pos)
#define RCC_APB1SMENR1_TIM4SMEN RCC_APB1SMENR1_TIM4SMEN_Msk
#define RCC_APB1SMENR1_TIM5SMEN_Pos (3U)
#define RCC_APB1SMENR1_TIM5SMEN_Msk (0x1UL << RCC_APB1SMENR1_TIM5SMEN_Pos)
#define RCC_APB1SMENR1_TIM5SMEN RCC_APB1SMENR1_TIM5SMEN_Msk
#define RCC_APB1SMENR1_TIM6SMEN_Pos (4U)
#define RCC_APB1SMENR1_TIM6SMEN_Msk (0x1UL << RCC_APB1SMENR1_TIM6SMEN_Pos)
#define RCC_APB1SMENR1_TIM6SMEN RCC_APB1SMENR1_TIM6SMEN_Msk
#define RCC_APB1SMENR1_TIM7SMEN_Pos (5U)
#define RCC_APB1SMENR1_TIM7SMEN_Msk (0x1UL << RCC_APB1SMENR1_TIM7SMEN_Pos)
#define RCC_APB1SMENR1_TIM7SMEN RCC_APB1SMENR1_TIM7SMEN_Msk
#define RCC_APB1SMENR1_CRSSMEN_Pos (8U)
#define RCC_APB1SMENR1_CRSSMEN_Msk (0x1UL << RCC_APB1SMENR1_CRSSMEN_Pos)
#define RCC_APB1SMENR1_CRSSMEN RCC_APB1SMENR1_CRSSMEN_Msk
#define RCC_APB1SMENR1_RTCAPBSMEN_Pos (10U)
#define RCC_APB1SMENR1_RTCAPBSMEN_Msk (0x1UL << RCC_APB1SMENR1_RTCAPBSMEN_Pos)
#define RCC_APB1SMENR1_RTCAPBSMEN RCC_APB1SMENR1_RTCAPBSMEN_Msk
#define RCC_APB1SMENR1_WWDGSMEN_Pos (11U)
#define RCC_APB1SMENR1_WWDGSMEN_Msk (0x1UL << RCC_APB1SMENR1_WWDGSMEN_Pos)
#define RCC_APB1SMENR1_WWDGSMEN RCC_APB1SMENR1_WWDGSMEN_Msk
#define RCC_APB1SMENR1_SPI2SMEN_Pos (14U)
#define RCC_APB1SMENR1_SPI2SMEN_Msk (0x1UL << RCC_APB1SMENR1_SPI2SMEN_Pos)
#define RCC_APB1SMENR1_SPI2SMEN RCC_APB1SMENR1_SPI2SMEN_Msk
#define RCC_APB1SMENR1_SPI3SMEN_Pos (15U)
#define RCC_APB1SMENR1_SPI3SMEN_Msk (0x1UL << RCC_APB1SMENR1_SPI3SMEN_Pos)
#define RCC_APB1SMENR1_SPI3SMEN RCC_APB1SMENR1_SPI3SMEN_Msk
#define RCC_APB1SMENR1_USART2SMEN_Pos (17U)
#define RCC_APB1SMENR1_USART2SMEN_Msk (0x1UL << RCC_APB1SMENR1_USART2SMEN_Pos)
#define RCC_APB1SMENR1_USART2SMEN RCC_APB1SMENR1_USART2SMEN_Msk
#define RCC_APB1SMENR1_USART3SMEN_Pos (18U)
#define RCC_APB1SMENR1_USART3SMEN_Msk (0x1UL << RCC_APB1SMENR1_USART3SMEN_Pos)
#define RCC_APB1SMENR1_USART3SMEN RCC_APB1SMENR1_USART3SMEN_Msk
#define RCC_APB1SMENR1_UART4SMEN_Pos (19U)
#define RCC_APB1SMENR1_UART4SMEN_Msk (0x1UL << RCC_APB1SMENR1_UART4SMEN_Pos)
#define RCC_APB1SMENR1_UART4SMEN RCC_APB1SMENR1_UART4SMEN_Msk
#define RCC_APB1SMENR1_UART5SMEN_Pos (20U)
#define RCC_APB1SMENR1_UART5SMEN_Msk (0x1UL << RCC_APB1SMENR1_UART5SMEN_Pos)
#define RCC_APB1SMENR1_UART5SMEN RCC_APB1SMENR1_UART5SMEN_Msk
#define RCC_APB1SMENR1_I2C1SMEN_Pos (21U)
#define RCC_APB1SMENR1_I2C1SMEN_Msk (0x1UL << RCC_APB1SMENR1_I2C1SMEN_Pos)
#define RCC_APB1SMENR1_I2C1SMEN RCC_APB1SMENR1_I2C1SMEN_Msk
#define RCC_APB1SMENR1_I2C2SMEN_Pos (22U)
#define RCC_APB1SMENR1_I2C2SMEN_Msk (0x1UL << RCC_APB1SMENR1_I2C2SMEN_Pos)
#define RCC_APB1SMENR1_I2C2SMEN RCC_APB1SMENR1_I2C2SMEN_Msk
#define RCC_APB1SMENR1_USBSMEN_Pos (23U)
#define RCC_APB1SMENR1_USBSMEN_Msk (0x1UL << RCC_APB1SMENR1_USBSMEN_Pos)
#define RCC_APB1SMENR1_USBSMEN RCC_APB1SMENR1_USBSMEN_Msk
#define RCC_APB1SMENR1_FDCANSMEN_Pos (25U)
#define RCC_APB1SMENR1_FDCANSMEN_Msk (0x1UL << RCC_APB1SMENR1_FDCANSMEN_Pos)
#define RCC_APB1SMENR1_FDCANSMEN RCC_APB1SMENR1_FDCANSMEN_Msk
#define RCC_APB1SMENR1_PWRSMEN_Pos (28U)
#define RCC_APB1SMENR1_PWRSMEN_Msk (0x1UL << RCC_APB1SMENR1_PWRSMEN_Pos)
#define RCC_APB1SMENR1_PWRSMEN RCC_APB1SMENR1_PWRSMEN_Msk
#define RCC_APB1SMENR1_I2C3SMEN_Pos (30U)
#define RCC_APB1SMENR1_I2C3SMEN_Msk (0x1UL << RCC_APB1SMENR1_I2C3SMEN_Pos)
#define RCC_APB1SMENR1_I2C3SMEN RCC_APB1SMENR1_I2C3SMEN_Msk
#define RCC_APB1SMENR1_LPTIM1SMEN_Pos (31U)
#define RCC_APB1SMENR1_LPTIM1SMEN_Msk (0x1UL << RCC_APB1SMENR1_LPTIM1SMEN_Pos)
#define RCC_APB1SMENR1_LPTIM1SMEN RCC_APB1SMENR1_LPTIM1SMEN_Msk

/********************  Bit definition for RCC_APB1SMENR2 register  *************/
#define RCC_APB1SMENR2_LPUART1SMEN_Pos (0U)
#define RCC_APB1SMENR2_LPUART1SMEN_Msk (0x1UL << RCC_APB1SMENR2_LPUART1SMEN_Pos)
#define RCC_APB1SMENR2_LPUART1SMEN RCC_APB1SMENR2_LPUART1SMEN_Msk
#define RCC_APB1SMENR2_I2C4SMEN_Pos (1U)
#define RCC_APB1SMENR2_I2C4SMEN_Msk (0x1UL << RCC_APB1SMENR2_I2C4SMEN_Pos)
#define RCC_APB1SMENR2_I2C4SMEN RCC_APB1SMENR2_I2C4SMEN_Msk
#define RCC_APB1SMENR2_UCPD1SMEN_Pos (8U)
#define RCC_APB1SMENR2_UCPD1SMEN_Msk (0x1UL << RCC_APB1SMENR2_UCPD1SMEN_Pos)
#define RCC_APB1SMENR2_UCPD1SMEN RCC_APB1SMENR2_UCPD1SMEN_Msk

/********************  Bit definition for RCC_APB2SMENR register  *************/
#define RCC_APB2SMENR_SYSCFGSMEN_Pos (0U)
#define RCC_APB2SMENR_SYSCFGSMEN_Msk (0x1UL << RCC_APB2SMENR_SYSCFGSMEN_Pos)
#define RCC_APB2SMENR_SYSCFGSMEN RCC_APB2SMENR_SYSCFGSMEN_Msk
#define RCC_APB2SMENR_TIM1SMEN_Pos (11U)
#define RCC_APB2SMENR_TIM1SMEN_Msk (0x1UL << RCC_APB2SMENR_TIM1SMEN_Pos)
#define RCC_APB2SMENR_TIM1SMEN RCC_APB2SMENR_TIM1SMEN_Msk
#define RCC_APB2SMENR_SPI1SMEN_Pos (12U)
#define RCC_APB2SMENR_SPI1SMEN_Msk (0x1UL << RCC_APB2SMENR_SPI1SMEN_Pos)
#define RCC_APB2SMENR_SPI1SMEN RCC_APB2SMENR_SPI1SMEN_Msk
#define RCC_APB2SMENR_TIM8SMEN_Pos (13U)
#define RCC_APB2SMENR_TIM8SMEN_Msk (0x1UL << RCC_APB2SMENR_TIM8SMEN_Pos)
#define RCC_APB2SMENR_TIM8SMEN RCC_APB2SMENR_TIM8SMEN_Msk
#define RCC_APB2SMENR_USART1SMEN_Pos (14U)
#define RCC_APB2SMENR_USART1SMEN_Msk (0x1UL << RCC_APB2SMENR_USART1SMEN_Pos)
#define RCC_APB2SMENR_USART1SMEN RCC_APB2SMENR_USART1SMEN_Msk
#define RCC_APB2SMENR_SPI4SMEN_Pos (15U)
#define RCC_APB2SMENR_SPI4SMEN_Msk (0x1UL << RCC_APB2SMENR_SPI4SMEN_Pos)
#define RCC_APB2SMENR_SPI4SMEN RCC_APB2SMENR_SPI4SMEN_Msk
#define RCC_APB2SMENR_TIM15SMEN_Pos (16U)
#define RCC_APB2SMENR_TIM15SMEN_Msk (0x1UL << RCC_APB2SMENR_TIM15SMEN_Pos)
#define RCC_APB2SMENR_TIM15SMEN RCC_APB2SMENR_TIM15SMEN_Msk
#define RCC_APB2SMENR_TIM16SMEN_Pos (17U)
#define RCC_APB2SMENR_TIM16SMEN_Msk (0x1UL << RCC_APB2SMENR_TIM16SMEN_Pos)
#define RCC_APB2SMENR_TIM16SMEN RCC_APB2SMENR_TIM16SMEN_Msk
#define RCC_APB2SMENR_TIM17SMEN_Pos (18U)
#define RCC_APB2SMENR_TIM17SMEN_Msk (0x1UL << RCC_APB2SMENR_TIM17SMEN_Pos)
#define RCC_APB2SMENR_TIM17SMEN RCC_APB2SMENR_TIM17SMEN_Msk
#define RCC_APB2SMENR_TIM20SMEN_Pos (20U)
#define RCC_APB2SMENR_TIM20SMEN_Msk (0x1UL << RCC_APB2SMENR_TIM20SMEN_Pos)
#define RCC_APB2SMENR_TIM20SMEN RCC_APB2SMENR_TIM20SMEN_Msk
#define RCC_APB2SMENR_SAI1SMEN_Pos (21U)
#define RCC_APB2SMENR_SAI1SMEN_Msk (0x1UL << RCC_APB2SMENR_SAI1SMEN_Pos)
#define RCC_APB2SMENR_SAI1SMEN RCC_APB2SMENR_SAI1SMEN_Msk

/********************  Bit definition for RCC_CCIPR register  ******************/
#define RCC_CCIPR_USART1SEL_Pos (0U)
#define RCC_CCIPR_USART1SEL_Msk (0x3UL << RCC_CCIPR_USART1SEL_Pos)
#define RCC_CCIPR_USART1SEL RCC_CCIPR_USART1SEL_Msk
#define RCC_CCIPR_USART1SEL_0 (0x1UL << RCC_CCIPR_USART1SEL_Pos)
#define RCC_CCIPR_USART1SEL_1 (0x2UL << RCC_CCIPR_USART1SEL_Pos)

#define RCC_CCIPR_USART2SEL_Pos (2U)
#define RCC_CCIPR_USART2SEL_Msk (0x3UL << RCC_CCIPR_USART2SEL_Pos)
#define RCC_CCIPR_USART2SEL RCC_CCIPR_USART2SEL_Msk
#define RCC_CCIPR_USART2SEL_0 (0x1UL << RCC_CCIPR_USART2SEL_Pos)
#define RCC_CCIPR_USART2SEL_1 (0x2UL << RCC_CCIPR_USART2SEL_Pos)

#define RCC_CCIPR_USART3SEL_Pos (4U)
#define RCC_CCIPR_USART3SEL_Msk (0x3UL << RCC_CCIPR_USART3SEL_Pos)
#define RCC_CCIPR_USART3SEL RCC_CCIPR_USART3SEL_Msk
#define RCC_CCIPR_USART3SEL_0 (0x1UL << RCC_CCIPR_USART3SEL_Pos)
#define RCC_CCIPR_USART3SEL_1 (0x2UL << RCC_CCIPR_USART3SEL_Pos)

#define RCC_CCIPR_UART4SEL_Pos (6U)
#define RCC_CCIPR_UART4SEL_Msk (0x3UL << RCC_CCIPR_UART4SEL_Pos)
#define RCC_CCIPR_UART4SEL RCC_CCIPR_UART4SEL_Msk
#define RCC_CCIPR_UART4SEL_0 (0x1UL << RCC_CCIPR_UART4SEL_Pos)
#define RCC_CCIPR_UART4SEL_1 (0x2UL << RCC_CCIPR_UART4SEL_Pos)

#define RCC_CCIPR_UART5SEL_Pos (8U)
#define RCC_CCIPR_UART5SEL_Msk (0x3UL << RCC_CCIPR_UART5SEL_Pos)
#define RCC_CCIPR_UART5SEL RCC_CCIPR_UART5SEL_Msk
#define RCC_CCIPR_UART5SEL_0 (0x1UL << RCC_CCIPR_UART5SEL_Pos)
#define RCC_CCIPR_UART5SEL_1 (0x2UL << RCC_CCIPR_UART5SEL_Pos)

#define RCC_CCIPR_LPUART1SEL_Pos (10U)
#define RCC_CCIPR_LPUART1SEL_Msk (0x3UL << RCC_CCIPR_LPUART1SEL_Pos)
#define RCC_CCIPR_LPUART1SEL RCC_CCIPR_LPUART1SEL_Msk
#define RCC_CCIPR_LPUART1SEL_0 (0x1UL << RCC_CCIPR_LPUART1SEL_Pos)
#define RCC_CCIPR_LPUART1SEL_1 (0x2UL << RCC_CCIPR_LPUART1SEL_Pos)

#define RCC_CCIPR_I2C1SEL_Pos (12U)
#define RCC_CCIPR_I2C1SEL_Msk (0x3UL << RCC_CCIPR_I2C1SEL_Pos)
#define RCC_CCIPR_I2C1SEL RCC_CCIPR_I2C1SEL_Msk
#define RCC_CCIPR_I2C1SEL_0 (0x1UL << RCC_CCIPR_I2C1SEL_Pos)
#define RCC_CCIPR_I2C1SEL_1 (0x2UL << RCC_CCIPR_I2C1SEL_Pos)

#define RCC_CCIPR_I2C2SEL_Pos (14U)
#define RCC_CCIPR_I2C2SEL_Msk (0x3UL << RCC_CCIPR_I2C2SEL_Pos)
#define RCC_CCIPR_I2C2SEL RCC_CCIPR_I2C2SEL_Msk
#define RCC_CCIPR_I2C2SEL_0 (0x1UL << RCC_CCIPR_I2C2SEL_Pos)
#define RCC_CCIPR_I2C2SEL_1 (0x2UL << RCC_CCIPR_I2C2SEL_Pos)

#define RCC_CCIPR_I2C3SEL_Pos (16U)
#define RCC_CCIPR_I2C3SEL_Msk (0x3UL << RCC_CCIPR_I2C3SEL_Pos)
#define RCC_CCIPR_I2C3SEL RCC_CCIPR_I2C3SEL_Msk
#define RCC_CCIPR_I2C3SEL_0 (0x1UL << RCC_CCIPR_I2C3SEL_Pos)
#define RCC_CCIPR_I2C3SEL_1 (0x2UL << RCC_CCIPR_I2C3SEL_Pos)

#define RCC_CCIPR_LPTIM1SEL_Pos (18U)
#define RCC_CCIPR_LPTIM1SEL_Msk (0x3UL << RCC_CCIPR_LPTIM1SEL_Pos)
#define RCC_CCIPR_LPTIM1SEL RCC_CCIPR_LPTIM1SEL_Msk
#define RCC_CCIPR_LPTIM1SEL_0 (0x1UL << RCC_CCIPR_LPTIM1SEL_Pos)
#define RCC_CCIPR_LPTIM1SEL_1 (0x2UL << RCC_CCIPR_LPTIM1SEL_Pos)

#define RCC_CCIPR_SAI1SEL_Pos (20U)
#define RCC_CCIPR_SAI1SEL_Msk (0x3UL << RCC_CCIPR_SAI1SEL_Pos)
#define RCC_CCIPR_SAI1SEL RCC_CCIPR_SAI1SEL_Msk
#define RCC_CCIPR_SAI1SEL_0 (0x1UL << RCC_CCIPR_SAI1SEL_Pos)
#define RCC_CCIPR_SAI1SEL_1 (0x2UL << RCC_CCIPR_SAI1SEL_Pos)

#define RCC_CCIPR_I2S23SEL_Pos (22U)
#define RCC_CCIPR_I2S23SEL_Msk (0x3UL << RCC_CCIPR_I2S23SEL_Pos)
#define RCC_CCIPR_I2S23SEL RCC_CCIPR_I2S23SEL_Msk
#define RCC_CCIPR_I2S23SEL_0 (0x1UL << RCC_CCIPR_I2S23SEL_Pos)
#define RCC_CCIPR_I2S23SEL_1 (0x2UL << RCC_CCIPR_I2S23SEL_Pos)

#define RCC_CCIPR_FDCANSEL_Pos (24U)
#define RCC_CCIPR_FDCANSEL_Msk (0x3UL << RCC_CCIPR_FDCANSEL_Pos)
#define RCC_CCIPR_FDCANSEL RCC_CCIPR_FDCANSEL_Msk
#define RCC_CCIPR_FDCANSEL_0 (0x1UL << RCC_CCIPR_FDCANSEL_Pos)
#define RCC_CCIPR_FDCANSEL_1 (0x2UL << RCC_CCIPR_FDCANSEL_Pos)

#define RCC_CCIPR_CLK48SEL_Pos (26U)
#define RCC_CCIPR_CLK48SEL_Msk (0x3UL << RCC_CCIPR_CLK48SEL_Pos)
#define RCC_CCIPR_CLK48SEL RCC_CCIPR_CLK48SEL_Msk
#define RCC_CCIPR_CLK48SEL_0 (0x1UL << RCC_CCIPR_CLK48SEL_Pos)
#define RCC_CCIPR_CLK48SEL_1 (0x2UL << RCC_CCIPR_CLK48SEL_Pos)

#define RCC_CCIPR_ADC12SEL_Pos (28U)
#define RCC_CCIPR_ADC12SEL_Msk (0x3UL << RCC_CCIPR_ADC12SEL_Pos)
#define RCC_CCIPR_ADC12SEL RCC_CCIPR_ADC12SEL_Msk
#define RCC_CCIPR_ADC12SEL_0 (0x1UL << RCC_CCIPR_ADC12SEL_Pos)
#define RCC_CCIPR_ADC12SEL_1 (0x2UL << RCC_CCIPR_ADC12SEL_Pos)

#define RCC_CCIPR_ADC345SEL_Pos (30U)
#define RCC_CCIPR_ADC345SEL_Msk (0x3UL << RCC_CCIPR_ADC345SEL_Pos)
#define RCC_CCIPR_ADC345SEL RCC_CCIPR_ADC345SEL_Msk
#define RCC_CCIPR_ADC345SEL_0 (0x1UL << RCC_CCIPR_ADC345SEL_Pos)
#define RCC_CCIPR_ADC345SEL_1 (0x2UL << RCC_CCIPR_ADC345SEL_Pos)

/********************  Bit definition for RCC_BDCR register  ******************/
#define RCC_BDCR_LSEON_Pos (0U)
#define RCC_BDCR_LSEON_Msk (0x1UL << RCC_BDCR_LSEON_Pos)
#define RCC_BDCR_LSEON RCC_BDCR_LSEON_Msk
#define RCC_BDCR_LSERDY_Pos (1U)
#define RCC_BDCR_LSERDY_Msk (0x1UL << RCC_BDCR_LSERDY_Pos)
#define RCC_BDCR_LSERDY RCC_BDCR_LSERDY_Msk
#define RCC_BDCR_LSEBYP_Pos (2U)
#define RCC_BDCR_LSEBYP_Msk (0x1UL << RCC_BDCR_LSEBYP_Pos)
#define RCC_BDCR_LSEBYP RCC_BDCR_LSEBYP_Msk

#define RCC_BDCR_LSEDRV_Pos (3U)
#define RCC_BDCR_LSEDRV_Msk (0x3UL << RCC_BDCR_LSEDRV_Pos)
#define RCC_BDCR_LSEDRV RCC_BDCR_LSEDRV_Msk
#define RCC_BDCR_LSEDRV_0 (0x1UL << RCC_BDCR_LSEDRV_Pos)
#define RCC_BDCR_LSEDRV_1 (0x2UL << RCC_BDCR_LSEDRV_Pos)

#define RCC_BDCR_LSECSSON_Pos (5U)
#define RCC_BDCR_LSECSSON_Msk (0x1UL << RCC_BDCR_LSECSSON_Pos)
#define RCC_BDCR_LSECSSON RCC_BDCR_LSECSSON_Msk
#define RCC_BDCR_LSECSSD_Pos (6U)
#define RCC_BDCR_LSECSSD_Msk (0x1UL << RCC_BDCR_LSECSSD_Pos)
#define RCC_BDCR_LSECSSD RCC_BDCR_LSECSSD_Msk

#define RCC_BDCR_RTCSEL_Pos (8U)
#define RCC_BDCR_RTCSEL_Msk (0x3UL << RCC_BDCR_RTCSEL_Pos)
#define RCC_BDCR_RTCSEL RCC_BDCR_RTCSEL_Msk
#define RCC_BDCR_RTCSEL_0 (0x1UL << RCC_BDCR_RTCSEL_Pos)
#define RCC_BDCR_RTCSEL_1 (0x2UL << RCC_BDCR_RTCSEL_Pos)

#define RCC_BDCR_RTCEN_Pos (15U)
#define RCC_BDCR_RTCEN_Msk (0x1UL << RCC_BDCR_RTCEN_Pos)
#define RCC_BDCR_RTCEN RCC_BDCR_RTCEN_Msk
#define RCC_BDCR_BDRST_Pos (16U)
#define RCC_BDCR_BDRST_Msk (0x1UL << RCC_BDCR_BDRST_Pos)
#define RCC_BDCR_BDRST RCC_BDCR_BDRST_Msk
#define RCC_BDCR_LSCOEN_Pos (24U)
#define RCC_BDCR_LSCOEN_Msk (0x1UL << RCC_BDCR_LSCOEN_Pos)
#define RCC_BDCR_LSCOEN RCC_BDCR_LSCOEN_Msk
#define RCC_BDCR_LSCOSEL_Pos (25U)
#define RCC_BDCR_LSCOSEL_Msk (0x1UL << RCC_BDCR_LSCOSEL_Pos)
#define RCC_BDCR_LSCOSEL RCC_BDCR_LSCOSEL_Msk

/********************  Bit definition for RCC_CSR register  *******************/
#define RCC_CSR_LSION_Pos (0U)
#define RCC_CSR_LSION_Msk (0x1UL << RCC_CSR_LSION_Pos)
#define RCC_CSR_LSION RCC_CSR_LSION_Msk
#define RCC_CSR_LSIRDY_Pos (1U)
#define RCC_CSR_LSIRDY_Msk (0x1UL << RCC_CSR_LSIRDY_Pos)
#define RCC_CSR_LSIRDY RCC_CSR_LSIRDY_Msk

#define RCC_CSR_RMVF_Pos (23U)
#define RCC_CSR_RMVF_Msk (0x1UL << RCC_CSR_RMVF_Pos)
#define RCC_CSR_RMVF RCC_CSR_RMVF_Msk
#define RCC_CSR_OBLRSTF_Pos (25U)
#define RCC_CSR_OBLRSTF_Msk (0x1UL << RCC_CSR_OBLRSTF_Pos)
#define RCC_CSR_OBLRSTF RCC_CSR_OBLRSTF_Msk
#define RCC_CSR_PINRSTF_Pos (26U)
#define RCC_CSR_PINRSTF_Msk (0x1UL << RCC_CSR_PINRSTF_Pos)
#define RCC_CSR_PINRSTF RCC_CSR_PINRSTF_Msk
#define RCC_CSR_BORRSTF_Pos (27U)
#define RCC_CSR_BORRSTF_Msk (0x1UL << RCC_CSR_BORRSTF_Pos)
#define RCC_CSR_BORRSTF RCC_CSR_BORRSTF_Msk
#define RCC_CSR_SFTRSTF_Pos (28U)
#define RCC_CSR_SFTRSTF_Msk (0x1UL << RCC_CSR_SFTRSTF_Pos)
#define RCC_CSR_SFTRSTF RCC_CSR_SFTRSTF_Msk
#define RCC_CSR_IWDGRSTF_Pos (29U)
#define RCC_CSR_IWDGRSTF_Msk (0x1UL << RCC_CSR_IWDGRSTF_Pos)
#define RCC_CSR_IWDGRSTF RCC_CSR_IWDGRSTF_Msk
#define RCC_CSR_WWDGRSTF_Pos (30U)
#define RCC_CSR_WWDGRSTF_Msk (0x1UL << RCC_CSR_WWDGRSTF_Pos)
#define RCC_CSR_WWDGRSTF RCC_CSR_WWDGRSTF_Msk
#define RCC_CSR_LPWRRSTF_Pos (31U)
#define RCC_CSR_LPWRRSTF_Msk (0x1UL << RCC_CSR_LPWRRSTF_Pos)
#define RCC_CSR_LPWRRSTF RCC_CSR_LPWRRSTF_Msk

/********************  Bit definition for RCC_CRRCR register  *****************/
#define RCC_CRRCR_HSI48ON_Pos (0U)
#define RCC_CRRCR_HSI48ON_Msk (0x1UL << RCC_CRRCR_HSI48ON_Pos)
#define RCC_CRRCR_HSI48ON RCC_CRRCR_HSI48ON_Msk
#define RCC_CRRCR_HSI48RDY_Pos (1U)
#define RCC_CRRCR_HSI48RDY_Msk (0x1UL << RCC_CRRCR_HSI48RDY_Pos)
#define RCC_CRRCR_HSI48RDY RCC_CRRCR_HSI48RDY_Msk

/*!< HSI48CAL configuration */
#define RCC_CRRCR_HSI48CAL_Pos (7U)
#define RCC_CRRCR_HSI48CAL_Msk (0x1FFUL << RCC_CRRCR_HSI48CAL_Pos)
#define RCC_CRRCR_HSI48CAL RCC_CRRCR_HSI48CAL_Msk
#define RCC_CRRCR_HSI48CAL_0 (0x001UL << RCC_CRRCR_HSI48CAL_Pos)
#define RCC_CRRCR_HSI48CAL_1 (0x002UL << RCC_CRRCR_HSI48CAL_Pos)
#define RCC_CRRCR_HSI48CAL_2 (0x004UL << RCC_CRRCR_HSI48CAL_Pos)
#define RCC_CRRCR_HSI48CAL_3 (0x008UL << RCC_CRRCR_HSI48CAL_Pos)
#define RCC_CRRCR_HSI48CAL_4 (0x010UL << RCC_CRRCR_HSI48CAL_Pos)
#define RCC_CRRCR_HSI48CAL_5 (0x020UL << RCC_CRRCR_HSI48CAL_Pos)
#define RCC_CRRCR_HSI48CAL_6 (0x040UL << RCC_CRRCR_HSI48CAL_Pos)
#define RCC_CRRCR_HSI48CAL_7 (0x080UL << RCC_CRRCR_HSI48CAL_Pos)
#define RCC_CRRCR_HSI48CAL_8 (0x100UL << RCC_CRRCR_HSI48CAL_Pos)

/********************  Bit definition for RCC_CCIPR2 register  ******************/
#define RCC_CCIPR2_I2C4SEL_Pos (0U)
#define RCC_CCIPR2_I2C4SEL_Msk (0x3UL << RCC_CCIPR2_I2C4SEL_Pos)
#define RCC_CCIPR2_I2C4SEL RCC_CCIPR2_I2C4SEL_Msk
#define RCC_CCIPR2_I2C4SEL_0 (0x1UL << RCC_CCIPR2_I2C4SEL_Pos)
#define RCC_CCIPR2_I2C4SEL_1 (0x2UL << RCC_CCIPR2_I2C4SEL_Pos)

#define RCC_CCIPR2_QSPISEL_Pos (20U)
#define RCC_CCIPR2_QSPISEL_Msk (0x3UL << RCC_CCIPR2_QSPISEL_Pos)
#define RCC_CCIPR2_QSPISEL RCC_CCIPR2_QSPISEL_Msk
#define RCC_CCIPR2_QSPISEL_0 (0x1UL << RCC_CCIPR2_QSPISEL_Pos)
#define RCC_CCIPR2_QSPISEL_1 (0x2UL << RCC_CCIPR2_QSPISEL_Pos)

/******************************************************************************/
/*                                                                            */
/*                                    RNG                                     */
/*                                                                            */
/******************************************************************************/
/********************  Bits definition for RNG_CR register  *******************/
#define RNG_CR_RNGEN_Pos (2U)
#define RNG_CR_RNGEN_Msk (0x1UL << RNG_CR_RNGEN_Pos)
#define RNG_CR_RNGEN RNG_CR_RNGEN_Msk
#define RNG_CR_IE_Pos (3U)
#define RNG_CR_IE_Msk (0x1UL << RNG_CR_IE_Pos)
#define RNG_CR_IE RNG_CR_IE_Msk
#define RNG_CR_CED_Pos (5U)
#define RNG_CR_CED_Msk (0x1UL << RNG_CR_IE_Pos)
#define RNG_CR_CED RNG_CR_IE_Msk

/********************  Bits definition for RNG_SR register  *******************/
#define RNG_SR_DRDY_Pos (0U)
#define RNG_SR_DRDY_Msk (0x1UL << RNG_SR_DRDY_Pos)
#define RNG_SR_DRDY RNG_SR_DRDY_Msk
#define RNG_SR_CECS_Pos (1U)
#define RNG_SR_CECS_Msk (0x1UL << RNG_SR_CECS_Pos)
#define RNG_SR_CECS RNG_SR_CECS_Msk
#define RNG_SR_SECS_Pos (2U)
#define RNG_SR_SECS_Msk (0x1UL << RNG_SR_SECS_Pos)
#define RNG_SR_SECS RNG_SR_SECS_Msk
#define RNG_SR_CEIS_Pos (5U)
#define RNG_SR_CEIS_Msk (0x1UL << RNG_SR_CEIS_Pos)
#define RNG_SR_CEIS RNG_SR_CEIS_Msk
#define RNG_SR_SEIS_Pos (6U)
#define RNG_SR_SEIS_Msk (0x1UL << RNG_SR_SEIS_Pos)
#define RNG_SR_SEIS RNG_SR_SEIS_Msk

/******************************************************************************/
/*                                                                            */
/*                           Real-Time Clock (RTC)                            */
/*                                                                            */
/******************************************************************************/

/********************  Bits definition for RTC_TR register  *******************/
#define RTC_TR_PM_Pos (22U)
#define RTC_TR_PM_Msk (0x1UL << RTC_TR_PM_Pos)
#define RTC_TR_PM RTC_TR_PM_Msk
#define RTC_TR_HT_Pos (20U)
#define RTC_TR_HT_Msk (0x3UL << RTC_TR_HT_Pos)
#define RTC_TR_HT RTC_TR_HT_Msk
#define RTC_TR_HT_0 (0x1UL << RTC_TR_HT_Pos)
#define RTC_TR_HT_1 (0x2UL << RTC_TR_HT_Pos)
#define RTC_TR_HU_Pos (16U)
#define RTC_TR_HU_Msk (0xFUL << RTC_TR_HU_Pos)
#define RTC_TR_HU RTC_TR_HU_Msk
#define RTC_TR_HU_0 (0x1UL << RTC_TR_HU_Pos)
#define RTC_TR_HU_1 (0x2UL << RTC_TR_HU_Pos)
#define RTC_TR_HU_2 (0x4UL << RTC_TR_HU_Pos)
#define RTC_TR_HU_3 (0x8UL << RTC_TR_HU_Pos)
#define RTC_TR_MNT_Pos (12U)
#define RTC_TR_MNT_Msk (0x7UL << RTC_TR_MNT_Pos)
#define RTC_TR_MNT RTC_TR_MNT_Msk
#define RTC_TR_MNT_0 (0x1UL << RTC_TR_MNT_Pos)
#define RTC_TR_MNT_1 (0x2UL << RTC_TR_MNT_Pos)
#define RTC_TR_MNT_2 (0x4UL << RTC_TR_MNT_Pos)
#define RTC_TR_MNU_Pos (8U)
#define RTC_TR_MNU_Msk (0xFUL << RTC_TR_MNU_Pos)
#define RTC_TR_MNU RTC_TR_MNU_Msk
#define RTC_TR_MNU_0 (0x1UL << RTC_TR_MNU_Pos)
#define RTC_TR_MNU_1 (0x2UL << RTC_TR_MNU_Pos)
#define RTC_TR_MNU_2 (0x4UL << RTC_TR_MNU_Pos)
#define RTC_TR_MNU_3 (0x8UL << RTC_TR_MNU_Pos)
#define RTC_TR_ST_Pos (4U)
#define RTC_TR_ST_Msk (0x7UL << RTC_TR_ST_Pos)
#define RTC_TR_ST RTC_TR_ST_Msk
#define RTC_TR_ST_0 (0x1UL << RTC_TR_ST_Pos)
#define RTC_TR_ST_1 (0x2UL << RTC_TR_ST_Pos)
#define RTC_TR_ST_2 (0x4UL << RTC_TR_ST_Pos)
#define RTC_TR_SU_Pos (0U)
#define RTC_TR_SU_Msk (0xFUL << RTC_TR_SU_Pos)
#define RTC_TR_SU RTC_TR_SU_Msk
#define RTC_TR_SU_0 (0x1UL << RTC_TR_SU_Pos)
#define RTC_TR_SU_1 (0x2UL << RTC_TR_SU_Pos)
#define RTC_TR_SU_2 (0x4UL << RTC_TR_SU_Pos)
#define RTC_TR_SU_3 (0x8UL << RTC_TR_SU_Pos)

/********************  Bits definition for RTC_DR register  *******************/
#define RTC_DR_YT_Pos (20U)
#define RTC_DR_YT_Msk (0xFUL << RTC_DR_YT_Pos)
#define RTC_DR_YT RTC_DR_YT_Msk
#define RTC_DR_YT_0 (0x1UL << RTC_DR_YT_Pos)
#define RTC_DR_YT_1 (0x2UL << RTC_DR_YT_Pos)
#define RTC_DR_YT_2 (0x4UL << RTC_DR_YT_Pos)
#define RTC_DR_YT_3 (0x8UL << RTC_DR_YT_Pos)
#define RTC_DR_YU_Pos (16U)
#define RTC_DR_YU_Msk (0xFUL << RTC_DR_YU_Pos)
#define RTC_DR_YU RTC_DR_YU_Msk
#define RTC_DR_YU_0 (0x1UL << RTC_DR_YU_Pos)
#define RTC_DR_YU_1 (0x2UL << RTC_DR_YU_Pos)
#define RTC_DR_YU_2 (0x4UL << RTC_DR_YU_Pos)
#define RTC_DR_YU_3 (0x8UL << RTC_DR_YU_Pos)
#define RTC_DR_WDU_Pos (13U)
#define RTC_DR_WDU_Msk (0x7UL << RTC_DR_WDU_Pos)
#define RTC_DR_WDU RTC_DR_WDU_Msk
#define RTC_DR_WDU_0 (0x1UL << RTC_DR_WDU_Pos)
#define RTC_DR_WDU_1 (0x2UL << RTC_DR_WDU_Pos)
#define RTC_DR_WDU_2 (0x4UL << RTC_DR_WDU_Pos)
#define RTC_DR_MT_Pos (12U)
#define RTC_DR_MT_Msk (0x1UL << RTC_DR_MT_Pos)
#define RTC_DR_MT RTC_DR_MT_Msk
#define RTC_DR_MU_Pos (8U)
#define RTC_DR_MU_Msk (0xFUL << RTC_DR_MU_Pos)
#define RTC_DR_MU RTC_DR_MU_Msk
#define RTC_DR_MU_0 (0x1UL << RTC_DR_MU_Pos)
#define RTC_DR_MU_1 (0x2UL << RTC_DR_MU_Pos)
#define RTC_DR_MU_2 (0x4UL << RTC_DR_MU_Pos)
#define RTC_DR_MU_3 (0x8UL << RTC_DR_MU_Pos)
#define RTC_DR_DT_Pos (4U)
#define RTC_DR_DT_Msk (0x3UL << RTC_DR_DT_Pos)
#define RTC_DR_DT RTC_DR_DT_Msk
#define RTC_DR_DT_0 (0x1UL << RTC_DR_DT_Pos)
#define RTC_DR_DT_1 (0x2UL << RTC_DR_DT_Pos)
#define RTC_DR_DU_Pos (0U)
#define RTC_DR_DU_Msk (0xFUL << RTC_DR_DU_Pos)
#define RTC_DR_DU RTC_DR_DU_Msk
#define RTC_DR_DU_0 (0x1UL << RTC_DR_DU_Pos)
#define RTC_DR_DU_1 (0x2UL << RTC_DR_DU_Pos)
#define RTC_DR_DU_2 (0x4UL << RTC_DR_DU_Pos)
#define RTC_DR_DU_3 (0x8UL << RTC_DR_DU_Pos)

/********************  Bits definition for RTC_SSR register  ******************/
#define RTC_SSR_SS_Pos (0U)
#define RTC_SSR_SS_Msk (0xFFFFUL << RTC_SSR_SS_Pos)
#define RTC_SSR_SS RTC_SSR_SS_Msk

/********************  Bits definition for RTC_ICSR register  ******************/
#define RTC_ICSR_RECALPF_Pos (16U)
#define RTC_ICSR_RECALPF_Msk (0x1UL << RTC_ICSR_RECALPF_Pos)
#define RTC_ICSR_RECALPF RTC_ICSR_RECALPF_Msk
#define RTC_ICSR_INIT_Pos (7U)
#define RTC_ICSR_INIT_Msk (0x1UL << RTC_ICSR_INIT_Pos)
#define RTC_ICSR_INIT RTC_ICSR_INIT_Msk
#define RTC_ICSR_INITF_Pos (6U)
#define RTC_ICSR_INITF_Msk (0x1UL << RTC_ICSR_INITF_Pos)
#define RTC_ICSR_INITF RTC_ICSR_INITF_Msk
#define RTC_ICSR_RSF_Pos (5U)
#define RTC_ICSR_RSF_Msk (0x1UL << RTC_ICSR_RSF_Pos)
#define RTC_ICSR_RSF RTC_ICSR_RSF_Msk
#define RTC_ICSR_INITS_Pos (4U)
#define RTC_ICSR_INITS_Msk (0x1UL << RTC_ICSR_INITS_Pos)
#define RTC_ICSR_INITS RTC_ICSR_INITS_Msk
#define RTC_ICSR_SHPF_Pos (3U)
#define RTC_ICSR_SHPF_Msk (0x1UL << RTC_ICSR_SHPF_Pos)
#define RTC_ICSR_SHPF RTC_ICSR_SHPF_Msk
#define RTC_ICSR_WUTWF_Pos (2U)
#define RTC_ICSR_WUTWF_Msk (0x1UL << RTC_ICSR_WUTWF_Pos)
#define RTC_ICSR_WUTWF RTC_ICSR_WUTWF_Msk
#define RTC_ICSR_ALRBWF_Pos (1U)
#define RTC_ICSR_ALRBWF_Msk (0x1UL << RTC_ICSR_ALRBWF_Pos)
#define RTC_ICSR_ALRBWF RTC_ICSR_ALRBWF_Msk
#define RTC_ICSR_ALRAWF_Pos (0U)
#define RTC_ICSR_ALRAWF_Msk (0x1UL << RTC_ICSR_ALRAWF_Pos)
#define RTC_ICSR_ALRAWF RTC_ICSR_ALRAWF_Msk

/********************  Bits definition for RTC_PRER register  *****************/
#define RTC_PRER_PREDIV_A_Pos (16U)
#define RTC_PRER_PREDIV_A_Msk (0x7FUL << RTC_PRER_PREDIV_A_Pos)
#define RTC_PRER_PREDIV_A RTC_PRER_PREDIV_A_Msk
#define RTC_PRER_PREDIV_S_Pos (0U)
#define RTC_PRER_PREDIV_S_Msk (0x7FFFUL << RTC_PRER_PREDIV_S_Pos)
#define RTC_PRER_PREDIV_S RTC_PRER_PREDIV_S_Msk

/********************  Bits definition for RTC_WUTR register  *****************/
#define RTC_WUTR_WUT_Pos (0U)
#define RTC_WUTR_WUT_Msk (0xFFFFUL << RTC_WUTR_WUT_Pos)
#define RTC_WUTR_WUT RTC_WUTR_WUT_Msk

/********************  Bits definition for RTC_CR register  *******************/
#define RTC_CR_OUT2EN_Pos (31U)
#define RTC_CR_OUT2EN_Msk (0x1UL << RTC_CR_OUT2EN_Pos)
#define RTC_CR_OUT2EN RTC_CR_OUT2EN_Msk
#define RTC_CR_TAMPALRM_TYPE_Pos (30U)
#define RTC_CR_TAMPALRM_TYPE_Msk (0x1UL << RTC_CR_TAMPALRM_TYPE_Pos)
#define RTC_CR_TAMPALRM_TYPE RTC_CR_TAMPALRM_TYPE_Msk
#define RTC_CR_TAMPALRM_PU_Pos (29U)
#define RTC_CR_TAMPALRM_PU_Msk (0x1UL << RTC_CR_TAMPALRM_PU_Pos)
#define RTC_CR_TAMPALRM_PU RTC_CR_TAMPALRM_PU_Msk
#define RTC_CR_TAMPOE_Pos (26U)
#define RTC_CR_TAMPOE_Msk (0x1UL << RTC_CR_TAMPOE_Pos)
#define RTC_CR_TAMPOE RTC_CR_TAMPOE_Msk
#define RTC_CR_TAMPTS_Pos (25U)
#define RTC_CR_TAMPTS_Msk (0x1UL << RTC_CR_TAMPTS_Pos)
#define RTC_CR_TAMPTS RTC_CR_TAMPTS_Msk
#define RTC_CR_ITSE_Pos (24U)
#define RTC_CR_ITSE_Msk (0x1UL << RTC_CR_ITSE_Pos)
#define RTC_CR_ITSE RTC_CR_ITSE_Msk
#define RTC_CR_COE_Pos (23U)
#define RTC_CR_COE_Msk (0x1UL << RTC_CR_COE_Pos)
#define RTC_CR_COE RTC_CR_COE_Msk
#define RTC_CR_OSEL_Pos (21U)
#define RTC_CR_OSEL_Msk (0x3UL << RTC_CR_OSEL_Pos)
#define RTC_CR_OSEL RTC_CR_OSEL_Msk
#define RTC_CR_OSEL_0 (0x1UL << RTC_CR_OSEL_Pos)
#define RTC_CR_OSEL_1 (0x2UL << RTC_CR_OSEL_Pos)
#define RTC_CR_POL_Pos (20U)
#define RTC_CR_POL_Msk (0x1UL << RTC_CR_POL_Pos)
#define RTC_CR_POL RTC_CR_POL_Msk
#define RTC_CR_COSEL_Pos (19U)
#define RTC_CR_COSEL_Msk (0x1UL << RTC_CR_COSEL_Pos)
#define RTC_CR_COSEL RTC_CR_COSEL_Msk
#define RTC_CR_BKP_Pos (18U)
#define RTC_CR_BKP_Msk (0x1UL << RTC_CR_BKP_Pos)
#define RTC_CR_BKP RTC_CR_BKP_Msk
#define RTC_CR_SUB1H_Pos (17U)
#define RTC_CR_SUB1H_Msk (0x1UL << RTC_CR_SUB1H_Pos)
#define RTC_CR_SUB1H RTC_CR_SUB1H_Msk
#define RTC_CR_ADD1H_Pos (16U)
#define RTC_CR_ADD1H_Msk (0x1UL << RTC_CR_ADD1H_Pos)
#define RTC_CR_ADD1H RTC_CR_ADD1H_Msk
#define RTC_CR_TSIE_Pos (15U)
#define RTC_CR_TSIE_Msk (0x1UL << RTC_CR_TSIE_Pos)
#define RTC_CR_TSIE RTC_CR_TSIE_Msk
#define RTC_CR_WUTIE_Pos (14U)
#define RTC_CR_WUTIE_Msk (0x1UL << RTC_CR_WUTIE_Pos)
#define RTC_CR_WUTIE RTC_CR_WUTIE_Msk
#define RTC_CR_ALRBIE_Pos (13U)
#define RTC_CR_ALRBIE_Msk (0x1UL << RTC_CR_ALRBIE_Pos)
#define RTC_CR_ALRBIE RTC_CR_ALRBIE_Msk
#define RTC_CR_ALRAIE_Pos (12U)
#define RTC_CR_ALRAIE_Msk (0x1UL << RTC_CR_ALRAIE_Pos)
#define RTC_CR_ALRAIE RTC_CR_ALRAIE_Msk
#define RTC_CR_TSE_Pos (11U)
#define RTC_CR_TSE_Msk (0x1UL << RTC_CR_TSE_Pos)
#define RTC_CR_TSE RTC_CR_TSE_Msk
#define RTC_CR_WUTE_Pos (10U)
#define RTC_CR_WUTE_Msk (0x1UL << RTC_CR_WUTE_Pos)
#define RTC_CR_WUTE RTC_CR_WUTE_Msk
#define RTC_CR_ALRBE_Pos (9U)
#define RTC_CR_ALRBE_Msk (0x1UL << RTC_CR_ALRBE_Pos)
#define RTC_CR_ALRBE RTC_CR_ALRBE_Msk
#define RTC_CR_ALRAE_Pos (8U)
#define RTC_CR_ALRAE_Msk (0x1UL << RTC_CR_ALRAE_Pos)
#define RTC_CR_ALRAE RTC_CR_ALRAE_Msk
#define RTC_CR_FMT_Pos (6U)
#define RTC_CR_FMT_Msk (0x1UL << RTC_CR_FMT_Pos)
#define RTC_CR_FMT RTC_CR_FMT_Msk
#define RTC_CR_BYPSHAD_Pos (5U)
#define RTC_CR_BYPSHAD_Msk (0x1UL << RTC_CR_BYPSHAD_Pos)
#define RTC_CR_BYPSHAD RTC_CR_BYPSHAD_Msk
#define RTC_CR_REFCKON_Pos (4U)
#define RTC_CR_REFCKON_Msk (0x1UL << RTC_CR_REFCKON_Pos)
#define RTC_CR_REFCKON RTC_CR_REFCKON_Msk
#define RTC_CR_TSEDGE_Pos (3U)
#define RTC_CR_TSEDGE_Msk (0x1UL << RTC_CR_TSEDGE_Pos)
#define RTC_CR_TSEDGE RTC_CR_TSEDGE_Msk
#define RTC_CR_WUCKSEL_Pos (0U)
#define RTC_CR_WUCKSEL_Msk (0x7UL << RTC_CR_WUCKSEL_Pos)
#define RTC_CR_WUCKSEL RTC_CR_WUCKSEL_Msk
#define RTC_CR_WUCKSEL_0 (0x1UL << RTC_CR_WUCKSEL_Pos)
#define RTC_CR_WUCKSEL_1 (0x2UL << RTC_CR_WUCKSEL_Pos)
#define RTC_CR_WUCKSEL_2 (0x4UL << RTC_CR_WUCKSEL_Pos)

/********************  Bits definition for RTC_WPR register  ******************/
#define RTC_WPR_KEY_Pos (0U)
#define RTC_WPR_KEY_Msk (0xFFUL << RTC_WPR_KEY_Pos)
#define RTC_WPR_KEY RTC_WPR_KEY_Msk

/********************  Bits definition for RTC_CALR register  *****************/
#define RTC_CALR_CALP_Pos (15U)
#define RTC_CALR_CALP_Msk (0x1UL << RTC_CALR_CALP_Pos)
#define RTC_CALR_CALP RTC_CALR_CALP_Msk
#define RTC_CALR_CALW8_Pos (14U)
#define RTC_CALR_CALW8_Msk (0x1UL << RTC_CALR_CALW8_Pos)
#define RTC_CALR_CALW8 RTC_CALR_CALW8_Msk
#define RTC_CALR_CALW16_Pos (13U)
#define RTC_CALR_CALW16_Msk (0x1UL << RTC_CALR_CALW16_Pos)
#define RTC_CALR_CALW16 RTC_CALR_CALW16_Msk
#define RTC_CALR_CALM_Pos (0U)
#define RTC_CALR_CALM_Msk (0x1FFUL << RTC_CALR_CALM_Pos)
#define RTC_CALR_CALM RTC_CALR_CALM_Msk
#define RTC_CALR_CALM_0 (0x001UL << RTC_CALR_CALM_Pos)
#define RTC_CALR_CALM_1 (0x002UL << RTC_CALR_CALM_Pos)
#define RTC_CALR_CALM_2 (0x004UL << RTC_CALR_CALM_Pos)
#define RTC_CALR_CALM_3 (0x008UL << RTC_CALR_CALM_Pos)
#define RTC_CALR_CALM_4 (0x010UL << RTC_CALR_CALM_Pos)
#define RTC_CALR_CALM_5 (0x020UL << RTC_CALR_CALM_Pos)
#define RTC_CALR_CALM_6 (0x040UL << RTC_CALR_CALM_Pos)
#define RTC_CALR_CALM_7 (0x080UL << RTC_CALR_CALM_Pos)
#define RTC_CALR_CALM_8 (0x100UL << RTC_CALR_CALM_Pos)

/********************  Bits definition for RTC_SHIFTR register  ***************/
#define RTC_SHIFTR_SUBFS_Pos (0U)
#define RTC_SHIFTR_SUBFS_Msk (0x7FFFUL << RTC_SHIFTR_SUBFS_Pos)
#define RTC_SHIFTR_SUBFS RTC_SHIFTR_SUBFS_Msk
#define RTC_SHIFTR_ADD1S_Pos (31U)
#define RTC_SHIFTR_ADD1S_Msk (0x1UL << RTC_SHIFTR_ADD1S_Pos)
#define RTC_SHIFTR_ADD1S RTC_SHIFTR_ADD1S_Msk

/********************  Bits definition for RTC_TSTR register  *****************/
#define RTC_TSTR_PM_Pos (22U)
#define RTC_TSTR_PM_Msk (0x1UL << RTC_TSTR_PM_Pos)
#define RTC_TSTR_PM RTC_TSTR_PM_Msk
#define RTC_TSTR_HT_Pos (20U)
#define RTC_TSTR_HT_Msk (0x3UL << RTC_TSTR_HT_Pos)
#define RTC_TSTR_HT RTC_TSTR_HT_Msk
#define RTC_TSTR_HT_0 (0x1UL << RTC_TSTR_HT_Pos)
#define RTC_TSTR_HT_1 (0x2UL << RTC_TSTR_HT_Pos)
#define RTC_TSTR_HU_Pos (16U)
#define RTC_TSTR_HU_Msk (0xFUL << RTC_TSTR_HU_Pos)
#define RTC_TSTR_HU RTC_TSTR_HU_Msk
#define RTC_TSTR_HU_0 (0x1UL << RTC_TSTR_HU_Pos)
#define RTC_TSTR_HU_1 (0x2UL << RTC_TSTR_HU_Pos)
#define RTC_TSTR_HU_2 (0x4UL << RTC_TSTR_HU_Pos)
#define RTC_TSTR_HU_3 (0x8UL << RTC_TSTR_HU_Pos)
#define RTC_TSTR_MNT_Pos (12U)
#define RTC_TSTR_MNT_Msk (0x7UL << RTC_TSTR_MNT_Pos)
#define RTC_TSTR_MNT RTC_TSTR_MNT_Msk
#define RTC_TSTR_MNT_0 (0x1UL << RTC_TSTR_MNT_Pos)
#define RTC_TSTR_MNT_1 (0x2UL << RTC_TSTR_MNT_Pos)
#define RTC_TSTR_MNT_2 (0x4UL << RTC_TSTR_MNT_Pos)
#define RTC_TSTR_MNU_Pos (8U)
#define RTC_TSTR_MNU_Msk (0xFUL << RTC_TSTR_MNU_Pos)
#define RTC_TSTR_MNU RTC_TSTR_MNU_Msk
#define RTC_TSTR_MNU_0 (0x1UL << RTC_TSTR_MNU_Pos)
#define RTC_TSTR_MNU_1 (0x2UL << RTC_TSTR_MNU_Pos)
#define RTC_TSTR_MNU_2 (0x4UL << RTC_TSTR_MNU_Pos)
#define RTC_TSTR_MNU_3 (0x8UL << RTC_TSTR_MNU_Pos)
#define RTC_TSTR_ST_Pos (4U)
#define RTC_TSTR_ST_Msk (0x7UL << RTC_TSTR_ST_Pos)
#define RTC_TSTR_ST RTC_TSTR_ST_Msk
#define RTC_TSTR_ST_0 (0x1UL << RTC_TSTR_ST_Pos)
#define RTC_TSTR_ST_1 (0x2UL << RTC_TSTR_ST_Pos)
#define RTC_TSTR_ST_2 (0x4UL << RTC_TSTR_ST_Pos)
#define RTC_TSTR_SU_Pos (0U)
#define RTC_TSTR_SU_Msk (0xFUL << RTC_TSTR_SU_Pos)
#define RTC_TSTR_SU RTC_TSTR_SU_Msk
#define RTC_TSTR_SU_0 (0x1UL << RTC_TSTR_SU_Pos)
#define RTC_TSTR_SU_1 (0x2UL << RTC_TSTR_SU_Pos)
#define RTC_TSTR_SU_2 (0x4UL << RTC_TSTR_SU_Pos)
#define RTC_TSTR_SU_3 (0x8UL << RTC_TSTR_SU_Pos)

/********************  Bits definition for RTC_TSDR register  *****************/
#define RTC_TSDR_WDU_Pos (13U)
#define RTC_TSDR_WDU_Msk (0x7UL << RTC_TSDR_WDU_Pos)
#define RTC_TSDR_WDU RTC_TSDR_WDU_Msk
#define RTC_TSDR_WDU_0 (0x1UL << RTC_TSDR_WDU_Pos)
#define RTC_TSDR_WDU_1 (0x2UL << RTC_TSDR_WDU_Pos)
#define RTC_TSDR_WDU_2 (0x4UL << RTC_TSDR_WDU_Pos)
#define RTC_TSDR_MT_Pos (12U)
#define RTC_TSDR_MT_Msk (0x1UL << RTC_TSDR_MT_Pos)
#define RTC_TSDR_MT RTC_TSDR_MT_Msk
#define RTC_TSDR_MU_Pos (8U)
#define RTC_TSDR_MU_Msk (0xFUL << RTC_TSDR_MU_Pos)
#define RTC_TSDR_MU RTC_TSDR_MU_Msk
#define RTC_TSDR_MU_0 (0x1UL << RTC_TSDR_MU_Pos)
#define RTC_TSDR_MU_1 (0x2UL << RTC_TSDR_MU_Pos)
#define RTC_TSDR_MU_2 (0x4UL << RTC_TSDR_MU_Pos)
#define RTC_TSDR_MU_3 (0x8UL << RTC_TSDR_MU_Pos)
#define RTC_TSDR_DT_Pos (4U)
#define RTC_TSDR_DT_Msk (0x3UL << RTC_TSDR_DT_Pos)
#define RTC_TSDR_DT RTC_TSDR_DT_Msk
#define RTC_TSDR_DT_0 (0x1UL << RTC_TSDR_DT_Pos)
#define RTC_TSDR_DT_1 (0x2UL << RTC_TSDR_DT_Pos)
#define RTC_TSDR_DU_Pos (0U)
#define RTC_TSDR_DU_Msk (0xFUL << RTC_TSDR_DU_Pos)
#define RTC_TSDR_DU RTC_TSDR_DU_Msk
#define RTC_TSDR_DU_0 (0x1UL << RTC_TSDR_DU_Pos)
#define RTC_TSDR_DU_1 (0x2UL << RTC_TSDR_DU_Pos)
#define RTC_TSDR_DU_2 (0x4UL << RTC_TSDR_DU_Pos)
#define RTC_TSDR_DU_3 (0x8UL << RTC_TSDR_DU_Pos)

/********************  Bits definition for RTC_TSSSR register  ****************/
#define RTC_TSSSR_SS_Pos (0U)
#define RTC_TSSSR_SS_Msk (0xFFFFUL << RTC_TSSSR_SS_Pos)
#define RTC_TSSSR_SS RTC_TSSSR_SS_Msk

/********************  Bits definition for RTC_ALRMAR register  ***************/
#define RTC_ALRMAR_MSK4_Pos (31U)
#define RTC_ALRMAR_MSK4_Msk (0x1UL << RTC_ALRMAR_MSK4_Pos)
#define RTC_ALRMAR_MSK4 RTC_ALRMAR_MSK4_Msk
#define RTC_ALRMAR_WDSEL_Pos (30U)
#define RTC_ALRMAR_WDSEL_Msk (0x1UL << RTC_ALRMAR_WDSEL_Pos)
#define RTC_ALRMAR_WDSEL RTC_ALRMAR_WDSEL_Msk
#define RTC_ALRMAR_DT_Pos (28U)
#define RTC_ALRMAR_DT_Msk (0x3UL << RTC_ALRMAR_DT_Pos)
#define RTC_ALRMAR_DT RTC_ALRMAR_DT_Msk
#define RTC_ALRMAR_DT_0 (0x1UL << RTC_ALRMAR_DT_Pos)
#define RTC_ALRMAR_DT_1 (0x2UL << RTC_ALRMAR_DT_Pos)
#define RTC_ALRMAR_DU_Pos (24U)
#define RTC_ALRMAR_DU_Msk (0xFUL << RTC_ALRMAR_DU_Pos)
#define RTC_ALRMAR_DU RTC_ALRMAR_DU_Msk
#define RTC_ALRMAR_DU_0 (0x1UL << RTC_ALRMAR_DU_Pos)
#define RTC_ALRMAR_DU_1 (0x2UL << RTC_ALRMAR_DU_Pos)
#define RTC_ALRMAR_DU_2 (0x4UL << RTC_ALRMAR_DU_Pos)
#define RTC_ALRMAR_DU_3 (0x8UL << RTC_ALRMAR_DU_Pos)
#define RTC_ALRMAR_MSK3_Pos (23U)
#define RTC_ALRMAR_MSK3_Msk (0x1UL << RTC_ALRMAR_MSK3_Pos)
#define RTC_ALRMAR_MSK3 RTC_ALRMAR_MSK3_Msk
#define RTC_ALRMAR_PM_Pos (22U)
#define RTC_ALRMAR_PM_Msk (0x1UL << RTC_ALRMAR_PM_Pos)
#define RTC_ALRMAR_PM RTC_ALRMAR_PM_Msk
#define RTC_ALRMAR_HT_Pos (20U)
#define RTC_ALRMAR_HT_Msk (0x3UL << RTC_ALRMAR_HT_Pos)
#define RTC_ALRMAR_HT RTC_ALRMAR_HT_Msk
#define RTC_ALRMAR_HT_0 (0x1UL << RTC_ALRMAR_HT_Pos)
#define RTC_ALRMAR_HT_1 (0x2UL << RTC_ALRMAR_HT_Pos)
#define RTC_ALRMAR_HU_Pos (16U)
#define RTC_ALRMAR_HU_Msk (0xFUL << RTC_ALRMAR_HU_Pos)
#define RTC_ALRMAR_HU RTC_ALRMAR_HU_Msk
#define RTC_ALRMAR_HU_0 (0x1UL << RTC_ALRMAR_HU_Pos)
#define RTC_ALRMAR_HU_1 (0x2UL << RTC_ALRMAR_HU_Pos)
#define RTC_ALRMAR_HU_2 (0x4UL << RTC_ALRMAR_HU_Pos)
#define RTC_ALRMAR_HU_3 (0x8UL << RTC_ALRMAR_HU_Pos)
#define RTC_ALRMAR_MSK2_Pos (15U)
#define RTC_ALRMAR_MSK2_Msk (0x1UL << RTC_ALRMAR_MSK2_Pos)
#define RTC_ALRMAR_MSK2 RTC_ALRMAR_MSK2_Msk
#define RTC_ALRMAR_MNT_Pos (12U)
#define RTC_ALRMAR_MNT_Msk (0x7UL << RTC_ALRMAR_MNT_Pos)
#define RTC_ALRMAR_MNT RTC_ALRMAR_MNT_Msk
#define RTC_ALRMAR_MNT_0 (0x1UL << RTC_ALRMAR_MNT_Pos)
#define RTC_ALRMAR_MNT_1 (0x2UL << RTC_ALRMAR_MNT_Pos)
#define RTC_ALRMAR_MNT_2 (0x4UL << RTC_ALRMAR_MNT_Pos)
#define RTC_ALRMAR_MNU_Pos (8U)
#define RTC_ALRMAR_MNU_Msk (0xFUL << RTC_ALRMAR_MNU_Pos)
#define RTC_ALRMAR_MNU RTC_ALRMAR_MNU_Msk
#define RTC_ALRMAR_MNU_0 (0x1UL << RTC_ALRMAR_MNU_Pos)
#define RTC_ALRMAR_MNU_1 (0x2UL << RTC_ALRMAR_MNU_Pos)
#define RTC_ALRMAR_MNU_2 (0x4UL << RTC_ALRMAR_MNU_Pos)
#define RTC_ALRMAR_MNU_3 (0x8UL << RTC_ALRMAR_MNU_Pos)
#define RTC_ALRMAR_MSK1_Pos (7U)
#define RTC_ALRMAR_MSK1_Msk (0x1UL << RTC_ALRMAR_MSK1_Pos)
#define RTC_ALRMAR_MSK1 RTC_ALRMAR_MSK1_Msk
#define RTC_ALRMAR_ST_Pos (4U)
#define RTC_ALRMAR_ST_Msk (0x7UL << RTC_ALRMAR_ST_Pos)
#define RTC_ALRMAR_ST RTC_ALRMAR_ST_Msk
#define RTC_ALRMAR_ST_0 (0x1UL << RTC_ALRMAR_ST_Pos)
#define RTC_ALRMAR_ST_1 (0x2UL << RTC_ALRMAR_ST_Pos)
#define RTC_ALRMAR_ST_2 (0x4UL << RTC_ALRMAR_ST_Pos)
#define RTC_ALRMAR_SU_Pos (0U)
#define RTC_ALRMAR_SU_Msk (0xFUL << RTC_ALRMAR_SU_Pos)
#define RTC_ALRMAR_SU RTC_ALRMAR_SU_Msk
#define RTC_ALRMAR_SU_0 (0x1UL << RTC_ALRMAR_SU_Pos)
#define RTC_ALRMAR_SU_1 (0x2UL << RTC_ALRMAR_SU_Pos)
#define RTC_ALRMAR_SU_2 (0x4UL << RTC_ALRMAR_SU_Pos)
#define RTC_ALRMAR_SU_3 (0x8UL << RTC_ALRMAR_SU_Pos)

/********************  Bits definition for RTC_ALRMASSR register  *************/
#define RTC_ALRMASSR_MASKSS_Pos (24U)
#define RTC_ALRMASSR_MASKSS_Msk (0xFUL << RTC_ALRMASSR_MASKSS_Pos)
#define RTC_ALRMASSR_MASKSS RTC_ALRMASSR_MASKSS_Msk
#define RTC_ALRMASSR_MASKSS_0 (0x1UL << RTC_ALRMASSR_MASKSS_Pos)
#define RTC_ALRMASSR_MASKSS_1 (0x2UL << RTC_ALRMASSR_MASKSS_Pos)
#define RTC_ALRMASSR_MASKSS_2 (0x4UL << RTC_ALRMASSR_MASKSS_Pos)
#define RTC_ALRMASSR_MASKSS_3 (0x8UL << RTC_ALRMASSR_MASKSS_Pos)
#define RTC_ALRMASSR_SS_Pos (0U)
#define RTC_ALRMASSR_SS_Msk (0x7FFFUL << RTC_ALRMASSR_SS_Pos)
#define RTC_ALRMASSR_SS RTC_ALRMASSR_SS_Msk

/********************  Bits definition for RTC_ALRMBR register  ***************/
#define RTC_ALRMBR_MSK4_Pos (31U)
#define RTC_ALRMBR_MSK4_Msk (0x1UL << RTC_ALRMBR_MSK4_Pos)
#define RTC_ALRMBR_MSK4 RTC_ALRMBR_MSK4_Msk
#define RTC_ALRMBR_WDSEL_Pos (30U)
#define RTC_ALRMBR_WDSEL_Msk (0x1UL << RTC_ALRMBR_WDSEL_Pos)
#define RTC_ALRMBR_WDSEL RTC_ALRMBR_WDSEL_Msk
#define RTC_ALRMBR_DT_Pos (28U)
#define RTC_ALRMBR_DT_Msk (0x3UL << RTC_ALRMBR_DT_Pos)
#define RTC_ALRMBR_DT RTC_ALRMBR_DT_Msk
#define RTC_ALRMBR_DT_0 (0x1UL << RTC_ALRMBR_DT_Pos)
#define RTC_ALRMBR_DT_1 (0x2UL << RTC_ALRMBR_DT_Pos)
#define RTC_ALRMBR_DU_Pos (24U)
#define RTC_ALRMBR_DU_Msk (0xFUL << RTC_ALRMBR_DU_Pos)
#define RTC_ALRMBR_DU RTC_ALRMBR_DU_Msk
#define RTC_ALRMBR_DU_0 (0x1UL << RTC_ALRMBR_DU_Pos)
#define RTC_ALRMBR_DU_1 (0x2UL << RTC_ALRMBR_DU_Pos)
#define RTC_ALRMBR_DU_2 (0x4UL << RTC_ALRMBR_DU_Pos)
#define RTC_ALRMBR_DU_3 (0x8UL << RTC_ALRMBR_DU_Pos)
#define RTC_ALRMBR_MSK3_Pos (23U)
#define RTC_ALRMBR_MSK3_Msk (0x1UL << RTC_ALRMBR_MSK3_Pos)
#define RTC_ALRMBR_MSK3 RTC_ALRMBR_MSK3_Msk
#define RTC_ALRMBR_PM_Pos (22U)
#define RTC_ALRMBR_PM_Msk (0x1UL << RTC_ALRMBR_PM_Pos)
#define RTC_ALRMBR_PM RTC_ALRMBR_PM_Msk
#define RTC_ALRMBR_HT_Pos (20U)
#define RTC_ALRMBR_HT_Msk (0x3UL << RTC_ALRMBR_HT_Pos)
#define RTC_ALRMBR_HT RTC_ALRMBR_HT_Msk
#define RTC_ALRMBR_HT_0 (0x1UL << RTC_ALRMBR_HT_Pos)
#define RTC_ALRMBR_HT_1 (0x2UL << RTC_ALRMBR_HT_Pos)
#define RTC_ALRMBR_HU_Pos (16U)
#define RTC_ALRMBR_HU_Msk (0xFUL << RTC_ALRMBR_HU_Pos)
#define RTC_ALRMBR_HU RTC_ALRMBR_HU_Msk
#define RTC_ALRMBR_HU_0 (0x1UL << RTC_ALRMBR_HU_Pos)
#define RTC_ALRMBR_HU_1 (0x2UL << RTC_ALRMBR_HU_Pos)
#define RTC_ALRMBR_HU_2 (0x4UL << RTC_ALRMBR_HU_Pos)
#define RTC_ALRMBR_HU_3 (0x8UL << RTC_ALRMBR_HU_Pos)
#define RTC_ALRMBR_MSK2_Pos (15U)
#define RTC_ALRMBR_MSK2_Msk (0x1UL << RTC_ALRMBR_MSK2_Pos)
#define RTC_ALRMBR_MSK2 RTC_ALRMBR_MSK2_Msk
#define RTC_ALRMBR_MNT_Pos (12U)
#define RTC_ALRMBR_MNT_Msk (0x7UL << RTC_ALRMBR_MNT_Pos)
#define RTC_ALRMBR_MNT RTC_ALRMBR_MNT_Msk
#define RTC_ALRMBR_MNT_0 (0x1UL << RTC_ALRMBR_MNT_Pos)
#define RTC_ALRMBR_MNT_1 (0x2UL << RTC_ALRMBR_MNT_Pos)
#define RTC_ALRMBR_MNT_2 (0x4UL << RTC_ALRMBR_MNT_Pos)
#define RTC_ALRMBR_MNU_Pos (8U)
#define RTC_ALRMBR_MNU_Msk (0xFUL << RTC_ALRMBR_MNU_Pos)
#define RTC_ALRMBR_MNU RTC_ALRMBR_MNU_Msk
#define RTC_ALRMBR_MNU_0 (0x1UL << RTC_ALRMBR_MNU_Pos)
#define RTC_ALRMBR_MNU_1 (0x2UL << RTC_ALRMBR_MNU_Pos)
#define RTC_ALRMBR_MNU_2 (0x4UL << RTC_ALRMBR_MNU_Pos)
#define RTC_ALRMBR_MNU_3 (0x8UL << RTC_ALRMBR_MNU_Pos)
#define RTC_ALRMBR_MSK1_Pos (7U)
#define RTC_ALRMBR_MSK1_Msk (0x1UL << RTC_ALRMBR_MSK1_Pos)
#define RTC_ALRMBR_MSK1 RTC_ALRMBR_MSK1_Msk
#define RTC_ALRMBR_ST_Pos (4U)
#define RTC_ALRMBR_ST_Msk (0x7UL << RTC_ALRMBR_ST_Pos)
#define RTC_ALRMBR_ST RTC_ALRMBR_ST_Msk
#define RTC_ALRMBR_ST_0 (0x1UL << RTC_ALRMBR_ST_Pos)
#define RTC_ALRMBR_ST_1 (0x2UL << RTC_ALRMBR_ST_Pos)
#define RTC_ALRMBR_ST_2 (0x4UL << RTC_ALRMBR_ST_Pos)
#define RTC_ALRMBR_SU_Pos (0U)
#define RTC_ALRMBR_SU_Msk (0xFUL << RTC_ALRMBR_SU_Pos)
#define RTC_ALRMBR_SU RTC_ALRMBR_SU_Msk
#define RTC_ALRMBR_SU_0 (0x1UL << RTC_ALRMBR_SU_Pos)
#define RTC_ALRMBR_SU_1 (0x2UL << RTC_ALRMBR_SU_Pos)
#define RTC_ALRMBR_SU_2 (0x4UL << RTC_ALRMBR_SU_Pos)
#define RTC_ALRMBR_SU_3 (0x8UL << RTC_ALRMBR_SU_Pos)

/********************  Bits definition for RTC_ALRMASSR register  *************/
#define RTC_ALRMBSSR_MASKSS_Pos (24U)
#define RTC_ALRMBSSR_MASKSS_Msk (0xFUL << RTC_ALRMBSSR_MASKSS_Pos)
#define RTC_ALRMBSSR_MASKSS RTC_ALRMBSSR_MASKSS_Msk
#define RTC_ALRMBSSR_MASKSS_0 (0x1UL << RTC_ALRMBSSR_MASKSS_Pos)
#define RTC_ALRMBSSR_MASKSS_1 (0x2UL << RTC_ALRMBSSR_MASKSS_Pos)
#define RTC_ALRMBSSR_MASKSS_2 (0x4UL << RTC_ALRMBSSR_MASKSS_Pos)
#define RTC_ALRMBSSR_MASKSS_3 (0x8UL << RTC_ALRMBSSR_MASKSS_Pos)
#define RTC_ALRMBSSR_SS_Pos (0U)
#define RTC_ALRMBSSR_SS_Msk (0x7FFFUL << RTC_ALRMBSSR_SS_Pos)
#define RTC_ALRMBSSR_SS RTC_ALRMBSSR_SS_Msk

/********************  Bits definition for RTC_SR register  *******************/
#define RTC_SR_ITSF_Pos (5U)
#define RTC_SR_ITSF_Msk (0x1UL << RTC_SR_ITSF_Pos)
#define RTC_SR_ITSF RTC_SR_ITSF_Msk
#define RTC_SR_TSOVF_Pos (4U)
#define RTC_SR_TSOVF_Msk (0x1UL << RTC_SR_TSOVF_Pos)
#define RTC_SR_TSOVF RTC_SR_TSOVF_Msk
#define RTC_SR_TSF_Pos (3U)
#define RTC_SR_TSF_Msk (0x1UL << RTC_SR_TSF_Pos)
#define RTC_SR_TSF RTC_SR_TSF_Msk
#define RTC_SR_WUTF_Pos (2U)
#define RTC_SR_WUTF_Msk (0x1UL << RTC_SR_WUTF_Pos)
#define RTC_SR_WUTF RTC_SR_WUTF_Msk
#define RTC_SR_ALRBF_Pos (1U)
#define RTC_SR_ALRBF_Msk (0x1UL << RTC_SR_ALRBF_Pos)
#define RTC_SR_ALRBF RTC_SR_ALRBF_Msk
#define RTC_SR_ALRAF_Pos (0U)
#define RTC_SR_ALRAF_Msk (0x1UL << RTC_SR_ALRAF_Pos)
#define RTC_SR_ALRAF RTC_SR_ALRAF_Msk

/********************  Bits definition for RTC_MISR register  *****************/
#define RTC_MISR_ITSMF_Pos (5U)
#define RTC_MISR_ITSMF_Msk (0x1UL << RTC_MISR_ITSMF_Pos)
#define RTC_MISR_ITSMF RTC_MISR_ITSMF_Msk
#define RTC_MISR_TSOVMF_Pos (4U)
#define RTC_MISR_TSOVMF_Msk (0x1UL << RTC_MISR_TSOVMF_Pos)
#define RTC_MISR_TSOVMF RTC_MISR_TSOVMF_Msk
#define RTC_MISR_TSMF_Pos (3U)
#define RTC_MISR_TSMF_Msk (0x1UL << RTC_MISR_TSMF_Pos)
#define RTC_MISR_TSMF RTC_MISR_TSMF_Msk
#define RTC_MISR_WUTMF_Pos (2U)
#define RTC_MISR_WUTMF_Msk (0x1UL << RTC_MISR_WUTMF_Pos)
#define RTC_MISR_WUTMF RTC_MISR_WUTMF_Msk
#define RTC_MISR_ALRBMF_Pos (1U)
#define RTC_MISR_ALRBMF_Msk (0x1UL << RTC_MISR_ALRBMF_Pos)
#define RTC_MISR_ALRBMF RTC_MISR_ALRBMF_Msk
#define RTC_MISR_ALRAMF_Pos (0U)
#define RTC_MISR_ALRAMF_Msk (0x1UL << RTC_MISR_ALRAMF_Pos)
#define RTC_MISR_ALRAMF RTC_MISR_ALRAMF_Msk

/********************  Bits definition for RTC_SCR register  ******************/
#define RTC_SCR_CITSF_Pos (5U)
#define RTC_SCR_CITSF_Msk (0x1UL << RTC_SCR_CITSF_Pos)
#define RTC_SCR_CITSF RTC_SCR_CITSF_Msk
#define RTC_SCR_CTSOVF_Pos (4U)
#define RTC_SCR_CTSOVF_Msk (0x1UL << RTC_SCR_CTSOVF_Pos)
#define RTC_SCR_CTSOVF RTC_SCR_CTSOVF_Msk
#define RTC_SCR_CTSF_Pos (3U)
#define RTC_SCR_CTSF_Msk (0x1UL << RTC_SCR_CTSF_Pos)
#define RTC_SCR_CTSF RTC_SCR_CTSF_Msk
#define RTC_SCR_CWUTF_Pos (2U)
#define RTC_SCR_CWUTF_Msk (0x1UL << RTC_SCR_CWUTF_Pos)
#define RTC_SCR_CWUTF RTC_SCR_CWUTF_Msk
#define RTC_SCR_CALRBF_Pos (1U)
#define RTC_SCR_CALRBF_Msk (0x1UL << RTC_SCR_CALRBF_Pos)
#define RTC_SCR_CALRBF RTC_SCR_CALRBF_Msk
#define RTC_SCR_CALRAF_Pos (0U)
#define RTC_SCR_CALRAF_Msk (0x1UL << RTC_SCR_CALRAF_Pos)
#define RTC_SCR_CALRAF RTC_SCR_CALRAF_Msk

/******************************************************************************/
/*                                                                            */
/*                     Tamper and backup register (TAMP)                      */
/*                                                                            */
/******************************************************************************/
/********************  Bits definition for TAMP_CR1 register  *****************/
#define TAMP_CR1_TAMP1E_Pos (0U)
#define TAMP_CR1_TAMP1E_Msk (0x1UL << TAMP_CR1_TAMP1E_Pos)
#define TAMP_CR1_TAMP1E TAMP_CR1_TAMP1E_Msk
#define TAMP_CR1_TAMP2E_Pos (1U)
#define TAMP_CR1_TAMP2E_Msk (0x1UL << TAMP_CR1_TAMP2E_Pos)
#define TAMP_CR1_TAMP2E TAMP_CR1_TAMP2E_Msk
#define TAMP_CR1_TAMP3E_Pos (2U)
#define TAMP_CR1_TAMP3E_Msk (0x1UL << TAMP_CR1_TAMP3E_Pos)
#define TAMP_CR1_TAMP3E TAMP_CR1_TAMP3E_Msk
#define TAMP_CR1_ITAMP3E_Pos (18U)
#define TAMP_CR1_ITAMP3E_Msk (0x1UL << TAMP_CR1_ITAMP3E_Pos)
#define TAMP_CR1_ITAMP3E TAMP_CR1_ITAMP3E_Msk
#define TAMP_CR1_ITAMP4E_Pos (19U)
#define TAMP_CR1_ITAMP4E_Msk (0x1UL << TAMP_CR1_ITAMP4E_Pos)
#define TAMP_CR1_ITAMP4E TAMP_CR1_ITAMP4E_Msk
#define TAMP_CR1_ITAMP5E_Pos (20U)
#define TAMP_CR1_ITAMP5E_Msk (0x1UL << TAMP_CR1_ITAMP5E_Pos)
#define TAMP_CR1_ITAMP5E TAMP_CR1_ITAMP5E_Msk
#define TAMP_CR1_ITAMP6E_Pos (21U)
#define TAMP_CR1_ITAMP6E_Msk (0x1UL << TAMP_CR1_ITAMP6E_Pos)
#define TAMP_CR1_ITAMP6E TAMP_CR1_ITAMP6E_Msk

/********************  Bits definition for TAMP_CR2 register  *****************/
#define TAMP_CR2_TAMP1NOERASE_Pos (0U)
#define TAMP_CR2_TAMP1NOERASE_Msk (0x1UL << TAMP_CR2_TAMP1NOERASE_Pos)
#define TAMP_CR2_TAMP1NOERASE TAMP_CR2_TAMP1NOERASE_Msk
#define TAMP_CR2_TAMP2NOERASE_Pos (1U)
#define TAMP_CR2_TAMP2NOERASE_Msk (0x1UL << TAMP_CR2_TAMP2NOERASE_Pos)
#define TAMP_CR2_TAMP2NOERASE TAMP_CR2_TAMP2NOERASE_Msk
#define TAMP_CR2_TAMP3NOERASE_Pos (2U)
#define TAMP_CR2_TAMP3NOERASE_Msk (0x1UL << TAMP_CR2_TAMP3NOERASE_Pos)
#define TAMP_CR2_TAMP3NOERASE TAMP_CR2_TAMP3NOERASE_Msk
#define TAMP_CR2_TAMP1MSK_Pos (16U)
#define TAMP_CR2_TAMP1MSK_Msk (0x1UL << TAMP_CR2_TAMP1MSK_Pos)
#define TAMP_CR2_TAMP1MSK TAMP_CR2_TAMP1MSK_Msk
#define TAMP_CR2_TAMP2MSK_Pos (17U)
#define TAMP_CR2_TAMP2MSK_Msk (0x1UL << TAMP_CR2_TAMP2MSK_Pos)
#define TAMP_CR2_TAMP2MSK TAMP_CR2_TAMP2MSK_Msk
#define TAMP_CR2_TAMP3MSK_Pos (18U)
#define TAMP_CR2_TAMP3MSK_Msk (0x1UL << TAMP_CR2_TAMP3MSK_Pos)
#define TAMP_CR2_TAMP3MSK TAMP_CR2_TAMP3MSK_Msk
#define TAMP_CR2_TAMP1TRG_Pos (24U)
#define TAMP_CR2_TAMP1TRG_Msk (0x1UL << TAMP_CR2_TAMP1TRG_Pos)
#define TAMP_CR2_TAMP1TRG TAMP_CR2_TAMP1TRG_Msk
#define TAMP_CR2_TAMP2TRG_Pos (25U)
#define TAMP_CR2_TAMP2TRG_Msk (0x1UL << TAMP_CR2_TAMP2TRG_Pos)
#define TAMP_CR2_TAMP2TRG TAMP_CR2_TAMP2TRG_Msk
#define TAMP_CR2_TAMP3TRG_Pos (26U)
#define TAMP_CR2_TAMP3TRG_Msk (0x1UL << TAMP_CR2_TAMP3TRG_Pos)
#define TAMP_CR2_TAMP3TRG TAMP_CR2_TAMP3TRG_Msk

/* Legacy aliases */
#define TAMP_CR2_TAMP1MF_Pos TAMP_CR2_TAMP1MSK_Pos
#define TAMP_CR2_TAMP1MF_Msk TAMP_CR2_TAMP1MSK_Msk
#define TAMP_CR2_TAMP1MF TAMP_CR2_TAMP1MSK
#define TAMP_CR2_TAMP2MF_Pos TAMP_CR2_TAMP2MSK_Pos
#define TAMP_CR2_TAMP2MF_Msk TAMP_CR2_TAMP2MSK_Msk
#define TAMP_CR2_TAMP2MF TAMP_CR2_TAMP2MSK
#define TAMP_CR2_TAMP3MF_Pos TAMP_CR2_TAMP3MSK_Pos
#define TAMP_CR2_TAMP3MF_Msk TAMP_CR2_TAMP3MSK_Msk
#define TAMP_CR2_TAMP3MF TAMP_CR2_TAMP3MSK

/********************  Bits definition for TAMP_FLTCR register  ***************/
#define TAMP_FLTCR_TAMPFREQ_0 (0x00000001UL)
#define TAMP_FLTCR_TAMPFREQ_1 (0x00000002UL)
#define TAMP_FLTCR_TAMPFREQ_2 (0x00000004UL)
#define TAMP_FLTCR_TAMPFREQ_Pos (0U)
#define TAMP_FLTCR_TAMPFREQ_Msk (0x7UL << TAMP_FLTCR_TAMPFREQ_Pos)
#define TAMP_FLTCR_TAMPFREQ TAMP_FLTCR_TAMPFREQ_Msk
#define TAMP_FLTCR_TAMPFLT_0 (0x00000008UL)
#define TAMP_FLTCR_TAMPFLT_1 (0x00000010UL)
#define TAMP_FLTCR_TAMPFLT_Pos (3U)
#define TAMP_FLTCR_TAMPFLT_Msk (0x3UL << TAMP_FLTCR_TAMPFLT_Pos)
#define TAMP_FLTCR_TAMPFLT TAMP_FLTCR_TAMPFLT_Msk
#define TAMP_FLTCR_TAMPPRCH_0 (0x00000020UL)
#define TAMP_FLTCR_TAMPPRCH_1 (0x00000040UL)
#define TAMP_FLTCR_TAMPPRCH_Pos (5U)
#define TAMP_FLTCR_TAMPPRCH_Msk (0x3UL << TAMP_FLTCR_TAMPPRCH_Pos)
#define TAMP_FLTCR_TAMPPRCH TAMP_FLTCR_TAMPPRCH_Msk
#define TAMP_FLTCR_TAMPPUDIS_Pos (7U)
#define TAMP_FLTCR_TAMPPUDIS_Msk (0x1UL << TAMP_FLTCR_TAMPPUDIS_Pos)
#define TAMP_FLTCR_TAMPPUDIS TAMP_FLTCR_TAMPPUDIS_Msk

/********************  Bits definition for TAMP_IER register  *****************/
#define TAMP_IER_TAMP1IE_Pos (0U)
#define TAMP_IER_TAMP1IE_Msk (0x1UL << TAMP_IER_TAMP1IE_Pos)
#define TAMP_IER_TAMP1IE TAMP_IER_TAMP1IE_Msk
#define TAMP_IER_TAMP2IE_Pos (1U)
#define TAMP_IER_TAMP2IE_Msk (0x1UL << TAMP_IER_TAMP2IE_Pos)
#define TAMP_IER_TAMP2IE TAMP_IER_TAMP2IE_Msk
#define TAMP_IER_TAMP3IE_Pos (2U)
#define TAMP_IER_TAMP3IE_Msk (0x1UL << TAMP_IER_TAMP3IE_Pos)
#define TAMP_IER_TAMP3IE TAMP_IER_TAMP3IE_Msk
#define TAMP_IER_ITAMP3IE_Pos (18U)
#define TAMP_IER_ITAMP3IE_Msk (0x1UL << TAMP_IER_ITAMP3IE_Pos)
#define TAMP_IER_ITAMP3IE TAMP_IER_ITAMP3IE_Msk
#define TAMP_IER_ITAMP4IE_Pos (19U)
#define TAMP_IER_ITAMP4IE_Msk (0x1UL << TAMP_IER_ITAMP4IE_Pos)
#define TAMP_IER_ITAMP4IE TAMP_IER_ITAMP4IE_Msk
#define TAMP_IER_ITAMP5IE_Pos (20U)
#define TAMP_IER_ITAMP5IE_Msk (0x1UL << TAMP_IER_ITAMP5IE_Pos)
#define TAMP_IER_ITAMP5IE TAMP_IER_ITAMP5IE_Msk
#define TAMP_IER_ITAMP6IE_Pos (21U)
#define TAMP_IER_ITAMP6IE_Msk (0x1UL << TAMP_IER_ITAMP6IE_Pos)
#define TAMP_IER_ITAMP6IE TAMP_IER_ITAMP6IE_Msk

/********************  Bits definition for TAMP_SR register  ******************/
#define TAMP_SR_TAMP1F_Pos (0U)
#define TAMP_SR_TAMP1F_Msk (0x1UL << TAMP_SR_TAMP1F_Pos)
#define TAMP_SR_TAMP1F TAMP_SR_TAMP1F_Msk
#define TAMP_SR_TAMP2F_Pos (1U)
#define TAMP_SR_TAMP2F_Msk (0x1UL << TAMP_SR_TAMP2F_Pos)
#define TAMP_SR_TAMP2F TAMP_SR_TAMP2F_Msk
#define TAMP_SR_TAMP3F_Pos (2U)
#define TAMP_SR_TAMP3F_Msk (0x1UL << TAMP_SR_TAMP3F_Pos)
#define TAMP_SR_TAMP3F TAMP_SR_TAMP3F_Msk
#define TAMP_SR_ITAMP3F_Pos (18U)
#define TAMP_SR_ITAMP3F_Msk (0x1UL << TAMP_SR_ITAMP3F_Pos)
#define TAMP_SR_ITAMP3F TAMP_SR_ITAMP3F_Msk
#define TAMP_SR_ITAMP4F_Pos (19U)
#define TAMP_SR_ITAMP4F_Msk (0x1UL << TAMP_SR_ITAMP4F_Pos)
#define TAMP_SR_ITAMP4F TAMP_SR_ITAMP4F_Msk
#define TAMP_SR_ITAMP5F_Pos (20U)
#define TAMP_SR_ITAMP5F_Msk (0x1UL << TAMP_SR_ITAMP5F_Pos)
#define TAMP_SR_ITAMP5F TAMP_SR_ITAMP5F_Msk
#define TAMP_SR_ITAMP6F_Pos (21U)
#define TAMP_SR_ITAMP6F_Msk (0x1UL << TAMP_SR_ITAMP6F_Pos)
#define TAMP_SR_ITAMP6F TAMP_SR_ITAMP6F_Msk

/********************  Bits definition for TAMP_MISR register  ****************/
#define TAMP_MISR_TAMP1MF_Pos (0U)
#define TAMP_MISR_TAMP1MF_Msk (0x1UL << TAMP_MISR_TAMP1MF_Pos)
#define TAMP_MISR_TAMP1MF TAMP_MISR_TAMP1MF_Msk
#define TAMP_MISR_TAMP2MF_Pos (1U)
#define TAMP_MISR_TAMP2MF_Msk (0x1UL << TAMP_MISR_TAMP2MF_Pos)
#define TAMP_MISR_TAMP2MF TAMP_MISR_TAMP2MF_Msk
#define TAMP_MISR_TAMP3MF_Pos (2U)
#define TAMP_MISR_TAMP3MF_Msk (0x1UL << TAMP_MISR_TAMP3MF_Pos)
#define TAMP_MISR_TAMP3MF TAMP_MISR_TAMP3MF_Msk
#define TAMP_MISR_ITAMP3MF_Pos (18U)
#define TAMP_MISR_ITAMP3MF_Msk (0x1UL << TAMP_MISR_ITAMP3MF_Pos)
#define TAMP_MISR_ITAMP3MF TAMP_MISR_ITAMP3MF_Msk
#define TAMP_MISR_ITAMP4MF_Pos (19U)
#define TAMP_MISR_ITAMP4MF_Msk (0x1UL << TAMP_MISR_ITAMP4MF_Pos)
#define TAMP_MISR_ITAMP4MF TAMP_MISR_ITAMP4MF_Msk
#define TAMP_MISR_ITAMP5MF_Pos (20U)
#define TAMP_MISR_ITAMP5MF_Msk (0x1UL << TAMP_MISR_ITAMP5MF_Pos)
#define TAMP_MISR_ITAMP5MF TAMP_MISR_ITAMP5MF_Msk
#define TAMP_MISR_ITAMP6MF_Pos (21U)
#define TAMP_MISR_ITAMP6MF_Msk (0x1UL << TAMP_MISR_ITAMP6MF_Pos)
#define TAMP_MISR_ITAMP6MF TAMP_MISR_ITAMP6MF_Msk

/********************  Bits definition for TAMP_SCR register  *****************/
#define TAMP_SCR_CTAMP1F_Pos (0U)
#define TAMP_SCR_CTAMP1F_Msk (0x1UL << TAMP_SCR_CTAMP1F_Pos)
#define TAMP_SCR_CTAMP1F TAMP_SCR_CTAMP1F_Msk
#define TAMP_SCR_CTAMP2F_Pos (1U)
#define TAMP_SCR_CTAMP2F_Msk (0x1UL << TAMP_SCR_CTAMP2F_Pos)
#define TAMP_SCR_CTAMP2F TAMP_SCR_CTAMP2F_Msk
#define TAMP_SCR_CTAMP3F_Pos (2U)
#define TAMP_SCR_CTAMP3F_Msk (0x1UL << TAMP_SCR_CTAMP3F_Pos)
#define TAMP_SCR_CTAMP3F TAMP_SCR_CTAMP3F_Msk
#define TAMP_SCR_CITAMP3F_Pos (18U)
#define TAMP_SCR_CITAMP3F_Msk (0x1UL << TAMP_SCR_CITAMP3F_Pos)
#define TAMP_SCR_CITAMP3F TAMP_SCR_CITAMP3F_Msk
#define TAMP_SCR_CITAMP4F_Pos (19U)
#define TAMP_SCR_CITAMP4F_Msk (0x1UL << TAMP_SCR_CITAMP4F_Pos)
#define TAMP_SCR_CITAMP4F TAMP_SCR_CITAMP4F_Msk
#define TAMP_SCR_CITAMP5F_Pos (20U)
#define TAMP_SCR_CITAMP5F_Msk (0x1UL << TAMP_SCR_CITAMP5F_Pos)
#define TAMP_SCR_CITAMP5F TAMP_SCR_CITAMP5F_Msk
#define TAMP_SCR_CITAMP6F_Pos (21U)
#define TAMP_SCR_CITAMP6F_Msk (0x1UL << TAMP_SCR_CITAMP6F_Pos)
#define TAMP_SCR_CITAMP6F TAMP_SCR_CITAMP6F_Msk

/********************  Bits definition for TAMP_BKP0R register  ***************/
#define TAMP_BKP0R_Pos (0U)
#define TAMP_BKP0R_Msk (0xFFFFFFFFUL << TAMP_BKP0R_Pos)
#define TAMP_BKP0R TAMP_BKP0R_Msk

/********************  Bits definition for TAMP_BKP1R register  ***************/
#define TAMP_BKP1R_Pos (0U)
#define TAMP_BKP1R_Msk (0xFFFFFFFFUL << TAMP_BKP1R_Pos)
#define TAMP_BKP1R TAMP_BKP1R_Msk

/********************  Bits definition for TAMP_BKP2R register  ***************/
#define TAMP_BKP2R_Pos (0U)
#define TAMP_BKP2R_Msk (0xFFFFFFFFUL << TAMP_BKP2R_Pos)
#define TAMP_BKP2R TAMP_BKP2R_Msk

/********************  Bits definition for TAMP_BKP3R register  ***************/
#define TAMP_BKP3R_Pos (0U)
#define TAMP_BKP3R_Msk (0xFFFFFFFFUL << TAMP_BKP3R_Pos)
#define TAMP_BKP3R TAMP_BKP3R_Msk

/********************  Bits definition for TAMP_BKP4R register  ***************/
#define TAMP_BKP4R_Pos (0U)
#define TAMP_BKP4R_Msk (0xFFFFFFFFUL << TAMP_BKP4R_Pos)
#define TAMP_BKP4R TAMP_BKP4R_Msk

/********************  Bits definition for TAMP_BKP5R register  ***************/
#define TAMP_BKP5R_Pos (0U)
#define TAMP_BKP5R_Msk (0xFFFFFFFFUL << TAMP_BKP5R_Pos)
#define TAMP_BKP5R TAMP_BKP5R_Msk

/********************  Bits definition for TAMP_BKP6R register  ***************/
#define TAMP_BKP6R_Pos (0U)
#define TAMP_BKP6R_Msk (0xFFFFFFFFUL << TAMP_BKP6R_Pos)
#define TAMP_BKP6R TAMP_BKP6R_Msk

/********************  Bits definition for TAMP_BKP7R register  ***************/
#define TAMP_BKP7R_Pos (0U)
#define TAMP_BKP7R_Msk (0xFFFFFFFFUL << TAMP_BKP7R_Pos)
#define TAMP_BKP7R TAMP_BKP7R_Msk

/********************  Bits definition for TAMP_BKP8R register  ***************/
#define TAMP_BKP8R_Pos (0U)
#define TAMP_BKP8R_Msk (0xFFFFFFFFUL << TAMP_BKP8R_Pos)
#define TAMP_BKP8R TAMP_BKP8R_Msk

/********************  Bits definition for TAMP_BKP9R register  ***************/
#define TAMP_BKP9R_Pos (0U)
#define TAMP_BKP9R_Msk (0xFFFFFFFFUL << TAMP_BKP9R_Pos)
#define TAMP_BKP9R TAMP_BKP9R_Msk

/********************  Bits definition for TAMP_BKP10R register  ***************/
#define TAMP_BKP10R_Pos (0U)
#define TAMP_BKP10R_Msk (0xFFFFFFFFUL << TAMP_BKP10R_Pos)
#define TAMP_BKP10R TAMP_BKP10R_Msk

/********************  Bits definition for TAMP_BKP11R register  ***************/
#define TAMP_BKP11R_Pos (0U)
#define TAMP_BKP11R_Msk (0xFFFFFFFFUL << TAMP_BKP11R_Pos)
#define TAMP_BKP11R TAMP_BKP11R_Msk

/********************  Bits definition for TAMP_BKP12R register  ***************/
#define TAMP_BKP12R_Pos (0U)
#define TAMP_BKP12R_Msk (0xFFFFFFFFUL << TAMP_BKP12R_Pos)
#define TAMP_BKP12R TAMP_BKP12R_Msk

/********************  Bits definition for TAMP_BKP13R register  ***************/
#define TAMP_BKP13R_Pos (0U)
#define TAMP_BKP13R_Msk (0xFFFFFFFFUL << TAMP_BKP13R_Pos)
#define TAMP_BKP13R TAMP_BKP13R_Msk

/********************  Bits definition for TAMP_BKP14R register  ***************/
#define TAMP_BKP14R_Pos (0U)
#define TAMP_BKP14R_Msk (0xFFFFFFFFUL << TAMP_BKP14R_Pos)
#define TAMP_BKP14R TAMP_BKP14R_Msk

/********************  Bits definition for TAMP_BKP15R register  ***************/
#define TAMP_BKP15R_Pos (0U)
#define TAMP_BKP15R_Msk (0xFFFFFFFFUL << TAMP_BKP15R_Pos)
#define TAMP_BKP15R TAMP_BKP15R_Msk

/********************  Bits definition for TAMP_BKP16R register  ***************/
#define TAMP_BKP16R_Pos (0U)
#define TAMP_BKP16R_Msk (0xFFFFFFFFUL << TAMP_BKP16R_Pos)
#define TAMP_BKP16R TAMP_BKP16R_Msk

/********************  Bits definition for TAMP_BKP17R register  ***************/
#define TAMP_BKP17R_Pos (0U)
#define TAMP_BKP17R_Msk (0xFFFFFFFFUL << TAMP_BKP17R_Pos)
#define TAMP_BKP17R TAMP_BKP17R_Msk

/********************  Bits definition for TAMP_BKP18R register  ***************/
#define TAMP_BKP18R_Pos (0U)
#define TAMP_BKP18R_Msk (0xFFFFFFFFUL << TAMP_BKP18R_Pos)
#define TAMP_BKP18R TAMP_BKP18R_Msk

/********************  Bits definition for TAMP_BKP19R register  ***************/
#define TAMP_BKP19R_Pos (0U)
#define TAMP_BKP19R_Msk (0xFFFFFFFFUL << TAMP_BKP19R_Pos)
#define TAMP_BKP19R TAMP_BKP19R_Msk

/********************  Bits definition for TAMP_BKP20R register  ***************/
#define TAMP_BKP20R_Pos (0U)
#define TAMP_BKP20R_Msk (0xFFFFFFFFUL << TAMP_BKP20R_Pos)
#define TAMP_BKP20R TAMP_BKP20R_Msk

/********************  Bits definition for TAMP_BKP21R register  ***************/
#define TAMP_BKP21R_Pos (0U)
#define TAMP_BKP21R_Msk (0xFFFFFFFFUL << TAMP_BKP21R_Pos)
#define TAMP_BKP21R TAMP_BKP21R_Msk

/********************  Bits definition for TAMP_BKP22R register  ***************/
#define TAMP_BKP22R_Pos (0U)
#define TAMP_BKP22R_Msk (0xFFFFFFFFUL << TAMP_BKP22R_Pos)
#define TAMP_BKP22R TAMP_BKP22R_Msk

/********************  Bits definition for TAMP_BKP23R register  ***************/
#define TAMP_BKP23R_Pos (0U)
#define TAMP_BKP23R_Msk (0xFFFFFFFFUL << TAMP_BKP23R_Pos)
#define TAMP_BKP23R TAMP_BKP23R_Msk

/********************  Bits definition for TAMP_BKP24R register  ***************/
#define TAMP_BKP24R_Pos (0U)
#define TAMP_BKP24R_Msk (0xFFFFFFFFUL << TAMP_BKP24R_Pos)
#define TAMP_BKP24R TAMP_BKP24R_Msk

/********************  Bits definition for TAMP_BKP25R register  ***************/
#define TAMP_BKP25R_Pos (0U)
#define TAMP_BKP25R_Msk (0xFFFFFFFFUL << TAMP_BKP25R_Pos)
#define TAMP_BKP25R TAMP_BKP25R_Msk

/********************  Bits definition for TAMP_BKP26R register  ***************/
#define TAMP_BKP26R_Pos (0U)
#define TAMP_BKP26R_Msk (0xFFFFFFFFUL << TAMP_BKP26R_Pos)
#define TAMP_BKP26R TAMP_BKP26R_Msk

/********************  Bits definition for TAMP_BKP27R register  ***************/
#define TAMP_BKP27R_Pos (0U)
#define TAMP_BKP27R_Msk (0xFFFFFFFFUL << TAMP_BKP27R_Pos)
#define TAMP_BKP27R TAMP_BKP27R_Msk

/********************  Bits definition for TAMP_BKP28R register  ***************/
#define TAMP_BKP28R_Pos (0U)
#define TAMP_BKP28R_Msk (0xFFFFFFFFUL << TAMP_BKP28R_Pos)
#define TAMP_BKP28R TAMP_BKP28R_Msk

/********************  Bits definition for TAMP_BKP29R register  ***************/
#define TAMP_BKP29R_Pos (0U)
#define TAMP_BKP29R_Msk (0xFFFFFFFFUL << TAMP_BKP29R_Pos)
#define TAMP_BKP29R TAMP_BKP29R_Msk

/********************  Bits definition for TAMP_BKP30R register  ***************/
#define TAMP_BKP30R_Pos (0U)
#define TAMP_BKP30R_Msk (0xFFFFFFFFUL << TAMP_BKP30R_Pos)
#define TAMP_BKP30R TAMP_BKP30R_Msk

/********************  Bits definition for TAMP_BKP31R register  ***************/
#define TAMP_BKP31R_Pos (0U)
#define TAMP_BKP31R_Msk (0xFFFFFFFFUL << TAMP_BKP31R_Pos)
#define TAMP_BKP31R TAMP_BKP31R_Msk


/******************************************************************************/
/*                                                                            */
/*                          Serial Audio Interface                            */
/*                                                                            */
/******************************************************************************/
/*******************  Bit definition for SAI_xCR1 register  *******************/
#define SAI_xCR1_MODE_Pos (0U)
#define SAI_xCR1_MODE_Msk (0x3UL << SAI_xCR1_MODE_Pos)
#define SAI_xCR1_MODE SAI_xCR1_MODE_Msk
#define SAI_xCR1_MODE_0 (0x1UL << SAI_xCR1_MODE_Pos)
#define SAI_xCR1_MODE_1 (0x2UL << SAI_xCR1_MODE_Pos)

#define SAI_xCR1_PRTCFG_Pos (2U)
#define SAI_xCR1_PRTCFG_Msk (0x3UL << SAI_xCR1_PRTCFG_Pos)
#define SAI_xCR1_PRTCFG SAI_xCR1_PRTCFG_Msk
#define SAI_xCR1_PRTCFG_0 (0x1UL << SAI_xCR1_PRTCFG_Pos)
#define SAI_xCR1_PRTCFG_1 (0x2UL << SAI_xCR1_PRTCFG_Pos)

#define SAI_xCR1_DS_Pos (5U)
#define SAI_xCR1_DS_Msk (0x7UL << SAI_xCR1_DS_Pos)
#define SAI_xCR1_DS SAI_xCR1_DS_Msk
#define SAI_xCR1_DS_0 (0x1UL << SAI_xCR1_DS_Pos)
#define SAI_xCR1_DS_1 (0x2UL << SAI_xCR1_DS_Pos)
#define SAI_xCR1_DS_2 (0x4UL << SAI_xCR1_DS_Pos)

#define SAI_xCR1_LSBFIRST_Pos (8U)
#define SAI_xCR1_LSBFIRST_Msk (0x1UL << SAI_xCR1_LSBFIRST_Pos)
#define SAI_xCR1_LSBFIRST SAI_xCR1_LSBFIRST_Msk
#define SAI_xCR1_CKSTR_Pos (9U)
#define SAI_xCR1_CKSTR_Msk (0x1UL << SAI_xCR1_CKSTR_Pos)
#define SAI_xCR1_CKSTR SAI_xCR1_CKSTR_Msk

#define SAI_xCR1_SYNCEN_Pos (10U)
#define SAI_xCR1_SYNCEN_Msk (0x3UL << SAI_xCR1_SYNCEN_Pos)
#define SAI_xCR1_SYNCEN SAI_xCR1_SYNCEN_Msk
#define SAI_xCR1_SYNCEN_0 (0x1UL << SAI_xCR1_SYNCEN_Pos)
#define SAI_xCR1_SYNCEN_1 (0x2UL << SAI_xCR1_SYNCEN_Pos)

#define SAI_xCR1_MONO_Pos (12U)
#define SAI_xCR1_MONO_Msk (0x1UL << SAI_xCR1_MONO_Pos)
#define SAI_xCR1_MONO SAI_xCR1_MONO_Msk
#define SAI_xCR1_OUTDRIV_Pos (13U)
#define SAI_xCR1_OUTDRIV_Msk (0x1UL << SAI_xCR1_OUTDRIV_Pos)
#define SAI_xCR1_OUTDRIV SAI_xCR1_OUTDRIV_Msk
#define SAI_xCR1_SAIEN_Pos (16U)
#define SAI_xCR1_SAIEN_Msk (0x1UL << SAI_xCR1_SAIEN_Pos)
#define SAI_xCR1_SAIEN SAI_xCR1_SAIEN_Msk
#define SAI_xCR1_DMAEN_Pos (17U)
#define SAI_xCR1_DMAEN_Msk (0x1UL << SAI_xCR1_DMAEN_Pos)
#define SAI_xCR1_DMAEN SAI_xCR1_DMAEN_Msk
#define SAI_xCR1_NODIV_Pos (19U)
#define SAI_xCR1_NODIV_Msk (0x1UL << SAI_xCR1_NODIV_Pos)
#define SAI_xCR1_NODIV SAI_xCR1_NODIV_Msk

#define SAI_xCR1_MCKDIV_Pos (20U)
#define SAI_xCR1_MCKDIV_Msk (0x3FUL << SAI_xCR1_MCKDIV_Pos)
#define SAI_xCR1_MCKDIV SAI_xCR1_MCKDIV_Msk
#define SAI_xCR1_MCKDIV_0 (0x00100000U)
#define SAI_xCR1_MCKDIV_1 (0x00200000U)
#define SAI_xCR1_MCKDIV_2 (0x00400000U)
#define SAI_xCR1_MCKDIV_3 (0x00800000U)
#define SAI_xCR1_MCKDIV_4 (0x01000000U)
#define SAI_xCR1_MCKDIV_5 (0x02000000U)

#define SAI_xCR1_OSR_Pos (26U)
#define SAI_xCR1_OSR_Msk (0x1UL << SAI_xCR1_OSR_Pos)
#define SAI_xCR1_OSR SAI_xCR1_OSR_Msk

#define SAI_xCR1_MCKEN_Pos (27U)
#define SAI_xCR1_MCKEN_Msk (0x1UL << SAI_xCR1_MCKEN_Pos)
#define SAI_xCR1_MCKEN SAI_xCR1_MCKEN_Msk

/*******************  Bit definition for SAI_xCR2 register  *******************/
#define SAI_xCR2_FTH_Pos (0U)
#define SAI_xCR2_FTH_Msk (0x7UL << SAI_xCR2_FTH_Pos)
#define SAI_xCR2_FTH SAI_xCR2_FTH_Msk
#define SAI_xCR2_FTH_0 (0x1UL << SAI_xCR2_FTH_Pos)
#define SAI_xCR2_FTH_1 (0x2UL << SAI_xCR2_FTH_Pos)
#define SAI_xCR2_FTH_2 (0x4UL << SAI_xCR2_FTH_Pos)

#define SAI_xCR2_FFLUSH_Pos (3U)
#define SAI_xCR2_FFLUSH_Msk (0x1UL << SAI_xCR2_FFLUSH_Pos)
#define SAI_xCR2_FFLUSH SAI_xCR2_FFLUSH_Msk
#define SAI_xCR2_TRIS_Pos (4U)
#define SAI_xCR2_TRIS_Msk (0x1UL << SAI_xCR2_TRIS_Pos)
#define SAI_xCR2_TRIS SAI_xCR2_TRIS_Msk
#define SAI_xCR2_MUTE_Pos (5U)
#define SAI_xCR2_MUTE_Msk (0x1UL << SAI_xCR2_MUTE_Pos)
#define SAI_xCR2_MUTE SAI_xCR2_MUTE_Msk
#define SAI_xCR2_MUTEVAL_Pos (6U)
#define SAI_xCR2_MUTEVAL_Msk (0x1UL << SAI_xCR2_MUTEVAL_Pos)
#define SAI_xCR2_MUTEVAL SAI_xCR2_MUTEVAL_Msk


#define SAI_xCR2_MUTECNT_Pos (7U)
#define SAI_xCR2_MUTECNT_Msk (0x3FUL << SAI_xCR2_MUTECNT_Pos)
#define SAI_xCR2_MUTECNT SAI_xCR2_MUTECNT_Msk
#define SAI_xCR2_MUTECNT_0 (0x01UL << SAI_xCR2_MUTECNT_Pos)
#define SAI_xCR2_MUTECNT_1 (0x02UL << SAI_xCR2_MUTECNT_Pos)
#define SAI_xCR2_MUTECNT_2 (0x04UL << SAI_xCR2_MUTECNT_Pos)
#define SAI_xCR2_MUTECNT_3 (0x08UL << SAI_xCR2_MUTECNT_Pos)
#define SAI_xCR2_MUTECNT_4 (0x10UL << SAI_xCR2_MUTECNT_Pos)
#define SAI_xCR2_MUTECNT_5 (0x20UL << SAI_xCR2_MUTECNT_Pos)

#define SAI_xCR2_CPL_Pos (13U)
#define SAI_xCR2_CPL_Msk (0x1UL << SAI_xCR2_CPL_Pos)
#define SAI_xCR2_CPL SAI_xCR2_CPL_Msk
#define SAI_xCR2_COMP_Pos (14U)
#define SAI_xCR2_COMP_Msk (0x3UL << SAI_xCR2_COMP_Pos)
#define SAI_xCR2_COMP SAI_xCR2_COMP_Msk
#define SAI_xCR2_COMP_0 (0x1UL << SAI_xCR2_COMP_Pos)
#define SAI_xCR2_COMP_1 (0x2UL << SAI_xCR2_COMP_Pos)


/******************  Bit definition for SAI_xFRCR register  *******************/
#define SAI_xFRCR_FRL_Pos (0U)
#define SAI_xFRCR_FRL_Msk (0xFFUL << SAI_xFRCR_FRL_Pos)
#define SAI_xFRCR_FRL SAI_xFRCR_FRL_Msk
#define SAI_xFRCR_FRL_0 (0x01UL << SAI_xFRCR_FRL_Pos)
#define SAI_xFRCR_FRL_1 (0x02UL << SAI_xFRCR_FRL_Pos)
#define SAI_xFRCR_FRL_2 (0x04UL << SAI_xFRCR_FRL_Pos)
#define SAI_xFRCR_FRL_3 (0x08UL << SAI_xFRCR_FRL_Pos)
#define SAI_xFRCR_FRL_4 (0x10UL << SAI_xFRCR_FRL_Pos)
#define SAI_xFRCR_FRL_5 (0x20UL << SAI_xFRCR_FRL_Pos)
#define SAI_xFRCR_FRL_6 (0x40UL << SAI_xFRCR_FRL_Pos)
#define SAI_xFRCR_FRL_7 (0x80UL << SAI_xFRCR_FRL_Pos)

#define SAI_xFRCR_FSALL_Pos (8U)
#define SAI_xFRCR_FSALL_Msk (0x7FUL << SAI_xFRCR_FSALL_Pos)
#define SAI_xFRCR_FSALL SAI_xFRCR_FSALL_Msk
#define SAI_xFRCR_FSALL_0 (0x01UL << SAI_xFRCR_FSALL_Pos)
#define SAI_xFRCR_FSALL_1 (0x02UL << SAI_xFRCR_FSALL_Pos)
#define SAI_xFRCR_FSALL_2 (0x04UL << SAI_xFRCR_FSALL_Pos)
#define SAI_xFRCR_FSALL_3 (0x08UL << SAI_xFRCR_FSALL_Pos)
#define SAI_xFRCR_FSALL_4 (0x10UL << SAI_xFRCR_FSALL_Pos)
#define SAI_xFRCR_FSALL_5 (0x20UL << SAI_xFRCR_FSALL_Pos)
#define SAI_xFRCR_FSALL_6 (0x40UL << SAI_xFRCR_FSALL_Pos)

#define SAI_xFRCR_FSDEF_Pos (16U)
#define SAI_xFRCR_FSDEF_Msk (0x1UL << SAI_xFRCR_FSDEF_Pos)
#define SAI_xFRCR_FSDEF SAI_xFRCR_FSDEF_Msk
#define SAI_xFRCR_FSPOL_Pos (17U)
#define SAI_xFRCR_FSPOL_Msk (0x1UL << SAI_xFRCR_FSPOL_Pos)
#define SAI_xFRCR_FSPOL SAI_xFRCR_FSPOL_Msk
#define SAI_xFRCR_FSOFF_Pos (18U)
#define SAI_xFRCR_FSOFF_Msk (0x1UL << SAI_xFRCR_FSOFF_Pos)
#define SAI_xFRCR_FSOFF SAI_xFRCR_FSOFF_Msk

/******************  Bit definition for SAI_xSLOTR register  *******************/
#define SAI_xSLOTR_FBOFF_Pos (0U)
#define SAI_xSLOTR_FBOFF_Msk (0x1FUL << SAI_xSLOTR_FBOFF_Pos)
#define SAI_xSLOTR_FBOFF SAI_xSLOTR_FBOFF_Msk
#define SAI_xSLOTR_FBOFF_0 (0x01UL << SAI_xSLOTR_FBOFF_Pos)
#define SAI_xSLOTR_FBOFF_1 (0x02UL << SAI_xSLOTR_FBOFF_Pos)
#define SAI_xSLOTR_FBOFF_2 (0x04UL << SAI_xSLOTR_FBOFF_Pos)
#define SAI_xSLOTR_FBOFF_3 (0x08UL << SAI_xSLOTR_FBOFF_Pos)
#define SAI_xSLOTR_FBOFF_4 (0x10UL << SAI_xSLOTR_FBOFF_Pos)

#define SAI_xSLOTR_SLOTSZ_Pos (6U)
#define SAI_xSLOTR_SLOTSZ_Msk (0x3UL << SAI_xSLOTR_SLOTSZ_Pos)
#define SAI_xSLOTR_SLOTSZ SAI_xSLOTR_SLOTSZ_Msk
#define SAI_xSLOTR_SLOTSZ_0 (0x1UL << SAI_xSLOTR_SLOTSZ_Pos)
#define SAI_xSLOTR_SLOTSZ_1 (0x2UL << SAI_xSLOTR_SLOTSZ_Pos)

#define SAI_xSLOTR_NBSLOT_Pos (8U)
#define SAI_xSLOTR_NBSLOT_Msk (0xFUL << SAI_xSLOTR_NBSLOT_Pos)
#define SAI_xSLOTR_NBSLOT SAI_xSLOTR_NBSLOT_Msk
#define SAI_xSLOTR_NBSLOT_0 (0x1UL << SAI_xSLOTR_NBSLOT_Pos)
#define SAI_xSLOTR_NBSLOT_1 (0x2UL << SAI_xSLOTR_NBSLOT_Pos)
#define SAI_xSLOTR_NBSLOT_2 (0x4UL << SAI_xSLOTR_NBSLOT_Pos)
#define SAI_xSLOTR_NBSLOT_3 (0x8UL << SAI_xSLOTR_NBSLOT_Pos)

#define SAI_xSLOTR_SLOTEN_Pos (16U)
#define SAI_xSLOTR_SLOTEN_Msk (0xFFFFUL << SAI_xSLOTR_SLOTEN_Pos)
#define SAI_xSLOTR_SLOTEN SAI_xSLOTR_SLOTEN_Msk

/*******************  Bit definition for SAI_xIMR register  *******************/
#define SAI_xIMR_OVRUDRIE_Pos (0U)
#define SAI_xIMR_OVRUDRIE_Msk (0x1UL << SAI_xIMR_OVRUDRIE_Pos)
#define SAI_xIMR_OVRUDRIE SAI_xIMR_OVRUDRIE_Msk
#define SAI_xIMR_MUTEDETIE_Pos (1U)
#define SAI_xIMR_MUTEDETIE_Msk (0x1UL << SAI_xIMR_MUTEDETIE_Pos)
#define SAI_xIMR_MUTEDETIE SAI_xIMR_MUTEDETIE_Msk
#define SAI_xIMR_WCKCFGIE_Pos (2U)
#define SAI_xIMR_WCKCFGIE_Msk (0x1UL << SAI_xIMR_WCKCFGIE_Pos)
#define SAI_xIMR_WCKCFGIE SAI_xIMR_WCKCFGIE_Msk
#define SAI_xIMR_FREQIE_Pos (3U)
#define SAI_xIMR_FREQIE_Msk (0x1UL << SAI_xIMR_FREQIE_Pos)
#define SAI_xIMR_FREQIE SAI_xIMR_FREQIE_Msk
#define SAI_xIMR_CNRDYIE_Pos (4U)
#define SAI_xIMR_CNRDYIE_Msk (0x1UL << SAI_xIMR_CNRDYIE_Pos)
#define SAI_xIMR_CNRDYIE SAI_xIMR_CNRDYIE_Msk
#define SAI_xIMR_AFSDETIE_Pos (5U)
#define SAI_xIMR_AFSDETIE_Msk (0x1UL << SAI_xIMR_AFSDETIE_Pos)
#define SAI_xIMR_AFSDETIE SAI_xIMR_AFSDETIE_Msk
#define SAI_xIMR_LFSDETIE_Pos (6U)
#define SAI_xIMR_LFSDETIE_Msk (0x1UL << SAI_xIMR_LFSDETIE_Pos)
#define SAI_xIMR_LFSDETIE SAI_xIMR_LFSDETIE_Msk

/********************  Bit definition for SAI_xSR register  *******************/
#define SAI_xSR_OVRUDR_Pos (0U)
#define SAI_xSR_OVRUDR_Msk (0x1UL << SAI_xSR_OVRUDR_Pos)
#define SAI_xSR_OVRUDR SAI_xSR_OVRUDR_Msk
#define SAI_xSR_MUTEDET_Pos (1U)
#define SAI_xSR_MUTEDET_Msk (0x1UL << SAI_xSR_MUTEDET_Pos)
#define SAI_xSR_MUTEDET SAI_xSR_MUTEDET_Msk
#define SAI_xSR_WCKCFG_Pos (2U)
#define SAI_xSR_WCKCFG_Msk (0x1UL << SAI_xSR_WCKCFG_Pos)
#define SAI_xSR_WCKCFG SAI_xSR_WCKCFG_Msk
#define SAI_xSR_FREQ_Pos (3U)
#define SAI_xSR_FREQ_Msk (0x1UL << SAI_xSR_FREQ_Pos)
#define SAI_xSR_FREQ SAI_xSR_FREQ_Msk
#define SAI_xSR_CNRDY_Pos (4U)
#define SAI_xSR_CNRDY_Msk (0x1UL << SAI_xSR_CNRDY_Pos)
#define SAI_xSR_CNRDY SAI_xSR_CNRDY_Msk
#define SAI_xSR_AFSDET_Pos (5U)
#define SAI_xSR_AFSDET_Msk (0x1UL << SAI_xSR_AFSDET_Pos)
#define SAI_xSR_AFSDET SAI_xSR_AFSDET_Msk
#define SAI_xSR_LFSDET_Pos (6U)
#define SAI_xSR_LFSDET_Msk (0x1UL << SAI_xSR_LFSDET_Pos)
#define SAI_xSR_LFSDET SAI_xSR_LFSDET_Msk

#define SAI_xSR_FLVL_Pos (16U)
#define SAI_xSR_FLVL_Msk (0x7UL << SAI_xSR_FLVL_Pos)
#define SAI_xSR_FLVL SAI_xSR_FLVL_Msk
#define SAI_xSR_FLVL_0 (0x1UL << SAI_xSR_FLVL_Pos)
#define SAI_xSR_FLVL_1 (0x2UL << SAI_xSR_FLVL_Pos)
#define SAI_xSR_FLVL_2 (0x4UL << SAI_xSR_FLVL_Pos)

/******************  Bit definition for SAI_xCLRFR register  ******************/
#define SAI_xCLRFR_COVRUDR_Pos (0U)
#define SAI_xCLRFR_COVRUDR_Msk (0x1UL << SAI_xCLRFR_COVRUDR_Pos)
#define SAI_xCLRFR_COVRUDR SAI_xCLRFR_COVRUDR_Msk
#define SAI_xCLRFR_CMUTEDET_Pos (1U)
#define SAI_xCLRFR_CMUTEDET_Msk (0x1UL << SAI_xCLRFR_CMUTEDET_Pos)
#define SAI_xCLRFR_CMUTEDET SAI_xCLRFR_CMUTEDET_Msk
#define SAI_xCLRFR_CWCKCFG_Pos (2U)
#define SAI_xCLRFR_CWCKCFG_Msk (0x1UL << SAI_xCLRFR_CWCKCFG_Pos)
#define SAI_xCLRFR_CWCKCFG SAI_xCLRFR_CWCKCFG_Msk
#define SAI_xCLRFR_CFREQ_Pos (3U)
#define SAI_xCLRFR_CFREQ_Msk (0x1UL << SAI_xCLRFR_CFREQ_Pos)
#define SAI_xCLRFR_CFREQ SAI_xCLRFR_CFREQ_Msk
#define SAI_xCLRFR_CCNRDY_Pos (4U)
#define SAI_xCLRFR_CCNRDY_Msk (0x1UL << SAI_xCLRFR_CCNRDY_Pos)
#define SAI_xCLRFR_CCNRDY SAI_xCLRFR_CCNRDY_Msk
#define SAI_xCLRFR_CAFSDET_Pos (5U)
#define SAI_xCLRFR_CAFSDET_Msk (0x1UL << SAI_xCLRFR_CAFSDET_Pos)
#define SAI_xCLRFR_CAFSDET SAI_xCLRFR_CAFSDET_Msk
#define SAI_xCLRFR_CLFSDET_Pos (6U)
#define SAI_xCLRFR_CLFSDET_Msk (0x1UL << SAI_xCLRFR_CLFSDET_Pos)
#define SAI_xCLRFR_CLFSDET SAI_xCLRFR_CLFSDET_Msk

/******************  Bit definition for SAI_xDR register  ******************/
#define SAI_xDR_DATA_Pos (0U)
#define SAI_xDR_DATA_Msk (0xFFFFFFFFUL << SAI_xDR_DATA_Pos)
#define SAI_xDR_DATA SAI_xDR_DATA_Msk

/******************  Bit definition for SAI_PDMCR register  *******************/
#define SAI_PDMCR_PDMEN_Pos (0U)
#define SAI_PDMCR_PDMEN_Msk (0x1UL << SAI_PDMCR_PDMEN_Pos)
#define SAI_PDMCR_PDMEN SAI_PDMCR_PDMEN_Msk

#define SAI_PDMCR_MICNBR_Pos (4U)
#define SAI_PDMCR_MICNBR_Msk (0x3UL << SAI_PDMCR_MICNBR_Pos)
#define SAI_PDMCR_MICNBR SAI_PDMCR_MICNBR_Msk
#define SAI_PDMCR_MICNBR_0 (0x1UL << SAI_PDMCR_MICNBR_Pos)
#define SAI_PDMCR_MICNBR_1 (0x2UL << SAI_PDMCR_MICNBR_Pos)

#define SAI_PDMCR_CKEN1_Pos (8U)
#define SAI_PDMCR_CKEN1_Msk (0x1UL << SAI_PDMCR_CKEN1_Pos)
#define SAI_PDMCR_CKEN1 SAI_PDMCR_CKEN1_Msk
#define SAI_PDMCR_CKEN2_Pos (9U)
#define SAI_PDMCR_CKEN2_Msk (0x1UL << SAI_PDMCR_CKEN2_Pos)
#define SAI_PDMCR_CKEN2 SAI_PDMCR_CKEN2_Msk
#define SAI_PDMCR_CKEN3_Pos (10U)
#define SAI_PDMCR_CKEN3_Msk (0x1UL << SAI_PDMCR_CKEN3_Pos)
#define SAI_PDMCR_CKEN3 SAI_PDMCR_CKEN3_Msk
#define SAI_PDMCR_CKEN4_Pos (11U)
#define SAI_PDMCR_CKEN4_Msk (0x1UL << SAI_PDMCR_CKEN4_Pos)
#define SAI_PDMCR_CKEN4 SAI_PDMCR_CKEN4_Msk

/******************  Bit definition for SAI_PDMDLY register  ******************/
#define SAI_PDMDLY_DLYM1L_Pos (0U)
#define SAI_PDMDLY_DLYM1L_Msk (0x7UL << SAI_PDMDLY_DLYM1L_Pos)
#define SAI_PDMDLY_DLYM1L SAI_PDMDLY_DLYM1L_Msk
#define SAI_PDMDLY_DLYM1L_0 (0x1UL << SAI_PDMDLY_DLYM1L_Pos)
#define SAI_PDMDLY_DLYM1L_1 (0x2UL << SAI_PDMDLY_DLYM1L_Pos)
#define SAI_PDMDLY_DLYM1L_2 (0x4UL << SAI_PDMDLY_DLYM1L_Pos)

#define SAI_PDMDLY_DLYM1R_Pos (4U)
#define SAI_PDMDLY_DLYM1R_Msk (0x7UL << SAI_PDMDLY_DLYM1R_Pos)
#define SAI_PDMDLY_DLYM1R SAI_PDMDLY_DLYM1R_Msk
#define SAI_PDMDLY_DLYM1R_0 (0x1UL << SAI_PDMDLY_DLYM1R_Pos)
#define SAI_PDMDLY_DLYM1R_1 (0x2UL << SAI_PDMDLY_DLYM1R_Pos)
#define SAI_PDMDLY_DLYM1R_2 (0x4UL << SAI_PDMDLY_DLYM1R_Pos)

#define SAI_PDMDLY_DLYM2L_Pos (8U)
#define SAI_PDMDLY_DLYM2L_Msk (0x7UL << SAI_PDMDLY_DLYM2L_Pos)
#define SAI_PDMDLY_DLYM2L SAI_PDMDLY_DLYM2L_Msk
#define SAI_PDMDLY_DLYM2L_0 (0x1UL << SAI_PDMDLY_DLYM2L_Pos)
#define SAI_PDMDLY_DLYM2L_1 (0x2UL << SAI_PDMDLY_DLYM2L_Pos)
#define SAI_PDMDLY_DLYM2L_2 (0x4UL << SAI_PDMDLY_DLYM2L_Pos)

#define SAI_PDMDLY_DLYM2R_Pos (12U)
#define SAI_PDMDLY_DLYM2R_Msk (0x7UL << SAI_PDMDLY_DLYM2R_Pos)
#define SAI_PDMDLY_DLYM2R SAI_PDMDLY_DLYM2R_Msk
#define SAI_PDMDLY_DLYM2R_0 (0x1UL << SAI_PDMDLY_DLYM2R_Pos)
#define SAI_PDMDLY_DLYM2R_1 (0x2UL << SAI_PDMDLY_DLYM2R_Pos)
#define SAI_PDMDLY_DLYM2R_2 (0x4UL << SAI_PDMDLY_DLYM2R_Pos)

#define SAI_PDMDLY_DLYM3L_Pos (16U)
#define SAI_PDMDLY_DLYM3L_Msk (0x7UL << SAI_PDMDLY_DLYM3L_Pos)
#define SAI_PDMDLY_DLYM3L SAI_PDMDLY_DLYM3L_Msk
#define SAI_PDMDLY_DLYM3L_0 (0x1UL << SAI_PDMDLY_DLYM3L_Pos)
#define SAI_PDMDLY_DLYM3L_1 (0x2UL << SAI_PDMDLY_DLYM3L_Pos)
#define SAI_PDMDLY_DLYM3L_2 (0x4UL << SAI_PDMDLY_DLYM3L_Pos)

#define SAI_PDMDLY_DLYM3R_Pos (20U)
#define SAI_PDMDLY_DLYM3R_Msk (0x7UL << SAI_PDMDLY_DLYM3R_Pos)
#define SAI_PDMDLY_DLYM3R SAI_PDMDLY_DLYM3R_Msk
#define SAI_PDMDLY_DLYM3R_0 (0x1UL << SAI_PDMDLY_DLYM3R_Pos)
#define SAI_PDMDLY_DLYM3R_1 (0x2UL << SAI_PDMDLY_DLYM3R_Pos)
#define SAI_PDMDLY_DLYM3R_2 (0x4UL << SAI_PDMDLY_DLYM3R_Pos)

#define SAI_PDMDLY_DLYM4L_Pos (24U)
#define SAI_PDMDLY_DLYM4L_Msk (0x7UL << SAI_PDMDLY_DLYM4L_Pos)
#define SAI_PDMDLY_DLYM4L SAI_PDMDLY_DLYM4L_Msk
#define SAI_PDMDLY_DLYM4L_0 (0x1UL << SAI_PDMDLY_DLYM4L_Pos)
#define SAI_PDMDLY_DLYM4L_1 (0x2UL << SAI_PDMDLY_DLYM4L_Pos)
#define SAI_PDMDLY_DLYM4L_2 (0x4UL << SAI_PDMDLY_DLYM4L_Pos)

#define SAI_PDMDLY_DLYM4R_Pos (28U)
#define SAI_PDMDLY_DLYM4R_Msk (0x7UL << SAI_PDMDLY_DLYM4R_Pos)
#define SAI_PDMDLY_DLYM4R SAI_PDMDLY_DLYM4R_Msk
#define SAI_PDMDLY_DLYM4R_0 (0x1UL << SAI_PDMDLY_DLYM4R_Pos)
#define SAI_PDMDLY_DLYM4R_1 (0x2UL << SAI_PDMDLY_DLYM4R_Pos)
#define SAI_PDMDLY_DLYM4R_2 (0x4UL << SAI_PDMDLY_DLYM4R_Pos)


/******************************************************************************/
/*                                                                            */
/*                        Serial Peripheral Interface (SPI)                   */
/*                                                                            */
/******************************************************************************/
/*
 * @brief Specific device feature definitions (not present on all devices in the STM32G4 series)
 */
#define SPI_I2S_SUPPORT 

/*******************  Bit definition for SPI_CR1 register  ********************/
#define SPI_CR1_CPHA_Pos (0U)
#define SPI_CR1_CPHA_Msk (0x1UL << SPI_CR1_CPHA_Pos)
#define SPI_CR1_CPHA SPI_CR1_CPHA_Msk
#define SPI_CR1_CPOL_Pos (1U)
#define SPI_CR1_CPOL_Msk (0x1UL << SPI_CR1_CPOL_Pos)
#define SPI_CR1_CPOL SPI_CR1_CPOL_Msk
#define SPI_CR1_MSTR_Pos (2U)
#define SPI_CR1_MSTR_Msk (0x1UL << SPI_CR1_MSTR_Pos)
#define SPI_CR1_MSTR SPI_CR1_MSTR_Msk

#define SPI_CR1_BR_Pos (3U)
#define SPI_CR1_BR_Msk (0x7UL << SPI_CR1_BR_Pos)
#define SPI_CR1_BR SPI_CR1_BR_Msk
#define SPI_CR1_BR_0 (0x1UL << SPI_CR1_BR_Pos)
#define SPI_CR1_BR_1 (0x2UL << SPI_CR1_BR_Pos)
#define SPI_CR1_BR_2 (0x4UL << SPI_CR1_BR_Pos)

#define SPI_CR1_SPE_Pos (6U)
#define SPI_CR1_SPE_Msk (0x1UL << SPI_CR1_SPE_Pos)
#define SPI_CR1_SPE SPI_CR1_SPE_Msk
#define SPI_CR1_LSBFIRST_Pos (7U)
#define SPI_CR1_LSBFIRST_Msk (0x1UL << SPI_CR1_LSBFIRST_Pos)
#define SPI_CR1_LSBFIRST SPI_CR1_LSBFIRST_Msk
#define SPI_CR1_SSI_Pos (8U)
#define SPI_CR1_SSI_Msk (0x1UL << SPI_CR1_SSI_Pos)
#define SPI_CR1_SSI SPI_CR1_SSI_Msk
#define SPI_CR1_SSM_Pos (9U)
#define SPI_CR1_SSM_Msk (0x1UL << SPI_CR1_SSM_Pos)
#define SPI_CR1_SSM SPI_CR1_SSM_Msk
#define SPI_CR1_RXONLY_Pos (10U)
#define SPI_CR1_RXONLY_Msk (0x1UL << SPI_CR1_RXONLY_Pos)
#define SPI_CR1_RXONLY SPI_CR1_RXONLY_Msk
#define SPI_CR1_CRCL_Pos (11U)
#define SPI_CR1_CRCL_Msk (0x1UL << SPI_CR1_CRCL_Pos)
#define SPI_CR1_CRCL SPI_CR1_CRCL_Msk
#define SPI_CR1_CRCNEXT_Pos (12U)
#define SPI_CR1_CRCNEXT_Msk (0x1UL << SPI_CR1_CRCNEXT_Pos)
#define SPI_CR1_CRCNEXT SPI_CR1_CRCNEXT_Msk
#define SPI_CR1_CRCEN_Pos (13U)
#define SPI_CR1_CRCEN_Msk (0x1UL << SPI_CR1_CRCEN_Pos)
#define SPI_CR1_CRCEN SPI_CR1_CRCEN_Msk
#define SPI_CR1_BIDIOE_Pos (14U)
#define SPI_CR1_BIDIOE_Msk (0x1UL << SPI_CR1_BIDIOE_Pos)
#define SPI_CR1_BIDIOE SPI_CR1_BIDIOE_Msk
#define SPI_CR1_BIDIMODE_Pos (15U)
#define SPI_CR1_BIDIMODE_Msk (0x1UL << SPI_CR1_BIDIMODE_Pos)
#define SPI_CR1_BIDIMODE SPI_CR1_BIDIMODE_Msk

/*******************  Bit definition for SPI_CR2 register  ********************/
#define SPI_CR2_RXDMAEN_Pos (0U)
#define SPI_CR2_RXDMAEN_Msk (0x1UL << SPI_CR2_RXDMAEN_Pos)
#define SPI_CR2_RXDMAEN SPI_CR2_RXDMAEN_Msk
#define SPI_CR2_TXDMAEN_Pos (1U)
#define SPI_CR2_TXDMAEN_Msk (0x1UL << SPI_CR2_TXDMAEN_Pos)
#define SPI_CR2_TXDMAEN SPI_CR2_TXDMAEN_Msk
#define SPI_CR2_SSOE_Pos (2U)
#define SPI_CR2_SSOE_Msk (0x1UL << SPI_CR2_SSOE_Pos)
#define SPI_CR2_SSOE SPI_CR2_SSOE_Msk
#define SPI_CR2_NSSP_Pos (3U)
#define SPI_CR2_NSSP_Msk (0x1UL << SPI_CR2_NSSP_Pos)
#define SPI_CR2_NSSP SPI_CR2_NSSP_Msk
#define SPI_CR2_FRF_Pos (4U)
#define SPI_CR2_FRF_Msk (0x1UL << SPI_CR2_FRF_Pos)
#define SPI_CR2_FRF SPI_CR2_FRF_Msk
#define SPI_CR2_ERRIE_Pos (5U)
#define SPI_CR2_ERRIE_Msk (0x1UL << SPI_CR2_ERRIE_Pos)
#define SPI_CR2_ERRIE SPI_CR2_ERRIE_Msk
#define SPI_CR2_RXNEIE_Pos (6U)
#define SPI_CR2_RXNEIE_Msk (0x1UL << SPI_CR2_RXNEIE_Pos)
#define SPI_CR2_RXNEIE SPI_CR2_RXNEIE_Msk
#define SPI_CR2_TXEIE_Pos (7U)
#define SPI_CR2_TXEIE_Msk (0x1UL << SPI_CR2_TXEIE_Pos)
#define SPI_CR2_TXEIE SPI_CR2_TXEIE_Msk
#define SPI_CR2_DS_Pos (8U)
#define SPI_CR2_DS_Msk (0xFUL << SPI_CR2_DS_Pos)
#define SPI_CR2_DS SPI_CR2_DS_Msk
#define SPI_CR2_DS_0 (0x1UL << SPI_CR2_DS_Pos)
#define SPI_CR2_DS_1 (0x2UL << SPI_CR2_DS_Pos)
#define SPI_CR2_DS_2 (0x4UL << SPI_CR2_DS_Pos)
#define SPI_CR2_DS_3 (0x8UL << SPI_CR2_DS_Pos)
#define SPI_CR2_FRXTH_Pos (12U)
#define SPI_CR2_FRXTH_Msk (0x1UL << SPI_CR2_FRXTH_Pos)
#define SPI_CR2_FRXTH SPI_CR2_FRXTH_Msk
#define SPI_CR2_LDMARX_Pos (13U)
#define SPI_CR2_LDMARX_Msk (0x1UL << SPI_CR2_LDMARX_Pos)
#define SPI_CR2_LDMARX SPI_CR2_LDMARX_Msk
#define SPI_CR2_LDMATX_Pos (14U)
#define SPI_CR2_LDMATX_Msk (0x1UL << SPI_CR2_LDMATX_Pos)
#define SPI_CR2_LDMATX SPI_CR2_LDMATX_Msk

/********************  Bit definition for SPI_SR register  ********************/
#define SPI_SR_RXNE_Pos (0U)
#define SPI_SR_RXNE_Msk (0x1UL << SPI_SR_RXNE_Pos)
#define SPI_SR_RXNE SPI_SR_RXNE_Msk
#define SPI_SR_TXE_Pos (1U)
#define SPI_SR_TXE_Msk (0x1UL << SPI_SR_TXE_Pos)
#define SPI_SR_TXE SPI_SR_TXE_Msk
#define SPI_SR_CHSIDE_Pos (2U)
#define SPI_SR_CHSIDE_Msk (0x1UL << SPI_SR_CHSIDE_Pos)
#define SPI_SR_CHSIDE SPI_SR_CHSIDE_Msk
#define SPI_SR_UDR_Pos (3U)
#define SPI_SR_UDR_Msk (0x1UL << SPI_SR_UDR_Pos)
#define SPI_SR_UDR SPI_SR_UDR_Msk
#define SPI_SR_CRCERR_Pos (4U)
#define SPI_SR_CRCERR_Msk (0x1UL << SPI_SR_CRCERR_Pos)
#define SPI_SR_CRCERR SPI_SR_CRCERR_Msk
#define SPI_SR_MODF_Pos (5U)
#define SPI_SR_MODF_Msk (0x1UL << SPI_SR_MODF_Pos)
#define SPI_SR_MODF SPI_SR_MODF_Msk
#define SPI_SR_OVR_Pos (6U)
#define SPI_SR_OVR_Msk (0x1UL << SPI_SR_OVR_Pos)
#define SPI_SR_OVR SPI_SR_OVR_Msk
#define SPI_SR_BSY_Pos (7U)
#define SPI_SR_BSY_Msk (0x1UL << SPI_SR_BSY_Pos)
#define SPI_SR_BSY SPI_SR_BSY_Msk
#define SPI_SR_FRE_Pos (8U)
#define SPI_SR_FRE_Msk (0x1UL << SPI_SR_FRE_Pos)
#define SPI_SR_FRE SPI_SR_FRE_Msk
#define SPI_SR_FRLVL_Pos (9U)
#define SPI_SR_FRLVL_Msk (0x3UL << SPI_SR_FRLVL_Pos)
#define SPI_SR_FRLVL SPI_SR_FRLVL_Msk
#define SPI_SR_FRLVL_0 (0x1UL << SPI_SR_FRLVL_Pos)
#define SPI_SR_FRLVL_1 (0x2UL << SPI_SR_FRLVL_Pos)
#define SPI_SR_FTLVL_Pos (11U)
#define SPI_SR_FTLVL_Msk (0x3UL << SPI_SR_FTLVL_Pos)
#define SPI_SR_FTLVL SPI_SR_FTLVL_Msk
#define SPI_SR_FTLVL_0 (0x1UL << SPI_SR_FTLVL_Pos)
#define SPI_SR_FTLVL_1 (0x2UL << SPI_SR_FTLVL_Pos)

/********************  Bit definition for SPI_DR register  ********************/
#define SPI_DR_DR_Pos (0U)
#define SPI_DR_DR_Msk (0xFFFFUL << SPI_DR_DR_Pos)
#define SPI_DR_DR SPI_DR_DR_Msk

/*******************  Bit definition for SPI_CRCPR register  ******************/
#define SPI_CRCPR_CRCPOLY_Pos (0U)
#define SPI_CRCPR_CRCPOLY_Msk (0xFFFFUL << SPI_CRCPR_CRCPOLY_Pos)
#define SPI_CRCPR_CRCPOLY SPI_CRCPR_CRCPOLY_Msk

/******************  Bit definition for SPI_RXCRCR register  ******************/
#define SPI_RXCRCR_RXCRC_Pos (0U)
#define SPI_RXCRCR_RXCRC_Msk (0xFFFFUL << SPI_RXCRCR_RXCRC_Pos)
#define SPI_RXCRCR_RXCRC SPI_RXCRCR_RXCRC_Msk

/******************  Bit definition for SPI_TXCRCR register  ******************/
#define SPI_TXCRCR_TXCRC_Pos (0U)
#define SPI_TXCRCR_TXCRC_Msk (0xFFFFUL << SPI_TXCRCR_TXCRC_Pos)
#define SPI_TXCRCR_TXCRC SPI_TXCRCR_TXCRC_Msk

/******************  Bit definition for SPI_I2SCFGR register  *****************/
#define SPI_I2SCFGR_CHLEN_Pos (0U)
#define SPI_I2SCFGR_CHLEN_Msk (0x1UL << SPI_I2SCFGR_CHLEN_Pos)
#define SPI_I2SCFGR_CHLEN SPI_I2SCFGR_CHLEN_Msk
#define SPI_I2SCFGR_DATLEN_Pos (1U)
#define SPI_I2SCFGR_DATLEN_Msk (0x3UL << SPI_I2SCFGR_DATLEN_Pos)
#define SPI_I2SCFGR_DATLEN SPI_I2SCFGR_DATLEN_Msk
#define SPI_I2SCFGR_DATLEN_0 (0x1UL << SPI_I2SCFGR_DATLEN_Pos)
#define SPI_I2SCFGR_DATLEN_1 (0x2UL << SPI_I2SCFGR_DATLEN_Pos)
#define SPI_I2SCFGR_CKPOL_Pos (3U)
#define SPI_I2SCFGR_CKPOL_Msk (0x1UL << SPI_I2SCFGR_CKPOL_Pos)
#define SPI_I2SCFGR_CKPOL SPI_I2SCFGR_CKPOL_Msk
#define SPI_I2SCFGR_I2SSTD_Pos (4U)
#define SPI_I2SCFGR_I2SSTD_Msk (0x3UL << SPI_I2SCFGR_I2SSTD_Pos)
#define SPI_I2SCFGR_I2SSTD SPI_I2SCFGR_I2SSTD_Msk
#define SPI_I2SCFGR_I2SSTD_0 (0x1UL << SPI_I2SCFGR_I2SSTD_Pos)
#define SPI_I2SCFGR_I2SSTD_1 (0x2UL << SPI_I2SCFGR_I2SSTD_Pos)
#define SPI_I2SCFGR_PCMSYNC_Pos (7U)
#define SPI_I2SCFGR_PCMSYNC_Msk (0x1UL << SPI_I2SCFGR_PCMSYNC_Pos)
#define SPI_I2SCFGR_PCMSYNC SPI_I2SCFGR_PCMSYNC_Msk
#define SPI_I2SCFGR_I2SCFG_Pos (8U)
#define SPI_I2SCFGR_I2SCFG_Msk (0x3UL << SPI_I2SCFGR_I2SCFG_Pos)
#define SPI_I2SCFGR_I2SCFG SPI_I2SCFGR_I2SCFG_Msk
#define SPI_I2SCFGR_I2SCFG_0 (0x1UL << SPI_I2SCFGR_I2SCFG_Pos)
#define SPI_I2SCFGR_I2SCFG_1 (0x2UL << SPI_I2SCFGR_I2SCFG_Pos)
#define SPI_I2SCFGR_I2SE_Pos (10U)
#define SPI_I2SCFGR_I2SE_Msk (0x1UL << SPI_I2SCFGR_I2SE_Pos)
#define SPI_I2SCFGR_I2SE SPI_I2SCFGR_I2SE_Msk
#define SPI_I2SCFGR_I2SMOD_Pos (11U)
#define SPI_I2SCFGR_I2SMOD_Msk (0x1UL << SPI_I2SCFGR_I2SMOD_Pos)
#define SPI_I2SCFGR_I2SMOD SPI_I2SCFGR_I2SMOD_Msk
#define SPI_I2SCFGR_ASTRTEN_Pos (12U)
#define SPI_I2SCFGR_ASTRTEN_Msk (0x1UL << SPI_I2SCFGR_ASTRTEN_Pos)
#define SPI_I2SCFGR_ASTRTEN SPI_I2SCFGR_ASTRTEN_Msk

/******************  Bit definition for SPI_I2SPR register  *******************/
#define SPI_I2SPR_I2SDIV_Pos (0U)
#define SPI_I2SPR_I2SDIV_Msk (0xFFUL << SPI_I2SPR_I2SDIV_Pos)
#define SPI_I2SPR_I2SDIV SPI_I2SPR_I2SDIV_Msk
#define SPI_I2SPR_ODD_Pos (8U)
#define SPI_I2SPR_ODD_Msk (0x1UL << SPI_I2SPR_ODD_Pos)
#define SPI_I2SPR_ODD SPI_I2SPR_ODD_Msk
#define SPI_I2SPR_MCKOE_Pos (9U)
#define SPI_I2SPR_MCKOE_Msk (0x1UL << SPI_I2SPR_MCKOE_Pos)
#define SPI_I2SPR_MCKOE SPI_I2SPR_MCKOE_Msk

/******************************************************************************/
/*                                                                            */
/*                                 SYSCFG                                     */
/*                                                                            */
/******************************************************************************/
/******************  Bit definition for SYSCFG_MEMRMP register ***************/
#define SYSCFG_MEMRMP_MEM_MODE_Pos (0U)
#define SYSCFG_MEMRMP_MEM_MODE_Msk (0x7UL << SYSCFG_MEMRMP_MEM_MODE_Pos)
#define SYSCFG_MEMRMP_MEM_MODE SYSCFG_MEMRMP_MEM_MODE_Msk
#define SYSCFG_MEMRMP_MEM_MODE_0 (0x1UL << SYSCFG_MEMRMP_MEM_MODE_Pos)
#define SYSCFG_MEMRMP_MEM_MODE_1 (0x2UL << SYSCFG_MEMRMP_MEM_MODE_Pos)
#define SYSCFG_MEMRMP_MEM_MODE_2 (0x4UL << SYSCFG_MEMRMP_MEM_MODE_Pos)

#define SYSCFG_MEMRMP_FB_MODE_Pos (8U)
#define SYSCFG_MEMRMP_FB_MODE_Msk (0x1UL << SYSCFG_MEMRMP_FB_MODE_Pos)
#define SYSCFG_MEMRMP_FB_MODE SYSCFG_MEMRMP_FB_MODE_Msk

/******************  Bit definition for SYSCFG_CFGR1 register ******************/
#define SYSCFG_CFGR1_BOOSTEN_Pos (8U)
#define SYSCFG_CFGR1_BOOSTEN_Msk (0x1UL << SYSCFG_CFGR1_BOOSTEN_Pos)
#define SYSCFG_CFGR1_BOOSTEN SYSCFG_CFGR1_BOOSTEN_Msk
#define SYSCFG_CFGR1_ANASWVDD_Pos (9U)
#define SYSCFG_CFGR1_ANASWVDD_Msk (0x1UL << SYSCFG_CFGR1_ANASWVDD_Pos)
#define SYSCFG_CFGR1_ANASWVDD SYSCFG_CFGR1_ANASWVDD_Msk
#define SYSCFG_CFGR1_I2C_PB6_FMP_Pos (16U)
#define SYSCFG_CFGR1_I2C_PB6_FMP_Msk (0x1UL << SYSCFG_CFGR1_I2C_PB6_FMP_Pos)
#define SYSCFG_CFGR1_I2C_PB6_FMP SYSCFG_CFGR1_I2C_PB6_FMP_Msk
#define SYSCFG_CFGR1_I2C_PB7_FMP_Pos (17U)
#define SYSCFG_CFGR1_I2C_PB7_FMP_Msk (0x1UL << SYSCFG_CFGR1_I2C_PB7_FMP_Pos)
#define SYSCFG_CFGR1_I2C_PB7_FMP SYSCFG_CFGR1_I2C_PB7_FMP_Msk
#define SYSCFG_CFGR1_I2C_PB8_FMP_Pos (18U)
#define SYSCFG_CFGR1_I2C_PB8_FMP_Msk (0x1UL << SYSCFG_CFGR1_I2C_PB8_FMP_Pos)
#define SYSCFG_CFGR1_I2C_PB8_FMP SYSCFG_CFGR1_I2C_PB8_FMP_Msk
#define SYSCFG_CFGR1_I2C_PB9_FMP_Pos (19U)
#define SYSCFG_CFGR1_I2C_PB9_FMP_Msk (0x1UL << SYSCFG_CFGR1_I2C_PB9_FMP_Pos)
#define SYSCFG_CFGR1_I2C_PB9_FMP SYSCFG_CFGR1_I2C_PB9_FMP_Msk
#define SYSCFG_CFGR1_I2C1_FMP_Pos (20U)
#define SYSCFG_CFGR1_I2C1_FMP_Msk (0x1UL << SYSCFG_CFGR1_I2C1_FMP_Pos)
#define SYSCFG_CFGR1_I2C1_FMP SYSCFG_CFGR1_I2C1_FMP_Msk
#define SYSCFG_CFGR1_I2C2_FMP_Pos (21U)
#define SYSCFG_CFGR1_I2C2_FMP_Msk (0x1UL << SYSCFG_CFGR1_I2C2_FMP_Pos)
#define SYSCFG_CFGR1_I2C2_FMP SYSCFG_CFGR1_I2C2_FMP_Msk
#define SYSCFG_CFGR1_I2C3_FMP_Pos (22U)
#define SYSCFG_CFGR1_I2C3_FMP_Msk (0x1UL << SYSCFG_CFGR1_I2C3_FMP_Pos)
#define SYSCFG_CFGR1_I2C3_FMP SYSCFG_CFGR1_I2C3_FMP_Msk
#define SYSCFG_CFGR1_I2C4_FMP_Pos (23U)
#define SYSCFG_CFGR1_I2C4_FMP_Msk (0x1UL << SYSCFG_CFGR1_I2C4_FMP_Pos)
#define SYSCFG_CFGR1_I2C4_FMP SYSCFG_CFGR1_I2C4_FMP_Msk
#define SYSCFG_CFGR1_FPU_IE_0 (0x04000000U)
#define SYSCFG_CFGR1_FPU_IE_1 (0x08000000U)
#define SYSCFG_CFGR1_FPU_IE_2 (0x10000000U)
#define SYSCFG_CFGR1_FPU_IE_3 (0x20000000U)
#define SYSCFG_CFGR1_FPU_IE_4 (0x40000000U)
#define SYSCFG_CFGR1_FPU_IE_5 (0x80000000U)

/*****************  Bit definition for SYSCFG_EXTICR1 register  ***************/
#define SYSCFG_EXTICR1_EXTI0_Pos (0U)
#define SYSCFG_EXTICR1_EXTI0_Msk (0x7UL << SYSCFG_EXTICR1_EXTI0_Pos)
#define SYSCFG_EXTICR1_EXTI0 SYSCFG_EXTICR1_EXTI0_Msk
#define SYSCFG_EXTICR1_EXTI1_Pos (4U)
#define SYSCFG_EXTICR1_EXTI1_Msk (0x7UL << SYSCFG_EXTICR1_EXTI1_Pos)
#define SYSCFG_EXTICR1_EXTI1 SYSCFG_EXTICR1_EXTI1_Msk
#define SYSCFG_EXTICR1_EXTI2_Pos (8U)
#define SYSCFG_EXTICR1_EXTI2_Msk (0x7UL << SYSCFG_EXTICR1_EXTI2_Pos)
#define SYSCFG_EXTICR1_EXTI2 SYSCFG_EXTICR1_EXTI2_Msk
#define SYSCFG_EXTICR1_EXTI3_Pos (12U)
#define SYSCFG_EXTICR1_EXTI3_Msk (0x7UL << SYSCFG_EXTICR1_EXTI3_Pos)
#define SYSCFG_EXTICR1_EXTI3 SYSCFG_EXTICR1_EXTI3_Msk

/**
  * @brief   EXTI0 configuration
  */
#define SYSCFG_EXTICR1_EXTI0_PA (0x00000000U)
#define SYSCFG_EXTICR1_EXTI0_PB (0x00000001U)
#define SYSCFG_EXTICR1_EXTI0_PC (0x00000002U)
#define SYSCFG_EXTICR1_EXTI0_PD (0x00000003U)
#define SYSCFG_EXTICR1_EXTI0_PE (0x00000004U)
#define SYSCFG_EXTICR1_EXTI0_PF (0x00000005U)
#define SYSCFG_EXTICR1_EXTI0_PG (0x00000006U)

/**
  * @brief   EXTI1 configuration
  */
#define SYSCFG_EXTICR1_EXTI1_PA (0x00000000U)
#define SYSCFG_EXTICR1_EXTI1_PB (0x00000010U)
#define SYSCFG_EXTICR1_EXTI1_PC (0x00000020U)
#define SYSCFG_EXTICR1_EXTI1_PD (0x00000030U)
#define SYSCFG_EXTICR1_EXTI1_PE (0x00000040U)
#define SYSCFG_EXTICR1_EXTI1_PF (0x00000050U)
#define SYSCFG_EXTICR1_EXTI1_PG (0x00000060U)

/**
  * @brief   EXTI2 configuration
  */
#define SYSCFG_EXTICR1_EXTI2_PA (0x00000000U)
#define SYSCFG_EXTICR1_EXTI2_PB (0x00000100U)
#define SYSCFG_EXTICR1_EXTI2_PC (0x00000200U)
#define SYSCFG_EXTICR1_EXTI2_PD (0x00000300U)
#define SYSCFG_EXTICR1_EXTI2_PE (0x00000400U)
#define SYSCFG_EXTICR1_EXTI2_PF (0x00000500U)
#define SYSCFG_EXTICR1_EXTI2_PG (0x00000600U)

/**
  * @brief   EXTI3 configuration
  */
#define SYSCFG_EXTICR1_EXTI3_PA (0x00000000U)
#define SYSCFG_EXTICR1_EXTI3_PB (0x00001000U)
#define SYSCFG_EXTICR1_EXTI3_PC (0x00002000U)
#define SYSCFG_EXTICR1_EXTI3_PD (0x00003000U)
#define SYSCFG_EXTICR1_EXTI3_PE (0x00004000U)
#define SYSCFG_EXTICR1_EXTI3_PF (0x00005000U)
#define SYSCFG_EXTICR1_EXTI3_PG (0x00006000U)

/*****************  Bit definition for SYSCFG_EXTICR2 register  ***************/
#define SYSCFG_EXTICR2_EXTI4_Pos (0U)
#define SYSCFG_EXTICR2_EXTI4_Msk (0x7UL << SYSCFG_EXTICR2_EXTI4_Pos)
#define SYSCFG_EXTICR2_EXTI4 SYSCFG_EXTICR2_EXTI4_Msk
#define SYSCFG_EXTICR2_EXTI5_Pos (4U)
#define SYSCFG_EXTICR2_EXTI5_Msk (0x7UL << SYSCFG_EXTICR2_EXTI5_Pos)
#define SYSCFG_EXTICR2_EXTI5 SYSCFG_EXTICR2_EXTI5_Msk
#define SYSCFG_EXTICR2_EXTI6_Pos (8U)
#define SYSCFG_EXTICR2_EXTI6_Msk (0x7UL << SYSCFG_EXTICR2_EXTI6_Pos)
#define SYSCFG_EXTICR2_EXTI6 SYSCFG_EXTICR2_EXTI6_Msk
#define SYSCFG_EXTICR2_EXTI7_Pos (12U)
#define SYSCFG_EXTICR2_EXTI7_Msk (0x7UL << SYSCFG_EXTICR2_EXTI7_Pos)
#define SYSCFG_EXTICR2_EXTI7 SYSCFG_EXTICR2_EXTI7_Msk

/**
  * @brief   EXTI4 configuration
  */
#define SYSCFG_EXTICR2_EXTI4_PA (0x00000000U)
#define SYSCFG_EXTICR2_EXTI4_PB (0x00000001U)
#define SYSCFG_EXTICR2_EXTI4_PC (0x00000002U)
#define SYSCFG_EXTICR2_EXTI4_PD (0x00000003U)
#define SYSCFG_EXTICR2_EXTI4_PE (0x00000004U)
#define SYSCFG_EXTICR2_EXTI4_PF (0x00000005U)
#define SYSCFG_EXTICR2_EXTI4_PG (0x00000006U)

/**
  * @brief   EXTI5 configuration
  */
#define SYSCFG_EXTICR2_EXTI5_PA (0x00000000U)
#define SYSCFG_EXTICR2_EXTI5_PB (0x00000010U)
#define SYSCFG_EXTICR2_EXTI5_PC (0x00000020U)
#define SYSCFG_EXTICR2_EXTI5_PD (0x00000030U)
#define SYSCFG_EXTICR2_EXTI5_PE (0x00000040U)
#define SYSCFG_EXTICR2_EXTI5_PF (0x00000050U)
#define SYSCFG_EXTICR2_EXTI5_PG (0x00000060U)

/**
  * @brief   EXTI6 configuration
  */
#define SYSCFG_EXTICR2_EXTI6_PA (0x00000000U)
#define SYSCFG_EXTICR2_EXTI6_PB (0x00000100U)
#define SYSCFG_EXTICR2_EXTI6_PC (0x00000200U)
#define SYSCFG_EXTICR2_EXTI6_PD (0x00000300U)
#define SYSCFG_EXTICR2_EXTI6_PE (0x00000400U)
#define SYSCFG_EXTICR2_EXTI6_PF (0x00000500U)
#define SYSCFG_EXTICR2_EXTI6_PG (0x00000600U)

/**
  * @brief   EXTI7 configuration
  */
#define SYSCFG_EXTICR2_EXTI7_PA (0x00000000U)
#define SYSCFG_EXTICR2_EXTI7_PB (0x00001000U)
#define SYSCFG_EXTICR2_EXTI7_PC (0x00002000U)
#define SYSCFG_EXTICR2_EXTI7_PD (0x00003000U)
#define SYSCFG_EXTICR2_EXTI7_PE (0x00004000U)
#define SYSCFG_EXTICR2_EXTI7_PF (0x00005000U)
#define SYSCFG_EXTICR2_EXTI7_PG (0x00006000U)

/*****************  Bit definition for SYSCFG_EXTICR3 register  ***************/
#define SYSCFG_EXTICR3_EXTI8_Pos (0U)
#define SYSCFG_EXTICR3_EXTI8_Msk (0x7UL << SYSCFG_EXTICR3_EXTI8_Pos)
#define SYSCFG_EXTICR3_EXTI8 SYSCFG_EXTICR3_EXTI8_Msk
#define SYSCFG_EXTICR3_EXTI9_Pos (4U)
#define SYSCFG_EXTICR3_EXTI9_Msk (0x7UL << SYSCFG_EXTICR3_EXTI9_Pos)
#define SYSCFG_EXTICR3_EXTI9 SYSCFG_EXTICR3_EXTI9_Msk
#define SYSCFG_EXTICR3_EXTI10_Pos (8U)
#define SYSCFG_EXTICR3_EXTI10_Msk (0x7UL << SYSCFG_EXTICR3_EXTI10_Pos)
#define SYSCFG_EXTICR3_EXTI10 SYSCFG_EXTICR3_EXTI10_Msk
#define SYSCFG_EXTICR3_EXTI11_Pos (12U)
#define SYSCFG_EXTICR3_EXTI11_Msk (0x7UL << SYSCFG_EXTICR3_EXTI11_Pos)
#define SYSCFG_EXTICR3_EXTI11 SYSCFG_EXTICR3_EXTI11_Msk

/**
  * @brief   EXTI8 configuration
  */
#define SYSCFG_EXTICR3_EXTI8_PA (0x00000000U)
#define SYSCFG_EXTICR3_EXTI8_PB (0x00000001U)
#define SYSCFG_EXTICR3_EXTI8_PC (0x00000002U)
#define SYSCFG_EXTICR3_EXTI8_PD (0x00000003U)
#define SYSCFG_EXTICR3_EXTI8_PE (0x00000004U)
#define SYSCFG_EXTICR3_EXTI8_PF (0x00000005U)
#define SYSCFG_EXTICR3_EXTI8_PG (0x00000006U)

/**
  * @brief   EXTI9 configuration
  */
#define SYSCFG_EXTICR3_EXTI9_PA (0x00000000U)
#define SYSCFG_EXTICR3_EXTI9_PB (0x00000010U)
#define SYSCFG_EXTICR3_EXTI9_PC (0x00000020U)
#define SYSCFG_EXTICR3_EXTI9_PD (0x00000030U)
#define SYSCFG_EXTICR3_EXTI9_PE (0x00000040U)
#define SYSCFG_EXTICR3_EXTI9_PF (0x00000050U)
#define SYSCFG_EXTICR3_EXTI9_PG (0x00000060U)

/**
  * @brief   EXTI10 configuration
  */
#define SYSCFG_EXTICR3_EXTI10_PA (0x00000000U)
#define SYSCFG_EXTICR3_EXTI10_PB (0x00000100U)
#define SYSCFG_EXTICR3_EXTI10_PC (0x00000200U)
#define SYSCFG_EXTICR3_EXTI10_PD (0x00000300U)
#define SYSCFG_EXTICR3_EXTI10_PE (0x00000400U)
#define SYSCFG_EXTICR3_EXTI10_PF (0x00000500U)

/**
  * @brief   EXTI11 configuration
  */
#define SYSCFG_EXTICR3_EXTI11_PA (0x00000000U)
#define SYSCFG_EXTICR3_EXTI11_PB (0x00001000U)
#define SYSCFG_EXTICR3_EXTI11_PC (0x00002000U)
#define SYSCFG_EXTICR3_EXTI11_PD (0x00003000U)
#define SYSCFG_EXTICR3_EXTI11_PE (0x00004000U)
#define SYSCFG_EXTICR3_EXTI11_PF (0x00005000U)

/*****************  Bit definition for SYSCFG_EXTICR4 register  ***************/
#define SYSCFG_EXTICR4_EXTI12_Pos (0U)
#define SYSCFG_EXTICR4_EXTI12_Msk (0x7UL << SYSCFG_EXTICR4_EXTI12_Pos)
#define SYSCFG_EXTICR4_EXTI12 SYSCFG_EXTICR4_EXTI12_Msk
#define SYSCFG_EXTICR4_EXTI13_Pos (4U)
#define SYSCFG_EXTICR4_EXTI13_Msk (0x7UL << SYSCFG_EXTICR4_EXTI13_Pos)
#define SYSCFG_EXTICR4_EXTI13 SYSCFG_EXTICR4_EXTI13_Msk
#define SYSCFG_EXTICR4_EXTI14_Pos (8U)
#define SYSCFG_EXTICR4_EXTI14_Msk (0x7UL << SYSCFG_EXTICR4_EXTI14_Pos)
#define SYSCFG_EXTICR4_EXTI14 SYSCFG_EXTICR4_EXTI14_Msk
#define SYSCFG_EXTICR4_EXTI15_Pos (12U)
#define SYSCFG_EXTICR4_EXTI15_Msk (0x7UL << SYSCFG_EXTICR4_EXTI15_Pos)
#define SYSCFG_EXTICR4_EXTI15 SYSCFG_EXTICR4_EXTI15_Msk

/**
  * @brief   EXTI12 configuration
  */
#define SYSCFG_EXTICR4_EXTI12_PA (0x00000000U)
#define SYSCFG_EXTICR4_EXTI12_PB (0x00000001U)
#define SYSCFG_EXTICR4_EXTI12_PC (0x00000002U)
#define SYSCFG_EXTICR4_EXTI12_PD (0x00000003U)
#define SYSCFG_EXTICR4_EXTI12_PE (0x00000004U)
#define SYSCFG_EXTICR4_EXTI12_PF (0x00000005U)

/**
  * @brief   EXTI13 configuration
  */
#define SYSCFG_EXTICR4_EXTI13_PA (0x00000000U)
#define SYSCFG_EXTICR4_EXTI13_PB (0x00000010U)
#define SYSCFG_EXTICR4_EXTI13_PC (0x00000020U)
#define SYSCFG_EXTICR4_EXTI13_PD (0x00000030U)
#define SYSCFG_EXTICR4_EXTI13_PE (0x00000040U)
#define SYSCFG_EXTICR4_EXTI13_PF (0x00000050U)

/**
  * @brief   EXTI14 configuration
  */
#define SYSCFG_EXTICR4_EXTI14_PA (0x00000000U)
#define SYSCFG_EXTICR4_EXTI14_PB (0x00000100U)
#define SYSCFG_EXTICR4_EXTI14_PC (0x00000200U)
#define SYSCFG_EXTICR4_EXTI14_PD (0x00000300U)
#define SYSCFG_EXTICR4_EXTI14_PE (0x00000400U)
#define SYSCFG_EXTICR4_EXTI14_PF (0x00000500U)

/**
  * @brief   EXTI15 configuration
  */
#define SYSCFG_EXTICR4_EXTI15_PA (0x00000000U)
#define SYSCFG_EXTICR4_EXTI15_PB (0x00001000U)
#define SYSCFG_EXTICR4_EXTI15_PC (0x00002000U)
#define SYSCFG_EXTICR4_EXTI15_PD (0x00003000U)
#define SYSCFG_EXTICR4_EXTI15_PE (0x00004000U)
#define SYSCFG_EXTICR4_EXTI15_PF (0x00005000U)

/******************  Bit definition for SYSCFG_SCSR register  ****************/
#define SYSCFG_SCSR_CCMER_Pos (0U)
#define SYSCFG_SCSR_CCMER_Msk (0x1UL << SYSCFG_SCSR_CCMER_Pos)
#define SYSCFG_SCSR_CCMER SYSCFG_SCSR_CCMER_Msk
#define SYSCFG_SCSR_CCMBSY_Pos (1U)
#define SYSCFG_SCSR_CCMBSY_Msk (0x1UL << SYSCFG_SCSR_CCMBSY_Pos)
#define SYSCFG_SCSR_CCMBSY SYSCFG_SCSR_CCMBSY_Msk

/******************  Bit definition for SYSCFG_CFGR2 register  ****************/
#define SYSCFG_CFGR2_CLL_Pos (0U)
#define SYSCFG_CFGR2_CLL_Msk (0x1UL << SYSCFG_CFGR2_CLL_Pos)
#define SYSCFG_CFGR2_CLL SYSCFG_CFGR2_CLL_Msk
#define SYSCFG_CFGR2_SPL_Pos (1U)
#define SYSCFG_CFGR2_SPL_Msk (0x1UL << SYSCFG_CFGR2_SPL_Pos)
#define SYSCFG_CFGR2_SPL SYSCFG_CFGR2_SPL_Msk
#define SYSCFG_CFGR2_PVDL_Pos (2U)
#define SYSCFG_CFGR2_PVDL_Msk (0x1UL << SYSCFG_CFGR2_PVDL_Pos)
#define SYSCFG_CFGR2_PVDL SYSCFG_CFGR2_PVDL_Msk
#define SYSCFG_CFGR2_ECCL_Pos (3U)
#define SYSCFG_CFGR2_ECCL_Msk (0x1UL << SYSCFG_CFGR2_ECCL_Pos)
#define SYSCFG_CFGR2_ECCL SYSCFG_CFGR2_ECCL_Msk
#define SYSCFG_CFGR2_SPF_Pos (8U)
#define SYSCFG_CFGR2_SPF_Msk (0x1UL << SYSCFG_CFGR2_SPF_Pos)
#define SYSCFG_CFGR2_SPF SYSCFG_CFGR2_SPF_Msk

/******************  Bit definition for SYSCFG_SWPR register  ****************/
#define SYSCFG_SWPR_PAGE0_Pos (0U)
#define SYSCFG_SWPR_PAGE0_Msk (0x1UL << SYSCFG_SWPR_PAGE0_Pos)
#define SYSCFG_SWPR_PAGE0 (SYSCFG_SWPR_PAGE0_Msk)
#define SYSCFG_SWPR_PAGE1_Pos (1U)
#define SYSCFG_SWPR_PAGE1_Msk (0x1UL << SYSCFG_SWPR_PAGE1_Pos)
#define SYSCFG_SWPR_PAGE1 (SYSCFG_SWPR_PAGE1_Msk)
#define SYSCFG_SWPR_PAGE2_Pos (2U)
#define SYSCFG_SWPR_PAGE2_Msk (0x1UL << SYSCFG_SWPR_PAGE2_Pos)
#define SYSCFG_SWPR_PAGE2 (SYSCFG_SWPR_PAGE2_Msk)
#define SYSCFG_SWPR_PAGE3_Pos (3U)
#define SYSCFG_SWPR_PAGE3_Msk (0x1UL << SYSCFG_SWPR_PAGE3_Pos)
#define SYSCFG_SWPR_PAGE3 (SYSCFG_SWPR_PAGE3_Msk)
#define SYSCFG_SWPR_PAGE4_Pos (4U)
#define SYSCFG_SWPR_PAGE4_Msk (0x1UL << SYSCFG_SWPR_PAGE4_Pos)
#define SYSCFG_SWPR_PAGE4 (SYSCFG_SWPR_PAGE4_Msk)
#define SYSCFG_SWPR_PAGE5_Pos (5U)
#define SYSCFG_SWPR_PAGE5_Msk (0x1UL << SYSCFG_SWPR_PAGE5_Pos)
#define SYSCFG_SWPR_PAGE5 (SYSCFG_SWPR_PAGE5_Msk)
#define SYSCFG_SWPR_PAGE6_Pos (6U)
#define SYSCFG_SWPR_PAGE6_Msk (0x1UL << SYSCFG_SWPR_PAGE6_Pos)
#define SYSCFG_SWPR_PAGE6 (SYSCFG_SWPR_PAGE6_Msk)
#define SYSCFG_SWPR_PAGE7_Pos (7U)
#define SYSCFG_SWPR_PAGE7_Msk (0x1UL << SYSCFG_SWPR_PAGE7_Pos)
#define SYSCFG_SWPR_PAGE7 (SYSCFG_SWPR_PAGE7_Msk)
#define SYSCFG_SWPR_PAGE8_Pos (8U)
#define SYSCFG_SWPR_PAGE8_Msk (0x1UL << SYSCFG_SWPR_PAGE8_Pos)
#define SYSCFG_SWPR_PAGE8 (SYSCFG_SWPR_PAGE8_Msk)
#define SYSCFG_SWPR_PAGE9_Pos (9U)
#define SYSCFG_SWPR_PAGE9_Msk (0x1UL << SYSCFG_SWPR_PAGE9_Pos)
#define SYSCFG_SWPR_PAGE9 (SYSCFG_SWPR_PAGE9_Msk)
#define SYSCFG_SWPR_PAGE10_Pos (10U)
#define SYSCFG_SWPR_PAGE10_Msk (0x1UL << SYSCFG_SWPR_PAGE10_Pos)
#define SYSCFG_SWPR_PAGE10 (SYSCFG_SWPR_PAGE10_Msk)
#define SYSCFG_SWPR_PAGE11_Pos (11U)
#define SYSCFG_SWPR_PAGE11_Msk (0x1UL << SYSCFG_SWPR_PAGE11_Pos)
#define SYSCFG_SWPR_PAGE11 (SYSCFG_SWPR_PAGE11_Msk)
#define SYSCFG_SWPR_PAGE12_Pos (12U)
#define SYSCFG_SWPR_PAGE12_Msk (0x1UL << SYSCFG_SWPR_PAGE12_Pos)
#define SYSCFG_SWPR_PAGE12 (SYSCFG_SWPR_PAGE12_Msk)
#define SYSCFG_SWPR_PAGE13_Pos (13U)
#define SYSCFG_SWPR_PAGE13_Msk (0x1UL << SYSCFG_SWPR_PAGE13_Pos)
#define SYSCFG_SWPR_PAGE13 (SYSCFG_SWPR_PAGE13_Msk)
#define SYSCFG_SWPR_PAGE14_Pos (14U)
#define SYSCFG_SWPR_PAGE14_Msk (0x1UL << SYSCFG_SWPR_PAGE14_Pos)
#define SYSCFG_SWPR_PAGE14 (SYSCFG_SWPR_PAGE14_Msk)
#define SYSCFG_SWPR_PAGE15_Pos (15U)
#define SYSCFG_SWPR_PAGE15_Msk (0x1UL << SYSCFG_SWPR_PAGE15_Pos)
#define SYSCFG_SWPR_PAGE15 (SYSCFG_SWPR_PAGE15_Msk)
#define SYSCFG_SWPR_PAGE16_Pos (16U)
#define SYSCFG_SWPR_PAGE16_Msk (0x1UL << SYSCFG_SWPR_PAGE16_Pos)
#define SYSCFG_SWPR_PAGE16 (SYSCFG_SWPR_PAGE16_Msk)
#define SYSCFG_SWPR_PAGE17_Pos (17U)
#define SYSCFG_SWPR_PAGE17_Msk (0x1UL << SYSCFG_SWPR_PAGE17_Pos)
#define SYSCFG_SWPR_PAGE17 (SYSCFG_SWPR_PAGE17_Msk)
#define SYSCFG_SWPR_PAGE18_Pos (18U)
#define SYSCFG_SWPR_PAGE18_Msk (0x1UL << SYSCFG_SWPR_PAGE18_Pos)
#define SYSCFG_SWPR_PAGE18 (SYSCFG_SWPR_PAGE18_Msk)
#define SYSCFG_SWPR_PAGE19_Pos (19U)
#define SYSCFG_SWPR_PAGE19_Msk (0x1UL << SYSCFG_SWPR_PAGE19_Pos)
#define SYSCFG_SWPR_PAGE19 (SYSCFG_SWPR_PAGE19_Msk)
#define SYSCFG_SWPR_PAGE20_Pos (20U)
#define SYSCFG_SWPR_PAGE20_Msk (0x1UL << SYSCFG_SWPR_PAGE20_Pos)
#define SYSCFG_SWPR_PAGE20 (SYSCFG_SWPR_PAGE20_Msk)
#define SYSCFG_SWPR_PAGE21_Pos (21U)
#define SYSCFG_SWPR_PAGE21_Msk (0x1UL << SYSCFG_SWPR_PAGE21_Pos)
#define SYSCFG_SWPR_PAGE21 (SYSCFG_SWPR_PAGE21_Msk)
#define SYSCFG_SWPR_PAGE22_Pos (22U)
#define SYSCFG_SWPR_PAGE22_Msk (0x1UL << SYSCFG_SWPR_PAGE22_Pos)
#define SYSCFG_SWPR_PAGE22 (SYSCFG_SWPR_PAGE22_Msk)
#define SYSCFG_SWPR_PAGE23_Pos (23U)
#define SYSCFG_SWPR_PAGE23_Msk (0x1UL << SYSCFG_SWPR_PAGE23_Pos)
#define SYSCFG_SWPR_PAGE23 (SYSCFG_SWPR_PAGE23_Msk)
#define SYSCFG_SWPR_PAGE24_Pos (24U)
#define SYSCFG_SWPR_PAGE24_Msk (0x1UL << SYSCFG_SWPR_PAGE24_Pos)
#define SYSCFG_SWPR_PAGE24 (SYSCFG_SWPR_PAGE24_Msk)
#define SYSCFG_SWPR_PAGE25_Pos (25U)
#define SYSCFG_SWPR_PAGE25_Msk (0x1UL << SYSCFG_SWPR_PAGE25_Pos)
#define SYSCFG_SWPR_PAGE25 (SYSCFG_SWPR_PAGE25_Msk)
#define SYSCFG_SWPR_PAGE26_Pos (26U)
#define SYSCFG_SWPR_PAGE26_Msk (0x1UL << SYSCFG_SWPR_PAGE26_Pos)
#define SYSCFG_SWPR_PAGE26 (SYSCFG_SWPR_PAGE26_Msk)
#define SYSCFG_SWPR_PAGE27_Pos (27U)
#define SYSCFG_SWPR_PAGE27_Msk (0x1UL << SYSCFG_SWPR_PAGE27_Pos)
#define SYSCFG_SWPR_PAGE27 (SYSCFG_SWPR_PAGE27_Msk)
#define SYSCFG_SWPR_PAGE28_Pos (28U)
#define SYSCFG_SWPR_PAGE28_Msk (0x1UL << SYSCFG_SWPR_PAGE28_Pos)
#define SYSCFG_SWPR_PAGE28 (SYSCFG_SWPR_PAGE28_Msk)
#define SYSCFG_SWPR_PAGE29_Pos (29U)
#define SYSCFG_SWPR_PAGE29_Msk (0x1UL << SYSCFG_SWPR_PAGE29_Pos)
#define SYSCFG_SWPR_PAGE29 (SYSCFG_SWPR_PAGE29_Msk)
#define SYSCFG_SWPR_PAGE30_Pos (30U)
#define SYSCFG_SWPR_PAGE30_Msk (0x1UL << SYSCFG_SWPR_PAGE30_Pos)
#define SYSCFG_SWPR_PAGE30 (SYSCFG_SWPR_PAGE30_Msk)
#define SYSCFG_SWPR_PAGE31_Pos (31U)
#define SYSCFG_SWPR_PAGE31_Msk (0x1UL << SYSCFG_SWPR_PAGE31_Pos)
#define SYSCFG_SWPR_PAGE31 (SYSCFG_SWPR_PAGE31_Msk)

/******************  Bit definition for SYSCFG_SKR register  ****************/
#define SYSCFG_SKR_KEY_Pos (0U)
#define SYSCFG_SKR_KEY_Msk (0xFFUL << SYSCFG_SKR_KEY_Pos)
#define SYSCFG_SKR_KEY SYSCFG_SKR_KEY_Msk

/******************************************************************************/
/*                                                                            */
/*                                    TIM                                     */
/*                                                                            */
/******************************************************************************/
/*******************  Bit definition for TIM_CR1 register  ********************/
#define TIM_CR1_CEN_Pos (0U)
#define TIM_CR1_CEN_Msk (0x1UL << TIM_CR1_CEN_Pos)
#define TIM_CR1_CEN TIM_CR1_CEN_Msk
#define TIM_CR1_UDIS_Pos (1U)
#define TIM_CR1_UDIS_Msk (0x1UL << TIM_CR1_UDIS_Pos)
#define TIM_CR1_UDIS TIM_CR1_UDIS_Msk
#define TIM_CR1_URS_Pos (2U)
#define TIM_CR1_URS_Msk (0x1UL << TIM_CR1_URS_Pos)
#define TIM_CR1_URS TIM_CR1_URS_Msk
#define TIM_CR1_OPM_Pos (3U)
#define TIM_CR1_OPM_Msk (0x1UL << TIM_CR1_OPM_Pos)
#define TIM_CR1_OPM TIM_CR1_OPM_Msk
#define TIM_CR1_DIR_Pos (4U)
#define TIM_CR1_DIR_Msk (0x1UL << TIM_CR1_DIR_Pos)
#define TIM_CR1_DIR TIM_CR1_DIR_Msk

#define TIM_CR1_CMS_Pos (5U)
#define TIM_CR1_CMS_Msk (0x3UL << TIM_CR1_CMS_Pos)
#define TIM_CR1_CMS TIM_CR1_CMS_Msk
#define TIM_CR1_CMS_0 (0x1UL << TIM_CR1_CMS_Pos)
#define TIM_CR1_CMS_1 (0x2UL << TIM_CR1_CMS_Pos)

#define TIM_CR1_ARPE_Pos (7U)
#define TIM_CR1_ARPE_Msk (0x1UL << TIM_CR1_ARPE_Pos)
#define TIM_CR1_ARPE TIM_CR1_ARPE_Msk

#define TIM_CR1_CKD_Pos (8U)
#define TIM_CR1_CKD_Msk (0x3UL << TIM_CR1_CKD_Pos)
#define TIM_CR1_CKD TIM_CR1_CKD_Msk
#define TIM_CR1_CKD_0 (0x1UL << TIM_CR1_CKD_Pos)
#define TIM_CR1_CKD_1 (0x2UL << TIM_CR1_CKD_Pos)

#define TIM_CR1_UIFREMAP_Pos (11U)
#define TIM_CR1_UIFREMAP_Msk (0x1UL << TIM_CR1_UIFREMAP_Pos)
#define TIM_CR1_UIFREMAP TIM_CR1_UIFREMAP_Msk

#define TIM_CR1_DITHEN_Pos (12U)
#define TIM_CR1_DITHEN_Msk (0x1UL << TIM_CR1_DITHEN_Pos)
#define TIM_CR1_DITHEN TIM_CR1_DITHEN_Msk

/*******************  Bit definition for TIM_CR2 register  ********************/
#define TIM_CR2_CCPC_Pos (0U)
#define TIM_CR2_CCPC_Msk (0x1UL << TIM_CR2_CCPC_Pos)
#define TIM_CR2_CCPC TIM_CR2_CCPC_Msk
#define TIM_CR2_CCUS_Pos (2U)
#define TIM_CR2_CCUS_Msk (0x1UL << TIM_CR2_CCUS_Pos)
#define TIM_CR2_CCUS TIM_CR2_CCUS_Msk
#define TIM_CR2_CCDS_Pos (3U)
#define TIM_CR2_CCDS_Msk (0x1UL << TIM_CR2_CCDS_Pos)
#define TIM_CR2_CCDS TIM_CR2_CCDS_Msk

#define TIM_CR2_MMS_Pos (4U)
#define TIM_CR2_MMS_Msk (0x200007UL << TIM_CR2_MMS_Pos)
#define TIM_CR2_MMS TIM_CR2_MMS_Msk
#define TIM_CR2_MMS_0 (0x000001UL << TIM_CR2_MMS_Pos)
#define TIM_CR2_MMS_1 (0x000002UL << TIM_CR2_MMS_Pos)
#define TIM_CR2_MMS_2 (0x000004UL << TIM_CR2_MMS_Pos)
#define TIM_CR2_MMS_3 (0x200000UL << TIM_CR2_MMS_Pos)

#define TIM_CR2_TI1S_Pos (7U)
#define TIM_CR2_TI1S_Msk (0x1UL << TIM_CR2_TI1S_Pos)
#define TIM_CR2_TI1S TIM_CR2_TI1S_Msk
#define TIM_CR2_OIS1_Pos (8U)
#define TIM_CR2_OIS1_Msk (0x1UL << TIM_CR2_OIS1_Pos)
#define TIM_CR2_OIS1 TIM_CR2_OIS1_Msk
#define TIM_CR2_OIS1N_Pos (9U)
#define TIM_CR2_OIS1N_Msk (0x1UL << TIM_CR2_OIS1N_Pos)
#define TIM_CR2_OIS1N TIM_CR2_OIS1N_Msk
#define TIM_CR2_OIS2_Pos (10U)
#define TIM_CR2_OIS2_Msk (0x1UL << TIM_CR2_OIS2_Pos)
#define TIM_CR2_OIS2 TIM_CR2_OIS2_Msk
#define TIM_CR2_OIS2N_Pos (11U)
#define TIM_CR2_OIS2N_Msk (0x1UL << TIM_CR2_OIS2N_Pos)
#define TIM_CR2_OIS2N TIM_CR2_OIS2N_Msk
#define TIM_CR2_OIS3_Pos (12U)
#define TIM_CR2_OIS3_Msk (0x1UL << TIM_CR2_OIS3_Pos)
#define TIM_CR2_OIS3 TIM_CR2_OIS3_Msk
#define TIM_CR2_OIS3N_Pos (13U)
#define TIM_CR2_OIS3N_Msk (0x1UL << TIM_CR2_OIS3N_Pos)
#define TIM_CR2_OIS3N TIM_CR2_OIS3N_Msk
#define TIM_CR2_OIS4_Pos (14U)
#define TIM_CR2_OIS4_Msk (0x1UL << TIM_CR2_OIS4_Pos)
#define TIM_CR2_OIS4 TIM_CR2_OIS4_Msk
#define TIM_CR2_OIS4N_Pos (15U)
#define TIM_CR2_OIS4N_Msk (0x1UL << TIM_CR2_OIS4N_Pos)
#define TIM_CR2_OIS4N TIM_CR2_OIS4N_Msk
#define TIM_CR2_OIS5_Pos (16U)
#define TIM_CR2_OIS5_Msk (0x1UL << TIM_CR2_OIS5_Pos)
#define TIM_CR2_OIS5 TIM_CR2_OIS5_Msk
#define TIM_CR2_OIS6_Pos (18U)
#define TIM_CR2_OIS6_Msk (0x1UL << TIM_CR2_OIS6_Pos)
#define TIM_CR2_OIS6 TIM_CR2_OIS6_Msk

#define TIM_CR2_MMS2_Pos (20U)
#define TIM_CR2_MMS2_Msk (0xFUL << TIM_CR2_MMS2_Pos)
#define TIM_CR2_MMS2 TIM_CR2_MMS2_Msk
#define TIM_CR2_MMS2_0 (0x1UL << TIM_CR2_MMS2_Pos)
#define TIM_CR2_MMS2_1 (0x2UL << TIM_CR2_MMS2_Pos)
#define TIM_CR2_MMS2_2 (0x4UL << TIM_CR2_MMS2_Pos)
#define TIM_CR2_MMS2_3 (0x8UL << TIM_CR2_MMS2_Pos)

/*******************  Bit definition for TIM_SMCR register  *******************/
#define TIM_SMCR_SMS_Pos (0U)
#define TIM_SMCR_SMS_Msk (0x10007UL << TIM_SMCR_SMS_Pos)
#define TIM_SMCR_SMS TIM_SMCR_SMS_Msk
#define TIM_SMCR_SMS_0 (0x00001UL << TIM_SMCR_SMS_Pos)
#define TIM_SMCR_SMS_1 (0x00002UL << TIM_SMCR_SMS_Pos)
#define TIM_SMCR_SMS_2 (0x00004UL << TIM_SMCR_SMS_Pos)
#define TIM_SMCR_SMS_3 (0x10000UL << TIM_SMCR_SMS_Pos)

#define TIM_SMCR_OCCS_Pos (3U)
#define TIM_SMCR_OCCS_Msk (0x1UL << TIM_SMCR_OCCS_Pos)
#define TIM_SMCR_OCCS TIM_SMCR_OCCS_Msk

#define TIM_SMCR_TS_Pos (4U)
#define TIM_SMCR_TS_Msk (0x30007UL << TIM_SMCR_TS_Pos)
#define TIM_SMCR_TS TIM_SMCR_TS_Msk
#define TIM_SMCR_TS_0 (0x00001UL << TIM_SMCR_TS_Pos)
#define TIM_SMCR_TS_1 (0x00002UL << TIM_SMCR_TS_Pos)
#define TIM_SMCR_TS_2 (0x00004UL << TIM_SMCR_TS_Pos)
#define TIM_SMCR_TS_3 (0x10000UL << TIM_SMCR_TS_Pos)
#define TIM_SMCR_TS_4 (0x20000UL << TIM_SMCR_TS_Pos)

#define TIM_SMCR_MSM_Pos (7U)
#define TIM_SMCR_MSM_Msk (0x1UL << TIM_SMCR_MSM_Pos)
#define TIM_SMCR_MSM TIM_SMCR_MSM_Msk

#define TIM_SMCR_ETF_Pos (8U)
#define TIM_SMCR_ETF_Msk (0xFUL << TIM_SMCR_ETF_Pos)
#define TIM_SMCR_ETF TIM_SMCR_ETF_Msk
#define TIM_SMCR_ETF_0 (0x1UL << TIM_SMCR_ETF_Pos)
#define TIM_SMCR_ETF_1 (0x2UL << TIM_SMCR_ETF_Pos)
#define TIM_SMCR_ETF_2 (0x4UL << TIM_SMCR_ETF_Pos)
#define TIM_SMCR_ETF_3 (0x8UL << TIM_SMCR_ETF_Pos)

#define TIM_SMCR_ETPS_Pos (12U)
#define TIM_SMCR_ETPS_Msk (0x3UL << TIM_SMCR_ETPS_Pos)
#define TIM_SMCR_ETPS TIM_SMCR_ETPS_Msk
#define TIM_SMCR_ETPS_0 (0x1UL << TIM_SMCR_ETPS_Pos)
#define TIM_SMCR_ETPS_1 (0x2UL << TIM_SMCR_ETPS_Pos)

#define TIM_SMCR_ECE_Pos (14U)
#define TIM_SMCR_ECE_Msk (0x1UL << TIM_SMCR_ECE_Pos)
#define TIM_SMCR_ECE TIM_SMCR_ECE_Msk
#define TIM_SMCR_ETP_Pos (15U)
#define TIM_SMCR_ETP_Msk (0x1UL << TIM_SMCR_ETP_Pos)
#define TIM_SMCR_ETP TIM_SMCR_ETP_Msk

#define TIM_SMCR_SMSPE_Pos (24U)
#define TIM_SMCR_SMSPE_Msk (0x1UL << TIM_SMCR_SMSPE_Pos)
#define TIM_SMCR_SMSPE TIM_SMCR_SMSPE_Msk

#define TIM_SMCR_SMSPS_Pos (25U)
#define TIM_SMCR_SMSPS_Msk (0x1UL << TIM_SMCR_SMSPS_Pos)
#define TIM_SMCR_SMSPS TIM_SMCR_SMSPS_Msk

/*******************  Bit definition for TIM_DIER register  *******************/
#define TIM_DIER_UIE_Pos (0U)
#define TIM_DIER_UIE_Msk (0x1UL << TIM_DIER_UIE_Pos)
#define TIM_DIER_UIE TIM_DIER_UIE_Msk
#define TIM_DIER_CC1IE_Pos (1U)
#define TIM_DIER_CC1IE_Msk (0x1UL << TIM_DIER_CC1IE_Pos)
#define TIM_DIER_CC1IE TIM_DIER_CC1IE_Msk
#define TIM_DIER_CC2IE_Pos (2U)
#define TIM_DIER_CC2IE_Msk (0x1UL << TIM_DIER_CC2IE_Pos)
#define TIM_DIER_CC2IE TIM_DIER_CC2IE_Msk
#define TIM_DIER_CC3IE_Pos (3U)
#define TIM_DIER_CC3IE_Msk (0x1UL << TIM_DIER_CC3IE_Pos)
#define TIM_DIER_CC3IE TIM_DIER_CC3IE_Msk
#define TIM_DIER_CC4IE_Pos (4U)
#define TIM_DIER_CC4IE_Msk (0x1UL << TIM_DIER_CC4IE_Pos)
#define TIM_DIER_CC4IE TIM_DIER_CC4IE_Msk
#define TIM_DIER_COMIE_Pos (5U)
#define TIM_DIER_COMIE_Msk (0x1UL << TIM_DIER_COMIE_Pos)
#define TIM_DIER_COMIE TIM_DIER_COMIE_Msk
#define TIM_DIER_TIE_Pos (6U)
#define TIM_DIER_TIE_Msk (0x1UL << TIM_DIER_TIE_Pos)
#define TIM_DIER_TIE TIM_DIER_TIE_Msk
#define TIM_DIER_BIE_Pos (7U)
#define TIM_DIER_BIE_Msk (0x1UL << TIM_DIER_BIE_Pos)
#define TIM_DIER_BIE TIM_DIER_BIE_Msk
#define TIM_DIER_UDE_Pos (8U)
#define TIM_DIER_UDE_Msk (0x1UL << TIM_DIER_UDE_Pos)
#define TIM_DIER_UDE TIM_DIER_UDE_Msk
#define TIM_DIER_CC1DE_Pos (9U)
#define TIM_DIER_CC1DE_Msk (0x1UL << TIM_DIER_CC1DE_Pos)
#define TIM_DIER_CC1DE TIM_DIER_CC1DE_Msk
#define TIM_DIER_CC2DE_Pos (10U)
#define TIM_DIER_CC2DE_Msk (0x1UL << TIM_DIER_CC2DE_Pos)
#define TIM_DIER_CC2DE TIM_DIER_CC2DE_Msk
#define TIM_DIER_CC3DE_Pos (11U)
#define TIM_DIER_CC3DE_Msk (0x1UL << TIM_DIER_CC3DE_Pos)
#define TIM_DIER_CC3DE TIM_DIER_CC3DE_Msk
#define TIM_DIER_CC4DE_Pos (12U)
#define TIM_DIER_CC4DE_Msk (0x1UL << TIM_DIER_CC4DE_Pos)
#define TIM_DIER_CC4DE TIM_DIER_CC4DE_Msk
#define TIM_DIER_COMDE_Pos (13U)
#define TIM_DIER_COMDE_Msk (0x1UL << TIM_DIER_COMDE_Pos)
#define TIM_DIER_COMDE TIM_DIER_COMDE_Msk
#define TIM_DIER_TDE_Pos (14U)
#define TIM_DIER_TDE_Msk (0x1UL << TIM_DIER_TDE_Pos)
#define TIM_DIER_TDE TIM_DIER_TDE_Msk
#define TIM_DIER_IDXIE_Pos (20U)
#define TIM_DIER_IDXIE_Msk (0x1UL << TIM_DIER_IDXIE_Pos)
#define TIM_DIER_IDXIE TIM_DIER_IDXIE_Msk
#define TIM_DIER_DIRIE_Pos (21U)
#define TIM_DIER_DIRIE_Msk (0x1UL << TIM_DIER_DIRIE_Pos)
#define TIM_DIER_DIRIE TIM_DIER_DIRIE_Msk
#define TIM_DIER_IERRIE_Pos (22U)
#define TIM_DIER_IERRIE_Msk (0x1UL << TIM_DIER_IERRIE_Pos)
#define TIM_DIER_IERRIE TIM_DIER_IERRIE_Msk
#define TIM_DIER_TERRIE_Pos (23U)
#define TIM_DIER_TERRIE_Msk (0x1UL << TIM_DIER_TERRIE_Pos)
#define TIM_DIER_TERRIE TIM_DIER_TERRIE_Msk

/********************  Bit definition for TIM_SR register  ********************/
#define TIM_SR_UIF_Pos (0U)
#define TIM_SR_UIF_Msk (0x1UL << TIM_SR_UIF_Pos)
#define TIM_SR_UIF TIM_SR_UIF_Msk
#define TIM_SR_CC1IF_Pos (1U)
#define TIM_SR_CC1IF_Msk (0x1UL << TIM_SR_CC1IF_Pos)
#define TIM_SR_CC1IF TIM_SR_CC1IF_Msk
#define TIM_SR_CC2IF_Pos (2U)
#define TIM_SR_CC2IF_Msk (0x1UL << TIM_SR_CC2IF_Pos)
#define TIM_SR_CC2IF TIM_SR_CC2IF_Msk
#define TIM_SR_CC3IF_Pos (3U)
#define TIM_SR_CC3IF_Msk (0x1UL << TIM_SR_CC3IF_Pos)
#define TIM_SR_CC3IF TIM_SR_CC3IF_Msk
#define TIM_SR_CC4IF_Pos (4U)
#define TIM_SR_CC4IF_Msk (0x1UL << TIM_SR_CC4IF_Pos)
#define TIM_SR_CC4IF TIM_SR_CC4IF_Msk
#define TIM_SR_COMIF_Pos (5U)
#define TIM_SR_COMIF_Msk (0x1UL << TIM_SR_COMIF_Pos)
#define TIM_SR_COMIF TIM_SR_COMIF_Msk
#define TIM_SR_TIF_Pos (6U)
#define TIM_SR_TIF_Msk (0x1UL << TIM_SR_TIF_Pos)
#define TIM_SR_TIF TIM_SR_TIF_Msk
#define TIM_SR_BIF_Pos (7U)
#define TIM_SR_BIF_Msk (0x1UL << TIM_SR_BIF_Pos)
#define TIM_SR_BIF TIM_SR_BIF_Msk
#define TIM_SR_B2IF_Pos (8U)
#define TIM_SR_B2IF_Msk (0x1UL << TIM_SR_B2IF_Pos)
#define TIM_SR_B2IF TIM_SR_B2IF_Msk
#define TIM_SR_CC1OF_Pos (9U)
#define TIM_SR_CC1OF_Msk (0x1UL << TIM_SR_CC1OF_Pos)
#define TIM_SR_CC1OF TIM_SR_CC1OF_Msk
#define TIM_SR_CC2OF_Pos (10U)
#define TIM_SR_CC2OF_Msk (0x1UL << TIM_SR_CC2OF_Pos)
#define TIM_SR_CC2OF TIM_SR_CC2OF_Msk
#define TIM_SR_CC3OF_Pos (11U)
#define TIM_SR_CC3OF_Msk (0x1UL << TIM_SR_CC3OF_Pos)
#define TIM_SR_CC3OF TIM_SR_CC3OF_Msk
#define TIM_SR_CC4OF_Pos (12U)
#define TIM_SR_CC4OF_Msk (0x1UL << TIM_SR_CC4OF_Pos)
#define TIM_SR_CC4OF TIM_SR_CC4OF_Msk
#define TIM_SR_SBIF_Pos (13U)
#define TIM_SR_SBIF_Msk (0x1UL << TIM_SR_SBIF_Pos)
#define TIM_SR_SBIF TIM_SR_SBIF_Msk
#define TIM_SR_CC5IF_Pos (16U)
#define TIM_SR_CC5IF_Msk (0x1UL << TIM_SR_CC5IF_Pos)
#define TIM_SR_CC5IF TIM_SR_CC5IF_Msk
#define TIM_SR_CC6IF_Pos (17U)
#define TIM_SR_CC6IF_Msk (0x1UL << TIM_SR_CC6IF_Pos)
#define TIM_SR_CC6IF TIM_SR_CC6IF_Msk
#define TIM_SR_IDXF_Pos (20U)
#define TIM_SR_IDXF_Msk (0x1UL << TIM_SR_IDXF_Pos)
#define TIM_SR_IDXF TIM_SR_IDXF_Msk
#define TIM_SR_DIRF_Pos (21U)
#define TIM_SR_DIRF_Msk (0x1UL << TIM_SR_DIRF_Pos)
#define TIM_SR_DIRF TIM_SR_DIRF_Msk
#define TIM_SR_IERRF_Pos (22U)
#define TIM_SR_IERRF_Msk (0x1UL << TIM_SR_IERRF_Pos)
#define TIM_SR_IERRF TIM_SR_IERRF_Msk
#define TIM_SR_TERRF_Pos (23U)
#define TIM_SR_TERRF_Msk (0x1UL << TIM_SR_TERRF_Pos)
#define TIM_SR_TERRF TIM_SR_TERRF_Msk

/*******************  Bit definition for TIM_EGR register  ********************/
#define TIM_EGR_UG_Pos (0U)
#define TIM_EGR_UG_Msk (0x1UL << TIM_EGR_UG_Pos)
#define TIM_EGR_UG TIM_EGR_UG_Msk
#define TIM_EGR_CC1G_Pos (1U)
#define TIM_EGR_CC1G_Msk (0x1UL << TIM_EGR_CC1G_Pos)
#define TIM_EGR_CC1G TIM_EGR_CC1G_Msk
#define TIM_EGR_CC2G_Pos (2U)
#define TIM_EGR_CC2G_Msk (0x1UL << TIM_EGR_CC2G_Pos)
#define TIM_EGR_CC2G TIM_EGR_CC2G_Msk
#define TIM_EGR_CC3G_Pos (3U)
#define TIM_EGR_CC3G_Msk (0x1UL << TIM_EGR_CC3G_Pos)
#define TIM_EGR_CC3G TIM_EGR_CC3G_Msk
#define TIM_EGR_CC4G_Pos (4U)
#define TIM_EGR_CC4G_Msk (0x1UL << TIM_EGR_CC4G_Pos)
#define TIM_EGR_CC4G TIM_EGR_CC4G_Msk
#define TIM_EGR_COMG_Pos (5U)
#define TIM_EGR_COMG_Msk (0x1UL << TIM_EGR_COMG_Pos)
#define TIM_EGR_COMG TIM_EGR_COMG_Msk
#define TIM_EGR_TG_Pos (6U)
#define TIM_EGR_TG_Msk (0x1UL << TIM_EGR_TG_Pos)
#define TIM_EGR_TG TIM_EGR_TG_Msk
#define TIM_EGR_BG_Pos (7U)
#define TIM_EGR_BG_Msk (0x1UL << TIM_EGR_BG_Pos)
#define TIM_EGR_BG TIM_EGR_BG_Msk
#define TIM_EGR_B2G_Pos (8U)
#define TIM_EGR_B2G_Msk (0x1UL << TIM_EGR_B2G_Pos)
#define TIM_EGR_B2G TIM_EGR_B2G_Msk


/******************  Bit definition for TIM_CCMR1 register  *******************/
#define TIM_CCMR1_CC1S_Pos (0U)
#define TIM_CCMR1_CC1S_Msk (0x3UL << TIM_CCMR1_CC1S_Pos)
#define TIM_CCMR1_CC1S TIM_CCMR1_CC1S_Msk
#define TIM_CCMR1_CC1S_0 (0x1UL << TIM_CCMR1_CC1S_Pos)
#define TIM_CCMR1_CC1S_1 (0x2UL << TIM_CCMR1_CC1S_Pos)

#define TIM_CCMR1_OC1FE_Pos (2U)
#define TIM_CCMR1_OC1FE_Msk (0x1UL << TIM_CCMR1_OC1FE_Pos)
#define TIM_CCMR1_OC1FE TIM_CCMR1_OC1FE_Msk
#define TIM_CCMR1_OC1PE_Pos (3U)
#define TIM_CCMR1_OC1PE_Msk (0x1UL << TIM_CCMR1_OC1PE_Pos)
#define TIM_CCMR1_OC1PE TIM_CCMR1_OC1PE_Msk

#define TIM_CCMR1_OC1M_Pos (4U)
#define TIM_CCMR1_OC1M_Msk (0x1007UL << TIM_CCMR1_OC1M_Pos)
#define TIM_CCMR1_OC1M TIM_CCMR1_OC1M_Msk
#define TIM_CCMR1_OC1M_0 (0x0001UL << TIM_CCMR1_OC1M_Pos)
#define TIM_CCMR1_OC1M_1 (0x0002UL << TIM_CCMR1_OC1M_Pos)
#define TIM_CCMR1_OC1M_2 (0x0004UL << TIM_CCMR1_OC1M_Pos)
#define TIM_CCMR1_OC1M_3 (0x1000UL << TIM_CCMR1_OC1M_Pos)

#define TIM_CCMR1_OC1CE_Pos (7U)
#define TIM_CCMR1_OC1CE_Msk (0x1UL << TIM_CCMR1_OC1CE_Pos)
#define TIM_CCMR1_OC1CE TIM_CCMR1_OC1CE_Msk

#define TIM_CCMR1_CC2S_Pos (8U)
#define TIM_CCMR1_CC2S_Msk (0x3UL << TIM_CCMR1_CC2S_Pos)
#define TIM_CCMR1_CC2S TIM_CCMR1_CC2S_Msk
#define TIM_CCMR1_CC2S_0 (0x1UL << TIM_CCMR1_CC2S_Pos)
#define TIM_CCMR1_CC2S_1 (0x2UL << TIM_CCMR1_CC2S_Pos)

#define TIM_CCMR1_OC2FE_Pos (10U)
#define TIM_CCMR1_OC2FE_Msk (0x1UL << TIM_CCMR1_OC2FE_Pos)
#define TIM_CCMR1_OC2FE TIM_CCMR1_OC2FE_Msk
#define TIM_CCMR1_OC2PE_Pos (11U)
#define TIM_CCMR1_OC2PE_Msk (0x1UL << TIM_CCMR1_OC2PE_Pos)
#define TIM_CCMR1_OC2PE TIM_CCMR1_OC2PE_Msk

#define TIM_CCMR1_OC2M_Pos (12U)
#define TIM_CCMR1_OC2M_Msk (0x1007UL << TIM_CCMR1_OC2M_Pos)
#define TIM_CCMR1_OC2M TIM_CCMR1_OC2M_Msk
#define TIM_CCMR1_OC2M_0 (0x0001UL << TIM_CCMR1_OC2M_Pos)
#define TIM_CCMR1_OC2M_1 (0x0002UL << TIM_CCMR1_OC2M_Pos)
#define TIM_CCMR1_OC2M_2 (0x0004UL << TIM_CCMR1_OC2M_Pos)
#define TIM_CCMR1_OC2M_3 (0x1000UL << TIM_CCMR1_OC2M_Pos)

#define TIM_CCMR1_OC2CE_Pos (15U)
#define TIM_CCMR1_OC2CE_Msk (0x1UL << TIM_CCMR1_OC2CE_Pos)
#define TIM_CCMR1_OC2CE TIM_CCMR1_OC2CE_Msk

/*----------------------------------------------------------------------------*/
#define TIM_CCMR1_IC1PSC_Pos (2U)
#define TIM_CCMR1_IC1PSC_Msk (0x3UL << TIM_CCMR1_IC1PSC_Pos)
#define TIM_CCMR1_IC1PSC TIM_CCMR1_IC1PSC_Msk
#define TIM_CCMR1_IC1PSC_0 (0x1UL << TIM_CCMR1_IC1PSC_Pos)
#define TIM_CCMR1_IC1PSC_1 (0x2UL << TIM_CCMR1_IC1PSC_Pos)

#define TIM_CCMR1_IC1F_Pos (4U)
#define TIM_CCMR1_IC1F_Msk (0xFUL << TIM_CCMR1_IC1F_Pos)
#define TIM_CCMR1_IC1F TIM_CCMR1_IC1F_Msk
#define TIM_CCMR1_IC1F_0 (0x1UL << TIM_CCMR1_IC1F_Pos)
#define TIM_CCMR1_IC1F_1 (0x2UL << TIM_CCMR1_IC1F_Pos)
#define TIM_CCMR1_IC1F_2 (0x4UL << TIM_CCMR1_IC1F_Pos)
#define TIM_CCMR1_IC1F_3 (0x8UL << TIM_CCMR1_IC1F_Pos)

#define TIM_CCMR1_IC2PSC_Pos (10U)
#define TIM_CCMR1_IC2PSC_Msk (0x3UL << TIM_CCMR1_IC2PSC_Pos)
#define TIM_CCMR1_IC2PSC TIM_CCMR1_IC2PSC_Msk
#define TIM_CCMR1_IC2PSC_0 (0x1UL << TIM_CCMR1_IC2PSC_Pos)
#define TIM_CCMR1_IC2PSC_1 (0x2UL << TIM_CCMR1_IC2PSC_Pos)

#define TIM_CCMR1_IC2F_Pos (12U)
#define TIM_CCMR1_IC2F_Msk (0xFUL << TIM_CCMR1_IC2F_Pos)
#define TIM_CCMR1_IC2F TIM_CCMR1_IC2F_Msk
#define TIM_CCMR1_IC2F_0 (0x1UL << TIM_CCMR1_IC2F_Pos)
#define TIM_CCMR1_IC2F_1 (0x2UL << TIM_CCMR1_IC2F_Pos)
#define TIM_CCMR1_IC2F_2 (0x4UL << TIM_CCMR1_IC2F_Pos)
#define TIM_CCMR1_IC2F_3 (0x8UL << TIM_CCMR1_IC2F_Pos)

/******************  Bit definition for TIM_CCMR2 register  *******************/
#define TIM_CCMR2_CC3S_Pos (0U)
#define TIM_CCMR2_CC3S_Msk (0x3UL << TIM_CCMR2_CC3S_Pos)
#define TIM_CCMR2_CC3S TIM_CCMR2_CC3S_Msk
#define TIM_CCMR2_CC3S_0 (0x1UL << TIM_CCMR2_CC3S_Pos)
#define TIM_CCMR2_CC3S_1 (0x2UL << TIM_CCMR2_CC3S_Pos)

#define TIM_CCMR2_OC3FE_Pos (2U)
#define TIM_CCMR2_OC3FE_Msk (0x1UL << TIM_CCMR2_OC3FE_Pos)
#define TIM_CCMR2_OC3FE TIM_CCMR2_OC3FE_Msk
#define TIM_CCMR2_OC3PE_Pos (3U)
#define TIM_CCMR2_OC3PE_Msk (0x1UL << TIM_CCMR2_OC3PE_Pos)
#define TIM_CCMR2_OC3PE TIM_CCMR2_OC3PE_Msk

#define TIM_CCMR2_OC3M_Pos (4U)
#define TIM_CCMR2_OC3M_Msk (0x1007UL << TIM_CCMR2_OC3M_Pos)
#define TIM_CCMR2_OC3M TIM_CCMR2_OC3M_Msk
#define TIM_CCMR2_OC3M_0 (0x0001UL << TIM_CCMR2_OC3M_Pos)
#define TIM_CCMR2_OC3M_1 (0x0002UL << TIM_CCMR2_OC3M_Pos)
#define TIM_CCMR2_OC3M_2 (0x0004UL << TIM_CCMR2_OC3M_Pos)
#define TIM_CCMR2_OC3M_3 (0x1000UL << TIM_CCMR2_OC3M_Pos)

#define TIM_CCMR2_OC3CE_Pos (7U)
#define TIM_CCMR2_OC3CE_Msk (0x1UL << TIM_CCMR2_OC3CE_Pos)
#define TIM_CCMR2_OC3CE TIM_CCMR2_OC3CE_Msk

#define TIM_CCMR2_CC4S_Pos (8U)
#define TIM_CCMR2_CC4S_Msk (0x3UL << TIM_CCMR2_CC4S_Pos)
#define TIM_CCMR2_CC4S TIM_CCMR2_CC4S_Msk
#define TIM_CCMR2_CC4S_0 (0x1UL << TIM_CCMR2_CC4S_Pos)
#define TIM_CCMR2_CC4S_1 (0x2UL << TIM_CCMR2_CC4S_Pos)

#define TIM_CCMR2_OC4FE_Pos (10U)
#define TIM_CCMR2_OC4FE_Msk (0x1UL << TIM_CCMR2_OC4FE_Pos)
#define TIM_CCMR2_OC4FE TIM_CCMR2_OC4FE_Msk
#define TIM_CCMR2_OC4PE_Pos (11U)
#define TIM_CCMR2_OC4PE_Msk (0x1UL << TIM_CCMR2_OC4PE_Pos)
#define TIM_CCMR2_OC4PE TIM_CCMR2_OC4PE_Msk

#define TIM_CCMR2_OC4M_Pos (12U)
#define TIM_CCMR2_OC4M_Msk (0x1007UL << TIM_CCMR2_OC4M_Pos)
#define TIM_CCMR2_OC4M TIM_CCMR2_OC4M_Msk
#define TIM_CCMR2_OC4M_0 (0x0001UL << TIM_CCMR2_OC4M_Pos)
#define TIM_CCMR2_OC4M_1 (0x0002UL << TIM_CCMR2_OC4M_Pos)
#define TIM_CCMR2_OC4M_2 (0x0004UL << TIM_CCMR2_OC4M_Pos)
#define TIM_CCMR2_OC4M_3 (0x1000UL << TIM_CCMR2_OC4M_Pos)

#define TIM_CCMR2_OC4CE_Pos (15U)
#define TIM_CCMR2_OC4CE_Msk (0x1UL << TIM_CCMR2_OC4CE_Pos)
#define TIM_CCMR2_OC4CE TIM_CCMR2_OC4CE_Msk

/*----------------------------------------------------------------------------*/
#define TIM_CCMR2_IC3PSC_Pos (2U)
#define TIM_CCMR2_IC3PSC_Msk (0x3UL << TIM_CCMR2_IC3PSC_Pos)
#define TIM_CCMR2_IC3PSC TIM_CCMR2_IC3PSC_Msk
#define TIM_CCMR2_IC3PSC_0 (0x1UL << TIM_CCMR2_IC3PSC_Pos)
#define TIM_CCMR2_IC3PSC_1 (0x2UL << TIM_CCMR2_IC3PSC_Pos)

#define TIM_CCMR2_IC3F_Pos (4U)
#define TIM_CCMR2_IC3F_Msk (0xFUL << TIM_CCMR2_IC3F_Pos)
#define TIM_CCMR2_IC3F TIM_CCMR2_IC3F_Msk
#define TIM_CCMR2_IC3F_0 (0x1UL << TIM_CCMR2_IC3F_Pos)
#define TIM_CCMR2_IC3F_1 (0x2UL << TIM_CCMR2_IC3F_Pos)
#define TIM_CCMR2_IC3F_2 (0x4UL << TIM_CCMR2_IC3F_Pos)
#define TIM_CCMR2_IC3F_3 (0x8UL << TIM_CCMR2_IC3F_Pos)

#define TIM_CCMR2_IC4PSC_Pos (10U)
#define TIM_CCMR2_IC4PSC_Msk (0x3UL << TIM_CCMR2_IC4PSC_Pos)
#define TIM_CCMR2_IC4PSC TIM_CCMR2_IC4PSC_Msk
#define TIM_CCMR2_IC4PSC_0 (0x1UL << TIM_CCMR2_IC4PSC_Pos)
#define TIM_CCMR2_IC4PSC_1 (0x2UL << TIM_CCMR2_IC4PSC_Pos)

#define TIM_CCMR2_IC4F_Pos (12U)
#define TIM_CCMR2_IC4F_Msk (0xFUL << TIM_CCMR2_IC4F_Pos)
#define TIM_CCMR2_IC4F TIM_CCMR2_IC4F_Msk
#define TIM_CCMR2_IC4F_0 (0x1UL << TIM_CCMR2_IC4F_Pos)
#define TIM_CCMR2_IC4F_1 (0x2UL << TIM_CCMR2_IC4F_Pos)
#define TIM_CCMR2_IC4F_2 (0x4UL << TIM_CCMR2_IC4F_Pos)
#define TIM_CCMR2_IC4F_3 (0x8UL << TIM_CCMR2_IC4F_Pos)

/******************  Bit definition for TIM_CCMR3 register  *******************/
#define TIM_CCMR3_OC5FE_Pos (2U)
#define TIM_CCMR3_OC5FE_Msk (0x1UL << TIM_CCMR3_OC5FE_Pos)
#define TIM_CCMR3_OC5FE TIM_CCMR3_OC5FE_Msk
#define TIM_CCMR3_OC5PE_Pos (3U)
#define TIM_CCMR3_OC5PE_Msk (0x1UL << TIM_CCMR3_OC5PE_Pos)
#define TIM_CCMR3_OC5PE TIM_CCMR3_OC5PE_Msk

#define TIM_CCMR3_OC5M_Pos (4U)
#define TIM_CCMR3_OC5M_Msk (0x1007UL << TIM_CCMR3_OC5M_Pos)
#define TIM_CCMR3_OC5M TIM_CCMR3_OC5M_Msk
#define TIM_CCMR3_OC5M_0 (0x0001UL << TIM_CCMR3_OC5M_Pos)
#define TIM_CCMR3_OC5M_1 (0x0002UL << TIM_CCMR3_OC5M_Pos)
#define TIM_CCMR3_OC5M_2 (0x0004UL << TIM_CCMR3_OC5M_Pos)
#define TIM_CCMR3_OC5M_3 (0x1000UL << TIM_CCMR3_OC5M_Pos)

#define TIM_CCMR3_OC5CE_Pos (7U)
#define TIM_CCMR3_OC5CE_Msk (0x1UL << TIM_CCMR3_OC5CE_Pos)
#define TIM_CCMR3_OC5CE TIM_CCMR3_OC5CE_Msk

#define TIM_CCMR3_OC6FE_Pos (10U)
#define TIM_CCMR3_OC6FE_Msk (0x1UL << TIM_CCMR3_OC6FE_Pos)
#define TIM_CCMR3_OC6FE TIM_CCMR3_OC6FE_Msk
#define TIM_CCMR3_OC6PE_Pos (11U)
#define TIM_CCMR3_OC6PE_Msk (0x1UL << TIM_CCMR3_OC6PE_Pos)
#define TIM_CCMR3_OC6PE TIM_CCMR3_OC6PE_Msk

#define TIM_CCMR3_OC6M_Pos (12U)
#define TIM_CCMR3_OC6M_Msk (0x1007UL << TIM_CCMR3_OC6M_Pos)
#define TIM_CCMR3_OC6M TIM_CCMR3_OC6M_Msk
#define TIM_CCMR3_OC6M_0 (0x0001UL << TIM_CCMR3_OC6M_Pos)
#define TIM_CCMR3_OC6M_1 (0x0002UL << TIM_CCMR3_OC6M_Pos)
#define TIM_CCMR3_OC6M_2 (0x0004UL << TIM_CCMR3_OC6M_Pos)
#define TIM_CCMR3_OC6M_3 (0x1000UL << TIM_CCMR3_OC6M_Pos)

#define TIM_CCMR3_OC6CE_Pos (15U)
#define TIM_CCMR3_OC6CE_Msk (0x1UL << TIM_CCMR3_OC6CE_Pos)
#define TIM_CCMR3_OC6CE TIM_CCMR3_OC6CE_Msk

/*******************  Bit definition for TIM_CCER register  *******************/
#define TIM_CCER_CC1E_Pos (0U)
#define TIM_CCER_CC1E_Msk (0x1UL << TIM_CCER_CC1E_Pos)
#define TIM_CCER_CC1E TIM_CCER_CC1E_Msk
#define TIM_CCER_CC1P_Pos (1U)
#define TIM_CCER_CC1P_Msk (0x1UL << TIM_CCER_CC1P_Pos)
#define TIM_CCER_CC1P TIM_CCER_CC1P_Msk
#define TIM_CCER_CC1NE_Pos (2U)
#define TIM_CCER_CC1NE_Msk (0x1UL << TIM_CCER_CC1NE_Pos)
#define TIM_CCER_CC1NE TIM_CCER_CC1NE_Msk
#define TIM_CCER_CC1NP_Pos (3U)
#define TIM_CCER_CC1NP_Msk (0x1UL << TIM_CCER_CC1NP_Pos)
#define TIM_CCER_CC1NP TIM_CCER_CC1NP_Msk
#define TIM_CCER_CC2E_Pos (4U)
#define TIM_CCER_CC2E_Msk (0x1UL << TIM_CCER_CC2E_Pos)
#define TIM_CCER_CC2E TIM_CCER_CC2E_Msk
#define TIM_CCER_CC2P_Pos (5U)
#define TIM_CCER_CC2P_Msk (0x1UL << TIM_CCER_CC2P_Pos)
#define TIM_CCER_CC2P TIM_CCER_CC2P_Msk
#define TIM_CCER_CC2NE_Pos (6U)
#define TIM_CCER_CC2NE_Msk (0x1UL << TIM_CCER_CC2NE_Pos)
#define TIM_CCER_CC2NE TIM_CCER_CC2NE_Msk
#define TIM_CCER_CC2NP_Pos (7U)
#define TIM_CCER_CC2NP_Msk (0x1UL << TIM_CCER_CC2NP_Pos)
#define TIM_CCER_CC2NP TIM_CCER_CC2NP_Msk
#define TIM_CCER_CC3E_Pos (8U)
#define TIM_CCER_CC3E_Msk (0x1UL << TIM_CCER_CC3E_Pos)
#define TIM_CCER_CC3E TIM_CCER_CC3E_Msk
#define TIM_CCER_CC3P_Pos (9U)
#define TIM_CCER_CC3P_Msk (0x1UL << TIM_CCER_CC3P_Pos)
#define TIM_CCER_CC3P TIM_CCER_CC3P_Msk
#define TIM_CCER_CC3NE_Pos (10U)
#define TIM_CCER_CC3NE_Msk (0x1UL << TIM_CCER_CC3NE_Pos)
#define TIM_CCER_CC3NE TIM_CCER_CC3NE_Msk
#define TIM_CCER_CC3NP_Pos (11U)
#define TIM_CCER_CC3NP_Msk (0x1UL << TIM_CCER_CC3NP_Pos)
#define TIM_CCER_CC3NP TIM_CCER_CC3NP_Msk
#define TIM_CCER_CC4E_Pos (12U)
#define TIM_CCER_CC4E_Msk (0x1UL << TIM_CCER_CC4E_Pos)
#define TIM_CCER_CC4E TIM_CCER_CC4E_Msk
#define TIM_CCER_CC4P_Pos (13U)
#define TIM_CCER_CC4P_Msk (0x1UL << TIM_CCER_CC4P_Pos)
#define TIM_CCER_CC4P TIM_CCER_CC4P_Msk
#define TIM_CCER_CC4NE_Pos (14U)
#define TIM_CCER_CC4NE_Msk (0x1UL << TIM_CCER_CC4NE_Pos)
#define TIM_CCER_CC4NE TIM_CCER_CC4NE_Msk
#define TIM_CCER_CC4NP_Pos (15U)
#define TIM_CCER_CC4NP_Msk (0x1UL << TIM_CCER_CC4NP_Pos)
#define TIM_CCER_CC4NP TIM_CCER_CC4NP_Msk
#define TIM_CCER_CC5E_Pos (16U)
#define TIM_CCER_CC5E_Msk (0x1UL << TIM_CCER_CC5E_Pos)
#define TIM_CCER_CC5E TIM_CCER_CC5E_Msk
#define TIM_CCER_CC5P_Pos (17U)
#define TIM_CCER_CC5P_Msk (0x1UL << TIM_CCER_CC5P_Pos)
#define TIM_CCER_CC5P TIM_CCER_CC5P_Msk
#define TIM_CCER_CC6E_Pos (20U)
#define TIM_CCER_CC6E_Msk (0x1UL << TIM_CCER_CC6E_Pos)
#define TIM_CCER_CC6E TIM_CCER_CC6E_Msk
#define TIM_CCER_CC6P_Pos (21U)
#define TIM_CCER_CC6P_Msk (0x1UL << TIM_CCER_CC6P_Pos)
#define TIM_CCER_CC6P TIM_CCER_CC6P_Msk

/*******************  Bit definition for TIM_CNT register  ********************/
#define TIM_CNT_CNT_Pos (0U)
#define TIM_CNT_CNT_Msk (0xFFFFFFFFUL << TIM_CNT_CNT_Pos)
#define TIM_CNT_CNT TIM_CNT_CNT_Msk
#define TIM_CNT_UIFCPY_Pos (31U)
#define TIM_CNT_UIFCPY_Msk (0x1UL << TIM_CNT_UIFCPY_Pos)
#define TIM_CNT_UIFCPY TIM_CNT_UIFCPY_Msk

/*******************  Bit definition for TIM_PSC register  ********************/
#define TIM_PSC_PSC_Pos (0U)
#define TIM_PSC_PSC_Msk (0xFFFFUL << TIM_PSC_PSC_Pos)
#define TIM_PSC_PSC TIM_PSC_PSC_Msk

/*******************  Bit definition for TIM_ARR register  ********************/
#define TIM_ARR_ARR_Pos (0U)
#define TIM_ARR_ARR_Msk (0xFFFFFFFFUL << TIM_ARR_ARR_Pos)
#define TIM_ARR_ARR TIM_ARR_ARR_Msk

/*******************  Bit definition for TIM_RCR register  ********************/
#define TIM_RCR_REP_Pos (0U)
#define TIM_RCR_REP_Msk (0xFFFFUL << TIM_RCR_REP_Pos)
#define TIM_RCR_REP TIM_RCR_REP_Msk

/*******************  Bit definition for TIM_CCR1 register  *******************/
#define TIM_CCR1_CCR1_Pos (0U)
#define TIM_CCR1_CCR1_Msk (0xFFFFUL << TIM_CCR1_CCR1_Pos)
#define TIM_CCR1_CCR1 TIM_CCR1_CCR1_Msk

/*******************  Bit definition for TIM_CCR2 register  *******************/
#define TIM_CCR2_CCR2_Pos (0U)
#define TIM_CCR2_CCR2_Msk (0xFFFFUL << TIM_CCR2_CCR2_Pos)
#define TIM_CCR2_CCR2 TIM_CCR2_CCR2_Msk

/*******************  Bit definition for TIM_CCR3 register  *******************/
#define TIM_CCR3_CCR3_Pos (0U)
#define TIM_CCR3_CCR3_Msk (0xFFFFUL << TIM_CCR3_CCR3_Pos)
#define TIM_CCR3_CCR3 TIM_CCR3_CCR3_Msk

/*******************  Bit definition for TIM_CCR4 register  *******************/
#define TIM_CCR4_CCR4_Pos (0U)
#define TIM_CCR4_CCR4_Msk (0xFFFFUL << TIM_CCR4_CCR4_Pos)
#define TIM_CCR4_CCR4 TIM_CCR4_CCR4_Msk

/*******************  Bit definition for TIM_CCR5 register  *******************/
#define TIM_CCR5_CCR5_Pos (0U)
#define TIM_CCR5_CCR5_Msk (0xFFFFFFFFUL << TIM_CCR5_CCR5_Pos)
#define TIM_CCR5_CCR5 TIM_CCR5_CCR5_Msk
#define TIM_CCR5_GC5C1_Pos (29U)
#define TIM_CCR5_GC5C1_Msk (0x1UL << TIM_CCR5_GC5C1_Pos)
#define TIM_CCR5_GC5C1 TIM_CCR5_GC5C1_Msk
#define TIM_CCR5_GC5C2_Pos (30U)
#define TIM_CCR5_GC5C2_Msk (0x1UL << TIM_CCR5_GC5C2_Pos)
#define TIM_CCR5_GC5C2 TIM_CCR5_GC5C2_Msk
#define TIM_CCR5_GC5C3_Pos (31U)
#define TIM_CCR5_GC5C3_Msk (0x1UL << TIM_CCR5_GC5C3_Pos)
#define TIM_CCR5_GC5C3 TIM_CCR5_GC5C3_Msk

/*******************  Bit definition for TIM_CCR6 register  *******************/
#define TIM_CCR6_CCR6_Pos (0U)
#define TIM_CCR6_CCR6_Msk (0xFFFFUL << TIM_CCR6_CCR6_Pos)
#define TIM_CCR6_CCR6 TIM_CCR6_CCR6_Msk

/*******************  Bit definition for TIM_BDTR register  *******************/
#define TIM_BDTR_DTG_Pos (0U)
#define TIM_BDTR_DTG_Msk (0xFFUL << TIM_BDTR_DTG_Pos)
#define TIM_BDTR_DTG TIM_BDTR_DTG_Msk
#define TIM_BDTR_DTG_0 (0x01UL << TIM_BDTR_DTG_Pos)
#define TIM_BDTR_DTG_1 (0x02UL << TIM_BDTR_DTG_Pos)
#define TIM_BDTR_DTG_2 (0x04UL << TIM_BDTR_DTG_Pos)
#define TIM_BDTR_DTG_3 (0x08UL << TIM_BDTR_DTG_Pos)
#define TIM_BDTR_DTG_4 (0x10UL << TIM_BDTR_DTG_Pos)
#define TIM_BDTR_DTG_5 (0x20UL << TIM_BDTR_DTG_Pos)
#define TIM_BDTR_DTG_6 (0x40UL << TIM_BDTR_DTG_Pos)
#define TIM_BDTR_DTG_7 (0x80UL << TIM_BDTR_DTG_Pos)

#define TIM_BDTR_LOCK_Pos (8U)
#define TIM_BDTR_LOCK_Msk (0x3UL << TIM_BDTR_LOCK_Pos)
#define TIM_BDTR_LOCK TIM_BDTR_LOCK_Msk
#define TIM_BDTR_LOCK_0 (0x1UL << TIM_BDTR_LOCK_Pos)
#define TIM_BDTR_LOCK_1 (0x2UL << TIM_BDTR_LOCK_Pos)

#define TIM_BDTR_OSSI_Pos (10U)
#define TIM_BDTR_OSSI_Msk (0x1UL << TIM_BDTR_OSSI_Pos)
#define TIM_BDTR_OSSI TIM_BDTR_OSSI_Msk
#define TIM_BDTR_OSSR_Pos (11U)
#define TIM_BDTR_OSSR_Msk (0x1UL << TIM_BDTR_OSSR_Pos)
#define TIM_BDTR_OSSR TIM_BDTR_OSSR_Msk
#define TIM_BDTR_BKE_Pos (12U)
#define TIM_BDTR_BKE_Msk (0x1UL << TIM_BDTR_BKE_Pos)
#define TIM_BDTR_BKE TIM_BDTR_BKE_Msk
#define TIM_BDTR_BKP_Pos (13U)
#define TIM_BDTR_BKP_Msk (0x1UL << TIM_BDTR_BKP_Pos)
#define TIM_BDTR_BKP TIM_BDTR_BKP_Msk
#define TIM_BDTR_AOE_Pos (14U)
#define TIM_BDTR_AOE_Msk (0x1UL << TIM_BDTR_AOE_Pos)
#define TIM_BDTR_AOE TIM_BDTR_AOE_Msk
#define TIM_BDTR_MOE_Pos (15U)
#define TIM_BDTR_MOE_Msk (0x1UL << TIM_BDTR_MOE_Pos)
#define TIM_BDTR_MOE TIM_BDTR_MOE_Msk

#define TIM_BDTR_BKF_Pos (16U)
#define TIM_BDTR_BKF_Msk (0xFUL << TIM_BDTR_BKF_Pos)
#define TIM_BDTR_BKF TIM_BDTR_BKF_Msk
#define TIM_BDTR_BK2F_Pos (20U)
#define TIM_BDTR_BK2F_Msk (0xFUL << TIM_BDTR_BK2F_Pos)
#define TIM_BDTR_BK2F TIM_BDTR_BK2F_Msk

#define TIM_BDTR_BK2E_Pos (24U)
#define TIM_BDTR_BK2E_Msk (0x1UL << TIM_BDTR_BK2E_Pos)
#define TIM_BDTR_BK2E TIM_BDTR_BK2E_Msk
#define TIM_BDTR_BK2P_Pos (25U)
#define TIM_BDTR_BK2P_Msk (0x1UL << TIM_BDTR_BK2P_Pos)
#define TIM_BDTR_BK2P TIM_BDTR_BK2P_Msk

#define TIM_BDTR_BKDSRM_Pos (26U)
#define TIM_BDTR_BKDSRM_Msk (0x1UL << TIM_BDTR_BKDSRM_Pos)
#define TIM_BDTR_BKDSRM TIM_BDTR_BKDSRM_Msk
#define TIM_BDTR_BK2DSRM_Pos (27U)
#define TIM_BDTR_BK2DSRM_Msk (0x1UL << TIM_BDTR_BK2DSRM_Pos)
#define TIM_BDTR_BK2DSRM TIM_BDTR_BK2DSRM_Msk

#define TIM_BDTR_BKBID_Pos (28U)
#define TIM_BDTR_BKBID_Msk (0x1UL << TIM_BDTR_BKBID_Pos)
#define TIM_BDTR_BKBID TIM_BDTR_BKBID_Msk
#define TIM_BDTR_BK2BID_Pos (29U)
#define TIM_BDTR_BK2BID_Msk (0x1UL << TIM_BDTR_BK2BID_Pos)
#define TIM_BDTR_BK2BID TIM_BDTR_BK2BID_Msk

/*******************  Bit definition for TIM_DCR register  ********************/
#define TIM_DCR_DBA_Pos (0U)
#define TIM_DCR_DBA_Msk (0x1FUL << TIM_DCR_DBA_Pos)
#define TIM_DCR_DBA TIM_DCR_DBA_Msk
#define TIM_DCR_DBA_0 (0x01UL << TIM_DCR_DBA_Pos)
#define TIM_DCR_DBA_1 (0x02UL << TIM_DCR_DBA_Pos)
#define TIM_DCR_DBA_2 (0x04UL << TIM_DCR_DBA_Pos)
#define TIM_DCR_DBA_3 (0x08UL << TIM_DCR_DBA_Pos)
#define TIM_DCR_DBA_4 (0x10UL << TIM_DCR_DBA_Pos)

#define TIM_DCR_DBL_Pos (8U)
#define TIM_DCR_DBL_Msk (0x1FUL << TIM_DCR_DBL_Pos)
#define TIM_DCR_DBL TIM_DCR_DBL_Msk
#define TIM_DCR_DBL_0 (0x01UL << TIM_DCR_DBL_Pos)
#define TIM_DCR_DBL_1 (0x02UL << TIM_DCR_DBL_Pos)
#define TIM_DCR_DBL_2 (0x04UL << TIM_DCR_DBL_Pos)
#define TIM_DCR_DBL_3 (0x08UL << TIM_DCR_DBL_Pos)
#define TIM_DCR_DBL_4 (0x10UL << TIM_DCR_DBL_Pos)

/*******************  Bit definition for TIM1_AF1 register  *******************/
#define TIM1_AF1_BKINE_Pos (0U)
#define TIM1_AF1_BKINE_Msk (0x1UL << TIM1_AF1_BKINE_Pos)
#define TIM1_AF1_BKINE TIM1_AF1_BKINE_Msk
#define TIM1_AF1_BKCMP1E_Pos (1U)
#define TIM1_AF1_BKCMP1E_Msk (0x1UL << TIM1_AF1_BKCMP1E_Pos)
#define TIM1_AF1_BKCMP1E TIM1_AF1_BKCMP1E_Msk
#define TIM1_AF1_BKCMP2E_Pos (2U)
#define TIM1_AF1_BKCMP2E_Msk (0x1UL << TIM1_AF1_BKCMP2E_Pos)
#define TIM1_AF1_BKCMP2E TIM1_AF1_BKCMP2E_Msk
#define TIM1_AF1_BKCMP3E_Pos (3U)
#define TIM1_AF1_BKCMP3E_Msk (0x1UL << TIM1_AF1_BKCMP3E_Pos)
#define TIM1_AF1_BKCMP3E TIM1_AF1_BKCMP3E_Msk
#define TIM1_AF1_BKCMP4E_Pos (4U)
#define TIM1_AF1_BKCMP4E_Msk (0x1UL << TIM1_AF1_BKCMP4E_Pos)
#define TIM1_AF1_BKCMP4E TIM1_AF1_BKCMP4E_Msk
#define TIM1_AF1_BKCMP5E_Pos (5U)
#define TIM1_AF1_BKCMP5E_Msk (0x1UL << TIM1_AF1_BKCMP5E_Pos)
#define TIM1_AF1_BKCMP5E TIM1_AF1_BKCMP5E_Msk
#define TIM1_AF1_BKCMP6E_Pos (6U)
#define TIM1_AF1_BKCMP6E_Msk (0x1UL << TIM1_AF1_BKCMP6E_Pos)
#define TIM1_AF1_BKCMP6E TIM1_AF1_BKCMP6E_Msk
#define TIM1_AF1_BKCMP7E_Pos (7U)
#define TIM1_AF1_BKCMP7E_Msk (0x1UL << TIM1_AF1_BKCMP7E_Pos)
#define TIM1_AF1_BKCMP7E TIM1_AF1_BKCMP7E_Msk
#define TIM1_AF1_BKINP_Pos (9U)
#define TIM1_AF1_BKINP_Msk (0x1UL << TIM1_AF1_BKINP_Pos)
#define TIM1_AF1_BKINP TIM1_AF1_BKINP_Msk
#define TIM1_AF1_BKCMP1P_Pos (10U)
#define TIM1_AF1_BKCMP1P_Msk (0x1UL << TIM1_AF1_BKCMP1P_Pos)
#define TIM1_AF1_BKCMP1P TIM1_AF1_BKCMP1P_Msk
#define TIM1_AF1_BKCMP2P_Pos (11U)
#define TIM1_AF1_BKCMP2P_Msk (0x1UL << TIM1_AF1_BKCMP2P_Pos)
#define TIM1_AF1_BKCMP2P TIM1_AF1_BKCMP2P_Msk
#define TIM1_AF1_BKCMP3P_Pos (12U)
#define TIM1_AF1_BKCMP3P_Msk (0x1UL << TIM1_AF1_BKCMP3P_Pos)
#define TIM1_AF1_BKCMP3P TIM1_AF1_BKCMP3P_Msk
#define TIM1_AF1_BKCMP4P_Pos (13U)
#define TIM1_AF1_BKCMP4P_Msk (0x1UL << TIM1_AF1_BKCMP4P_Pos)
#define TIM1_AF1_BKCMP4P TIM1_AF1_BKCMP4P_Msk
#define TIM1_AF1_ETRSEL_Pos (14U)
#define TIM1_AF1_ETRSEL_Msk (0xFUL << TIM1_AF1_ETRSEL_Pos)
#define TIM1_AF1_ETRSEL TIM1_AF1_ETRSEL_Msk
#define TIM1_AF1_ETRSEL_0 (0x1UL << TIM1_AF1_ETRSEL_Pos)
#define TIM1_AF1_ETRSEL_1 (0x2UL << TIM1_AF1_ETRSEL_Pos)
#define TIM1_AF1_ETRSEL_2 (0x4UL << TIM1_AF1_ETRSEL_Pos)
#define TIM1_AF1_ETRSEL_3 (0x8UL << TIM1_AF1_ETRSEL_Pos)

/*******************  Bit definition for TIM1_AF2 register  *********************/
#define TIM1_AF2_BK2INE_Pos (0U)
#define TIM1_AF2_BK2INE_Msk (0x1UL << TIM1_AF2_BK2INE_Pos)
#define TIM1_AF2_BK2INE TIM1_AF2_BK2INE_Msk
#define TIM1_AF2_BK2CMP1E_Pos (1U)
#define TIM1_AF2_BK2CMP1E_Msk (0x1UL << TIM1_AF2_BK2CMP1E_Pos)
#define TIM1_AF2_BK2CMP1E TIM1_AF2_BK2CMP1E_Msk
#define TIM1_AF2_BK2CMP2E_Pos (2U)
#define TIM1_AF2_BK2CMP2E_Msk (0x1UL << TIM1_AF2_BK2CMP2E_Pos)
#define TIM1_AF2_BK2CMP2E TIM1_AF2_BK2CMP2E_Msk
#define TIM1_AF2_BK2CMP3E_Pos (3U)
#define TIM1_AF2_BK2CMP3E_Msk (0x1UL << TIM1_AF2_BK2CMP3E_Pos)
#define TIM1_AF2_BK2CMP3E TIM1_AF2_BK2CMP3E_Msk
#define TIM1_AF2_BK2CMP4E_Pos (4U)
#define TIM1_AF2_BK2CMP4E_Msk (0x1UL << TIM1_AF2_BK2CMP4E_Pos)
#define TIM1_AF2_BK2CMP4E TIM1_AF2_BK2CMP4E_Msk
#define TIM1_AF2_BK2CMP5E_Pos (5U)
#define TIM1_AF2_BK2CMP5E_Msk (0x1UL << TIM1_AF2_BK2CMP5E_Pos)
#define TIM1_AF2_BK2CMP5E TIM1_AF2_BK2CMP5E_Msk
#define TIM1_AF2_BK2CMP6E_Pos (6U)
#define TIM1_AF2_BK2CMP6E_Msk (0x1UL << TIM1_AF2_BK2CMP6E_Pos)
#define TIM1_AF2_BK2CMP6E TIM1_AF2_BK2CMP6E_Msk
#define TIM1_AF2_BK2CMP7E_Pos (7U)
#define TIM1_AF2_BK2CMP7E_Msk (0x1UL << TIM1_AF2_BK2CMP7E_Pos)
#define TIM1_AF2_BK2CMP7E TIM1_AF2_BK2CMP7E_Msk
#define TIM1_AF2_BK2INP_Pos (9U)
#define TIM1_AF2_BK2INP_Msk (0x1UL << TIM1_AF2_BK2INP_Pos)
#define TIM1_AF2_BK2INP TIM1_AF2_BK2INP_Msk
#define TIM1_AF2_BK2CMP1P_Pos (10U)
#define TIM1_AF2_BK2CMP1P_Msk (0x1UL << TIM1_AF2_BK2CMP1P_Pos)
#define TIM1_AF2_BK2CMP1P TIM1_AF2_BK2CMP1P_Msk
#define TIM1_AF2_BK2CMP2P_Pos (11U)
#define TIM1_AF2_BK2CMP2P_Msk (0x1UL << TIM1_AF2_BK2CMP2P_Pos)
#define TIM1_AF2_BK2CMP2P TIM1_AF2_BK2CMP2P_Msk
#define TIM1_AF2_BK2CMP3P_Pos (12U)
#define TIM1_AF2_BK2CMP3P_Msk (0x1UL << TIM1_AF2_BK2CMP3P_Pos)
#define TIM1_AF2_BK2CMP3P TIM1_AF2_BK2CMP3P_Msk
#define TIM1_AF2_BK2CMP4P_Pos (13U)
#define TIM1_AF2_BK2CMP4P_Msk (0x1UL << TIM1_AF2_BK2CMP4P_Pos)
#define TIM1_AF2_BK2CMP4P TIM1_AF2_BK2CMP4P_Msk
#define TIM1_AF2_OCRSEL_Pos (16U)
#define TIM1_AF2_OCRSEL_Msk (0x7UL << TIM1_AF2_OCRSEL_Pos)
#define TIM1_AF2_OCRSEL TIM1_AF2_OCRSEL_Msk
#define TIM1_AF2_OCRSEL_0 (0x1UL << TIM1_AF2_OCRSEL_Pos)
#define TIM1_AF2_OCRSEL_1 (0x2UL << TIM1_AF2_OCRSEL_Pos)
#define TIM1_AF2_OCRSEL_2 (0x4UL << TIM1_AF2_OCRSEL_Pos)

/*******************  Bit definition for TIM_OR register  *********************/
#define TIM_OR_HSE32EN_Pos (0U)
#define TIM_OR_HSE32EN_Msk (0x1UL << TIM_OR_HSE32EN_Pos)
#define TIM_OR_HSE32EN TIM_OR_HSE32EN_Msk

/*******************  Bit definition for TIM_TISEL register  *********************/
#define TIM_TISEL_TI1SEL_Pos (0U)
#define TIM_TISEL_TI1SEL_Msk (0xFUL << TIM_TISEL_TI1SEL_Pos)
#define TIM_TISEL_TI1SEL TIM_TISEL_TI1SEL_Msk
#define TIM_TISEL_TI1SEL_0 (0x1UL << TIM_TISEL_TI1SEL_Pos)
#define TIM_TISEL_TI1SEL_1 (0x2UL << TIM_TISEL_TI1SEL_Pos)
#define TIM_TISEL_TI1SEL_2 (0x4UL << TIM_TISEL_TI1SEL_Pos)
#define TIM_TISEL_TI1SEL_3 (0x8UL << TIM_TISEL_TI1SEL_Pos)

#define TIM_TISEL_TI2SEL_Pos (8U)
#define TIM_TISEL_TI2SEL_Msk (0xFUL << TIM_TISEL_TI2SEL_Pos)
#define TIM_TISEL_TI2SEL TIM_TISEL_TI2SEL_Msk
#define TIM_TISEL_TI2SEL_0 (0x1UL << TIM_TISEL_TI2SEL_Pos)
#define TIM_TISEL_TI2SEL_1 (0x2UL << TIM_TISEL_TI2SEL_Pos)
#define TIM_TISEL_TI2SEL_2 (0x4UL << TIM_TISEL_TI2SEL_Pos)
#define TIM_TISEL_TI2SEL_3 (0x8UL << TIM_TISEL_TI2SEL_Pos)

#define TIM_TISEL_TI3SEL_Pos (16U)
#define TIM_TISEL_TI3SEL_Msk (0xFUL << TIM_TISEL_TI3SEL_Pos)
#define TIM_TISEL_TI3SEL TIM_TISEL_TI3SEL_Msk
#define TIM_TISEL_TI3SEL_0 (0x1UL << TIM_TISEL_TI3SEL_Pos)
#define TIM_TISEL_TI3SEL_1 (0x2UL << TIM_TISEL_TI3SEL_Pos)
#define TIM_TISEL_TI3SEL_2 (0x4UL << TIM_TISEL_TI3SEL_Pos)
#define TIM_TISEL_TI3SEL_3 (0x8UL << TIM_TISEL_TI3SEL_Pos)

#define TIM_TISEL_TI4SEL_Pos (24U)
#define TIM_TISEL_TI4SEL_Msk (0xFUL << TIM_TISEL_TI4SEL_Pos)
#define TIM_TISEL_TI4SEL TIM_TISEL_TI4SEL_Msk
#define TIM_TISEL_TI4SEL_0 (0x1UL << TIM_TISEL_TI4SEL_Pos)
#define TIM_TISEL_TI4SEL_1 (0x2UL << TIM_TISEL_TI4SEL_Pos)
#define TIM_TISEL_TI4SEL_2 (0x4UL << TIM_TISEL_TI4SEL_Pos)
#define TIM_TISEL_TI4SEL_3 (0x8UL << TIM_TISEL_TI4SEL_Pos)

/*******************  Bit definition for TIM_DTR2 register  *********************/
#define TIM_DTR2_DTGF_Pos (0U)
#define TIM_DTR2_DTGF_Msk (0xFFUL << TIM_DTR2_DTGF_Pos)
#define TIM_DTR2_DTGF TIM_DTR2_DTGF_Msk
#define TIM_DTR2_DTGF_0 (0x01UL << TIM_DTR2_DTGF_Pos)
#define TIM_DTR2_DTGF_1 (0x02UL << TIM_DTR2_DTGF_Pos)
#define TIM_DTR2_DTGF_2 (0x04UL << TIM_DTR2_DTGF_Pos)
#define TIM_DTR2_DTGF_3 (0x08UL << TIM_DTR2_DTGF_Pos)
#define TIM_DTR2_DTGF_4 (0x10UL << TIM_DTR2_DTGF_Pos)
#define TIM_DTR2_DTGF_5 (0x20UL << TIM_DTR2_DTGF_Pos)
#define TIM_DTR2_DTGF_6 (0x40UL << TIM_DTR2_DTGF_Pos)
#define TIM_DTR2_DTGF_7 (0x80UL << TIM_DTR2_DTGF_Pos)

#define TIM_DTR2_DTAE_Pos (16U)
#define TIM_DTR2_DTAE_Msk (0x1UL << TIM_DTR2_DTAE_Pos)
#define TIM_DTR2_DTAE TIM_DTR2_DTAE_Msk
#define TIM_DTR2_DTPE_Pos (17U)
#define TIM_DTR2_DTPE_Msk (0x1UL << TIM_DTR2_DTPE_Pos)
#define TIM_DTR2_DTPE TIM_DTR2_DTPE_Msk

/*******************  Bit definition for TIM_ECR register  *********************/
#define TIM_ECR_IE_Pos (0U)
#define TIM_ECR_IE_Msk (0x1UL << TIM_ECR_IE_Pos)
#define TIM_ECR_IE TIM_ECR_IE_Msk

#define TIM_ECR_IDIR_Pos (1U)
#define TIM_ECR_IDIR_Msk (0x3UL << TIM_ECR_IDIR_Pos)
#define TIM_ECR_IDIR TIM_ECR_IDIR_Msk
#define TIM_ECR_IDIR_0 (0x01UL << TIM_ECR_IDIR_Pos)
#define TIM_ECR_IDIR_1 (0x02UL << TIM_ECR_IDIR_Pos)

#define TIM_ECR_FIDX_Pos (5U)
#define TIM_ECR_FIDX_Msk (0x1UL << TIM_ECR_FIDX_Pos)
#define TIM_ECR_FIDX TIM_ECR_FIDX_Msk

#define TIM_ECR_IPOS_Pos (6U)
#define TIM_ECR_IPOS_Msk (0x3UL << TIM_ECR_IPOS_Pos)
#define TIM_ECR_IPOS TIM_ECR_IPOS_Msk
#define TIM_ECR_IPOS_0 (0x01UL << TIM_ECR_IPOS_Pos)
#define TIM_ECR_IPOS_1 (0x02UL << TIM_ECR_IPOS_Pos)

#define TIM_ECR_PW_Pos (16U)
#define TIM_ECR_PW_Msk (0xFFUL << TIM_ECR_PW_Pos)
#define TIM_ECR_PW TIM_ECR_PW_Msk
#define TIM_ECR_PW_0 (0x01UL << TIM_ECR_PW_Pos)
#define TIM_ECR_PW_1 (0x02UL << TIM_ECR_PW_Pos)
#define TIM_ECR_PW_2 (0x04UL << TIM_ECR_PW_Pos)
#define TIM_ECR_PW_3 (0x08UL << TIM_ECR_PW_Pos)
#define TIM_ECR_PW_4 (0x10UL << TIM_ECR_PW_Pos)
#define TIM_ECR_PW_5 (0x20UL << TIM_ECR_PW_Pos)
#define TIM_ECR_PW_6 (0x40UL << TIM_ECR_PW_Pos)
#define TIM_ECR_PW_7 (0x80UL << TIM_ECR_PW_Pos)

#define TIM_ECR_PWPRSC_Pos (24U)
#define TIM_ECR_PWPRSC_Msk (0x7UL << TIM_ECR_PWPRSC_Pos)
#define TIM_ECR_PWPRSC TIM_ECR_PWPRSC_Msk
#define TIM_ECR_PWPRSC_0 (0x01UL << TIM_ECR_PWPRSC_Pos)
#define TIM_ECR_PWPRSC_1 (0x02UL << TIM_ECR_PWPRSC_Pos)
#define TIM_ECR_PWPRSC_2 (0x04UL << TIM_ECR_PWPRSC_Pos)

/*******************  Bit definition for TIM_DMAR register  *******************/
#define TIM_DMAR_DMAB_Pos (0U)
#define TIM_DMAR_DMAB_Msk (0xFFFFFFFFUL << TIM_DMAR_DMAB_Pos)
#define TIM_DMAR_DMAB TIM_DMAR_DMAB_Msk

/******************************************************************************/
/*                                                                            */
/*                         Low Power Timer (LPTIM)                           */
/*                                                                            */
/******************************************************************************/
/******************  Bit definition for LPTIM_ISR register  *******************/
#define LPTIM_ISR_CMPM_Pos (0U)
#define LPTIM_ISR_CMPM_Msk (0x1UL << LPTIM_ISR_CMPM_Pos)
#define LPTIM_ISR_CMPM LPTIM_ISR_CMPM_Msk
#define LPTIM_ISR_ARRM_Pos (1U)
#define LPTIM_ISR_ARRM_Msk (0x1UL << LPTIM_ISR_ARRM_Pos)
#define LPTIM_ISR_ARRM LPTIM_ISR_ARRM_Msk
#define LPTIM_ISR_EXTTRIG_Pos (2U)
#define LPTIM_ISR_EXTTRIG_Msk (0x1UL << LPTIM_ISR_EXTTRIG_Pos)
#define LPTIM_ISR_EXTTRIG LPTIM_ISR_EXTTRIG_Msk
#define LPTIM_ISR_CMPOK_Pos (3U)
#define LPTIM_ISR_CMPOK_Msk (0x1UL << LPTIM_ISR_CMPOK_Pos)
#define LPTIM_ISR_CMPOK LPTIM_ISR_CMPOK_Msk
#define LPTIM_ISR_ARROK_Pos (4U)
#define LPTIM_ISR_ARROK_Msk (0x1UL << LPTIM_ISR_ARROK_Pos)
#define LPTIM_ISR_ARROK LPTIM_ISR_ARROK_Msk
#define LPTIM_ISR_UP_Pos (5U)
#define LPTIM_ISR_UP_Msk (0x1UL << LPTIM_ISR_UP_Pos)
#define LPTIM_ISR_UP LPTIM_ISR_UP_Msk
#define LPTIM_ISR_DOWN_Pos (6U)
#define LPTIM_ISR_DOWN_Msk (0x1UL << LPTIM_ISR_DOWN_Pos)
#define LPTIM_ISR_DOWN LPTIM_ISR_DOWN_Msk

/******************  Bit definition for LPTIM_ICR register  *******************/
#define LPTIM_ICR_CMPMCF_Pos (0U)
#define LPTIM_ICR_CMPMCF_Msk (0x1UL << LPTIM_ICR_CMPMCF_Pos)
#define LPTIM_ICR_CMPMCF LPTIM_ICR_CMPMCF_Msk
#define LPTIM_ICR_ARRMCF_Pos (1U)
#define LPTIM_ICR_ARRMCF_Msk (0x1UL << LPTIM_ICR_ARRMCF_Pos)
#define LPTIM_ICR_ARRMCF LPTIM_ICR_ARRMCF_Msk
#define LPTIM_ICR_EXTTRIGCF_Pos (2U)
#define LPTIM_ICR_EXTTRIGCF_Msk (0x1UL << LPTIM_ICR_EXTTRIGCF_Pos)
#define LPTIM_ICR_EXTTRIGCF LPTIM_ICR_EXTTRIGCF_Msk
#define LPTIM_ICR_CMPOKCF_Pos (3U)
#define LPTIM_ICR_CMPOKCF_Msk (0x1UL << LPTIM_ICR_CMPOKCF_Pos)
#define LPTIM_ICR_CMPOKCF LPTIM_ICR_CMPOKCF_Msk
#define LPTIM_ICR_ARROKCF_Pos (4U)
#define LPTIM_ICR_ARROKCF_Msk (0x1UL << LPTIM_ICR_ARROKCF_Pos)
#define LPTIM_ICR_ARROKCF LPTIM_ICR_ARROKCF_Msk
#define LPTIM_ICR_UPCF_Pos (5U)
#define LPTIM_ICR_UPCF_Msk (0x1UL << LPTIM_ICR_UPCF_Pos)
#define LPTIM_ICR_UPCF LPTIM_ICR_UPCF_Msk
#define LPTIM_ICR_DOWNCF_Pos (6U)
#define LPTIM_ICR_DOWNCF_Msk (0x1UL << LPTIM_ICR_DOWNCF_Pos)
#define LPTIM_ICR_DOWNCF LPTIM_ICR_DOWNCF_Msk

/******************  Bit definition for LPTIM_IER register ********************/
#define LPTIM_IER_CMPMIE_Pos (0U)
#define LPTIM_IER_CMPMIE_Msk (0x1UL << LPTIM_IER_CMPMIE_Pos)
#define LPTIM_IER_CMPMIE LPTIM_IER_CMPMIE_Msk
#define LPTIM_IER_ARRMIE_Pos (1U)
#define LPTIM_IER_ARRMIE_Msk (0x1UL << LPTIM_IER_ARRMIE_Pos)
#define LPTIM_IER_ARRMIE LPTIM_IER_ARRMIE_Msk
#define LPTIM_IER_EXTTRIGIE_Pos (2U)
#define LPTIM_IER_EXTTRIGIE_Msk (0x1UL << LPTIM_IER_EXTTRIGIE_Pos)
#define LPTIM_IER_EXTTRIGIE LPTIM_IER_EXTTRIGIE_Msk
#define LPTIM_IER_CMPOKIE_Pos (3U)
#define LPTIM_IER_CMPOKIE_Msk (0x1UL << LPTIM_IER_CMPOKIE_Pos)
#define LPTIM_IER_CMPOKIE LPTIM_IER_CMPOKIE_Msk
#define LPTIM_IER_ARROKIE_Pos (4U)
#define LPTIM_IER_ARROKIE_Msk (0x1UL << LPTIM_IER_ARROKIE_Pos)
#define LPTIM_IER_ARROKIE LPTIM_IER_ARROKIE_Msk
#define LPTIM_IER_UPIE_Pos (5U)
#define LPTIM_IER_UPIE_Msk (0x1UL << LPTIM_IER_UPIE_Pos)
#define LPTIM_IER_UPIE LPTIM_IER_UPIE_Msk
#define LPTIM_IER_DOWNIE_Pos (6U)
#define LPTIM_IER_DOWNIE_Msk (0x1UL << LPTIM_IER_DOWNIE_Pos)
#define LPTIM_IER_DOWNIE LPTIM_IER_DOWNIE_Msk

/******************  Bit definition for LPTIM_CFGR register *******************/
#define LPTIM_CFGR_CKSEL_Pos (0U)
#define LPTIM_CFGR_CKSEL_Msk (0x1UL << LPTIM_CFGR_CKSEL_Pos)
#define LPTIM_CFGR_CKSEL LPTIM_CFGR_CKSEL_Msk

#define LPTIM_CFGR_CKPOL_Pos (1U)
#define LPTIM_CFGR_CKPOL_Msk (0x3UL << LPTIM_CFGR_CKPOL_Pos)
#define LPTIM_CFGR_CKPOL LPTIM_CFGR_CKPOL_Msk
#define LPTIM_CFGR_CKPOL_0 (0x1UL << LPTIM_CFGR_CKPOL_Pos)
#define LPTIM_CFGR_CKPOL_1 (0x2UL << LPTIM_CFGR_CKPOL_Pos)

#define LPTIM_CFGR_CKFLT_Pos (3U)
#define LPTIM_CFGR_CKFLT_Msk (0x3UL << LPTIM_CFGR_CKFLT_Pos)
#define LPTIM_CFGR_CKFLT LPTIM_CFGR_CKFLT_Msk
#define LPTIM_CFGR_CKFLT_0 (0x1UL << LPTIM_CFGR_CKFLT_Pos)
#define LPTIM_CFGR_CKFLT_1 (0x2UL << LPTIM_CFGR_CKFLT_Pos)

#define LPTIM_CFGR_TRGFLT_Pos (6U)
#define LPTIM_CFGR_TRGFLT_Msk (0x3UL << LPTIM_CFGR_TRGFLT_Pos)
#define LPTIM_CFGR_TRGFLT LPTIM_CFGR_TRGFLT_Msk
#define LPTIM_CFGR_TRGFLT_0 (0x1UL << LPTIM_CFGR_TRGFLT_Pos)
#define LPTIM_CFGR_TRGFLT_1 (0x2UL << LPTIM_CFGR_TRGFLT_Pos)

#define LPTIM_CFGR_PRESC_Pos (9U)
#define LPTIM_CFGR_PRESC_Msk (0x7UL << LPTIM_CFGR_PRESC_Pos)
#define LPTIM_CFGR_PRESC LPTIM_CFGR_PRESC_Msk
#define LPTIM_CFGR_PRESC_0 (0x1UL << LPTIM_CFGR_PRESC_Pos)
#define LPTIM_CFGR_PRESC_1 (0x2UL << LPTIM_CFGR_PRESC_Pos)
#define LPTIM_CFGR_PRESC_2 (0x4UL << LPTIM_CFGR_PRESC_Pos)

#define LPTIM_CFGR_TRIGSEL_Pos (13U)
#define LPTIM_CFGR_TRIGSEL_Msk (0x10007UL << LPTIM_CFGR_TRIGSEL_Pos)
#define LPTIM_CFGR_TRIGSEL LPTIM_CFGR_TRIGSEL_Msk
#define LPTIM_CFGR_TRIGSEL_0 (0x00001UL << LPTIM_CFGR_TRIGSEL_Pos)
#define LPTIM_CFGR_TRIGSEL_1 (0x00002UL << LPTIM_CFGR_TRIGSEL_Pos)
#define LPTIM_CFGR_TRIGSEL_2 (0x00004UL << LPTIM_CFGR_TRIGSEL_Pos)
#define LPTIM_CFGR_TRIGSEL_3 (0x10000UL << LPTIM_CFGR_TRIGSEL_Pos)

#define LPTIM_CFGR_TRIGEN_Pos (17U)
#define LPTIM_CFGR_TRIGEN_Msk (0x3UL << LPTIM_CFGR_TRIGEN_Pos)
#define LPTIM_CFGR_TRIGEN LPTIM_CFGR_TRIGEN_Msk
#define LPTIM_CFGR_TRIGEN_0 (0x1UL << LPTIM_CFGR_TRIGEN_Pos)
#define LPTIM_CFGR_TRIGEN_1 (0x2UL << LPTIM_CFGR_TRIGEN_Pos)

#define LPTIM_CFGR_TIMOUT_Pos (19U)
#define LPTIM_CFGR_TIMOUT_Msk (0x1UL << LPTIM_CFGR_TIMOUT_Pos)
#define LPTIM_CFGR_TIMOUT LPTIM_CFGR_TIMOUT_Msk
#define LPTIM_CFGR_WAVE_Pos (20U)
#define LPTIM_CFGR_WAVE_Msk (0x1UL << LPTIM_CFGR_WAVE_Pos)
#define LPTIM_CFGR_WAVE LPTIM_CFGR_WAVE_Msk
#define LPTIM_CFGR_WAVPOL_Pos (21U)
#define LPTIM_CFGR_WAVPOL_Msk (0x1UL << LPTIM_CFGR_WAVPOL_Pos)
#define LPTIM_CFGR_WAVPOL LPTIM_CFGR_WAVPOL_Msk
#define LPTIM_CFGR_PRELOAD_Pos (22U)
#define LPTIM_CFGR_PRELOAD_Msk (0x1UL << LPTIM_CFGR_PRELOAD_Pos)
#define LPTIM_CFGR_PRELOAD LPTIM_CFGR_PRELOAD_Msk
#define LPTIM_CFGR_COUNTMODE_Pos (23U)
#define LPTIM_CFGR_COUNTMODE_Msk (0x1UL << LPTIM_CFGR_COUNTMODE_Pos)
#define LPTIM_CFGR_COUNTMODE LPTIM_CFGR_COUNTMODE_Msk
#define LPTIM_CFGR_ENC_Pos (24U)
#define LPTIM_CFGR_ENC_Msk (0x1UL << LPTIM_CFGR_ENC_Pos)
#define LPTIM_CFGR_ENC LPTIM_CFGR_ENC_Msk

/******************  Bit definition for LPTIM_CR register  ********************/
#define LPTIM_CR_ENABLE_Pos (0U)
#define LPTIM_CR_ENABLE_Msk (0x1UL << LPTIM_CR_ENABLE_Pos)
#define LPTIM_CR_ENABLE LPTIM_CR_ENABLE_Msk
#define LPTIM_CR_SNGSTRT_Pos (1U)
#define LPTIM_CR_SNGSTRT_Msk (0x1UL << LPTIM_CR_SNGSTRT_Pos)
#define LPTIM_CR_SNGSTRT LPTIM_CR_SNGSTRT_Msk
#define LPTIM_CR_CNTSTRT_Pos (2U)
#define LPTIM_CR_CNTSTRT_Msk (0x1UL << LPTIM_CR_CNTSTRT_Pos)
#define LPTIM_CR_CNTSTRT LPTIM_CR_CNTSTRT_Msk
#define LPTIM_CR_COUNTRST_Pos (3U)
#define LPTIM_CR_COUNTRST_Msk (0x1UL << LPTIM_CR_COUNTRST_Pos)
#define LPTIM_CR_COUNTRST LPTIM_CR_COUNTRST_Msk
#define LPTIM_CR_RSTARE_Pos (4U)
#define LPTIM_CR_RSTARE_Msk (0x1UL << LPTIM_CR_RSTARE_Pos)
#define LPTIM_CR_RSTARE LPTIM_CR_RSTARE_Msk

/******************  Bit definition for LPTIM_CMP register  *******************/
#define LPTIM_CMP_CMP_Pos (0U)
#define LPTIM_CMP_CMP_Msk (0xFFFFUL << LPTIM_CMP_CMP_Pos)
#define LPTIM_CMP_CMP LPTIM_CMP_CMP_Msk

/******************  Bit definition for LPTIM_ARR register  *******************/
#define LPTIM_ARR_ARR_Pos (0U)
#define LPTIM_ARR_ARR_Msk (0xFFFFUL << LPTIM_ARR_ARR_Pos)
#define LPTIM_ARR_ARR LPTIM_ARR_ARR_Msk

/******************  Bit definition for LPTIM_CNT register  *******************/
#define LPTIM_CNT_CNT_Pos (0U)
#define LPTIM_CNT_CNT_Msk (0xFFFFUL << LPTIM_CNT_CNT_Pos)
#define LPTIM_CNT_CNT LPTIM_CNT_CNT_Msk

/******************  Bit definition for LPTIM_OR register  *******************/
#define LPTIM_OR_IN1_Pos (0U)
#define LPTIM_OR_IN1_Msk (0xDUL << LPTIM_OR_IN1_Pos)
#define LPTIM_OR_IN1 LPTIM_OR_IN1_Msk
#define LPTIM_OR_IN1_0 (0x1UL << LPTIM_OR_IN1_Pos)
#define LPTIM_OR_IN1_1 (0x4UL << LPTIM_OR_IN1_Pos)
#define LPTIM_OR_IN1_2 (0x8UL << LPTIM_OR_IN1_Pos)

#define LPTIM_OR_IN2_Pos (1U)
#define LPTIM_OR_IN2_Msk (0x19UL << LPTIM_OR_IN2_Pos)
#define LPTIM_OR_IN2 LPTIM_OR_IN2_Msk
#define LPTIM_OR_IN2_0 (0x1UL << LPTIM_OR_IN2_Pos)
#define LPTIM_OR_IN2_1 (0x8UL << LPTIM_OR_IN2_Pos)
#define LPTIM_OR_IN2_2 (0x10UL << LPTIM_OR_IN2_Pos)
/******************************************************************************/
/*                                                                            */
/*      Universal Synchronous Asynchronous Receiver Transmitter (USART)       */
/*                                                                            */
/******************************************************************************/
/******************  Bit definition for USART_CR1 register  *******************/
#define USART_CR1_UE_Pos (0U)
#define USART_CR1_UE_Msk (0x1UL << USART_CR1_UE_Pos)
#define USART_CR1_UE USART_CR1_UE_Msk
#define USART_CR1_UESM_Pos (1U)
#define USART_CR1_UESM_Msk (0x1UL << USART_CR1_UESM_Pos)
#define USART_CR1_UESM USART_CR1_UESM_Msk
#define USART_CR1_RE_Pos (2U)
#define USART_CR1_RE_Msk (0x1UL << USART_CR1_RE_Pos)
#define USART_CR1_RE USART_CR1_RE_Msk
#define USART_CR1_TE_Pos (3U)
#define USART_CR1_TE_Msk (0x1UL << USART_CR1_TE_Pos)
#define USART_CR1_TE USART_CR1_TE_Msk
#define USART_CR1_IDLEIE_Pos (4U)
#define USART_CR1_IDLEIE_Msk (0x1UL << USART_CR1_IDLEIE_Pos)
#define USART_CR1_IDLEIE USART_CR1_IDLEIE_Msk
#define USART_CR1_RXNEIE_Pos (5U)
#define USART_CR1_RXNEIE_Msk (0x1UL << USART_CR1_RXNEIE_Pos)
#define USART_CR1_RXNEIE USART_CR1_RXNEIE_Msk
#define USART_CR1_RXNEIE_RXFNEIE_Pos USART_CR1_RXNEIE_Pos
#define USART_CR1_RXNEIE_RXFNEIE_Msk USART_CR1_RXNEIE_Msk
#define USART_CR1_RXNEIE_RXFNEIE USART_CR1_RXNEIE_Msk
#define USART_CR1_TCIE_Pos (6U)
#define USART_CR1_TCIE_Msk (0x1UL << USART_CR1_TCIE_Pos)
#define USART_CR1_TCIE USART_CR1_TCIE_Msk
#define USART_CR1_TXEIE_Pos (7U)
#define USART_CR1_TXEIE_Msk (0x1UL << USART_CR1_TXEIE_Pos)
#define USART_CR1_TXEIE USART_CR1_TXEIE_Msk
#define USART_CR1_TXEIE_TXFNFIE_Pos USART_CR1_TXEIE_Pos
#define USART_CR1_TXEIE_TXFNFIE_Msk USART_CR1_TXEIE_Msk
#define USART_CR1_TXEIE_TXFNFIE USART_CR1_TXEIE_Msk
#define USART_CR1_PEIE_Pos (8U)
#define USART_CR1_PEIE_Msk (0x1UL << USART_CR1_PEIE_Pos)
#define USART_CR1_PEIE USART_CR1_PEIE_Msk
#define USART_CR1_PS_Pos (9U)
#define USART_CR1_PS_Msk (0x1UL << USART_CR1_PS_Pos)
#define USART_CR1_PS USART_CR1_PS_Msk
#define USART_CR1_PCE_Pos (10U)
#define USART_CR1_PCE_Msk (0x1UL << USART_CR1_PCE_Pos)
#define USART_CR1_PCE USART_CR1_PCE_Msk
#define USART_CR1_WAKE_Pos (11U)
#define USART_CR1_WAKE_Msk (0x1UL << USART_CR1_WAKE_Pos)
#define USART_CR1_WAKE USART_CR1_WAKE_Msk
#define USART_CR1_M_Pos (12U)
#define USART_CR1_M_Msk (0x10001UL << USART_CR1_M_Pos)
#define USART_CR1_M USART_CR1_M_Msk
#define USART_CR1_M0_Pos (12U)
#define USART_CR1_M0_Msk (0x1UL << USART_CR1_M0_Pos)
#define USART_CR1_M0 USART_CR1_M0_Msk
#define USART_CR1_MME_Pos (13U)
#define USART_CR1_MME_Msk (0x1UL << USART_CR1_MME_Pos)
#define USART_CR1_MME USART_CR1_MME_Msk
#define USART_CR1_CMIE_Pos (14U)
#define USART_CR1_CMIE_Msk (0x1UL << USART_CR1_CMIE_Pos)
#define USART_CR1_CMIE USART_CR1_CMIE_Msk
#define USART_CR1_OVER8_Pos (15U)
#define USART_CR1_OVER8_Msk (0x1UL << USART_CR1_OVER8_Pos)
#define USART_CR1_OVER8 USART_CR1_OVER8_Msk
#define USART_CR1_DEDT_Pos (16U)
#define USART_CR1_DEDT_Msk (0x1FUL << USART_CR1_DEDT_Pos)
#define USART_CR1_DEDT USART_CR1_DEDT_Msk
#define USART_CR1_DEDT_0 (0x01UL << USART_CR1_DEDT_Pos)
#define USART_CR1_DEDT_1 (0x02UL << USART_CR1_DEDT_Pos)
#define USART_CR1_DEDT_2 (0x04UL << USART_CR1_DEDT_Pos)
#define USART_CR1_DEDT_3 (0x08UL << USART_CR1_DEDT_Pos)
#define USART_CR1_DEDT_4 (0x10UL << USART_CR1_DEDT_Pos)
#define USART_CR1_DEAT_Pos (21U)
#define USART_CR1_DEAT_Msk (0x1FUL << USART_CR1_DEAT_Pos)
#define USART_CR1_DEAT USART_CR1_DEAT_Msk
#define USART_CR1_DEAT_0 (0x01UL << USART_CR1_DEAT_Pos)
#define USART_CR1_DEAT_1 (0x02UL << USART_CR1_DEAT_Pos)
#define USART_CR1_DEAT_2 (0x04UL << USART_CR1_DEAT_Pos)
#define USART_CR1_DEAT_3 (0x08UL << USART_CR1_DEAT_Pos)
#define USART_CR1_DEAT_4 (0x10UL << USART_CR1_DEAT_Pos)
#define USART_CR1_RTOIE_Pos (26U)
#define USART_CR1_RTOIE_Msk (0x1UL << USART_CR1_RTOIE_Pos)
#define USART_CR1_RTOIE USART_CR1_RTOIE_Msk
#define USART_CR1_EOBIE_Pos (27U)
#define USART_CR1_EOBIE_Msk (0x1UL << USART_CR1_EOBIE_Pos)
#define USART_CR1_EOBIE USART_CR1_EOBIE_Msk
#define USART_CR1_M1_Pos (28U)
#define USART_CR1_M1_Msk (0x1UL << USART_CR1_M1_Pos)
#define USART_CR1_M1 USART_CR1_M1_Msk
#define USART_CR1_FIFOEN_Pos (29U)
#define USART_CR1_FIFOEN_Msk (0x1UL << USART_CR1_FIFOEN_Pos)
#define USART_CR1_FIFOEN USART_CR1_FIFOEN_Msk
#define USART_CR1_TXFEIE_Pos (30U)
#define USART_CR1_TXFEIE_Msk (0x1UL << USART_CR1_TXFEIE_Pos)
#define USART_CR1_TXFEIE USART_CR1_TXFEIE_Msk
#define USART_CR1_RXFFIE_Pos (31U)
#define USART_CR1_RXFFIE_Msk (0x1UL << USART_CR1_RXFFIE_Pos)
#define USART_CR1_RXFFIE USART_CR1_RXFFIE_Msk

/******************  Bit definition for USART_CR2 register  *******************/
#define USART_CR2_SLVEN_Pos (0U)
#define USART_CR2_SLVEN_Msk (0x1UL << USART_CR2_SLVEN_Pos)
#define USART_CR2_SLVEN USART_CR2_SLVEN_Msk
#define USART_CR2_DIS_NSS_Pos (3U)
#define USART_CR2_DIS_NSS_Msk (0x1UL << USART_CR2_DIS_NSS_Pos)
#define USART_CR2_DIS_NSS USART_CR2_DIS_NSS_Msk
#define USART_CR2_ADDM7_Pos (4U)
#define USART_CR2_ADDM7_Msk (0x1UL << USART_CR2_ADDM7_Pos)
#define USART_CR2_ADDM7 USART_CR2_ADDM7_Msk
#define USART_CR2_LBDL_Pos (5U)
#define USART_CR2_LBDL_Msk (0x1UL << USART_CR2_LBDL_Pos)
#define USART_CR2_LBDL USART_CR2_LBDL_Msk
#define USART_CR2_LBDIE_Pos (6U)
#define USART_CR2_LBDIE_Msk (0x1UL << USART_CR2_LBDIE_Pos)
#define USART_CR2_LBDIE USART_CR2_LBDIE_Msk
#define USART_CR2_LBCL_Pos (8U)
#define USART_CR2_LBCL_Msk (0x1UL << USART_CR2_LBCL_Pos)
#define USART_CR2_LBCL USART_CR2_LBCL_Msk
#define USART_CR2_CPHA_Pos (9U)
#define USART_CR2_CPHA_Msk (0x1UL << USART_CR2_CPHA_Pos)
#define USART_CR2_CPHA USART_CR2_CPHA_Msk
#define USART_CR2_CPOL_Pos (10U)
#define USART_CR2_CPOL_Msk (0x1UL << USART_CR2_CPOL_Pos)
#define USART_CR2_CPOL USART_CR2_CPOL_Msk
#define USART_CR2_CLKEN_Pos (11U)
#define USART_CR2_CLKEN_Msk (0x1UL << USART_CR2_CLKEN_Pos)
#define USART_CR2_CLKEN USART_CR2_CLKEN_Msk
#define USART_CR2_STOP_Pos (12U)
#define USART_CR2_STOP_Msk (0x3UL << USART_CR2_STOP_Pos)
#define USART_CR2_STOP USART_CR2_STOP_Msk
#define USART_CR2_STOP_0 (0x1UL << USART_CR2_STOP_Pos)
#define USART_CR2_STOP_1 (0x2UL << USART_CR2_STOP_Pos)
#define USART_CR2_LINEN_Pos (14U)
#define USART_CR2_LINEN_Msk (0x1UL << USART_CR2_LINEN_Pos)
#define USART_CR2_LINEN USART_CR2_LINEN_Msk
#define USART_CR2_SWAP_Pos (15U)
#define USART_CR2_SWAP_Msk (0x1UL << USART_CR2_SWAP_Pos)
#define USART_CR2_SWAP USART_CR2_SWAP_Msk
#define USART_CR2_RXINV_Pos (16U)
#define USART_CR2_RXINV_Msk (0x1UL << USART_CR2_RXINV_Pos)
#define USART_CR2_RXINV USART_CR2_RXINV_Msk
#define USART_CR2_TXINV_Pos (17U)
#define USART_CR2_TXINV_Msk (0x1UL << USART_CR2_TXINV_Pos)
#define USART_CR2_TXINV USART_CR2_TXINV_Msk
#define USART_CR2_DATAINV_Pos (18U)
#define USART_CR2_DATAINV_Msk (0x1UL << USART_CR2_DATAINV_Pos)
#define USART_CR2_DATAINV USART_CR2_DATAINV_Msk
#define USART_CR2_MSBFIRST_Pos (19U)
#define USART_CR2_MSBFIRST_Msk (0x1UL << USART_CR2_MSBFIRST_Pos)
#define USART_CR2_MSBFIRST USART_CR2_MSBFIRST_Msk
#define USART_CR2_ABREN_Pos (20U)
#define USART_CR2_ABREN_Msk (0x1UL << USART_CR2_ABREN_Pos)
#define USART_CR2_ABREN USART_CR2_ABREN_Msk
#define USART_CR2_ABRMODE_Pos (21U)
#define USART_CR2_ABRMODE_Msk (0x3UL << USART_CR2_ABRMODE_Pos)
#define USART_CR2_ABRMODE USART_CR2_ABRMODE_Msk
#define USART_CR2_ABRMODE_0 (0x1UL << USART_CR2_ABRMODE_Pos)
#define USART_CR2_ABRMODE_1 (0x2UL << USART_CR2_ABRMODE_Pos)
#define USART_CR2_RTOEN_Pos (23U)
#define USART_CR2_RTOEN_Msk (0x1UL << USART_CR2_RTOEN_Pos)
#define USART_CR2_RTOEN USART_CR2_RTOEN_Msk
#define USART_CR2_ADD_Pos (24U)
#define USART_CR2_ADD_Msk (0xFFUL << USART_CR2_ADD_Pos)
#define USART_CR2_ADD USART_CR2_ADD_Msk

/******************  Bit definition for USART_CR3 register  *******************/
#define USART_CR3_EIE_Pos (0U)
#define USART_CR3_EIE_Msk (0x1UL << USART_CR3_EIE_Pos)
#define USART_CR3_EIE USART_CR3_EIE_Msk
#define USART_CR3_IREN_Pos (1U)
#define USART_CR3_IREN_Msk (0x1UL << USART_CR3_IREN_Pos)
#define USART_CR3_IREN USART_CR3_IREN_Msk
#define USART_CR3_IRLP_Pos (2U)
#define USART_CR3_IRLP_Msk (0x1UL << USART_CR3_IRLP_Pos)
#define USART_CR3_IRLP USART_CR3_IRLP_Msk
#define USART_CR3_HDSEL_Pos (3U)
#define USART_CR3_HDSEL_Msk (0x1UL << USART_CR3_HDSEL_Pos)
#define USART_CR3_HDSEL USART_CR3_HDSEL_Msk
#define USART_CR3_NACK_Pos (4U)
#define USART_CR3_NACK_Msk (0x1UL << USART_CR3_NACK_Pos)
#define USART_CR3_NACK USART_CR3_NACK_Msk
#define USART_CR3_SCEN_Pos (5U)
#define USART_CR3_SCEN_Msk (0x1UL << USART_CR3_SCEN_Pos)
#define USART_CR3_SCEN USART_CR3_SCEN_Msk
#define USART_CR3_DMAR_Pos (6U)
#define USART_CR3_DMAR_Msk (0x1UL << USART_CR3_DMAR_Pos)
#define USART_CR3_DMAR USART_CR3_DMAR_Msk
#define USART_CR3_DMAT_Pos (7U)
#define USART_CR3_DMAT_Msk (0x1UL << USART_CR3_DMAT_Pos)
#define USART_CR3_DMAT USART_CR3_DMAT_Msk
#define USART_CR3_RTSE_Pos (8U)
#define USART_CR3_RTSE_Msk (0x1UL << USART_CR3_RTSE_Pos)
#define USART_CR3_RTSE USART_CR3_RTSE_Msk
#define USART_CR3_CTSE_Pos (9U)
#define USART_CR3_CTSE_Msk (0x1UL << USART_CR3_CTSE_Pos)
#define USART_CR3_CTSE USART_CR3_CTSE_Msk
#define USART_CR3_CTSIE_Pos (10U)
#define USART_CR3_CTSIE_Msk (0x1UL << USART_CR3_CTSIE_Pos)
#define USART_CR3_CTSIE USART_CR3_CTSIE_Msk
#define USART_CR3_ONEBIT_Pos (11U)
#define USART_CR3_ONEBIT_Msk (0x1UL << USART_CR3_ONEBIT_Pos)
#define USART_CR3_ONEBIT USART_CR3_ONEBIT_Msk
#define USART_CR3_OVRDIS_Pos (12U)
#define USART_CR3_OVRDIS_Msk (0x1UL << USART_CR3_OVRDIS_Pos)
#define USART_CR3_OVRDIS USART_CR3_OVRDIS_Msk
#define USART_CR3_DDRE_Pos (13U)
#define USART_CR3_DDRE_Msk (0x1UL << USART_CR3_DDRE_Pos)
#define USART_CR3_DDRE USART_CR3_DDRE_Msk
#define USART_CR3_DEM_Pos (14U)
#define USART_CR3_DEM_Msk (0x1UL << USART_CR3_DEM_Pos)
#define USART_CR3_DEM USART_CR3_DEM_Msk
#define USART_CR3_DEP_Pos (15U)
#define USART_CR3_DEP_Msk (0x1UL << USART_CR3_DEP_Pos)
#define USART_CR3_DEP USART_CR3_DEP_Msk
#define USART_CR3_SCARCNT_Pos (17U)
#define USART_CR3_SCARCNT_Msk (0x7UL << USART_CR3_SCARCNT_Pos)
#define USART_CR3_SCARCNT USART_CR3_SCARCNT_Msk
#define USART_CR3_SCARCNT_0 (0x1UL << USART_CR3_SCARCNT_Pos)
#define USART_CR3_SCARCNT_1 (0x2UL << USART_CR3_SCARCNT_Pos)
#define USART_CR3_SCARCNT_2 (0x4UL << USART_CR3_SCARCNT_Pos)
#define USART_CR3_WUS_Pos (20U)
#define USART_CR3_WUS_Msk (0x3UL << USART_CR3_WUS_Pos)
#define USART_CR3_WUS USART_CR3_WUS_Msk
#define USART_CR3_WUS_0 (0x1UL << USART_CR3_WUS_Pos)
#define USART_CR3_WUS_1 (0x2UL << USART_CR3_WUS_Pos)
#define USART_CR3_WUFIE_Pos (22U)
#define USART_CR3_WUFIE_Msk (0x1UL << USART_CR3_WUFIE_Pos)
#define USART_CR3_WUFIE USART_CR3_WUFIE_Msk
#define USART_CR3_TXFTIE_Pos (23U)
#define USART_CR3_TXFTIE_Msk (0x1UL << USART_CR3_TXFTIE_Pos)
#define USART_CR3_TXFTIE USART_CR3_TXFTIE_Msk
#define USART_CR3_TCBGTIE_Pos (24U)
#define USART_CR3_TCBGTIE_Msk (0x1UL << USART_CR3_TCBGTIE_Pos)
#define USART_CR3_TCBGTIE USART_CR3_TCBGTIE_Msk
#define USART_CR3_RXFTCFG_Pos (25U)
#define USART_CR3_RXFTCFG_Msk (0x7UL << USART_CR3_RXFTCFG_Pos)
#define USART_CR3_RXFTCFG USART_CR3_RXFTCFG_Msk
#define USART_CR3_RXFTCFG_0 (0x1UL << USART_CR3_RXFTCFG_Pos)
#define USART_CR3_RXFTCFG_1 (0x2UL << USART_CR3_RXFTCFG_Pos)
#define USART_CR3_RXFTCFG_2 (0x4UL << USART_CR3_RXFTCFG_Pos)
#define USART_CR3_RXFTIE_Pos (28U)
#define USART_CR3_RXFTIE_Msk (0x1UL << USART_CR3_RXFTIE_Pos)
#define USART_CR3_RXFTIE USART_CR3_RXFTIE_Msk
#define USART_CR3_TXFTCFG_Pos (29U)
#define USART_CR3_TXFTCFG_Msk (0x7UL << USART_CR3_TXFTCFG_Pos)
#define USART_CR3_TXFTCFG USART_CR3_TXFTCFG_Msk
#define USART_CR3_TXFTCFG_0 (0x1UL << USART_CR3_TXFTCFG_Pos)
#define USART_CR3_TXFTCFG_1 (0x2UL << USART_CR3_TXFTCFG_Pos)
#define USART_CR3_TXFTCFG_2 (0x4UL << USART_CR3_TXFTCFG_Pos)

/******************  Bit definition for USART_BRR register  *******************/
#define USART_BRR_LPUART_Pos (0U)
#define USART_BRR_LPUART_Msk (0xFFFFFUL << USART_BRR_LPUART_Pos)
#define USART_BRR_LPUART USART_BRR_LPUART_Msk
#define USART_BRR_BRR_Pos (0U)
#define USART_BRR_BRR_Msk (0xFFFFUL << USART_BRR_BRR_Pos)
#define USART_BRR_BRR USART_BRR_BRR_Msk

/******************  Bit definition for USART_GTPR register  ******************/
#define USART_GTPR_PSC_Pos (0U)
#define USART_GTPR_PSC_Msk (0xFFUL << USART_GTPR_PSC_Pos)
#define USART_GTPR_PSC USART_GTPR_PSC_Msk
#define USART_GTPR_GT_Pos (8U)
#define USART_GTPR_GT_Msk (0xFFUL << USART_GTPR_GT_Pos)
#define USART_GTPR_GT USART_GTPR_GT_Msk

/*******************  Bit definition for USART_RTOR register  *****************/
#define USART_RTOR_RTO_Pos (0U)
#define USART_RTOR_RTO_Msk (0xFFFFFFUL << USART_RTOR_RTO_Pos)
#define USART_RTOR_RTO USART_RTOR_RTO_Msk
#define USART_RTOR_BLEN_Pos (24U)
#define USART_RTOR_BLEN_Msk (0xFFUL << USART_RTOR_BLEN_Pos)
#define USART_RTOR_BLEN USART_RTOR_BLEN_Msk

/*******************  Bit definition for USART_RQR register  ******************/
#define USART_RQR_ABRRQ_Pos (0U)
#define USART_RQR_ABRRQ_Msk (0x1UL << USART_RQR_ABRRQ_Pos)
#define USART_RQR_ABRRQ USART_RQR_ABRRQ_Msk
#define USART_RQR_SBKRQ_Pos (1U)
#define USART_RQR_SBKRQ_Msk (0x1UL << USART_RQR_SBKRQ_Pos)
#define USART_RQR_SBKRQ USART_RQR_SBKRQ_Msk
#define USART_RQR_MMRQ_Pos (2U)
#define USART_RQR_MMRQ_Msk (0x1UL << USART_RQR_MMRQ_Pos)
#define USART_RQR_MMRQ USART_RQR_MMRQ_Msk
#define USART_RQR_RXFRQ_Pos (3U)
#define USART_RQR_RXFRQ_Msk (0x1UL << USART_RQR_RXFRQ_Pos)
#define USART_RQR_RXFRQ USART_RQR_RXFRQ_Msk
#define USART_RQR_TXFRQ_Pos (4U)
#define USART_RQR_TXFRQ_Msk (0x1UL << USART_RQR_TXFRQ_Pos)
#define USART_RQR_TXFRQ USART_RQR_TXFRQ_Msk

/*******************  Bit definition for USART_ISR register  ******************/
#define USART_ISR_PE_Pos (0U)
#define USART_ISR_PE_Msk (0x1UL << USART_ISR_PE_Pos)
#define USART_ISR_PE USART_ISR_PE_Msk
#define USART_ISR_FE_Pos (1U)
#define USART_ISR_FE_Msk (0x1UL << USART_ISR_FE_Pos)
#define USART_ISR_FE USART_ISR_FE_Msk
#define USART_ISR_NE_Pos (2U)
#define USART_ISR_NE_Msk (0x1UL << USART_ISR_NE_Pos)
#define USART_ISR_NE USART_ISR_NE_Msk
#define USART_ISR_ORE_Pos (3U)
#define USART_ISR_ORE_Msk (0x1UL << USART_ISR_ORE_Pos)
#define USART_ISR_ORE USART_ISR_ORE_Msk
#define USART_ISR_IDLE_Pos (4U)
#define USART_ISR_IDLE_Msk (0x1UL << USART_ISR_IDLE_Pos)
#define USART_ISR_IDLE USART_ISR_IDLE_Msk
#define USART_ISR_RXNE_Pos (5U)
#define USART_ISR_RXNE_Msk (0x1UL << USART_ISR_RXNE_Pos)
#define USART_ISR_RXNE USART_ISR_RXNE_Msk
#define USART_ISR_RXNE_RXFNE_Pos USART_ISR_RXNE_Pos
#define USART_ISR_RXNE_RXFNE_Msk USART_ISR_RXNE_Msk
#define USART_ISR_RXNE_RXFNE USART_ISR_RXNE_Msk
#define USART_ISR_TC_Pos (6U)
#define USART_ISR_TC_Msk (0x1UL << USART_ISR_TC_Pos)
#define USART_ISR_TC USART_ISR_TC_Msk
#define USART_ISR_TXE_Pos (7U)
#define USART_ISR_TXE_Msk (0x1UL << USART_ISR_TXE_Pos)
#define USART_ISR_TXE USART_ISR_TXE_Msk
#define USART_ISR_TXE_TXFNF_Pos USART_ISR_TXE_Pos
#define USART_ISR_TXE_TXFNF_Msk USART_ISR_TXE_Msk
#define USART_ISR_TXE_TXFNF USART_ISR_TXE_Msk
#define USART_ISR_LBDF_Pos (8U)
#define USART_ISR_LBDF_Msk (0x1UL << USART_ISR_LBDF_Pos)
#define USART_ISR_LBDF USART_ISR_LBDF_Msk
#define USART_ISR_CTSIF_Pos (9U)
#define USART_ISR_CTSIF_Msk (0x1UL << USART_ISR_CTSIF_Pos)
#define USART_ISR_CTSIF USART_ISR_CTSIF_Msk
#define USART_ISR_CTS_Pos (10U)
#define USART_ISR_CTS_Msk (0x1UL << USART_ISR_CTS_Pos)
#define USART_ISR_CTS USART_ISR_CTS_Msk
#define USART_ISR_RTOF_Pos (11U)
#define USART_ISR_RTOF_Msk (0x1UL << USART_ISR_RTOF_Pos)
#define USART_ISR_RTOF USART_ISR_RTOF_Msk
#define USART_ISR_EOBF_Pos (12U)
#define USART_ISR_EOBF_Msk (0x1UL << USART_ISR_EOBF_Pos)
#define USART_ISR_EOBF USART_ISR_EOBF_Msk
#define USART_ISR_UDR_Pos (13U)
#define USART_ISR_UDR_Msk (0x1UL << USART_ISR_UDR_Pos)
#define USART_ISR_UDR USART_ISR_UDR_Msk
#define USART_ISR_ABRE_Pos (14U)
#define USART_ISR_ABRE_Msk (0x1UL << USART_ISR_ABRE_Pos)
#define USART_ISR_ABRE USART_ISR_ABRE_Msk
#define USART_ISR_ABRF_Pos (15U)
#define USART_ISR_ABRF_Msk (0x1UL << USART_ISR_ABRF_Pos)
#define USART_ISR_ABRF USART_ISR_ABRF_Msk
#define USART_ISR_BUSY_Pos (16U)
#define USART_ISR_BUSY_Msk (0x1UL << USART_ISR_BUSY_Pos)
#define USART_ISR_BUSY USART_ISR_BUSY_Msk
#define USART_ISR_CMF_Pos (17U)
#define USART_ISR_CMF_Msk (0x1UL << USART_ISR_CMF_Pos)
#define USART_ISR_CMF USART_ISR_CMF_Msk
#define USART_ISR_SBKF_Pos (18U)
#define USART_ISR_SBKF_Msk (0x1UL << USART_ISR_SBKF_Pos)
#define USART_ISR_SBKF USART_ISR_SBKF_Msk
#define USART_ISR_RWU_Pos (19U)
#define USART_ISR_RWU_Msk (0x1UL << USART_ISR_RWU_Pos)
#define USART_ISR_RWU USART_ISR_RWU_Msk
#define USART_ISR_WUF_Pos (20U)
#define USART_ISR_WUF_Msk (0x1UL << USART_ISR_WUF_Pos)
#define USART_ISR_WUF USART_ISR_WUF_Msk
#define USART_ISR_TEACK_Pos (21U)
#define USART_ISR_TEACK_Msk (0x1UL << USART_ISR_TEACK_Pos)
#define USART_ISR_TEACK USART_ISR_TEACK_Msk
#define USART_ISR_REACK_Pos (22U)
#define USART_ISR_REACK_Msk (0x1UL << USART_ISR_REACK_Pos)
#define USART_ISR_REACK USART_ISR_REACK_Msk
#define USART_ISR_TXFE_Pos (23U)
#define USART_ISR_TXFE_Msk (0x1UL << USART_ISR_TXFE_Pos)
#define USART_ISR_TXFE USART_ISR_TXFE_Msk
#define USART_ISR_RXFF_Pos (24U)
#define USART_ISR_RXFF_Msk (0x1UL << USART_ISR_RXFF_Pos)
#define USART_ISR_RXFF USART_ISR_RXFF_Msk
#define USART_ISR_TCBGT_Pos (25U)
#define USART_ISR_TCBGT_Msk (0x1UL << USART_ISR_TCBGT_Pos)
#define USART_ISR_TCBGT USART_ISR_TCBGT_Msk
#define USART_ISR_RXFT_Pos (26U)
#define USART_ISR_RXFT_Msk (0x1UL << USART_ISR_RXFT_Pos)
#define USART_ISR_RXFT USART_ISR_RXFT_Msk
#define USART_ISR_TXFT_Pos (27U)
#define USART_ISR_TXFT_Msk (0x1UL << USART_ISR_TXFT_Pos)
#define USART_ISR_TXFT USART_ISR_TXFT_Msk

/*******************  Bit definition for USART_ICR register  ******************/
#define USART_ICR_PECF_Pos (0U)
#define USART_ICR_PECF_Msk (0x1UL << USART_ICR_PECF_Pos)
#define USART_ICR_PECF USART_ICR_PECF_Msk
#define USART_ICR_FECF_Pos (1U)
#define USART_ICR_FECF_Msk (0x1UL << USART_ICR_FECF_Pos)
#define USART_ICR_FECF USART_ICR_FECF_Msk
#define USART_ICR_NECF_Pos (2U)
#define USART_ICR_NECF_Msk (0x1UL << USART_ICR_NECF_Pos)
#define USART_ICR_NECF USART_ICR_NECF_Msk
#define USART_ICR_ORECF_Pos (3U)
#define USART_ICR_ORECF_Msk (0x1UL << USART_ICR_ORECF_Pos)
#define USART_ICR_ORECF USART_ICR_ORECF_Msk
#define USART_ICR_IDLECF_Pos (4U)
#define USART_ICR_IDLECF_Msk (0x1UL << USART_ICR_IDLECF_Pos)
#define USART_ICR_IDLECF USART_ICR_IDLECF_Msk
#define USART_ICR_TXFECF_Pos (5U)
#define USART_ICR_TXFECF_Msk (0x1UL << USART_ICR_TXFECF_Pos)
#define USART_ICR_TXFECF USART_ICR_TXFECF_Msk
#define USART_ICR_TCCF_Pos (6U)
#define USART_ICR_TCCF_Msk (0x1UL << USART_ICR_TCCF_Pos)
#define USART_ICR_TCCF USART_ICR_TCCF_Msk
#define USART_ICR_TCBGTCF_Pos (7U)
#define USART_ICR_TCBGTCF_Msk (0x1UL << USART_ICR_TCBGTCF_Pos)
#define USART_ICR_TCBGTCF USART_ICR_TCBGTCF_Msk
#define USART_ICR_LBDCF_Pos (8U)
#define USART_ICR_LBDCF_Msk (0x1UL << USART_ICR_LBDCF_Pos)
#define USART_ICR_LBDCF USART_ICR_LBDCF_Msk
#define USART_ICR_CTSCF_Pos (9U)
#define USART_ICR_CTSCF_Msk (0x1UL << USART_ICR_CTSCF_Pos)
#define USART_ICR_CTSCF USART_ICR_CTSCF_Msk
#define USART_ICR_RTOCF_Pos (11U)
#define USART_ICR_RTOCF_Msk (0x1UL << USART_ICR_RTOCF_Pos)
#define USART_ICR_RTOCF USART_ICR_RTOCF_Msk
#define USART_ICR_EOBCF_Pos (12U)
#define USART_ICR_EOBCF_Msk (0x1UL << USART_ICR_EOBCF_Pos)
#define USART_ICR_EOBCF USART_ICR_EOBCF_Msk
#define USART_ICR_UDRCF_Pos (13U)
#define USART_ICR_UDRCF_Msk (0x1UL << USART_ICR_UDRCF_Pos)
#define USART_ICR_UDRCF USART_ICR_UDRCF_Msk
#define USART_ICR_CMCF_Pos (17U)
#define USART_ICR_CMCF_Msk (0x1UL << USART_ICR_CMCF_Pos)
#define USART_ICR_CMCF USART_ICR_CMCF_Msk
#define USART_ICR_WUCF_Pos (20U)
#define USART_ICR_WUCF_Msk (0x1UL << USART_ICR_WUCF_Pos)
#define USART_ICR_WUCF USART_ICR_WUCF_Msk

/*******************  Bit definition for USART_RDR register  ******************/
#define USART_RDR_RDR_Pos (0U)
#define USART_RDR_RDR_Msk (0x1FFUL << USART_RDR_RDR_Pos)
#define USART_RDR_RDR USART_RDR_RDR_Msk

/*******************  Bit definition for USART_TDR register  ******************/
#define USART_TDR_TDR_Pos (0U)
#define USART_TDR_TDR_Msk (0x1FFUL << USART_TDR_TDR_Pos)
#define USART_TDR_TDR USART_TDR_TDR_Msk

/*******************  Bit definition for USART_PRESC register  ****************/
#define USART_PRESC_PRESCALER_Pos (0U)
#define USART_PRESC_PRESCALER_Msk (0xFUL << USART_PRESC_PRESCALER_Pos)
#define USART_PRESC_PRESCALER USART_PRESC_PRESCALER_Msk
#define USART_PRESC_PRESCALER_0 (0x1UL << USART_PRESC_PRESCALER_Pos)
#define USART_PRESC_PRESCALER_1 (0x2UL << USART_PRESC_PRESCALER_Pos)
#define USART_PRESC_PRESCALER_2 (0x4UL << USART_PRESC_PRESCALER_Pos)
#define USART_PRESC_PRESCALER_3 (0x8UL << USART_PRESC_PRESCALER_Pos)

/******************************************************************************/
/*                                                                            */
/*                                 VREFBUF                                    */
/*                                                                            */
/******************************************************************************/
/*******************  Bit definition for VREFBUF_CSR register  ****************/
#define VREFBUF_CSR_ENVR_Pos (0U)
#define VREFBUF_CSR_ENVR_Msk (0x1UL << VREFBUF_CSR_ENVR_Pos)
#define VREFBUF_CSR_ENVR VREFBUF_CSR_ENVR_Msk
#define VREFBUF_CSR_HIZ_Pos (1U)
#define VREFBUF_CSR_HIZ_Msk (0x1UL << VREFBUF_CSR_HIZ_Pos)
#define VREFBUF_CSR_HIZ VREFBUF_CSR_HIZ_Msk
#define VREFBUF_CSR_VRR_Pos (3U)
#define VREFBUF_CSR_VRR_Msk (0x1UL << VREFBUF_CSR_VRR_Pos)
#define VREFBUF_CSR_VRR VREFBUF_CSR_VRR_Msk
#define VREFBUF_CSR_VRS_Pos (4U)
#define VREFBUF_CSR_VRS_Msk (0x3UL << VREFBUF_CSR_VRS_Pos)
#define VREFBUF_CSR_VRS VREFBUF_CSR_VRS_Msk
#define VREFBUF_CSR_VRS_0 (0x1UL << VREFBUF_CSR_VRS_Pos)
#define VREFBUF_CSR_VRS_1 (0x2UL << VREFBUF_CSR_VRS_Pos)

/*******************  Bit definition for VREFBUF_CCR register  ******************/
#define VREFBUF_CCR_TRIM_Pos (0U)
#define VREFBUF_CCR_TRIM_Msk (0x3FUL << VREFBUF_CCR_TRIM_Pos)
#define VREFBUF_CCR_TRIM VREFBUF_CCR_TRIM_Msk

/******************************************************************************/
/*                                                                            */
/*                         USB Device FS Endpoint registers                   */
/*                                                                            */
/******************************************************************************/
#define USB_EP0R USB_BASE
#define USB_EP1R (USB_BASE + 0x0x00000004)
#define USB_EP2R (USB_BASE + 0x0x00000008)
#define USB_EP3R (USB_BASE + 0x0x0000000C)
#define USB_EP4R (USB_BASE + 0x0x00000010)
#define USB_EP5R (USB_BASE + 0x0x00000014)
#define USB_EP6R (USB_BASE + 0x0x00000018)
#define USB_EP7R (USB_BASE + 0x0x0000001C)

/* bit positions */
#define USB_EP_CTR_RX ((uint16_t)0x8000U)
#define USB_EP_DTOG_RX ((uint16_t)0x4000U)
#define USB_EPRX_STAT ((uint16_t)0x3000U)
#define USB_EP_SETUP ((uint16_t)0x0800U)
#define USB_EP_T_FIELD ((uint16_t)0x0600U)
#define USB_EP_KIND ((uint16_t)0x0100U)
#define USB_EP_CTR_TX ((uint16_t)0x0080U)
#define USB_EP_DTOG_TX ((uint16_t)0x0040U)
#define USB_EPTX_STAT ((uint16_t)0x0030U)
#define USB_EPADDR_FIELD ((uint16_t)0x000FU)

/* EndPoint REGister MASK (no toggle fields) */
#define USB_EPREG_MASK (USB_EP_CTR_RX|USB_EP_SETUP|USB_EP_T_FIELD|USB_EP_KIND|USB_EP_CTR_TX|USB_EPADDR_FIELD)
                                                                         /*!< EP_TYPE[1:0] EndPoint TYPE */
#define USB_EP_TYPE_MASK ((uint16_t)0x0600U)
#define USB_EP_BULK ((uint16_t)0x0000U)
#define USB_EP_CONTROL ((uint16_t)0x0200U)
#define USB_EP_ISOCHRONOUS ((uint16_t)0x0400U)
#define USB_EP_INTERRUPT ((uint16_t)0x0600U)
#define USB_EP_T_MASK ((uint16_t) ~USB_EP_T_FIELD & USB_EPREG_MASK)

#define USB_EPKIND_MASK ((uint16_t)~USB_EP_KIND & USB_EPREG_MASK)
                                                                         /*!< STAT_TX[1:0] STATus for TX transfer */
#define USB_EP_TX_DIS ((uint16_t)0x0000U)
#define USB_EP_TX_STALL ((uint16_t)0x0010U)
#define USB_EP_TX_NAK ((uint16_t)0x0020U)
#define USB_EP_TX_VALID ((uint16_t)0x0030U)
#define USB_EPTX_DTOG1 ((uint16_t)0x0010U)
#define USB_EPTX_DTOG2 ((uint16_t)0x0020U)
#define USB_EPTX_DTOGMASK (USB_EPTX_STAT|USB_EPREG_MASK)
                                                                         /*!< STAT_RX[1:0] STATus for RX transfer */
#define USB_EP_RX_DIS ((uint16_t)0x0000U)
#define USB_EP_RX_STALL ((uint16_t)0x1000U)
#define USB_EP_RX_NAK ((uint16_t)0x2000U)
#define USB_EP_RX_VALID ((uint16_t)0x3000U)
#define USB_EPRX_DTOG1 ((uint16_t)0x1000U)
#define USB_EPRX_DTOG2 ((uint16_t)0x2000U)
#define USB_EPRX_DTOGMASK (USB_EPRX_STAT|USB_EPREG_MASK)

/******************************************************************************/
/*                                                                            */
/*                         USB Device FS General registers                    */
/*                                                                            */
/******************************************************************************/
#define USB_CNTR (USB_BASE + 0x00000040U)
#define USB_ISTR (USB_BASE + 0x00000044U)
#define USB_FNR (USB_BASE + 0x00000048U)
#define USB_DADDR (USB_BASE + 0x0000004CU)
#define USB_BTABLE (USB_BASE + 0x00000050U)
#define USB_LPMCSR (USB_BASE + 0x00000054U)
#define USB_BCDR (USB_BASE + 0x00000058U)

/******************  Bits definition for USB_CNTR register  *******************/
#define USB_CNTR_CTRM ((uint16_t)0x8000U)
#define USB_CNTR_PMAOVRM ((uint16_t)0x4000U)
#define USB_CNTR_ERRM ((uint16_t)0x2000U)
#define USB_CNTR_WKUPM ((uint16_t)0x1000U)
#define USB_CNTR_SUSPM ((uint16_t)0x0800U)
#define USB_CNTR_RESETM ((uint16_t)0x0400U)
#define USB_CNTR_SOFM ((uint16_t)0x0200U)
#define USB_CNTR_ESOFM ((uint16_t)0x0100U)
#define USB_CNTR_L1REQM ((uint16_t)0x0080U)
#define USB_CNTR_L1RESUME ((uint16_t)0x0020U)
#define USB_CNTR_RESUME ((uint16_t)0x0010U)
#define USB_CNTR_FSUSP ((uint16_t)0x0008U)
#define USB_CNTR_LPMODE ((uint16_t)0x0004U)
#define USB_CNTR_PDWN ((uint16_t)0x0002U)
#define USB_CNTR_FRES ((uint16_t)0x0001U)

/******************  Bits definition for USB_ISTR register  *******************/
#define USB_ISTR_EP_ID ((uint16_t)0x000FU)
#define USB_ISTR_DIR ((uint16_t)0x0010U)
#define USB_ISTR_L1REQ ((uint16_t)0x0080U)
#define USB_ISTR_ESOF ((uint16_t)0x0100U)
#define USB_ISTR_SOF ((uint16_t)0x0200U)
#define USB_ISTR_RESET ((uint16_t)0x0400U)
#define USB_ISTR_SUSP ((uint16_t)0x0800U)
#define USB_ISTR_WKUP ((uint16_t)0x1000U)
#define USB_ISTR_ERR ((uint16_t)0x2000U)
#define USB_ISTR_PMAOVR ((uint16_t)0x4000U)
#define USB_ISTR_CTR ((uint16_t)0x8000U)

#define USB_CLR_L1REQ (~USB_ISTR_L1REQ)
#define USB_CLR_ESOF (~USB_ISTR_ESOF)
#define USB_CLR_SOF (~USB_ISTR_SOF)
#define USB_CLR_RESET (~USB_ISTR_RESET)
#define USB_CLR_SUSP (~USB_ISTR_SUSP)
#define USB_CLR_WKUP (~USB_ISTR_WKUP)
#define USB_CLR_ERR (~USB_ISTR_ERR)
#define USB_CLR_PMAOVR (~USB_ISTR_PMAOVR)
#define USB_CLR_CTR (~USB_ISTR_CTR)

/******************  Bits definition for USB_FNR register  ********************/
#define USB_FNR_FN ((uint16_t)0x07FFU)
#define USB_FNR_LSOF ((uint16_t)0x1800U)
#define USB_FNR_LCK ((uint16_t)0x2000U)
#define USB_FNR_RXDM ((uint16_t)0x4000U)
#define USB_FNR_RXDP ((uint16_t)0x8000U)

/******************  Bits definition for USB_DADDR register    ****************/
#define USB_DADDR_ADD ((uint8_t)0x7FU)
#define USB_DADDR_ADD0 ((uint8_t)0x01U)
#define USB_DADDR_ADD1 ((uint8_t)0x02U)
#define USB_DADDR_ADD2 ((uint8_t)0x04U)
#define USB_DADDR_ADD3 ((uint8_t)0x08U)
#define USB_DADDR_ADD4 ((uint8_t)0x10U)
#define USB_DADDR_ADD5 ((uint8_t)0x20U)
#define USB_DADDR_ADD6 ((uint8_t)0x40U)

#define USB_DADDR_EF ((uint8_t)0x80U)

/******************  Bit definition for USB_BTABLE register  ******************/
#define USB_BTABLE_BTABLE ((uint16_t)0xFFF8U)

/******************  Bits definition for USB_BCDR register  *******************/
#define USB_BCDR_BCDEN ((uint16_t)0x0001U)
#define USB_BCDR_DCDEN ((uint16_t)0x0002U)
#define USB_BCDR_PDEN ((uint16_t)0x0004U)
#define USB_BCDR_SDEN ((uint16_t)0x0008U)
#define USB_BCDR_DCDET ((uint16_t)0x0010U)
#define USB_BCDR_PDET ((uint16_t)0x0020U)
#define USB_BCDR_SDET ((uint16_t)0x0040U)
#define USB_BCDR_PS2DET ((uint16_t)0x0080U)
#define USB_BCDR_DPPU ((uint16_t)0x8000U)

/*******************  Bit definition for LPMCSR register  *********************/
#define USB_LPMCSR_LMPEN ((uint16_t)0x0001U)
#define USB_LPMCSR_LPMACK ((uint16_t)0x0002U)
#define USB_LPMCSR_REMWAKE ((uint16_t)0x0008U)
#define USB_LPMCSR_BESL ((uint16_t)0x00F0U)

/*!< Buffer descriptor table */
/*****************  Bit definition for USB_ADDR0_TX register  *****************/
#define USB_ADDR0_TX_ADDR0_TX_Pos (1U)
#define USB_ADDR0_TX_ADDR0_TX_Msk (0x7FFFUL << USB_ADDR0_TX_ADDR0_TX_Pos)
#define USB_ADDR0_TX_ADDR0_TX USB_ADDR0_TX_ADDR0_TX_Msk

/*****************  Bit definition for USB_ADDR1_TX register  *****************/
#define USB_ADDR1_TX_ADDR1_TX_Pos (1U)
#define USB_ADDR1_TX_ADDR1_TX_Msk (0x7FFFUL << USB_ADDR1_TX_ADDR1_TX_Pos)
#define USB_ADDR1_TX_ADDR1_TX USB_ADDR1_TX_ADDR1_TX_Msk

/*****************  Bit definition for USB_ADDR2_TX register  *****************/
#define USB_ADDR2_TX_ADDR2_TX_Pos (1U)
#define USB_ADDR2_TX_ADDR2_TX_Msk (0x7FFFUL << USB_ADDR2_TX_ADDR2_TX_Pos)
#define USB_ADDR2_TX_ADDR2_TX USB_ADDR2_TX_ADDR2_TX_Msk

/*****************  Bit definition for USB_ADDR3_TX register  *****************/
#define USB_ADDR3_TX_ADDR3_TX_Pos (1U)
#define USB_ADDR3_TX_ADDR3_TX_Msk (0x7FFFUL << USB_ADDR3_TX_ADDR3_TX_Pos)
#define USB_ADDR3_TX_ADDR3_TX USB_ADDR3_TX_ADDR3_TX_Msk

/*****************  Bit definition for USB_ADDR4_TX register  *****************/
#define USB_ADDR4_TX_ADDR4_TX_Pos (1U)
#define USB_ADDR4_TX_ADDR4_TX_Msk (0x7FFFUL << USB_ADDR4_TX_ADDR4_TX_Pos)
#define USB_ADDR4_TX_ADDR4_TX USB_ADDR4_TX_ADDR4_TX_Msk

/*****************  Bit definition for USB_ADDR5_TX register  *****************/
#define USB_ADDR5_TX_ADDR5_TX_Pos (1U)
#define USB_ADDR5_TX_ADDR5_TX_Msk (0x7FFFUL << USB_ADDR5_TX_ADDR5_TX_Pos)
#define USB_ADDR5_TX_ADDR5_TX USB_ADDR5_TX_ADDR5_TX_Msk

/*****************  Bit definition for USB_ADDR6_TX register  *****************/
#define USB_ADDR6_TX_ADDR6_TX_Pos (1U)
#define USB_ADDR6_TX_ADDR6_TX_Msk (0x7FFFUL << USB_ADDR6_TX_ADDR6_TX_Pos)
#define USB_ADDR6_TX_ADDR6_TX USB_ADDR6_TX_ADDR6_TX_Msk

/*****************  Bit definition for USB_ADDR7_TX register  *****************/
#define USB_ADDR7_TX_ADDR7_TX_Pos (1U)
#define USB_ADDR7_TX_ADDR7_TX_Msk (0x7FFFUL << USB_ADDR7_TX_ADDR7_TX_Pos)
#define USB_ADDR7_TX_ADDR7_TX USB_ADDR7_TX_ADDR7_TX_Msk

/*----------------------------------------------------------------------------*/

/*****************  Bit definition for USB_COUNT0_TX register  ****************/
#define USB_COUNT0_TX_COUNT0_TX_Pos (0U)
#define USB_COUNT0_TX_COUNT0_TX_Msk (0x3FFUL << USB_COUNT0_TX_COUNT0_TX_Pos)
#define USB_COUNT0_TX_COUNT0_TX USB_COUNT0_TX_COUNT0_TX_Msk

/*****************  Bit definition for USB_COUNT1_TX register  ****************/
#define USB_COUNT1_TX_COUNT1_TX_Pos (0U)
#define USB_COUNT1_TX_COUNT1_TX_Msk (0x3FFUL << USB_COUNT1_TX_COUNT1_TX_Pos)
#define USB_COUNT1_TX_COUNT1_TX USB_COUNT1_TX_COUNT1_TX_Msk

/*****************  Bit definition for USB_COUNT2_TX register  ****************/
#define USB_COUNT2_TX_COUNT2_TX_Pos (0U)
#define USB_COUNT2_TX_COUNT2_TX_Msk (0x3FFUL << USB_COUNT2_TX_COUNT2_TX_Pos)
#define USB_COUNT2_TX_COUNT2_TX USB_COUNT2_TX_COUNT2_TX_Msk

/*****************  Bit definition for USB_COUNT3_TX register  ****************/
#define USB_COUNT3_TX_COUNT3_TX_Pos (0U)
#define USB_COUNT3_TX_COUNT3_TX_Msk (0x3FFUL << USB_COUNT3_TX_COUNT3_TX_Pos)
#define USB_COUNT3_TX_COUNT3_TX USB_COUNT3_TX_COUNT3_TX_Msk

/*****************  Bit definition for USB_COUNT4_TX register  ****************/
#define USB_COUNT4_TX_COUNT4_TX_Pos (0U)
#define USB_COUNT4_TX_COUNT4_TX_Msk (0x3FFUL << USB_COUNT4_TX_COUNT4_TX_Pos)
#define USB_COUNT4_TX_COUNT4_TX USB_COUNT4_TX_COUNT4_TX_Msk

/*****************  Bit definition for USB_COUNT5_TX register  ****************/
#define USB_COUNT5_TX_COUNT5_TX_Pos (0U)
#define USB_COUNT5_TX_COUNT5_TX_Msk (0x3FFUL << USB_COUNT5_TX_COUNT5_TX_Pos)
#define USB_COUNT5_TX_COUNT5_TX USB_COUNT5_TX_COUNT5_TX_Msk

/*****************  Bit definition for USB_COUNT6_TX register  ****************/
#define USB_COUNT6_TX_COUNT6_TX_Pos (0U)
#define USB_COUNT6_TX_COUNT6_TX_Msk (0x3FFUL << USB_COUNT6_TX_COUNT6_TX_Pos)
#define USB_COUNT6_TX_COUNT6_TX USB_COUNT6_TX_COUNT6_TX_Msk

/*****************  Bit definition for USB_COUNT7_TX register  ****************/
#define USB_COUNT7_TX_COUNT7_TX_Pos (0U)
#define USB_COUNT7_TX_COUNT7_TX_Msk (0x3FFUL << USB_COUNT7_TX_COUNT7_TX_Pos)
#define USB_COUNT7_TX_COUNT7_TX USB_COUNT7_TX_COUNT7_TX_Msk

/*----------------------------------------------------------------------------*/

/****************  Bit definition for USB_COUNT0_TX_0 register  ***************/
#define USB_COUNT0_TX_0_COUNT0_TX_0 (0x000003FFU)

/****************  Bit definition for USB_COUNT0_TX_1 register  ***************/
#define USB_COUNT0_TX_1_COUNT0_TX_1 (0x03FF0000U)

/****************  Bit definition for USB_COUNT1_TX_0 register  ***************/
#define USB_COUNT1_TX_0_COUNT1_TX_0 (0x000003FFU)

/****************  Bit definition for USB_COUNT1_TX_1 register  ***************/
#define USB_COUNT1_TX_1_COUNT1_TX_1 (0x03FF0000U)

/****************  Bit definition for USB_COUNT2_TX_0 register  ***************/
#define USB_COUNT2_TX_0_COUNT2_TX_0 (0x000003FFU)

/****************  Bit definition for USB_COUNT2_TX_1 register  ***************/
#define USB_COUNT2_TX_1_COUNT2_TX_1 (0x03FF0000U)

/****************  Bit definition for USB_COUNT3_TX_0 register  ***************/
#define USB_COUNT3_TX_0_COUNT3_TX_0 (0x000003FFU)

/****************  Bit definition for USB_COUNT3_TX_1 register  ***************/
#define USB_COUNT3_TX_1_COUNT3_TX_1 (0x03FF0000U)

/****************  Bit definition for USB_COUNT4_TX_0 register  ***************/
#define USB_COUNT4_TX_0_COUNT4_TX_0 (0x000003FFU)

/****************  Bit definition for USB_COUNT4_TX_1 register  ***************/
#define USB_COUNT4_TX_1_COUNT4_TX_1 (0x03FF0000U)

/****************  Bit definition for USB_COUNT5_TX_0 register  ***************/
#define USB_COUNT5_TX_0_COUNT5_TX_0 (0x000003FFU)

/****************  Bit definition for USB_COUNT5_TX_1 register  ***************/
#define USB_COUNT5_TX_1_COUNT5_TX_1 (0x03FF0000U)

/****************  Bit definition for USB_COUNT6_TX_0 register  ***************/
#define USB_COUNT6_TX_0_COUNT6_TX_0 (0x000003FFU)

/****************  Bit definition for USB_COUNT6_TX_1 register  ***************/
#define USB_COUNT6_TX_1_COUNT6_TX_1 (0x03FF0000U)

/****************  Bit definition for USB_COUNT7_TX_0 register  ***************/
#define USB_COUNT7_TX_0_COUNT7_TX_0 (0x000003FFU)

/****************  Bit definition for USB_COUNT7_TX_1 register  ***************/
#define USB_COUNT7_TX_1_COUNT7_TX_1 (0x03FF0000U)

/*----------------------------------------------------------------------------*/

/*****************  Bit definition for USB_ADDR0_RX register  *****************/
#define USB_ADDR0_RX_ADDR0_RX_Pos (1U)
#define USB_ADDR0_RX_ADDR0_RX_Msk (0x7FFFUL << USB_ADDR0_RX_ADDR0_RX_Pos)
#define USB_ADDR0_RX_ADDR0_RX USB_ADDR0_RX_ADDR0_RX_Msk

/*****************  Bit definition for USB_ADDR1_RX register  *****************/
#define USB_ADDR1_RX_ADDR1_RX_Pos (1U)
#define USB_ADDR1_RX_ADDR1_RX_Msk (0x7FFFUL << USB_ADDR1_RX_ADDR1_RX_Pos)
#define USB_ADDR1_RX_ADDR1_RX USB_ADDR1_RX_ADDR1_RX_Msk

/*****************  Bit definition for USB_ADDR2_RX register  *****************/
#define USB_ADDR2_RX_ADDR2_RX_Pos (1U)
#define USB_ADDR2_RX_ADDR2_RX_Msk (0x7FFFUL << USB_ADDR2_RX_ADDR2_RX_Pos)
#define USB_ADDR2_RX_ADDR2_RX USB_ADDR2_RX_ADDR2_RX_Msk

/*****************  Bit definition for USB_ADDR3_RX register  *****************/
#define USB_ADDR3_RX_ADDR3_RX_Pos (1U)
#define USB_ADDR3_RX_ADDR3_RX_Msk (0x7FFFUL << USB_ADDR3_RX_ADDR3_RX_Pos)
#define USB_ADDR3_RX_ADDR3_RX USB_ADDR3_RX_ADDR3_RX_Msk

/*****************  Bit definition for USB_ADDR4_RX register  *****************/
#define USB_ADDR4_RX_ADDR4_RX_Pos (1U)
#define USB_ADDR4_RX_ADDR4_RX_Msk (0x7FFFUL << USB_ADDR4_RX_ADDR4_RX_Pos)
#define USB_ADDR4_RX_ADDR4_RX USB_ADDR4_RX_ADDR4_RX_Msk

/*****************  Bit definition for USB_ADDR5_RX register  *****************/
#define USB_ADDR5_RX_ADDR5_RX_Pos (1U)
#define USB_ADDR5_RX_ADDR5_RX_Msk (0x7FFFUL << USB_ADDR5_RX_ADDR5_RX_Pos)
#define USB_ADDR5_RX_ADDR5_RX USB_ADDR5_RX_ADDR5_RX_Msk

/*****************  Bit definition for USB_ADDR6_RX register  *****************/
#define USB_ADDR6_RX_ADDR6_RX_Pos (1U)
#define USB_ADDR6_RX_ADDR6_RX_Msk (0x7FFFUL << USB_ADDR6_RX_ADDR6_RX_Pos)
#define USB_ADDR6_RX_ADDR6_RX USB_ADDR6_RX_ADDR6_RX_Msk

/*****************  Bit definition for USB_ADDR7_RX register  *****************/
#define USB_ADDR7_RX_ADDR7_RX_Pos (1U)
#define USB_ADDR7_RX_ADDR7_RX_Msk (0x7FFFUL << USB_ADDR7_RX_ADDR7_RX_Pos)
#define USB_ADDR7_RX_ADDR7_RX USB_ADDR7_RX_ADDR7_RX_Msk

/*----------------------------------------------------------------------------*/

/*****************  Bit definition for USB_COUNT0_RX register  ****************/
#define USB_COUNT0_RX_COUNT0_RX_Pos (0U)
#define USB_COUNT0_RX_COUNT0_RX_Msk (0x3FFUL << USB_COUNT0_RX_COUNT0_RX_Pos)
#define USB_COUNT0_RX_COUNT0_RX USB_COUNT0_RX_COUNT0_RX_Msk

#define USB_COUNT0_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT0_RX_NUM_BLOCK_Msk (0x1FUL << USB_COUNT0_RX_NUM_BLOCK_Pos)
#define USB_COUNT0_RX_NUM_BLOCK USB_COUNT0_RX_NUM_BLOCK_Msk
#define USB_COUNT0_RX_NUM_BLOCK_0 (0x01UL << USB_COUNT0_RX_NUM_BLOCK_Pos)
#define USB_COUNT0_RX_NUM_BLOCK_1 (0x02UL << USB_COUNT0_RX_NUM_BLOCK_Pos)
#define USB_COUNT0_RX_NUM_BLOCK_2 (0x04UL << USB_COUNT0_RX_NUM_BLOCK_Pos)
#define USB_COUNT0_RX_NUM_BLOCK_3 (0x08UL << USB_COUNT0_RX_NUM_BLOCK_Pos)
#define USB_COUNT0_RX_NUM_BLOCK_4 (0x10UL << USB_COUNT0_RX_NUM_BLOCK_Pos)

#define USB_COUNT0_RX_BLSIZE_Pos (15U)
#define USB_COUNT0_RX_BLSIZE_Msk (0x1UL << USB_COUNT0_RX_BLSIZE_Pos)
#define USB_COUNT0_RX_BLSIZE USB_COUNT0_RX_BLSIZE_Msk

/*****************  Bit definition for USB_COUNT1_RX register  ****************/
#define USB_COUNT1_RX_COUNT1_RX_Pos (0U)
#define USB_COUNT1_RX_COUNT1_RX_Msk (0x3FFUL << USB_COUNT1_RX_COUNT1_RX_Pos)
#define USB_COUNT1_RX_COUNT1_RX USB_COUNT1_RX_COUNT1_RX_Msk

#define USB_COUNT1_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT1_RX_NUM_BLOCK_Msk (0x1FUL << USB_COUNT1_RX_NUM_BLOCK_Pos)
#define USB_COUNT1_RX_NUM_BLOCK USB_COUNT1_RX_NUM_BLOCK_Msk
#define USB_COUNT1_RX_NUM_BLOCK_0 (0x01UL << USB_COUNT1_RX_NUM_BLOCK_Pos)
#define USB_COUNT1_RX_NUM_BLOCK_1 (0x02UL << USB_COUNT1_RX_NUM_BLOCK_Pos)
#define USB_COUNT1_RX_NUM_BLOCK_2 (0x04UL << USB_COUNT1_RX_NUM_BLOCK_Pos)
#define USB_COUNT1_RX_NUM_BLOCK_3 (0x08UL << USB_COUNT1_RX_NUM_BLOCK_Pos)
#define USB_COUNT1_RX_NUM_BLOCK_4 (0x10UL << USB_COUNT1_RX_NUM_BLOCK_Pos)

#define USB_COUNT1_RX_BLSIZE_Pos (15U)
#define USB_COUNT1_RX_BLSIZE_Msk (0x1UL << USB_COUNT1_RX_BLSIZE_Pos)
#define USB_COUNT1_RX_BLSIZE USB_COUNT1_RX_BLSIZE_Msk

/*****************  Bit definition for USB_COUNT2_RX register  ****************/
#define USB_COUNT2_RX_COUNT2_RX_Pos (0U)
#define USB_COUNT2_RX_COUNT2_RX_Msk (0x3FFUL << USB_COUNT2_RX_COUNT2_RX_Pos)
#define USB_COUNT2_RX_COUNT2_RX USB_COUNT2_RX_COUNT2_RX_Msk

#define USB_COUNT2_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT2_RX_NUM_BLOCK_Msk (0x1FUL << USB_COUNT2_RX_NUM_BLOCK_Pos)
#define USB_COUNT2_RX_NUM_BLOCK USB_COUNT2_RX_NUM_BLOCK_Msk
#define USB_COUNT2_RX_NUM_BLOCK_0 (0x01UL << USB_COUNT2_RX_NUM_BLOCK_Pos)
#define USB_COUNT2_RX_NUM_BLOCK_1 (0x02UL << USB_COUNT2_RX_NUM_BLOCK_Pos)
#define USB_COUNT2_RX_NUM_BLOCK_2 (0x04UL << USB_COUNT2_RX_NUM_BLOCK_Pos)
#define USB_COUNT2_RX_NUM_BLOCK_3 (0x08UL << USB_COUNT2_RX_NUM_BLOCK_Pos)
#define USB_COUNT2_RX_NUM_BLOCK_4 (0x10UL << USB_COUNT2_RX_NUM_BLOCK_Pos)

#define USB_COUNT2_RX_BLSIZE_Pos (15U)
#define USB_COUNT2_RX_BLSIZE_Msk (0x1UL << USB_COUNT2_RX_BLSIZE_Pos)
#define USB_COUNT2_RX_BLSIZE USB_COUNT2_RX_BLSIZE_Msk

/*****************  Bit definition for USB_COUNT3_RX register  ****************/
#define USB_COUNT3_RX_COUNT3_RX_Pos (0U)
#define USB_COUNT3_RX_COUNT3_RX_Msk (0x3FFUL << USB_COUNT3_RX_COUNT3_RX_Pos)
#define USB_COUNT3_RX_COUNT3_RX USB_COUNT3_RX_COUNT3_RX_Msk

#define USB_COUNT3_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT3_RX_NUM_BLOCK_Msk (0x1FUL << USB_COUNT3_RX_NUM_BLOCK_Pos)
#define USB_COUNT3_RX_NUM_BLOCK USB_COUNT3_RX_NUM_BLOCK_Msk
#define USB_COUNT3_RX_NUM_BLOCK_0 (0x01UL << USB_COUNT3_RX_NUM_BLOCK_Pos)
#define USB_COUNT3_RX_NUM_BLOCK_1 (0x02UL << USB_COUNT3_RX_NUM_BLOCK_Pos)
#define USB_COUNT3_RX_NUM_BLOCK_2 (0x04UL << USB_COUNT3_RX_NUM_BLOCK_Pos)
#define USB_COUNT3_RX_NUM_BLOCK_3 (0x08UL << USB_COUNT3_RX_NUM_BLOCK_Pos)
#define USB_COUNT3_RX_NUM_BLOCK_4 (0x10UL << USB_COUNT3_RX_NUM_BLOCK_Pos)

#define USB_COUNT3_RX_BLSIZE_Pos (15U)
#define USB_COUNT3_RX_BLSIZE_Msk (0x1UL << USB_COUNT3_RX_BLSIZE_Pos)
#define USB_COUNT3_RX_BLSIZE USB_COUNT3_RX_BLSIZE_Msk

/*****************  Bit definition for USB_COUNT4_RX register  ****************/
#define USB_COUNT4_RX_COUNT4_RX_Pos (0U)
#define USB_COUNT4_RX_COUNT4_RX_Msk (0x3FFUL << USB_COUNT4_RX_COUNT4_RX_Pos)
#define USB_COUNT4_RX_COUNT4_RX USB_COUNT4_RX_COUNT4_RX_Msk

#define USB_COUNT4_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT4_RX_NUM_BLOCK_Msk (0x1FUL << USB_COUNT4_RX_NUM_BLOCK_Pos)
#define USB_COUNT4_RX_NUM_BLOCK USB_COUNT4_RX_NUM_BLOCK_Msk
#define USB_COUNT4_RX_NUM_BLOCK_0 (0x01UL << USB_COUNT4_RX_NUM_BLOCK_Pos)
#define USB_COUNT4_RX_NUM_BLOCK_1 (0x02UL << USB_COUNT4_RX_NUM_BLOCK_Pos)
#define USB_COUNT4_RX_NUM_BLOCK_2 (0x04UL << USB_COUNT4_RX_NUM_BLOCK_Pos)
#define USB_COUNT4_RX_NUM_BLOCK_3 (0x08UL << USB_COUNT4_RX_NUM_BLOCK_Pos)
#define USB_COUNT4_RX_NUM_BLOCK_4 (0x10UL << USB_COUNT4_RX_NUM_BLOCK_Pos)

#define USB_COUNT4_RX_BLSIZE_Pos (15U)
#define USB_COUNT4_RX_BLSIZE_Msk (0x1UL << USB_COUNT4_RX_BLSIZE_Pos)
#define USB_COUNT4_RX_BLSIZE USB_COUNT4_RX_BLSIZE_Msk

/*****************  Bit definition for USB_COUNT5_RX register  ****************/
#define USB_COUNT5_RX_COUNT5_RX_Pos (0U)
#define USB_COUNT5_RX_COUNT5_RX_Msk (0x3FFUL << USB_COUNT5_RX_COUNT5_RX_Pos)
#define USB_COUNT5_RX_COUNT5_RX USB_COUNT5_RX_COUNT5_RX_Msk

#define USB_COUNT5_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT5_RX_NUM_BLOCK_Msk (0x1FUL << USB_COUNT5_RX_NUM_BLOCK_Pos)
#define USB_COUNT5_RX_NUM_BLOCK USB_COUNT5_RX_NUM_BLOCK_Msk
#define USB_COUNT5_RX_NUM_BLOCK_0 (0x01UL << USB_COUNT5_RX_NUM_BLOCK_Pos)
#define USB_COUNT5_RX_NUM_BLOCK_1 (0x02UL << USB_COUNT5_RX_NUM_BLOCK_Pos)
#define USB_COUNT5_RX_NUM_BLOCK_2 (0x04UL << USB_COUNT5_RX_NUM_BLOCK_Pos)
#define USB_COUNT5_RX_NUM_BLOCK_3 (0x08UL << USB_COUNT5_RX_NUM_BLOCK_Pos)
#define USB_COUNT5_RX_NUM_BLOCK_4 (0x10UL << USB_COUNT5_RX_NUM_BLOCK_Pos)

#define USB_COUNT5_RX_BLSIZE_Pos (15U)
#define USB_COUNT5_RX_BLSIZE_Msk (0x1UL << USB_COUNT5_RX_BLSIZE_Pos)
#define USB_COUNT5_RX_BLSIZE USB_COUNT5_RX_BLSIZE_Msk

/*****************  Bit definition for USB_COUNT6_RX register  ****************/
#define USB_COUNT6_RX_COUNT6_RX_Pos (0U)
#define USB_COUNT6_RX_COUNT6_RX_Msk (0x3FFUL << USB_COUNT6_RX_COUNT6_RX_Pos)
#define USB_COUNT6_RX_COUNT6_RX USB_COUNT6_RX_COUNT6_RX_Msk

#define USB_COUNT6_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT6_RX_NUM_BLOCK_Msk (0x1FUL << USB_COUNT6_RX_NUM_BLOCK_Pos)
#define USB_COUNT6_RX_NUM_BLOCK USB_COUNT6_RX_NUM_BLOCK_Msk
#define USB_COUNT6_RX_NUM_BLOCK_0 (0x01UL << USB_COUNT6_RX_NUM_BLOCK_Pos)
#define USB_COUNT6_RX_NUM_BLOCK_1 (0x02UL << USB_COUNT6_RX_NUM_BLOCK_Pos)
#define USB_COUNT6_RX_NUM_BLOCK_2 (0x04UL << USB_COUNT6_RX_NUM_BLOCK_Pos)
#define USB_COUNT6_RX_NUM_BLOCK_3 (0x08UL << USB_COUNT6_RX_NUM_BLOCK_Pos)
#define USB_COUNT6_RX_NUM_BLOCK_4 (0x10UL << USB_COUNT6_RX_NUM_BLOCK_Pos)

#define USB_COUNT6_RX_BLSIZE_Pos (15U)
#define USB_COUNT6_RX_BLSIZE_Msk (0x1UL << USB_COUNT6_RX_BLSIZE_Pos)
#define USB_COUNT6_RX_BLSIZE USB_COUNT6_RX_BLSIZE_Msk

/*****************  Bit definition for USB_COUNT7_RX register  ****************/
#define USB_COUNT7_RX_COUNT7_RX_Pos (0U)
#define USB_COUNT7_RX_COUNT7_RX_Msk (0x3FFUL << USB_COUNT7_RX_COUNT7_RX_Pos)
#define USB_COUNT7_RX_COUNT7_RX USB_COUNT7_RX_COUNT7_RX_Msk

#define USB_COUNT7_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT7_RX_NUM_BLOCK_Msk (0x1FUL << USB_COUNT7_RX_NUM_BLOCK_Pos)
#define USB_COUNT7_RX_NUM_BLOCK USB_COUNT7_RX_NUM_BLOCK_Msk
#define USB_COUNT7_RX_NUM_BLOCK_0 (0x01UL << USB_COUNT7_RX_NUM_BLOCK_Pos)
#define USB_COUNT7_RX_NUM_BLOCK_1 (0x02UL << USB_COUNT7_RX_NUM_BLOCK_Pos)
#define USB_COUNT7_RX_NUM_BLOCK_2 (0x04UL << USB_COUNT7_RX_NUM_BLOCK_Pos)
#define USB_COUNT7_RX_NUM_BLOCK_3 (0x08UL << USB_COUNT7_RX_NUM_BLOCK_Pos)
#define USB_COUNT7_RX_NUM_BLOCK_4 (0x10UL << USB_COUNT7_RX_NUM_BLOCK_Pos)

#define USB_COUNT7_RX_BLSIZE_Pos (15U)
#define USB_COUNT7_RX_BLSIZE_Msk (0x1UL << USB_COUNT7_RX_BLSIZE_Pos)
#define USB_COUNT7_RX_BLSIZE USB_COUNT7_RX_BLSIZE_Msk

/*----------------------------------------------------------------------------*/

/****************  Bit definition for USB_COUNT0_RX_0 register  ***************/
#define USB_COUNT0_RX_0_COUNT0_RX_0 (0x000003FFU)

#define USB_COUNT0_RX_0_NUM_BLOCK_0 (0x00007C00U)
#define USB_COUNT0_RX_0_NUM_BLOCK_0_0 (0x00000400U)
#define USB_COUNT0_RX_0_NUM_BLOCK_0_1 (0x00000800U)
#define USB_COUNT0_RX_0_NUM_BLOCK_0_2 (0x00001000U)
#define USB_COUNT0_RX_0_NUM_BLOCK_0_3 (0x00002000U)
#define USB_COUNT0_RX_0_NUM_BLOCK_0_4 (0x00004000U)

#define USB_COUNT0_RX_0_BLSIZE_0 (0x00008000U)

/****************  Bit definition for USB_COUNT0_RX_1 register  ***************/
#define USB_COUNT0_RX_1_COUNT0_RX_1 (0x03FF0000U)

#define USB_COUNT0_RX_1_NUM_BLOCK_1 (0x7C000000U)
#define USB_COUNT0_RX_1_NUM_BLOCK_1_0 (0x04000000U)
#define USB_COUNT0_RX_1_NUM_BLOCK_1_1 (0x08000000U)
#define USB_COUNT0_RX_1_NUM_BLOCK_1_2 (0x10000000U)
#define USB_COUNT0_RX_1_NUM_BLOCK_1_3 (0x20000000U)
#define USB_COUNT0_RX_1_NUM_BLOCK_1_4 (0x40000000U)

#define USB_COUNT0_RX_1_BLSIZE_1 (0x80000000U)

/****************  Bit definition for USB_COUNT1_RX_0 register  ***************/
#define USB_COUNT1_RX_0_COUNT1_RX_0 (0x000003FFU)

#define USB_COUNT1_RX_0_NUM_BLOCK_0 (0x00007C00U)
#define USB_COUNT1_RX_0_NUM_BLOCK_0_0 (0x00000400U)
#define USB_COUNT1_RX_0_NUM_BLOCK_0_1 (0x00000800U)
#define USB_COUNT1_RX_0_NUM_BLOCK_0_2 (0x00001000U)
#define USB_COUNT1_RX_0_NUM_BLOCK_0_3 (0x00002000U)
#define USB_COUNT1_RX_0_NUM_BLOCK_0_4 (0x00004000U)

#define USB_COUNT1_RX_0_BLSIZE_0 (0x00008000U)

/****************  Bit definition for USB_COUNT1_RX_1 register  ***************/
#define USB_COUNT1_RX_1_COUNT1_RX_1 (0x03FF0000U)

#define USB_COUNT1_RX_1_NUM_BLOCK_1 (0x7C000000U)
#define USB_COUNT1_RX_1_NUM_BLOCK_1_0 (0x04000000U)
#define USB_COUNT1_RX_1_NUM_BLOCK_1_1 (0x08000000U)
#define USB_COUNT1_RX_1_NUM_BLOCK_1_2 (0x10000000U)
#define USB_COUNT1_RX_1_NUM_BLOCK_1_3 (0x20000000U)
#define USB_COUNT1_RX_1_NUM_BLOCK_1_4 (0x40000000U)

#define USB_COUNT1_RX_1_BLSIZE_1 (0x80000000U)

/****************  Bit definition for USB_COUNT2_RX_0 register  ***************/
#define USB_COUNT2_RX_0_COUNT2_RX_0 (0x000003FFU)

#define USB_COUNT2_RX_0_NUM_BLOCK_0 (0x00007C00U)
#define USB_COUNT2_RX_0_NUM_BLOCK_0_0 (0x00000400U)
#define USB_COUNT2_RX_0_NUM_BLOCK_0_1 (0x00000800U)
#define USB_COUNT2_RX_0_NUM_BLOCK_0_2 (0x00001000U)
#define USB_COUNT2_RX_0_NUM_BLOCK_0_3 (0x00002000U)
#define USB_COUNT2_RX_0_NUM_BLOCK_0_4 (0x00004000U)

#define USB_COUNT2_RX_0_BLSIZE_0 (0x00008000U)

/****************  Bit definition for USB_COUNT2_RX_1 register  ***************/
#define USB_COUNT2_RX_1_COUNT2_RX_1 (0x03FF0000U)

#define USB_COUNT2_RX_1_NUM_BLOCK_1 (0x7C000000U)
#define USB_COUNT2_RX_1_NUM_BLOCK_1_0 (0x04000000U)
#define USB_COUNT2_RX_1_NUM_BLOCK_1_1 (0x08000000U)
#define USB_COUNT2_RX_1_NUM_BLOCK_1_2 (0x10000000U)
#define USB_COUNT2_RX_1_NUM_BLOCK_1_3 (0x20000000U)
#define USB_COUNT2_RX_1_NUM_BLOCK_1_4 (0x40000000U)

#define USB_COUNT2_RX_1_BLSIZE_1 (0x80000000U)

/****************  Bit definition for USB_COUNT3_RX_0 register  ***************/
#define USB_COUNT3_RX_0_COUNT3_RX_0 (0x000003FFU)

#define USB_COUNT3_RX_0_NUM_BLOCK_0 (0x00007C00U)
#define USB_COUNT3_RX_0_NUM_BLOCK_0_0 (0x00000400U)
#define USB_COUNT3_RX_0_NUM_BLOCK_0_1 (0x00000800U)
#define USB_COUNT3_RX_0_NUM_BLOCK_0_2 (0x00001000U)
#define USB_COUNT3_RX_0_NUM_BLOCK_0_3 (0x00002000U)
#define USB_COUNT3_RX_0_NUM_BLOCK_0_4 (0x00004000U)

#define USB_COUNT3_RX_0_BLSIZE_0 (0x00008000U)

/****************  Bit definition for USB_COUNT3_RX_1 register  ***************/
#define USB_COUNT3_RX_1_COUNT3_RX_1 (0x03FF0000U)

#define USB_COUNT3_RX_1_NUM_BLOCK_1 (0x7C000000U)
#define USB_COUNT3_RX_1_NUM_BLOCK_1_0 (0x04000000U)
#define USB_COUNT3_RX_1_NUM_BLOCK_1_1 (0x08000000U)
#define USB_COUNT3_RX_1_NUM_BLOCK_1_2 (0x10000000U)
#define USB_COUNT3_RX_1_NUM_BLOCK_1_3 (0x20000000U)
#define USB_COUNT3_RX_1_NUM_BLOCK_1_4 (0x40000000U)

#define USB_COUNT3_RX_1_BLSIZE_1 (0x80000000U)

/****************  Bit definition for USB_COUNT4_RX_0 register  ***************/
#define USB_COUNT4_RX_0_COUNT4_RX_0 (0x000003FFU)

#define USB_COUNT4_RX_0_NUM_BLOCK_0 (0x00007C00U)
#define USB_COUNT4_RX_0_NUM_BLOCK_0_0 (0x00000400U)
#define USB_COUNT4_RX_0_NUM_BLOCK_0_1 (0x00000800U)
#define USB_COUNT4_RX_0_NUM_BLOCK_0_2 (0x00001000U)
#define USB_COUNT4_RX_0_NUM_BLOCK_0_3 (0x00002000U)
#define USB_COUNT4_RX_0_NUM_BLOCK_0_4 (0x00004000U)

#define USB_COUNT4_RX_0_BLSIZE_0 (0x00008000U)

/****************  Bit definition for USB_COUNT4_RX_1 register  ***************/
#define USB_COUNT4_RX_1_COUNT4_RX_1 (0x03FF0000U)

#define USB_COUNT4_RX_1_NUM_BLOCK_1 (0x7C000000U)
#define USB_COUNT4_RX_1_NUM_BLOCK_1_0 (0x04000000U)
#define USB_COUNT4_RX_1_NUM_BLOCK_1_1 (0x08000000U)
#define USB_COUNT4_RX_1_NUM_BLOCK_1_2 (0x10000000U)
#define USB_COUNT4_RX_1_NUM_BLOCK_1_3 (0x20000000U)
#define USB_COUNT4_RX_1_NUM_BLOCK_1_4 (0x40000000U)

#define USB_COUNT4_RX_1_BLSIZE_1 (0x80000000U)

/****************  Bit definition for USB_COUNT5_RX_0 register  ***************/
#define USB_COUNT5_RX_0_COUNT5_RX_0 (0x000003FFU)

#define USB_COUNT5_RX_0_NUM_BLOCK_0 (0x00007C00U)
#define USB_COUNT5_RX_0_NUM_BLOCK_0_0 (0x00000400U)
#define USB_COUNT5_RX_0_NUM_BLOCK_0_1 (0x00000800U)
#define USB_COUNT5_RX_0_NUM_BLOCK_0_2 (0x00001000U)
#define USB_COUNT5_RX_0_NUM_BLOCK_0_3 (0x00002000U)
#define USB_COUNT5_RX_0_NUM_BLOCK_0_4 (0x00004000U)

#define USB_COUNT5_RX_0_BLSIZE_0 (0x00008000U)

/****************  Bit definition for USB_COUNT5_RX_1 register  ***************/
#define USB_COUNT5_RX_1_COUNT5_RX_1 (0x03FF0000U)

#define USB_COUNT5_RX_1_NUM_BLOCK_1 (0x7C000000U)
#define USB_COUNT5_RX_1_NUM_BLOCK_1_0 (0x04000000U)
#define USB_COUNT5_RX_1_NUM_BLOCK_1_1 (0x08000000U)
#define USB_COUNT5_RX_1_NUM_BLOCK_1_2 (0x10000000U)
#define USB_COUNT5_RX_1_NUM_BLOCK_1_3 (0x20000000U)
#define USB_COUNT5_RX_1_NUM_BLOCK_1_4 (0x40000000U)

#define USB_COUNT5_RX_1_BLSIZE_1 (0x80000000U)

/***************  Bit definition for USB_COUNT6_RX_0  register  ***************/
#define USB_COUNT6_RX_0_COUNT6_RX_0 (0x000003FFU)

#define USB_COUNT6_RX_0_NUM_BLOCK_0 (0x00007C00U)
#define USB_COUNT6_RX_0_NUM_BLOCK_0_0 (0x00000400U)
#define USB_COUNT6_RX_0_NUM_BLOCK_0_1 (0x00000800U)
#define USB_COUNT6_RX_0_NUM_BLOCK_0_2 (0x00001000U)
#define USB_COUNT6_RX_0_NUM_BLOCK_0_3 (0x00002000U)
#define USB_COUNT6_RX_0_NUM_BLOCK_0_4 (0x00004000U)

#define USB_COUNT6_RX_0_BLSIZE_0 (0x00008000U)

/****************  Bit definition for USB_COUNT6_RX_1 register  ***************/
#define USB_COUNT6_RX_1_COUNT6_RX_1 (0x03FF0000U)

#define USB_COUNT6_RX_1_NUM_BLOCK_1 (0x7C000000U)
#define USB_COUNT6_RX_1_NUM_BLOCK_1_0 (0x04000000U)
#define USB_COUNT6_RX_1_NUM_BLOCK_1_1 (0x08000000U)
#define USB_COUNT6_RX_1_NUM_BLOCK_1_2 (0x10000000U)
#define USB_COUNT6_RX_1_NUM_BLOCK_1_3 (0x20000000U)
#define USB_COUNT6_RX_1_NUM_BLOCK_1_4 (0x40000000U)

#define USB_COUNT6_RX_1_BLSIZE_1 (0x80000000U)

/***************  Bit definition for USB_COUNT7_RX_0 register  ****************/
#define USB_COUNT7_RX_0_COUNT7_RX_0 (0x000003FFU)

#define USB_COUNT7_RX_0_NUM_BLOCK_0 (0x00007C00U)
#define USB_COUNT7_RX_0_NUM_BLOCK_0_0 (0x00000400U)
#define USB_COUNT7_RX_0_NUM_BLOCK_0_1 (0x00000800U)
#define USB_COUNT7_RX_0_NUM_BLOCK_0_2 (0x00001000U)
#define USB_COUNT7_RX_0_NUM_BLOCK_0_3 (0x00002000U)
#define USB_COUNT7_RX_0_NUM_BLOCK_0_4 (0x00004000U)

#define USB_COUNT7_RX_0_BLSIZE_0 (0x00008000U)

/***************  Bit definition for USB_COUNT7_RX_1 register  ****************/
#define USB_COUNT7_RX_1_COUNT7_RX_1 (0x03FF0000U)

#define USB_COUNT7_RX_1_NUM_BLOCK_1 (0x7C000000U)
#define USB_COUNT7_RX_1_NUM_BLOCK_1_0 (0x04000000U)
#define USB_COUNT7_RX_1_NUM_BLOCK_1_1 (0x08000000U)
#define USB_COUNT7_RX_1_NUM_BLOCK_1_2 (0x10000000U)
#define USB_COUNT7_RX_1_NUM_BLOCK_1_3 (0x20000000U)
#define USB_COUNT7_RX_1_NUM_BLOCK_1_4 (0x40000000U)

#define USB_COUNT7_RX_1_BLSIZE_1 (0x80000000U)

/******************************************************************************/
/*                                                                            */
/*                                    UCPD                                    */
/*                                                                            */
/******************************************************************************/
/********************  Bits definition for UCPD_CFG1 register  *******************/
#define UCPD_CFG1_HBITCLKDIV_Pos (0U)
#define UCPD_CFG1_HBITCLKDIV_Msk (0x3FUL << UCPD_CFG1_HBITCLKDIV_Pos)
#define UCPD_CFG1_HBITCLKDIV UCPD_CFG1_HBITCLKDIV_Msk
#define UCPD_CFG1_HBITCLKDIV_0 (0x01UL << UCPD_CFG1_HBITCLKDIV_Pos)
#define UCPD_CFG1_HBITCLKDIV_1 (0x02UL << UCPD_CFG1_HBITCLKDIV_Pos)
#define UCPD_CFG1_HBITCLKDIV_2 (0x04UL << UCPD_CFG1_HBITCLKDIV_Pos)
#define UCPD_CFG1_HBITCLKDIV_3 (0x08UL << UCPD_CFG1_HBITCLKDIV_Pos)
#define UCPD_CFG1_HBITCLKDIV_4 (0x10UL << UCPD_CFG1_HBITCLKDIV_Pos)
#define UCPD_CFG1_HBITCLKDIV_5 (0x20UL << UCPD_CFG1_HBITCLKDIV_Pos)
#define UCPD_CFG1_IFRGAP_Pos (6U)
#define UCPD_CFG1_IFRGAP_Msk (0x1FUL << UCPD_CFG1_IFRGAP_Pos)
#define UCPD_CFG1_IFRGAP UCPD_CFG1_IFRGAP_Msk
#define UCPD_CFG1_IFRGAP_0 (0x01UL << UCPD_CFG1_IFRGAP_Pos)
#define UCPD_CFG1_IFRGAP_1 (0x02UL << UCPD_CFG1_IFRGAP_Pos)
#define UCPD_CFG1_IFRGAP_2 (0x04UL << UCPD_CFG1_IFRGAP_Pos)
#define UCPD_CFG1_IFRGAP_3 (0x08UL << UCPD_CFG1_IFRGAP_Pos)
#define UCPD_CFG1_IFRGAP_4 (0x10UL << UCPD_CFG1_IFRGAP_Pos)
#define UCPD_CFG1_TRANSWIN_Pos (11U)
#define UCPD_CFG1_TRANSWIN_Msk (0x1FUL << UCPD_CFG1_TRANSWIN_Pos)
#define UCPD_CFG1_TRANSWIN UCPD_CFG1_TRANSWIN_Msk
#define UCPD_CFG1_TRANSWIN_0 (0x01UL << UCPD_CFG1_TRANSWIN_Pos)
#define UCPD_CFG1_TRANSWIN_1 (0x02UL << UCPD_CFG1_TRANSWIN_Pos)
#define UCPD_CFG1_TRANSWIN_2 (0x04UL << UCPD_CFG1_TRANSWIN_Pos)
#define UCPD_CFG1_TRANSWIN_3 (0x08UL << UCPD_CFG1_TRANSWIN_Pos)
#define UCPD_CFG1_TRANSWIN_4 (0x10UL << UCPD_CFG1_TRANSWIN_Pos)
#define UCPD_CFG1_PSC_UCPDCLK_Pos (17U)
#define UCPD_CFG1_PSC_UCPDCLK_Msk (0x7UL << UCPD_CFG1_PSC_UCPDCLK_Pos)
#define UCPD_CFG1_PSC_UCPDCLK UCPD_CFG1_PSC_UCPDCLK_Msk
#define UCPD_CFG1_PSC_UCPDCLK_0 (0x1UL << UCPD_CFG1_PSC_UCPDCLK_Pos)
#define UCPD_CFG1_PSC_UCPDCLK_1 (0x2UL << UCPD_CFG1_PSC_UCPDCLK_Pos)
#define UCPD_CFG1_PSC_UCPDCLK_2 (0x4UL << UCPD_CFG1_PSC_UCPDCLK_Pos)
#define UCPD_CFG1_RXORDSETEN_Pos (20U)
#define UCPD_CFG1_RXORDSETEN_Msk (0x1FFUL << UCPD_CFG1_RXORDSETEN_Pos)
#define UCPD_CFG1_RXORDSETEN UCPD_CFG1_RXORDSETEN_Msk
#define UCPD_CFG1_RXORDSETEN_0 (0x001UL << UCPD_CFG1_RXORDSETEN_Pos)
#define UCPD_CFG1_RXORDSETEN_1 (0x002UL << UCPD_CFG1_RXORDSETEN_Pos)
#define UCPD_CFG1_RXORDSETEN_2 (0x004UL << UCPD_CFG1_RXORDSETEN_Pos)
#define UCPD_CFG1_RXORDSETEN_3 (0x008UL << UCPD_CFG1_RXORDSETEN_Pos)
#define UCPD_CFG1_RXORDSETEN_4 (0x010UL << UCPD_CFG1_RXORDSETEN_Pos)
#define UCPD_CFG1_RXORDSETEN_5 (0x020UL << UCPD_CFG1_RXORDSETEN_Pos)
#define UCPD_CFG1_RXORDSETEN_6 (0x040UL << UCPD_CFG1_RXORDSETEN_Pos)
#define UCPD_CFG1_RXORDSETEN_7 (0x080UL << UCPD_CFG1_RXORDSETEN_Pos)
#define UCPD_CFG1_RXORDSETEN_8 (0x100UL << UCPD_CFG1_RXORDSETEN_Pos)
#define UCPD_CFG1_TXDMAEN_Pos (29U)
#define UCPD_CFG1_TXDMAEN_Msk (0x1UL << UCPD_CFG1_TXDMAEN_Pos)
#define UCPD_CFG1_TXDMAEN UCPD_CFG1_TXDMAEN_Msk
#define UCPD_CFG1_RXDMAEN_Pos (30U)
#define UCPD_CFG1_RXDMAEN_Msk (0x1UL << UCPD_CFG1_RXDMAEN_Pos)
#define UCPD_CFG1_RXDMAEN UCPD_CFG1_RXDMAEN_Msk
#define UCPD_CFG1_UCPDEN_Pos (31U)
#define UCPD_CFG1_UCPDEN_Msk (0x1UL << UCPD_CFG1_UCPDEN_Pos)
#define UCPD_CFG1_UCPDEN UCPD_CFG1_UCPDEN_Msk

/********************  Bits definition for UCPD_CFG2 register  *******************/
#define UCPD_CFG2_RXFILTDIS_Pos (0U)
#define UCPD_CFG2_RXFILTDIS_Msk (0x1UL << UCPD_CFG2_RXFILTDIS_Pos)
#define UCPD_CFG2_RXFILTDIS UCPD_CFG2_RXFILTDIS_Msk
#define UCPD_CFG2_RXFILT2N3_Pos (1U)
#define UCPD_CFG2_RXFILT2N3_Msk (0x1UL << UCPD_CFG2_RXFILT2N3_Pos)
#define UCPD_CFG2_RXFILT2N3 UCPD_CFG2_RXFILT2N3_Msk
#define UCPD_CFG2_FORCECLK_Pos (2U)
#define UCPD_CFG2_FORCECLK_Msk (0x1UL << UCPD_CFG2_FORCECLK_Pos)
#define UCPD_CFG2_FORCECLK UCPD_CFG2_FORCECLK_Msk
#define UCPD_CFG2_WUPEN_Pos (3U)
#define UCPD_CFG2_WUPEN_Msk (0x1UL << UCPD_CFG2_WUPEN_Pos)
#define UCPD_CFG2_WUPEN UCPD_CFG2_WUPEN_Msk

/********************  Bits definition for UCPD_CR register  ********************/
#define UCPD_CR_TXMODE_Pos (0U)
#define UCPD_CR_TXMODE_Msk (0x3UL << UCPD_CR_TXMODE_Pos)
#define UCPD_CR_TXMODE UCPD_CR_TXMODE_Msk
#define UCPD_CR_TXMODE_0 (0x1UL << UCPD_CR_TXMODE_Pos)
#define UCPD_CR_TXMODE_1 (0x2UL << UCPD_CR_TXMODE_Pos)
#define UCPD_CR_TXSEND_Pos (2U)
#define UCPD_CR_TXSEND_Msk (0x1UL << UCPD_CR_TXSEND_Pos)
#define UCPD_CR_TXSEND UCPD_CR_TXSEND_Msk
#define UCPD_CR_TXHRST_Pos (3U)
#define UCPD_CR_TXHRST_Msk (0x1UL << UCPD_CR_TXHRST_Pos)
#define UCPD_CR_TXHRST UCPD_CR_TXHRST_Msk
#define UCPD_CR_RXMODE_Pos (4U)
#define UCPD_CR_RXMODE_Msk (0x1UL << UCPD_CR_RXMODE_Pos)
#define UCPD_CR_RXMODE UCPD_CR_RXMODE_Msk
#define UCPD_CR_PHYRXEN_Pos (5U)
#define UCPD_CR_PHYRXEN_Msk (0x1UL << UCPD_CR_PHYRXEN_Pos)
#define UCPD_CR_PHYRXEN UCPD_CR_PHYRXEN_Msk
#define UCPD_CR_PHYCCSEL_Pos (6U)
#define UCPD_CR_PHYCCSEL_Msk (0x1UL << UCPD_CR_PHYCCSEL_Pos)
#define UCPD_CR_PHYCCSEL UCPD_CR_PHYCCSEL_Msk
#define UCPD_CR_ANASUBMODE_Pos (7U)
#define UCPD_CR_ANASUBMODE_Msk (0x3UL << UCPD_CR_ANASUBMODE_Pos)
#define UCPD_CR_ANASUBMODE UCPD_CR_ANASUBMODE_Msk
#define UCPD_CR_ANASUBMODE_0 (0x1UL << UCPD_CR_ANASUBMODE_Pos)
#define UCPD_CR_ANASUBMODE_1 (0x2UL << UCPD_CR_ANASUBMODE_Pos)
#define UCPD_CR_ANAMODE_Pos (9U)
#define UCPD_CR_ANAMODE_Msk (0x1UL << UCPD_CR_ANAMODE_Pos)
#define UCPD_CR_ANAMODE UCPD_CR_ANAMODE_Msk
#define UCPD_CR_CCENABLE_Pos (10U)
#define UCPD_CR_CCENABLE_Msk (0x3UL << UCPD_CR_CCENABLE_Pos)
#define UCPD_CR_CCENABLE UCPD_CR_CCENABLE_Msk
#define UCPD_CR_CCENABLE_0 (0x1UL << UCPD_CR_CCENABLE_Pos)
#define UCPD_CR_CCENABLE_1 (0x2UL << UCPD_CR_CCENABLE_Pos)
#define UCPD_CR_FRSRXEN_Pos (16U)
#define UCPD_CR_FRSRXEN_Msk (0x1UL << UCPD_CR_FRSRXEN_Pos)
#define UCPD_CR_FRSRXEN UCPD_CR_FRSRXEN_Msk
#define UCPD_CR_FRSTX_Pos (17U)
#define UCPD_CR_FRSTX_Msk (0x1UL << UCPD_CR_FRSTX_Pos)
#define UCPD_CR_FRSTX UCPD_CR_FRSTX_Msk
#define UCPD_CR_RDCH_Pos (18U)
#define UCPD_CR_RDCH_Msk (0x1UL << UCPD_CR_RDCH_Pos)
#define UCPD_CR_RDCH UCPD_CR_RDCH_Msk
#define UCPD_CR_CC1TCDIS_Pos (20U)
#define UCPD_CR_CC1TCDIS_Msk (0x1UL << UCPD_CR_CC1TCDIS_Pos)
#define UCPD_CR_CC1TCDIS UCPD_CR_CC1TCDIS_Msk
#define UCPD_CR_CC2TCDIS_Pos (21U)
#define UCPD_CR_CC2TCDIS_Msk (0x1UL << UCPD_CR_CC2TCDIS_Pos)
#define UCPD_CR_CC2TCDIS UCPD_CR_CC2TCDIS_Msk

/********************  Bits definition for UCPD_IMR register  *******************/
#define UCPD_IMR_TXISIE_Pos (0U)
#define UCPD_IMR_TXISIE_Msk (0x1UL << UCPD_IMR_TXISIE_Pos)
#define UCPD_IMR_TXISIE UCPD_IMR_TXISIE_Msk
#define UCPD_IMR_TXMSGDISCIE_Pos (1U)
#define UCPD_IMR_TXMSGDISCIE_Msk (0x1UL << UCPD_IMR_TXMSGDISCIE_Pos)
#define UCPD_IMR_TXMSGDISCIE UCPD_IMR_TXMSGDISCIE_Msk
#define UCPD_IMR_TXMSGSENTIE_Pos (2U)
#define UCPD_IMR_TXMSGSENTIE_Msk (0x1UL << UCPD_IMR_TXMSGSENTIE_Pos)
#define UCPD_IMR_TXMSGSENTIE UCPD_IMR_TXMSGSENTIE_Msk
#define UCPD_IMR_TXMSGABTIE_Pos (3U)
#define UCPD_IMR_TXMSGABTIE_Msk (0x1UL << UCPD_IMR_TXMSGABTIE_Pos)
#define UCPD_IMR_TXMSGABTIE UCPD_IMR_TXMSGABTIE_Msk
#define UCPD_IMR_HRSTDISCIE_Pos (4U)
#define UCPD_IMR_HRSTDISCIE_Msk (0x1UL << UCPD_IMR_HRSTDISCIE_Pos)
#define UCPD_IMR_HRSTDISCIE UCPD_IMR_HRSTDISCIE_Msk
#define UCPD_IMR_HRSTSENTIE_Pos (5U)
#define UCPD_IMR_HRSTSENTIE_Msk (0x1UL << UCPD_IMR_HRSTSENTIE_Pos)
#define UCPD_IMR_HRSTSENTIE UCPD_IMR_HRSTSENTIE_Msk
#define UCPD_IMR_TXUNDIE_Pos (6U)
#define UCPD_IMR_TXUNDIE_Msk (0x1UL << UCPD_IMR_TXUNDIE_Pos)
#define UCPD_IMR_TXUNDIE UCPD_IMR_TXUNDIE_Msk
#define UCPD_IMR_RXNEIE_Pos (8U)
#define UCPD_IMR_RXNEIE_Msk (0x1UL << UCPD_IMR_RXNEIE_Pos)
#define UCPD_IMR_RXNEIE UCPD_IMR_RXNEIE_Msk
#define UCPD_IMR_RXORDDETIE_Pos (9U)
#define UCPD_IMR_RXORDDETIE_Msk (0x1UL << UCPD_IMR_RXORDDETIE_Pos)
#define UCPD_IMR_RXORDDETIE UCPD_IMR_RXORDDETIE_Msk
#define UCPD_IMR_RXHRSTDETIE_Pos (10U)
#define UCPD_IMR_RXHRSTDETIE_Msk (0x1UL << UCPD_IMR_RXHRSTDETIE_Pos)
#define UCPD_IMR_RXHRSTDETIE UCPD_IMR_RXHRSTDETIE_Msk
#define UCPD_IMR_RXOVRIE_Pos (11U)
#define UCPD_IMR_RXOVRIE_Msk (0x1UL << UCPD_IMR_RXOVRIE_Pos)
#define UCPD_IMR_RXOVRIE UCPD_IMR_RXOVRIE_Msk
#define UCPD_IMR_RXMSGENDIE_Pos (12U)
#define UCPD_IMR_RXMSGENDIE_Msk (0x1UL << UCPD_IMR_RXMSGENDIE_Pos)
#define UCPD_IMR_RXMSGENDIE UCPD_IMR_RXMSGENDIE_Msk
#define UCPD_IMR_TYPECEVT1IE_Pos (14U)
#define UCPD_IMR_TYPECEVT1IE_Msk (0x1UL << UCPD_IMR_TYPECEVT1IE_Pos)
#define UCPD_IMR_TYPECEVT1IE UCPD_IMR_TYPECEVT1IE_Msk
#define UCPD_IMR_TYPECEVT2IE_Pos (15U)
#define UCPD_IMR_TYPECEVT2IE_Msk (0x1UL << UCPD_IMR_TYPECEVT2IE_Pos)
#define UCPD_IMR_TYPECEVT2IE UCPD_IMR_TYPECEVT2IE_Msk
#define UCPD_IMR_FRSEVTIE_Pos (20U)
#define UCPD_IMR_FRSEVTIE_Msk (0x1UL << UCPD_IMR_FRSEVTIE_Pos)
#define UCPD_IMR_FRSEVTIE UCPD_IMR_FRSEVTIE_Msk

/********************  Bits definition for UCPD_SR register  ********************/
#define UCPD_SR_TXIS_Pos (0U)
#define UCPD_SR_TXIS_Msk (0x1UL << UCPD_SR_TXIS_Pos)
#define UCPD_SR_TXIS UCPD_SR_TXIS_Msk
#define UCPD_SR_TXMSGDISC_Pos (1U)
#define UCPD_SR_TXMSGDISC_Msk (0x1UL << UCPD_SR_TXMSGDISC_Pos)
#define UCPD_SR_TXMSGDISC UCPD_SR_TXMSGDISC_Msk
#define UCPD_SR_TXMSGSENT_Pos (2U)
#define UCPD_SR_TXMSGSENT_Msk (0x1UL << UCPD_SR_TXMSGSENT_Pos)
#define UCPD_SR_TXMSGSENT UCPD_SR_TXMSGSENT_Msk
#define UCPD_SR_TXMSGABT_Pos (3U)
#define UCPD_SR_TXMSGABT_Msk (0x1UL << UCPD_SR_TXMSGABT_Pos)
#define UCPD_SR_TXMSGABT UCPD_SR_TXMSGABT_Msk
#define UCPD_SR_HRSTDISC_Pos (4U)
#define UCPD_SR_HRSTDISC_Msk (0x1UL << UCPD_SR_HRSTDISC_Pos)
#define UCPD_SR_HRSTDISC UCPD_SR_HRSTDISC_Msk
#define UCPD_SR_HRSTSENT_Pos (5U)
#define UCPD_SR_HRSTSENT_Msk (0x1UL << UCPD_SR_HRSTSENT_Pos)
#define UCPD_SR_HRSTSENT UCPD_SR_HRSTSENT_Msk
#define UCPD_SR_TXUND_Pos (6U)
#define UCPD_SR_TXUND_Msk (0x1UL << UCPD_SR_TXUND_Pos)
#define UCPD_SR_TXUND UCPD_SR_TXUND_Msk
#define UCPD_SR_RXNE_Pos (8U)
#define UCPD_SR_RXNE_Msk (0x1UL << UCPD_SR_RXNE_Pos)
#define UCPD_SR_RXNE UCPD_SR_RXNE_Msk
#define UCPD_SR_RXORDDET_Pos (9U)
#define UCPD_SR_RXORDDET_Msk (0x1UL << UCPD_SR_RXORDDET_Pos)
#define UCPD_SR_RXORDDET UCPD_SR_RXORDDET_Msk
#define UCPD_SR_RXHRSTDET_Pos (10U)
#define UCPD_SR_RXHRSTDET_Msk (0x1UL << UCPD_SR_RXHRSTDET_Pos)
#define UCPD_SR_RXHRSTDET UCPD_SR_RXHRSTDET_Msk
#define UCPD_SR_RXOVR_Pos (11U)
#define UCPD_SR_RXOVR_Msk (0x1UL << UCPD_SR_RXOVR_Pos)
#define UCPD_SR_RXOVR UCPD_SR_RXOVR_Msk
#define UCPD_SR_RXMSGEND_Pos (12U)
#define UCPD_SR_RXMSGEND_Msk (0x1UL << UCPD_SR_RXMSGEND_Pos)
#define UCPD_SR_RXMSGEND UCPD_SR_RXMSGEND_Msk
#define UCPD_SR_RXERR_Pos (13U)
#define UCPD_SR_RXERR_Msk (0x1UL << UCPD_SR_RXERR_Pos)
#define UCPD_SR_RXERR UCPD_SR_RXERR_Msk
#define UCPD_SR_TYPECEVT1_Pos (14U)
#define UCPD_SR_TYPECEVT1_Msk (0x1UL << UCPD_SR_TYPECEVT1_Pos)
#define UCPD_SR_TYPECEVT1 UCPD_SR_TYPECEVT1_Msk
#define UCPD_SR_TYPECEVT2_Pos (15U)
#define UCPD_SR_TYPECEVT2_Msk (0x1UL << UCPD_SR_TYPECEVT2_Pos)
#define UCPD_SR_TYPECEVT2 UCPD_SR_TYPECEVT2_Msk
#define UCPD_SR_TYPEC_VSTATE_CC1_Pos (16U)
#define UCPD_SR_TYPEC_VSTATE_CC1_Msk (0x3UL << UCPD_SR_TYPEC_VSTATE_CC1_Pos)
#define UCPD_SR_TYPEC_VSTATE_CC1 UCPD_SR_TYPEC_VSTATE_CC1_Msk
#define UCPD_SR_TYPEC_VSTATE_CC1_0 (0x1UL << UCPD_SR_TYPEC_VSTATE_CC1_Pos)
#define UCPD_SR_TYPEC_VSTATE_CC1_1 (0x2UL << UCPD_SR_TYPEC_VSTATE_CC1_Pos)
#define UCPD_SR_TYPEC_VSTATE_CC2_Pos (18U)
#define UCPD_SR_TYPEC_VSTATE_CC2_Msk (0x3UL << UCPD_SR_TYPEC_VSTATE_CC2_Pos)
#define UCPD_SR_TYPEC_VSTATE_CC2 UCPD_SR_TYPEC_VSTATE_CC2_Msk
#define UCPD_SR_TYPEC_VSTATE_CC2_0 (0x1UL << UCPD_SR_TYPEC_VSTATE_CC2_Pos)
#define UCPD_SR_TYPEC_VSTATE_CC2_1 (0x2UL << UCPD_SR_TYPEC_VSTATE_CC2_Pos)
#define UCPD_SR_FRSEVT_Pos (20U)
#define UCPD_SR_FRSEVT_Msk (0x1UL << UCPD_SR_FRSEVT_Pos)
#define UCPD_SR_FRSEVT UCPD_SR_FRSEVT_Msk

/********************  Bits definition for UCPD_ICR register  *******************/
#define UCPD_ICR_TXMSGDISCCF_Pos (1U)
#define UCPD_ICR_TXMSGDISCCF_Msk (0x1UL << UCPD_ICR_TXMSGDISCCF_Pos)
#define UCPD_ICR_TXMSGDISCCF UCPD_ICR_TXMSGDISCCF_Msk
#define UCPD_ICR_TXMSGSENTCF_Pos (2U)
#define UCPD_ICR_TXMSGSENTCF_Msk (0x1UL << UCPD_ICR_TXMSGSENTCF_Pos)
#define UCPD_ICR_TXMSGSENTCF UCPD_ICR_TXMSGSENTCF_Msk
#define UCPD_ICR_TXMSGABTCF_Pos (3U)
#define UCPD_ICR_TXMSGABTCF_Msk (0x1UL << UCPD_ICR_TXMSGABTCF_Pos)
#define UCPD_ICR_TXMSGABTCF UCPD_ICR_TXMSGABTCF_Msk
#define UCPD_ICR_HRSTDISCCF_Pos (4U)
#define UCPD_ICR_HRSTDISCCF_Msk (0x1UL << UCPD_ICR_HRSTDISCCF_Pos)
#define UCPD_ICR_HRSTDISCCF UCPD_ICR_HRSTDISCCF_Msk
#define UCPD_ICR_HRSTSENTCF_Pos (5U)
#define UCPD_ICR_HRSTSENTCF_Msk (0x1UL << UCPD_ICR_HRSTSENTCF_Pos)
#define UCPD_ICR_HRSTSENTCF UCPD_ICR_HRSTSENTCF_Msk
#define UCPD_ICR_TXUNDCF_Pos (6U)
#define UCPD_ICR_TXUNDCF_Msk (0x1UL << UCPD_ICR_TXUNDCF_Pos)
#define UCPD_ICR_TXUNDCF UCPD_ICR_TXUNDCF_Msk
#define UCPD_ICR_RXORDDETCF_Pos (9U)
#define UCPD_ICR_RXORDDETCF_Msk (0x1UL << UCPD_ICR_RXORDDETCF_Pos)
#define UCPD_ICR_RXORDDETCF UCPD_ICR_RXORDDETCF_Msk
#define UCPD_ICR_RXHRSTDETCF_Pos (10U)
#define UCPD_ICR_RXHRSTDETCF_Msk (0x1UL << UCPD_ICR_RXHRSTDETCF_Pos)
#define UCPD_ICR_RXHRSTDETCF UCPD_ICR_RXHRSTDETCF_Msk
#define UCPD_ICR_RXOVRCF_Pos (11U)
#define UCPD_ICR_RXOVRCF_Msk (0x1UL << UCPD_ICR_RXOVRCF_Pos)
#define UCPD_ICR_RXOVRCF UCPD_ICR_RXOVRCF_Msk
#define UCPD_ICR_RXMSGENDCF_Pos (12U)
#define UCPD_ICR_RXMSGENDCF_Msk (0x1UL << UCPD_ICR_RXMSGENDCF_Pos)
#define UCPD_ICR_RXMSGENDCF UCPD_ICR_RXMSGENDCF_Msk
#define UCPD_ICR_TYPECEVT1CF_Pos (14U)
#define UCPD_ICR_TYPECEVT1CF_Msk (0x1UL << UCPD_ICR_TYPECEVT1CF_Pos)
#define UCPD_ICR_TYPECEVT1CF UCPD_ICR_TYPECEVT1CF_Msk
#define UCPD_ICR_TYPECEVT2CF_Pos (15U)
#define UCPD_ICR_TYPECEVT2CF_Msk (0x1UL << UCPD_ICR_TYPECEVT2CF_Pos)
#define UCPD_ICR_TYPECEVT2CF UCPD_ICR_TYPECEVT2CF_Msk
#define UCPD_ICR_FRSEVTCF_Pos (20U)
#define UCPD_ICR_FRSEVTCF_Msk (0x1UL << UCPD_ICR_FRSEVTCF_Pos)
#define UCPD_ICR_FRSEVTCF UCPD_ICR_FRSEVTCF_Msk

/********************  Bits definition for UCPD_TXORDSET register  **************/
#define UCPD_TX_ORDSET_TXORDSET_Pos (0U)
#define UCPD_TX_ORDSET_TXORDSET_Msk (0xFFFFFUL << UCPD_TX_ORDSET_TXORDSET_Pos)
#define UCPD_TX_ORDSET_TXORDSET UCPD_TX_ORDSET_TXORDSET_Msk

/********************  Bits definition for UCPD_TXPAYSZ register  ****************/
#define UCPD_TX_PAYSZ_TXPAYSZ_Pos (0U)
#define UCPD_TX_PAYSZ_TXPAYSZ_Msk (0x3FFUL << UCPD_TX_PAYSZ_TXPAYSZ_Pos)
#define UCPD_TX_PAYSZ_TXPAYSZ UCPD_TX_PAYSZ_TXPAYSZ_Msk

/********************  Bits definition for UCPD_TXDR register  *******************/
#define UCPD_TXDR_TXDATA_Pos (0U)
#define UCPD_TXDR_TXDATA_Msk (0xFFUL << UCPD_TXDR_TXDATA_Pos)
#define UCPD_TXDR_TXDATA UCPD_TXDR_TXDATA_Msk

/********************  Bits definition for UCPD_RXORDSET register  **************/
#define UCPD_RX_ORDSET_RXORDSET_Pos (0U)
#define UCPD_RX_ORDSET_RXORDSET_Msk (0x7UL << UCPD_RX_ORDSET_RXORDSET_Pos)
#define UCPD_RX_ORDSET_RXORDSET UCPD_RX_ORDSET_RXORDSET_Msk
#define UCPD_RX_ORDSET_RXORDSET_0 (0x1UL << UCPD_RX_ORDSET_RXORDSET_Pos)
#define UCPD_RX_ORDSET_RXORDSET_1 (0x2UL << UCPD_RX_ORDSET_RXORDSET_Pos)
#define UCPD_RX_ORDSET_RXORDSET_2 (0x4UL << UCPD_RX_ORDSET_RXORDSET_Pos)
#define UCPD_RX_ORDSET_RXSOP3OF4_Pos (3U)
#define UCPD_RX_ORDSET_RXSOP3OF4_Msk (0x1UL << UCPD_RX_ORDSET_RXSOP3OF4_Pos)
#define UCPD_RX_ORDSET_RXSOP3OF4 UCPD_RX_ORDSET_RXSOP3OF4_Msk
#define UCPD_RX_ORDSET_RXSOPKINVALID_Pos (4U)
#define UCPD_RX_ORDSET_RXSOPKINVALID_Msk (0x7UL << UCPD_RX_ORDSET_RXSOPKINVALID_Pos)
#define UCPD_RX_ORDSET_RXSOPKINVALID UCPD_RX_ORDSET_RXSOPKINVALID_Msk

/********************  Bits definition for UCPD_RXPAYSZ register  ****************/
#define UCPD_RX_PAYSZ_RXPAYSZ_Pos (0U)
#define UCPD_RX_PAYSZ_RXPAYSZ_Msk (0x3FFUL << UCPD_RX_PAYSZ_RXPAYSZ_Pos)
#define UCPD_RX_PAYSZ_RXPAYSZ UCPD_RX_PAYSZ_RXPAYSZ_Msk

/********************  Bits definition for UCPD_RXDR register  *******************/
#define UCPD_RXDR_RXDATA_Pos (0U)
#define UCPD_RXDR_RXDATA_Msk (0xFFUL << UCPD_RXDR_RXDATA_Pos)
#define UCPD_RXDR_RXDATA UCPD_RXDR_RXDATA_Msk

/********************  Bits definition for UCPD_RXORDEXT1 register  **************/
#define UCPD_RX_ORDEXT1_RXSOPX1_Pos (0U)
#define UCPD_RX_ORDEXT1_RXSOPX1_Msk (0xFFFFFUL << UCPD_RX_ORDEXT1_RXSOPX1_Pos)
#define UCPD_RX_ORDEXT1_RXSOPX1 UCPD_RX_ORDEXT1_RXSOPX1_Msk

/********************  Bits definition for UCPD_RXORDEXT2 register  **************/
#define UCPD_RX_ORDEXT2_RXSOPX2_Pos (0U)
#define UCPD_RX_ORDEXT2_RXSOPX2_Msk (0xFFFFFUL << UCPD_RX_ORDEXT2_RXSOPX2_Pos)
#define UCPD_RX_ORDEXT2_RXSOPX2 UCPD_RX_ORDEXT2_RXSOPX2_Msk

/******************************************************************************/
/*                                                                            */
/*                            Window WATCHDOG                                 */
/*                                                                            */
/******************************************************************************/
/*******************  Bit definition for WWDG_CR register  ********************/
#define WWDG_CR_T_Pos (0U)
#define WWDG_CR_T_Msk (0x7FUL << WWDG_CR_T_Pos)
#define WWDG_CR_T WWDG_CR_T_Msk
#define WWDG_CR_T_0 (0x01UL << WWDG_CR_T_Pos)
#define WWDG_CR_T_1 (0x02UL << WWDG_CR_T_Pos)
#define WWDG_CR_T_2 (0x04UL << WWDG_CR_T_Pos)
#define WWDG_CR_T_3 (0x08UL << WWDG_CR_T_Pos)
#define WWDG_CR_T_4 (0x10UL << WWDG_CR_T_Pos)
#define WWDG_CR_T_5 (0x20UL << WWDG_CR_T_Pos)
#define WWDG_CR_T_6 (0x40UL << WWDG_CR_T_Pos)

#define WWDG_CR_WDGA_Pos (7U)
#define WWDG_CR_WDGA_Msk (0x1UL << WWDG_CR_WDGA_Pos)
#define WWDG_CR_WDGA WWDG_CR_WDGA_Msk

/*******************  Bit definition for WWDG_CFR register  *******************/
#define WWDG_CFR_W_Pos (0U)
#define WWDG_CFR_W_Msk (0x7FUL << WWDG_CFR_W_Pos)
#define WWDG_CFR_W WWDG_CFR_W_Msk
#define WWDG_CFR_W_0 (0x01UL << WWDG_CFR_W_Pos)
#define WWDG_CFR_W_1 (0x02UL << WWDG_CFR_W_Pos)
#define WWDG_CFR_W_2 (0x04UL << WWDG_CFR_W_Pos)
#define WWDG_CFR_W_3 (0x08UL << WWDG_CFR_W_Pos)
#define WWDG_CFR_W_4 (0x10UL << WWDG_CFR_W_Pos)
#define WWDG_CFR_W_5 (0x20UL << WWDG_CFR_W_Pos)
#define WWDG_CFR_W_6 (0x40UL << WWDG_CFR_W_Pos)

#define WWDG_CFR_WDGTB_Pos (11U)
#define WWDG_CFR_WDGTB_Msk (0x7UL << WWDG_CFR_WDGTB_Pos)
#define WWDG_CFR_WDGTB WWDG_CFR_WDGTB_Msk
#define WWDG_CFR_WDGTB_0 (0x1UL << WWDG_CFR_WDGTB_Pos)
#define WWDG_CFR_WDGTB_1 (0x2UL << WWDG_CFR_WDGTB_Pos)
#define WWDG_CFR_WDGTB_2 (0x4UL << WWDG_CFR_WDGTB_Pos)

#define WWDG_CFR_EWI_Pos (9U)
#define WWDG_CFR_EWI_Msk (0x1UL << WWDG_CFR_EWI_Pos)
#define WWDG_CFR_EWI WWDG_CFR_EWI_Msk

/*******************  Bit definition for WWDG_SR register  ********************/
#define WWDG_SR_EWIF_Pos (0U)
#define WWDG_SR_EWIF_Msk (0x1UL << WWDG_SR_EWIF_Pos)
#define WWDG_SR_EWIF WWDG_SR_EWIF_Msk

/**
  * @}
  */

/**
  * @}
  */

/** @addtogroup Exported_macros
  * @{
  */

/******************************* ADC Instances ********************************/
#define IS_ADC_ALL_INSTANCE(INSTANCE) (((INSTANCE) == ADC1) || ((INSTANCE) == ADC2) || ((INSTANCE) == ADC3) || ((INSTANCE) == ADC4) || ((INSTANCE) == ADC5))





#define IS_ADC_MULTIMODE_MASTER_INSTANCE(INSTANCE) (((INSTANCE) == ADC1) || ((INSTANCE) == ADC3))


#define IS_ADC_COMMON_INSTANCE(INSTANCE) (((INSTANCE) == ADC12_COMMON) || ((INSTANCE) == ADC345_COMMON) )



/******************************** FDCAN Instances ******************************/
#define IS_FDCAN_ALL_INSTANCE(INSTANCE) (((INSTANCE) == FDCAN1) || ((INSTANCE) == FDCAN2) || ((INSTANCE) == FDCAN3))



#define IS_FDCAN_CONFIG_INSTANCE(INSTANCE) ((INSTANCE) == FDCAN_CONFIG)
/******************************** COMP Instances ******************************/
#define IS_COMP_ALL_INSTANCE(INSTANCE) (((INSTANCE) == COMP1) || ((INSTANCE) == COMP2) || ((INSTANCE) == COMP3) || ((INSTANCE) == COMP4) || ((INSTANCE) == COMP5) || ((INSTANCE) == COMP6) || ((INSTANCE) == COMP7))







/******************************* CORDIC Instances *****************************/
#define IS_CORDIC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == CORDIC)

/******************************* CRC Instances ********************************/
#define IS_CRC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == CRC)

/******************************* DAC Instances ********************************/
#define IS_DAC_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DAC1) || ((INSTANCE) == DAC2) || ((INSTANCE) == DAC3) || ((INSTANCE) == DAC4))





/******************************** DMA Instances *******************************/
#define IS_DMA_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DMA1_Channel1) || ((INSTANCE) == DMA1_Channel2) || ((INSTANCE) == DMA1_Channel3) || ((INSTANCE) == DMA1_Channel4) || ((INSTANCE) == DMA1_Channel5) || ((INSTANCE) == DMA1_Channel6) || ((INSTANCE) == DMA1_Channel7) || ((INSTANCE) == DMA1_Channel8) || ((INSTANCE) == DMA2_Channel1) || ((INSTANCE) == DMA2_Channel2) || ((INSTANCE) == DMA2_Channel3) || ((INSTANCE) == DMA2_Channel4) || ((INSTANCE) == DMA2_Channel5) || ((INSTANCE) == DMA2_Channel6) || ((INSTANCE) == DMA2_Channel7) || ((INSTANCE) == DMA2_Channel8))
# 13903 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h"

#define IS_DMA_REQUEST_GEN_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DMAMUX1_RequestGenerator0) || ((INSTANCE) == DMAMUX1_RequestGenerator1) || ((INSTANCE) == DMAMUX1_RequestGenerator2) || ((INSTANCE) == DMAMUX1_RequestGenerator3))




/******************************* FMAC Instances *******************************/
#define IS_FMAC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == FMAC)

/******************************* GPIO Instances *******************************/
#define IS_GPIO_ALL_INSTANCE(INSTANCE) (((INSTANCE) == GPIOA) || ((INSTANCE) == GPIOB) || ((INSTANCE) == GPIOC) || ((INSTANCE) == GPIOD) || ((INSTANCE) == GPIOE) || ((INSTANCE) == GPIOF) || ((INSTANCE) == GPIOG))







/******************************* GPIO AF Instances ****************************/
#define IS_GPIO_AF_INSTANCE(INSTANCE) IS_GPIO_ALL_INSTANCE(INSTANCE)

/**************************** GPIO Lock Instances *****************************/
#define IS_GPIO_LOCK_INSTANCE(INSTANCE) IS_GPIO_ALL_INSTANCE(INSTANCE)

/******************************** I2C Instances *******************************/
#define IS_I2C_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2C1) || ((INSTANCE) == I2C2) || ((INSTANCE) == I2C3) || ((INSTANCE) == I2C4))




/****************** I2C Instances : wakeup capability from stop modes *********/
#define IS_I2C_WAKEUP_FROMSTOP_INSTANCE(INSTANCE) IS_I2C_ALL_INSTANCE(INSTANCE)

/****************************** OPAMP Instances *******************************/
#define IS_OPAMP_ALL_INSTANCE(INSTANCE) (((INSTANCE) == OPAMP1) || ((INSTANCE) == OPAMP2) || ((INSTANCE) == OPAMP3) || ((INSTANCE) == OPAMP4) || ((INSTANCE) == OPAMP5) || ((INSTANCE) == OPAMP6))






/******************************** PCD Instances *******************************/
#define IS_PCD_ALL_INSTANCE(INSTANCE) ((INSTANCE) == USB)

/******************************* QSPI Instances *******************************/
#define IS_QSPI_ALL_INSTANCE(INSTANCE) ((INSTANCE) == QUADSPI)

/******************************* RNG Instances ********************************/
#define IS_RNG_ALL_INSTANCE(INSTANCE) ((INSTANCE) == RNG)

/****************************** RTC Instances *********************************/
#define IS_RTC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == RTC)

#define IS_TAMP_ALL_INSTANCE(INSTANCE) ((INSTANCE) == TAMP)

/****************************** SMBUS Instances *******************************/
#define IS_SMBUS_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2C1) || ((INSTANCE) == I2C2) || ((INSTANCE) == I2C3) || ((INSTANCE) == I2C4))




/******************************** SAI Instances *******************************/
#define IS_SAI_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SAI1_Block_A) || ((INSTANCE) == SAI1_Block_B))

/******************************** SPI Instances *******************************/
#define IS_SPI_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SPI1) || ((INSTANCE) == SPI2) || ((INSTANCE) == SPI3) || ((INSTANCE) == SPI4))




/******************************** I2S Instances *******************************/
#define IS_I2S_ALL_INSTANCE(__INSTANCE__) (((__INSTANCE__) == SPI2) || ((__INSTANCE__) == SPI3))


/****************** LPTIM Instances : All supported instances *****************/
#define IS_LPTIM_INSTANCE(INSTANCE) ((INSTANCE) == LPTIM1)

/****************** LPTIM Instances : supporting encoder interface **************/
#define IS_LPTIM_ENCODER_INTERFACE_INSTANCE(INSTANCE) ((INSTANCE) == LPTIM1)

/****************** LPTIM Instances : All supported instances *****************/
#define IS_LPTIM_ENCODER_INSTANCE(INSTANCE) ((INSTANCE) == LPTIM1)

/****************** TIM Instances : All supported instances *******************/
#define IS_TIM_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM6) || ((INSTANCE) == TIM7) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM16) || ((INSTANCE) == TIM17) || ((INSTANCE) == TIM20))
# 13999 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h"

/****************** TIM Instances : supporting 32 bits counter ****************/

#define IS_TIM_32B_COUNTER_INSTANCE(INSTANCE) (((INSTANCE) == TIM2) || ((INSTANCE) == TIM5))


/****************** TIM Instances : supporting the break function *************/
#define IS_TIM_BREAK_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM16) || ((INSTANCE) == TIM17) || ((INSTANCE) == TIM20))






/************** TIM Instances : supporting Break source selection *************/
#define IS_TIM_BREAKSOURCE_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM16) || ((INSTANCE) == TIM17) || ((INSTANCE) == TIM20))






/****************** TIM Instances : supporting 2 break inputs *****************/
#define IS_TIM_BKIN2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))



/************* TIM Instances : at least 1 capture/compare channel *************/
#define IS_TIM_CC1_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM16) || ((INSTANCE) == TIM17) || ((INSTANCE) == TIM20))
# 14037 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h"

/************ TIM Instances : at least 2 capture/compare channels *************/
#define IS_TIM_CC2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM20))








/************ TIM Instances : at least 3 capture/compare channels *************/
#define IS_TIM_CC3_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))







/************ TIM Instances : at least 4 capture/compare channels *************/
#define IS_TIM_CC4_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))







/****************** TIM Instances : at least 5 capture/compare channels *******/
#define IS_TIM_CC5_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))



/****************** TIM Instances : at least 6 capture/compare channels *******/
#define IS_TIM_CC6_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))



/************ TIM Instances : DMA requests generation (TIMx_DIER.COMDE) *******/
#define IS_TIM_CCDMA_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM16) || ((INSTANCE) == TIM17) || ((INSTANCE) == TIM20))






/****************** TIM Instances : DMA requests generation (TIMx_DIER.UDE) ***/
#define IS_TIM_DMA_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM6) || ((INSTANCE) == TIM7) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM16) || ((INSTANCE) == TIM17) || ((INSTANCE) == TIM20))
# 14097 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h"

/************ TIM Instances : DMA requests generation (TIMx_DIER.CCxDE) *******/
#define IS_TIM_DMA_CC_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM16) || ((INSTANCE) == TIM17) || ((INSTANCE) == TIM20))
# 14109 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h"

/******************** TIM Instances : DMA burst feature ***********************/
#define IS_TIM_DMABURST_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM16) || ((INSTANCE) == TIM17) || ((INSTANCE) == TIM20))
# 14121 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h"

/******************* TIM Instances : output(s) available **********************/
#define IS_TIM_CCX_INSTANCE(INSTANCE,CHANNEL) ((((INSTANCE) == TIM1) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3) || ((CHANNEL) == TIM_CHANNEL_4) || ((CHANNEL) == TIM_CHANNEL_5) || ((CHANNEL) == TIM_CHANNEL_6))) || (((INSTANCE) == TIM2) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3) || ((CHANNEL) == TIM_CHANNEL_4))) || (((INSTANCE) == TIM3) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3) || ((CHANNEL) == TIM_CHANNEL_4))) || (((INSTANCE) == TIM4) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3) || ((CHANNEL) == TIM_CHANNEL_4))) || (((INSTANCE) == TIM5) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3) || ((CHANNEL) == TIM_CHANNEL_4))) || (((INSTANCE) == TIM8) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3) || ((CHANNEL) == TIM_CHANNEL_4) || ((CHANNEL) == TIM_CHANNEL_5) || ((CHANNEL) == TIM_CHANNEL_6))) || (((INSTANCE) == TIM15) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2))) || (((INSTANCE) == TIM16) && (((CHANNEL) == TIM_CHANNEL_1))) || (((INSTANCE) == TIM17) && (((CHANNEL) == TIM_CHANNEL_1))) || (((INSTANCE) == TIM20) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3) || ((CHANNEL) == TIM_CHANNEL_4) || ((CHANNEL) == TIM_CHANNEL_5) || ((CHANNEL) == TIM_CHANNEL_6))))
# 14181 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h"

/****************** TIM Instances : supporting complementary output(s) ********/
#define IS_TIM_CCXN_INSTANCE(INSTANCE,CHANNEL) ((((INSTANCE) == TIM1) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3) || ((CHANNEL) == TIM_CHANNEL_4))) || (((INSTANCE) == TIM8) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3) || ((CHANNEL) == TIM_CHANNEL_4))) || (((INSTANCE) == TIM15) && ((CHANNEL) == TIM_CHANNEL_1)) || (((INSTANCE) == TIM16) && ((CHANNEL) == TIM_CHANNEL_1)) || (((INSTANCE) == TIM17) && ((CHANNEL) == TIM_CHANNEL_1)) || (((INSTANCE) == TIM20) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3) || ((CHANNEL) == TIM_CHANNEL_4))))
# 14210 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h"

/****************** TIM Instances : supporting clock division *****************/
#define IS_TIM_CLOCK_DIVISION_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM16) || ((INSTANCE) == TIM17) || ((INSTANCE) == TIM20))
# 14222 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h"

/****** TIM Instances : supporting external clock mode 1 for ETRF input *******/
#define IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))







/****** TIM Instances : supporting external clock mode 2 for ETRF input *******/
#define IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))







/****************** TIM Instances : supporting external clock mode 1 for TIX inputs*/
#define IS_TIM_CLOCKSOURCE_TIX_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15)|| ((INSTANCE) == TIM20))








/****************** TIM Instances : supporting internal trigger inputs(ITRX) *******/
#define IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15)|| ((INSTANCE) == TIM20))








/****************** TIM Instances : supporting combined 3-phase PWM mode ******/
#define IS_TIM_COMBINED3PHASEPWM_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))



/****************** TIM Instances : supporting commutation event generation ***/
#define IS_TIM_COMMUTATION_EVENT_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM16) || ((INSTANCE) == TIM17) || ((INSTANCE) == TIM20))






/****************** TIM Instances : supporting counting mode selection ********/
#define IS_TIM_COUNTER_MODE_SELECT_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))







/****************** TIM Instances : supporting encoder interface **************/
#define IS_TIM_ENCODER_INTERFACE_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))







/****************** TIM Instances : supporting Hall sensor interface **********/
#define IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM20))








/**************** TIM Instances : external trigger input available ************/
#define IS_TIM_ETR_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))







/************* TIM Instances : supporting ETR source selection ***************/
#define IS_TIM_ETRSEL_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))







/****** TIM Instances : Master mode available (TIMx_CR2.MMS available )********/
#define IS_TIM_MASTER_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM6) || ((INSTANCE) == TIM7) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM20))
# 14331 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h"

/*********** TIM Instances : Slave mode available (TIMx_SMCR available )*******/
#define IS_TIM_SLAVE_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM20))








/****************** TIM Instances : supporting OCxREF clear *******************/
#define IS_TIM_OCXREF_CLEAR_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM16) || ((INSTANCE) == TIM17) || ((INSTANCE) == TIM20))
# 14353 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h"

/****************** TIM Instances : supporting bitfield OCCS in SMCR register *******************/
#define IS_TIM_OCCS_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM16) || ((INSTANCE) == TIM17) || ((INSTANCE) == TIM20))








/****************** TIM Instances : remapping capability **********************/
#define IS_TIM_REMAP_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))







/****************** TIM Instances : supporting repetition counter *************/
#define IS_TIM_REPETITION_COUNTER_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM16) || ((INSTANCE) == TIM17) || ((INSTANCE) == TIM20))






/****************** TIM Instances : supporting ADC triggering through TRGO2 ***/
#define IS_TIM_TRGO2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))



/******************* TIM Instances : Timer input XOR function *****************/
#define IS_TIM_XOR_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM20))








/******************* TIM Instances : Timer input selection ********************/
#define IS_TIM_TISEL_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4) || ((INSTANCE) == TIM5) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM15) || ((INSTANCE) == TIM16) || ((INSTANCE) == TIM17) || ((INSTANCE) == TIM20))
# 14407 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g473xx.h"

/****************** TIM Instances : Advanced timer instances *******************/
#define IS_TIM_ADVANCED_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM8) || ((INSTANCE) == TIM20))



/****************** TIM Instances : supporting HSE/32 request instances *******************/
#define IS_TIM_HSE32_INSTANCE(INSTANCE) (((INSTANCE) == TIM16) || ((INSTANCE) == TIM17))



/******************** USART Instances : Synchronous mode **********************/
#define IS_USART_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3))



/******************** UART Instances : Asynchronous mode **********************/
#define IS_UART_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3) || ((INSTANCE) == UART4) || ((INSTANCE) == UART5))





/*********************** UART Instances : FIFO mode ***************************/
#define IS_UART_FIFO_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3) || ((INSTANCE) == UART4) || ((INSTANCE) == UART5) || ((INSTANCE) == LPUART1))






/*********************** UART Instances : SPI Slave mode **********************/
#define IS_UART_SPI_SLAVE_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3))



/****************** UART Instances : Auto Baud Rate detection ****************/
#define IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3) || ((INSTANCE) == UART4) || ((INSTANCE) == UART5))





/****************** UART Instances : Driver Enable *****************/
#define IS_UART_DRIVER_ENABLE_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3) || ((INSTANCE) == UART4) || ((INSTANCE) == UART5) || ((INSTANCE) == LPUART1))






/******************** UART Instances : Half-Duplex mode **********************/
#define IS_UART_HALFDUPLEX_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3) || ((INSTANCE) == UART4) || ((INSTANCE) == UART5) || ((INSTANCE) == LPUART1))






/****************** UART Instances : Hardware Flow control ********************/
#define IS_UART_HWFLOW_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3) || ((INSTANCE) == UART4) || ((INSTANCE) == UART5) || ((INSTANCE) == LPUART1))






/******************** UART Instances : LIN mode **********************/
#define IS_UART_LIN_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3) || ((INSTANCE) == UART4) || ((INSTANCE) == UART5))





/******************** UART Instances : Wake-up from Stop mode **********************/
#define IS_UART_WAKEUP_FROMSTOP_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3) || ((INSTANCE) == UART4) || ((INSTANCE) == UART5) || ((INSTANCE) == LPUART1))






/*********************** UART Instances : IRDA mode ***************************/
#define IS_IRDA_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3) || ((INSTANCE) == UART4) || ((INSTANCE) == UART5))





/********************* USART Instances : Smard card mode ***********************/
#define IS_SMARTCARD_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3))



/******************** LPUART Instance *****************************************/
#define IS_LPUART_INSTANCE(INSTANCE) ((INSTANCE) == LPUART1)

/****************************** IWDG Instances ********************************/
#define IS_IWDG_ALL_INSTANCE(INSTANCE) ((INSTANCE) == IWDG)

/****************************** WWDG Instances ********************************/
#define IS_WWDG_ALL_INSTANCE(INSTANCE) ((INSTANCE) == WWDG)

/****************************** UCPD Instances ********************************/
#define IS_UCPD_ALL_INSTANCE(INSTANCE) ((INSTANCE) == UCPD1)

/******************************* USB Instances *******************************/
#define IS_USB_ALL_INSTANCE(INSTANCE) ((INSTANCE) == USB)

/**
  * @}
  */


/******************************************************************************/
/*  For a painless codes migration between the STM32G4xx device product       */
/*  lines, the aliases defined below are put in place to overcome the         */
/*  differences in the interrupt handlers and IRQn definitions.               */
/*  No need to update developed interrupt code when moving across             */
/*  product lines within the same STM32G4 Family                              */
/******************************************************************************/

/* Aliases for __IRQn */

/* Aliases for __IRQHandler */







/**
  * @}
  */

  /**
  * @}
  */

# 118 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g4xx.h" 2
# 139 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g4xx.h"

/**
  * @}
  */

/** @addtogroup Exported_types
  * @{
  */
typedef enum
{
  RESET = 0,
  SET = !RESET
} FlagStatus, ITStatus;

typedef enum
{
  DISABLE = 0,
  ENABLE = !DISABLE
} FunctionalState;
#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))

typedef enum
{
  SUCCESS = 0,
  ERROR = !SUCCESS
} ErrorStatus;

/**
  * @}
  */


/** @addtogroup Exported_macros
  * @{
  */
#define SET_BIT(REG,BIT) ((REG) |= (BIT))

#define CLEAR_BIT(REG,BIT) ((REG) &= ~(BIT))

#define READ_BIT(REG,BIT) ((REG) & (BIT))

#define CLEAR_REG(REG) ((REG) = (0x0))

#define WRITE_REG(REG,VAL) ((REG) = (VAL))

#define READ_REG(REG) ((REG))

#define MODIFY_REG(REG,CLEARMASK,SETMASK) WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))

#define POSITION_VAL(VAL) (__CLZ(__RBIT(VAL)))

/* Use of CMSIS compiler intrinsics for register exclusive access */
/* Atomic 32-bit register access macro to set one or several bits */
#define ATOMIC_SET_BIT(REG,BIT) do { uint32_t val; do { val = __LDREXW((__IO uint32_t *)&(REG)) | (BIT); } while ((__STREXW(val,(__IO uint32_t *)&(REG))) != 0U); } while(0)







/* Atomic 32-bit register access macro to clear one or several bits */
#define ATOMIC_CLEAR_BIT(REG,BIT) do { uint32_t val; do { val = __LDREXW((__IO uint32_t *)&(REG)) & ~(BIT); } while ((__STREXW(val,(__IO uint32_t *)&(REG))) != 0U); } while(0)







/* Atomic 32-bit register access macro to clear and set one or several bits */
#define ATOMIC_MODIFY_REG(REG,CLEARMSK,SETMASK) do { uint32_t val; do { val = (__LDREXW((__IO uint32_t *)&(REG)) & ~(CLEARMSK)) | (SETMASK); } while ((__STREXW(val,(__IO uint32_t *)&(REG))) != 0U); } while(0)







/* Atomic 16-bit register access macro to set one or several bits */
#define ATOMIC_SETH_BIT(REG,BIT) do { uint16_t val; do { val = __LDREXH((__IO uint16_t *)&(REG)) | (BIT); } while ((__STREXH(val,(__IO uint16_t *)&(REG))) != 0U); } while(0)







/* Atomic 16-bit register access macro to clear one or several bits */
#define ATOMIC_CLEARH_BIT(REG,BIT) do { uint16_t val; do { val = __LDREXH((__IO uint16_t *)&(REG)) & ~(BIT); } while ((__STREXH(val,(__IO uint16_t *)&(REG))) != 0U); } while(0)







/* Atomic 16-bit register access macro to clear and set one or several bits */
#define ATOMIC_MODIFYH_REG(REG,CLEARMSK,SETMASK) do { uint16_t val; do { val = (__LDREXH((__IO uint16_t *)&(REG)) & ~(CLEARMSK)) | (SETMASK); } while ((__STREXH(val,(__IO uint16_t *)&(REG))) != 0U); } while(0)








/**
  * @}
  */


 # 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal.h
  * @author  MCD Application Team
  * @brief   This file contains all the functions prototypes for the HAL
  *          module driver.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
# 630 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal.h"

# 252 "Drivers/CMSIS/Device/ST/STM32G4xx/Include/stm32g4xx.h" 2







/**
  * @}
  */

/**
  * @}
  */




# 30 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_def.h" 2
# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h" 1
/**
  ******************************************************************************
  * @file    stm32_hal_legacy.h
  * @author  MCD Application Team
  * @brief   This file contains aliases definition for the STM32Cube HAL constants
  *          macros and functions maintained for legacy purpose.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32_HAL_LEGACY 





/* Includes ------------------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/

/** @defgroup HAL_AES_Aliased_Defines HAL CRYP Aliased Defines maintained for legacy purpose
  * @{
  */
#define AES_FLAG_RDERR CRYP_FLAG_RDERR
#define AES_FLAG_WRERR CRYP_FLAG_WRERR
#define AES_CLEARFLAG_CCF CRYP_CLEARFLAG_CCF
#define AES_CLEARFLAG_RDERR CRYP_CLEARFLAG_RDERR
#define AES_CLEARFLAG_WRERR CRYP_CLEARFLAG_WRERR






/**
  * @}
  */

/** @defgroup HAL_ADC_Aliased_Defines HAL ADC Aliased Defines maintained for legacy purpose
  * @{
  */
#define ADC_RESOLUTION12b ADC_RESOLUTION_12B
#define ADC_RESOLUTION10b ADC_RESOLUTION_10B
#define ADC_RESOLUTION8b ADC_RESOLUTION_8B
#define ADC_RESOLUTION6b ADC_RESOLUTION_6B
#define OVR_DATA_OVERWRITTEN ADC_OVR_DATA_OVERWRITTEN
#define OVR_DATA_PRESERVED ADC_OVR_DATA_PRESERVED
#define EOC_SINGLE_CONV ADC_EOC_SINGLE_CONV
#define EOC_SEQ_CONV ADC_EOC_SEQ_CONV
#define EOC_SINGLE_SEQ_CONV ADC_EOC_SINGLE_SEQ_CONV
#define REGULAR_GROUP ADC_REGULAR_GROUP
#define INJECTED_GROUP ADC_INJECTED_GROUP
#define REGULAR_INJECTED_GROUP ADC_REGULAR_INJECTED_GROUP
#define AWD_EVENT ADC_AWD_EVENT
#define AWD1_EVENT ADC_AWD1_EVENT
#define AWD2_EVENT ADC_AWD2_EVENT
#define AWD3_EVENT ADC_AWD3_EVENT
#define OVR_EVENT ADC_OVR_EVENT
#define JQOVF_EVENT ADC_JQOVF_EVENT
#define ALL_CHANNELS ADC_ALL_CHANNELS
#define REGULAR_CHANNELS ADC_REGULAR_CHANNELS
#define INJECTED_CHANNELS ADC_INJECTED_CHANNELS
#define SYSCFG_FLAG_SENSOR_ADC ADC_FLAG_SENSOR
#define SYSCFG_FLAG_VREF_ADC ADC_FLAG_VREFINT
#define ADC_CLOCKPRESCALER_PCLK_DIV1 ADC_CLOCK_SYNC_PCLK_DIV1
#define ADC_CLOCKPRESCALER_PCLK_DIV2 ADC_CLOCK_SYNC_PCLK_DIV2
#define ADC_CLOCKPRESCALER_PCLK_DIV4 ADC_CLOCK_SYNC_PCLK_DIV4
#define ADC_CLOCKPRESCALER_PCLK_DIV6 ADC_CLOCK_SYNC_PCLK_DIV6
#define ADC_CLOCKPRESCALER_PCLK_DIV8 ADC_CLOCK_SYNC_PCLK_DIV8
#define ADC_EXTERNALTRIG0_T6_TRGO ADC_EXTERNALTRIGCONV_T6_TRGO
#define ADC_EXTERNALTRIG1_T21_CC2 ADC_EXTERNALTRIGCONV_T21_CC2
#define ADC_EXTERNALTRIG2_T2_TRGO ADC_EXTERNALTRIGCONV_T2_TRGO
#define ADC_EXTERNALTRIG3_T2_CC4 ADC_EXTERNALTRIGCONV_T2_CC4
#define ADC_EXTERNALTRIG4_T22_TRGO ADC_EXTERNALTRIGCONV_T22_TRGO
#define ADC_EXTERNALTRIG7_EXT_IT11 ADC_EXTERNALTRIGCONV_EXT_IT11
#define ADC_CLOCK_ASYNC ADC_CLOCK_ASYNC_DIV1
#define ADC_EXTERNALTRIG_EDGE_NONE ADC_EXTERNALTRIGCONVEDGE_NONE
#define ADC_EXTERNALTRIG_EDGE_RISING ADC_EXTERNALTRIGCONVEDGE_RISING
#define ADC_EXTERNALTRIG_EDGE_FALLING ADC_EXTERNALTRIGCONVEDGE_FALLING
#define ADC_EXTERNALTRIG_EDGE_RISINGFALLING ADC_EXTERNALTRIGCONVEDGE_RISINGFALLING
#define ADC_SAMPLETIME_2CYCLE_5 ADC_SAMPLETIME_2CYCLES_5

#define HAL_ADC_STATE_BUSY_REG HAL_ADC_STATE_REG_BUSY
#define HAL_ADC_STATE_BUSY_INJ HAL_ADC_STATE_INJ_BUSY
#define HAL_ADC_STATE_EOC_REG HAL_ADC_STATE_REG_EOC
#define HAL_ADC_STATE_EOC_INJ HAL_ADC_STATE_INJ_EOC
#define HAL_ADC_STATE_ERROR HAL_ADC_STATE_ERROR_INTERNAL
#define HAL_ADC_STATE_BUSY HAL_ADC_STATE_BUSY_INTERNAL
#define HAL_ADC_STATE_AWD HAL_ADC_STATE_AWD1














/**
  * @}
  */

/** @defgroup HAL_CEC_Aliased_Defines HAL CEC Aliased Defines maintained for legacy purpose
  * @{
  */

#define __HAL_CEC_GET_IT __HAL_CEC_GET_FLAG

/**
  * @}
  */

/** @defgroup HAL_COMP_Aliased_Defines HAL COMP Aliased Defines maintained for legacy purpose
  * @{
  */
#define COMP_WINDOWMODE_DISABLED COMP_WINDOWMODE_DISABLE
#define COMP_WINDOWMODE_ENABLED COMP_WINDOWMODE_ENABLE
#define COMP_EXTI_LINE_COMP1_EVENT COMP_EXTI_LINE_COMP1
#define COMP_EXTI_LINE_COMP2_EVENT COMP_EXTI_LINE_COMP2
#define COMP_EXTI_LINE_COMP3_EVENT COMP_EXTI_LINE_COMP3
#define COMP_EXTI_LINE_COMP4_EVENT COMP_EXTI_LINE_COMP4
#define COMP_EXTI_LINE_COMP5_EVENT COMP_EXTI_LINE_COMP5
#define COMP_EXTI_LINE_COMP6_EVENT COMP_EXTI_LINE_COMP6
#define COMP_EXTI_LINE_COMP7_EVENT COMP_EXTI_LINE_COMP7




#define COMP_OUTPUT_COMP6TIM2OCREFCLR COMP_OUTPUT_COMP6_TIM2OCREFCLR





# 217 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"





/**
  * @}
  */

/** @defgroup HAL_CORTEX_Aliased_Defines HAL CORTEX Aliased Defines maintained for legacy purpose
  * @{
  */
#define __HAL_CORTEX_SYSTICKCLK_CONFIG HAL_SYSTICK_CLKSourceConfig





/**
  * @}
  */

/** @defgroup CRC_Aliases CRC API aliases
  * @{
  */


#define HAL_CRC_Input_Data_Reverse HAL_CRCEx_Input_Data_Reverse

#define HAL_CRC_Output_Data_Reverse HAL_CRCEx_Output_Data_Reverse


/**
  * @}
  */

/** @defgroup HAL_CRC_Aliased_Defines HAL CRC Aliased Defines maintained for legacy purpose
  * @{
  */

#define CRC_OUTPUTDATA_INVERSION_DISABLED CRC_OUTPUTDATA_INVERSION_DISABLE
#define CRC_OUTPUTDATA_INVERSION_ENABLED CRC_OUTPUTDATA_INVERSION_ENABLE

/**
  * @}
  */

/** @defgroup HAL_DAC_Aliased_Defines HAL DAC Aliased Defines maintained for legacy purpose
  * @{
  */

#define DAC1_CHANNEL_1 DAC_CHANNEL_1
#define DAC1_CHANNEL_2 DAC_CHANNEL_2
#define DAC2_CHANNEL_1 DAC_CHANNEL_1
#define DAC_WAVE_NONE 0x00000000U
#define DAC_WAVE_NOISE DAC_CR_WAVE1_0
#define DAC_WAVE_TRIANGLE DAC_CR_WAVE1_1
#define DAC_WAVEGENERATION_NONE DAC_WAVE_NONE
#define DAC_WAVEGENERATION_NOISE DAC_WAVE_NOISE
#define DAC_WAVEGENERATION_TRIANGLE DAC_WAVE_TRIANGLE


#define DAC_CHIPCONNECT_DISABLE DAC_CHIPCONNECT_EXTERNAL
#define DAC_CHIPCONNECT_ENABLE DAC_CHIPCONNECT_INTERNAL
















#define HAL_DAC_MSP_INIT_CB_ID HAL_DAC_MSPINIT_CB_ID
#define HAL_DAC_MSP_DEINIT_CB_ID HAL_DAC_MSPDEINIT_CB_ID


/**
  * @}
  */

/** @defgroup HAL_DMA_Aliased_Defines HAL DMA Aliased Defines maintained for legacy purpose
  * @{
  */
#define HAL_REMAPDMA_ADC_DMA_CH2 DMA_REMAP_ADC_DMA_CH2
#define HAL_REMAPDMA_USART1_TX_DMA_CH4 DMA_REMAP_USART1_TX_DMA_CH4
#define HAL_REMAPDMA_USART1_RX_DMA_CH5 DMA_REMAP_USART1_RX_DMA_CH5
#define HAL_REMAPDMA_TIM16_DMA_CH4 DMA_REMAP_TIM16_DMA_CH4
#define HAL_REMAPDMA_TIM17_DMA_CH2 DMA_REMAP_TIM17_DMA_CH2
#define HAL_REMAPDMA_USART3_DMA_CH32 DMA_REMAP_USART3_DMA_CH32
#define HAL_REMAPDMA_TIM16_DMA_CH6 DMA_REMAP_TIM16_DMA_CH6
#define HAL_REMAPDMA_TIM17_DMA_CH7 DMA_REMAP_TIM17_DMA_CH7
#define HAL_REMAPDMA_SPI2_DMA_CH67 DMA_REMAP_SPI2_DMA_CH67
#define HAL_REMAPDMA_USART2_DMA_CH67 DMA_REMAP_USART2_DMA_CH67
#define HAL_REMAPDMA_I2C1_DMA_CH76 DMA_REMAP_I2C1_DMA_CH76
#define HAL_REMAPDMA_TIM1_DMA_CH6 DMA_REMAP_TIM1_DMA_CH6
#define HAL_REMAPDMA_TIM2_DMA_CH7 DMA_REMAP_TIM2_DMA_CH7
#define HAL_REMAPDMA_TIM3_DMA_CH6 DMA_REMAP_TIM3_DMA_CH6

#define IS_HAL_REMAPDMA IS_DMA_REMAP
#define __HAL_REMAPDMA_CHANNEL_ENABLE __HAL_DMA_REMAP_CHANNEL_ENABLE
#define __HAL_REMAPDMA_CHANNEL_DISABLE __HAL_DMA_REMAP_CHANNEL_DISABLE

# 367 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

# 377 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

# 439 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"




/**
  * @}
  */

/** @defgroup HAL_FLASH_Aliased_Defines HAL FLASH Aliased Defines maintained for legacy purpose
  * @{
  */

#define TYPEPROGRAM_BYTE FLASH_TYPEPROGRAM_BYTE
#define TYPEPROGRAM_HALFWORD FLASH_TYPEPROGRAM_HALFWORD
#define TYPEPROGRAM_WORD FLASH_TYPEPROGRAM_WORD
#define TYPEPROGRAM_DOUBLEWORD FLASH_TYPEPROGRAM_DOUBLEWORD
#define TYPEERASE_SECTORS FLASH_TYPEERASE_SECTORS
#define TYPEERASE_PAGES FLASH_TYPEERASE_PAGES
#define TYPEERASE_PAGEERASE FLASH_TYPEERASE_PAGES
#define TYPEERASE_MASSERASE FLASH_TYPEERASE_MASSERASE
#define WRPSTATE_DISABLE OB_WRPSTATE_DISABLE
#define WRPSTATE_ENABLE OB_WRPSTATE_ENABLE
#define HAL_FLASH_TIMEOUT_VALUE FLASH_TIMEOUT_VALUE
#define OBEX_PCROP OPTIONBYTE_PCROP
#define OBEX_BOOTCONFIG OPTIONBYTE_BOOTCONFIG
#define PCROPSTATE_DISABLE OB_PCROP_STATE_DISABLE
#define PCROPSTATE_ENABLE OB_PCROP_STATE_ENABLE
#define TYPEERASEDATA_BYTE FLASH_TYPEERASEDATA_BYTE
#define TYPEERASEDATA_HALFWORD FLASH_TYPEERASEDATA_HALFWORD
#define TYPEERASEDATA_WORD FLASH_TYPEERASEDATA_WORD
#define TYPEPROGRAMDATA_BYTE FLASH_TYPEPROGRAMDATA_BYTE
#define TYPEPROGRAMDATA_HALFWORD FLASH_TYPEPROGRAMDATA_HALFWORD
#define TYPEPROGRAMDATA_WORD FLASH_TYPEPROGRAMDATA_WORD
#define TYPEPROGRAMDATA_FASTBYTE FLASH_TYPEPROGRAMDATA_FASTBYTE
#define TYPEPROGRAMDATA_FASTHALFWORD FLASH_TYPEPROGRAMDATA_FASTHALFWORD
#define TYPEPROGRAMDATA_FASTWORD FLASH_TYPEPROGRAMDATA_FASTWORD

#define PAGESIZE FLASH_PAGE_SIZE

#define TYPEPROGRAM_FASTBYTE FLASH_TYPEPROGRAM_BYTE
#define TYPEPROGRAM_FASTHALFWORD FLASH_TYPEPROGRAM_HALFWORD
#define TYPEPROGRAM_FASTWORD FLASH_TYPEPROGRAM_WORD
#define VOLTAGE_RANGE_1 FLASH_VOLTAGE_RANGE_1
#define VOLTAGE_RANGE_2 FLASH_VOLTAGE_RANGE_2
#define VOLTAGE_RANGE_3 FLASH_VOLTAGE_RANGE_3
#define VOLTAGE_RANGE_4 FLASH_VOLTAGE_RANGE_4
#define TYPEPROGRAM_FAST FLASH_TYPEPROGRAM_FAST
#define TYPEPROGRAM_FAST_AND_LAST FLASH_TYPEPROGRAM_FAST_AND_LAST
#define WRPAREA_BANK1_AREAA OB_WRPAREA_BANK1_AREAA
#define WRPAREA_BANK1_AREAB OB_WRPAREA_BANK1_AREAB
#define WRPAREA_BANK2_AREAA OB_WRPAREA_BANK2_AREAA
#define WRPAREA_BANK2_AREAB OB_WRPAREA_BANK2_AREAB
#define IWDG_STDBY_FREEZE OB_IWDG_STDBY_FREEZE
#define IWDG_STDBY_ACTIVE OB_IWDG_STDBY_RUN
#define IWDG_STOP_FREEZE OB_IWDG_STOP_FREEZE
#define IWDG_STOP_ACTIVE OB_IWDG_STOP_RUN
#define FLASH_ERROR_NONE HAL_FLASH_ERROR_NONE
#define FLASH_ERROR_RD HAL_FLASH_ERROR_RD
#define FLASH_ERROR_PG HAL_FLASH_ERROR_PROG
#define FLASH_ERROR_PGP HAL_FLASH_ERROR_PGS
#define FLASH_ERROR_WRP HAL_FLASH_ERROR_WRP
#define FLASH_ERROR_OPTV HAL_FLASH_ERROR_OPTV
#define FLASH_ERROR_OPTVUSR HAL_FLASH_ERROR_OPTVUSR
#define FLASH_ERROR_PROG HAL_FLASH_ERROR_PROG
#define FLASH_ERROR_OP HAL_FLASH_ERROR_OPERATION
#define FLASH_ERROR_PGA HAL_FLASH_ERROR_PGA
#define FLASH_ERROR_SIZE HAL_FLASH_ERROR_SIZE
#define FLASH_ERROR_SIZ HAL_FLASH_ERROR_SIZE
#define FLASH_ERROR_PGS HAL_FLASH_ERROR_PGS
#define FLASH_ERROR_MIS HAL_FLASH_ERROR_MIS
#define FLASH_ERROR_FAST HAL_FLASH_ERROR_FAST
#define FLASH_ERROR_FWWERR HAL_FLASH_ERROR_FWWERR
#define FLASH_ERROR_NOTZERO HAL_FLASH_ERROR_NOTZERO
#define FLASH_ERROR_OPERATION HAL_FLASH_ERROR_OPERATION
#define FLASH_ERROR_ERS HAL_FLASH_ERROR_ERS
#define OB_WDG_SW OB_IWDG_SW
#define OB_WDG_HW OB_IWDG_HW
#define OB_SDADC12_VDD_MONITOR_SET OB_SDACD_VDD_MONITOR_SET
#define OB_SDADC12_VDD_MONITOR_RESET OB_SDACD_VDD_MONITOR_RESET
#define OB_RAM_PARITY_CHECK_SET OB_SRAM_PARITY_SET
#define OB_RAM_PARITY_CHECK_RESET OB_SRAM_PARITY_RESET
#define IS_OB_SDADC12_VDD_MONITOR IS_OB_SDACD_VDD_MONITOR
#define OB_RDP_LEVEL0 OB_RDP_LEVEL_0
#define OB_RDP_LEVEL1 OB_RDP_LEVEL_1
#define OB_RDP_LEVEL2 OB_RDP_LEVEL_2




#define OB_BOOT_ENTRY_FORCED_NONE OB_BOOT_LOCK_DISABLE
#define OB_BOOT_ENTRY_FORCED_FLASH OB_BOOT_LOCK_ENABLE

# 541 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"
# 553 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"
# 563 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

/**
  * @}
  */

/** @defgroup HAL_JPEG_Aliased_Macros HAL JPEG Aliased Macros maintained for legacy purpose
  * @{
  */

# 580 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

/**
  * @}
  */

/** @defgroup HAL_SYSCFG_Aliased_Defines HAL SYSCFG Aliased Defines maintained for legacy purpose
  * @{
  */

#define HAL_SYSCFG_FASTMODEPLUS_I2C_PA9 I2C_FASTMODEPLUS_PA9
#define HAL_SYSCFG_FASTMODEPLUS_I2C_PA10 I2C_FASTMODEPLUS_PA10
#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB6 I2C_FASTMODEPLUS_PB6
#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB7 I2C_FASTMODEPLUS_PB7
#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB8 I2C_FASTMODEPLUS_PB8
#define HAL_SYSCFG_FASTMODEPLUS_I2C_PB9 I2C_FASTMODEPLUS_PB9
#define HAL_SYSCFG_FASTMODEPLUS_I2C1 I2C_FASTMODEPLUS_I2C1
#define HAL_SYSCFG_FASTMODEPLUS_I2C2 I2C_FASTMODEPLUS_I2C2
#define HAL_SYSCFG_FASTMODEPLUS_I2C3 I2C_FASTMODEPLUS_I2C3


#define HAL_SYSCFG_EnableIOAnalogSwitchBooster HAL_SYSCFG_EnableIOSwitchBooster
#define HAL_SYSCFG_DisableIOAnalogSwitchBooster HAL_SYSCFG_DisableIOSwitchBooster
#define HAL_SYSCFG_EnableIOAnalogSwitchVDD HAL_SYSCFG_EnableIOSwitchVDD
#define HAL_SYSCFG_DisableIOAnalogSwitchVDD HAL_SYSCFG_DisableIOSwitchVDD


# 614 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

# 713 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"


/**
  * @}
  */


/** @defgroup LL_FMC_Aliased_Defines LL FMC Aliased Defines maintained for compatibility purpose
  * @{
  */

#define FMC_NAND_PCC_WAIT_FEATURE_DISABLE FMC_NAND_WAIT_FEATURE_DISABLE
#define FMC_NAND_PCC_WAIT_FEATURE_ENABLE FMC_NAND_WAIT_FEATURE_ENABLE
#define FMC_NAND_PCC_MEM_BUS_WIDTH_8 FMC_NAND_MEM_BUS_WIDTH_8
#define FMC_NAND_PCC_MEM_BUS_WIDTH_16 FMC_NAND_MEM_BUS_WIDTH_16






/**
  * @}
  */

/** @defgroup LL_FSMC_Aliased_Defines LL FSMC Aliased Defines maintained for legacy purpose
  * @{
  */

#define FSMC_NORSRAM_TYPEDEF FSMC_NORSRAM_TypeDef
#define FSMC_NORSRAM_EXTENDED_TYPEDEF FSMC_NORSRAM_EXTENDED_TypeDef
/**
  * @}
  */

/** @defgroup HAL_GPIO_Aliased_Macros HAL GPIO Aliased Macros maintained for legacy purpose
  * @{
  */
#define GET_GPIO_SOURCE GPIO_GET_INDEX
#define GET_GPIO_INDEX GPIO_GET_INDEX
















# 785 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

#define GPIO_AF0_LPTIM GPIO_AF0_LPTIM1
#define GPIO_AF1_LPTIM GPIO_AF1_LPTIM1
#define GPIO_AF2_LPTIM GPIO_AF2_LPTIM1



#define GPIO_SPEED_LOW GPIO_SPEED_FREQ_LOW
#define GPIO_SPEED_MEDIUM GPIO_SPEED_FREQ_MEDIUM
#define GPIO_SPEED_FAST GPIO_SPEED_FREQ_HIGH
#define GPIO_SPEED_HIGH GPIO_SPEED_FREQ_VERY_HIGH















#define GPIO_AF6_DFSDM GPIO_AF6_DFSDM1









# 835 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"
/**
  * @}
  */

/** @defgroup HAL_GTZC_Aliased_Defines HAL GTZC Aliased Defines maintained for legacy purpose
  * @{
  */









# 863 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"
/**
  * @}
  */

/** @defgroup HAL_HRTIM_Aliased_Macros HAL HRTIM Aliased Macros maintained for legacy purpose
  * @{
  */
#define HRTIM_TIMDELAYEDPROTECTION_DISABLED HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DISABLED
#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT1_EEV68 HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT1_EEV6
#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT2_EEV68 HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT2_EEV6
#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDBOTH_EEV68 HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDBOTH_EEV6
#define HRTIM_TIMDELAYEDPROTECTION_BALANCED_EEV68 HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_BALANCED_EEV6
#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT1_DEEV79 HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT1_DEEV7
#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT2_DEEV79 HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT2_DEEV7
#define HRTIM_TIMDELAYEDPROTECTION_DELAYEDBOTH_EEV79 HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDBOTH_EEV7
#define HRTIM_TIMDELAYEDPROTECTION_BALANCED_EEV79 HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_BALANCED_EEV7

#define __HAL_HRTIM_SetCounter __HAL_HRTIM_SETCOUNTER
#define __HAL_HRTIM_GetCounter __HAL_HRTIM_GETCOUNTER
#define __HAL_HRTIM_SetPeriod __HAL_HRTIM_SETPERIOD
#define __HAL_HRTIM_GetPeriod __HAL_HRTIM_GETPERIOD
#define __HAL_HRTIM_SetClockPrescaler __HAL_HRTIM_SETCLOCKPRESCALER
#define __HAL_HRTIM_GetClockPrescaler __HAL_HRTIM_GETCLOCKPRESCALER
#define __HAL_HRTIM_SetCompare __HAL_HRTIM_SETCOMPARE
#define __HAL_HRTIM_GetCompare __HAL_HRTIM_GETCOMPARE


#define HRTIMInterruptResquests HRTIMInterruptRequests



#define HAL_HRTIM_ExternalEventCounterConfig HAL_HRTIM_ExtEventCounterConfig
#define HAL_HRTIM_ExternalEventCounterEnable HAL_HRTIM_ExtEventCounterEnable
#define HAL_HRTIM_ExternalEventCounterDisable HAL_HRTIM_ExtEventCounterDisable
#define HAL_HRTIM_ExternalEventCounterReset HAL_HRTIM_ExtEventCounterReset
#define HRTIM_TIMEEVENT_A HRTIM_EVENTCOUNTER_A
#define HRTIM_TIMEEVENT_B HRTIM_EVENTCOUNTER_B
#define HRTIM_TIMEEVENTRESETMODE_UNCONDITIONAL HRTIM_EVENTCOUNTER_RSTMODE_UNCONDITIONAL
#define HRTIM_TIMEEVENTRESETMODE_CONDITIONAL HRTIM_EVENTCOUNTER_RSTMODE_CONDITIONAL


# 1015 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

# 1031 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

/**
  * @}
  */

/** @defgroup HAL_I2C_Aliased_Defines HAL I2C Aliased Defines maintained for legacy purpose
  * @{
  */
#define I2C_DUALADDRESS_DISABLED I2C_DUALADDRESS_DISABLE
#define I2C_DUALADDRESS_ENABLED I2C_DUALADDRESS_ENABLE
#define I2C_GENERALCALL_DISABLED I2C_GENERALCALL_DISABLE
#define I2C_GENERALCALL_ENABLED I2C_GENERALCALL_ENABLE
#define I2C_NOSTRETCH_DISABLED I2C_NOSTRETCH_DISABLE
#define I2C_NOSTRETCH_ENABLED I2C_NOSTRETCH_ENABLE
#define I2C_ANALOGFILTER_ENABLED I2C_ANALOGFILTER_ENABLE
#define I2C_ANALOGFILTER_DISABLED I2C_ANALOGFILTER_DISABLE
# 1056 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"
/**
  * @}
  */

/** @defgroup HAL_IRDA_Aliased_Defines HAL IRDA Aliased Defines maintained for legacy purpose
  * @{
  */
#define IRDA_ONE_BIT_SAMPLE_DISABLED IRDA_ONE_BIT_SAMPLE_DISABLE
#define IRDA_ONE_BIT_SAMPLE_ENABLED IRDA_ONE_BIT_SAMPLE_ENABLE

/**
  * @}
  */

/** @defgroup HAL_IWDG_Aliased_Defines HAL IWDG Aliased Defines maintained for legacy purpose
  * @{
  */
#define KR_KEY_RELOAD IWDG_KEY_RELOAD
#define KR_KEY_ENABLE IWDG_KEY_ENABLE
#define KR_KEY_EWA IWDG_KEY_WRITE_ACCESS_ENABLE
#define KR_KEY_DWA IWDG_KEY_WRITE_ACCESS_DISABLE
/**
  * @}
  */

/** @defgroup HAL_LPTIM_Aliased_Defines HAL LPTIM Aliased Defines maintained for legacy purpose
  * @{
  */

#define LPTIM_CLOCKSAMPLETIME_DIRECTTRANSISTION LPTIM_CLOCKSAMPLETIME_DIRECTTRANSITION
#define LPTIM_CLOCKSAMPLETIME_2TRANSISTIONS LPTIM_CLOCKSAMPLETIME_2TRANSITIONS
#define LPTIM_CLOCKSAMPLETIME_4TRANSISTIONS LPTIM_CLOCKSAMPLETIME_4TRANSITIONS
#define LPTIM_CLOCKSAMPLETIME_8TRANSISTIONS LPTIM_CLOCKSAMPLETIME_8TRANSITIONS

#define LPTIM_CLOCKPOLARITY_RISINGEDGE LPTIM_CLOCKPOLARITY_RISING
#define LPTIM_CLOCKPOLARITY_FALLINGEDGE LPTIM_CLOCKPOLARITY_FALLING
#define LPTIM_CLOCKPOLARITY_BOTHEDGES LPTIM_CLOCKPOLARITY_RISING_FALLING

#define LPTIM_TRIGSAMPLETIME_DIRECTTRANSISTION LPTIM_TRIGSAMPLETIME_DIRECTTRANSITION
#define LPTIM_TRIGSAMPLETIME_2TRANSISTIONS LPTIM_TRIGSAMPLETIME_2TRANSITIONS
#define LPTIM_TRIGSAMPLETIME_4TRANSISTIONS LPTIM_TRIGSAMPLETIME_4TRANSITIONS
#define LPTIM_TRIGSAMPLETIME_8TRANSISTIONS LPTIM_TRIGSAMPLETIME_8TRANSITIONS

/* The following 3 definition have also been present in a temporary version of lptim.h */
/* They need to be renamed also to the right name, just in case */
#define LPTIM_TRIGSAMPLETIME_2TRANSITION LPTIM_TRIGSAMPLETIME_2TRANSITIONS
#define LPTIM_TRIGSAMPLETIME_4TRANSITION LPTIM_TRIGSAMPLETIME_4TRANSITIONS
#define LPTIM_TRIGSAMPLETIME_8TRANSITION LPTIM_TRIGSAMPLETIME_8TRANSITIONS


/** @defgroup HAL_LPTIM_Aliased_Defines HAL LPTIM Aliased Defines maintained for legacy purpose
  * @{
  */
#define HAL_LPTIM_ReadCompare HAL_LPTIM_ReadCapturedValue
/**
  * @}
  */






/**
  * @}
  */

/** @defgroup HAL_NAND_Aliased_Defines HAL NAND Aliased Defines maintained for legacy purpose
  * @{
  */
#define HAL_NAND_Read_Page HAL_NAND_Read_Page_8b
#define HAL_NAND_Write_Page HAL_NAND_Write_Page_8b
#define HAL_NAND_Read_SpareArea HAL_NAND_Read_SpareArea_8b
#define HAL_NAND_Write_SpareArea HAL_NAND_Write_SpareArea_8b

#define NAND_AddressTypedef NAND_AddressTypeDef

#define __ARRAY_ADDRESS ARRAY_ADDRESS
#define __ADDR_1st_CYCLE ADDR_1ST_CYCLE
#define __ADDR_2nd_CYCLE ADDR_2ND_CYCLE
#define __ADDR_3rd_CYCLE ADDR_3RD_CYCLE
#define __ADDR_4th_CYCLE ADDR_4TH_CYCLE
/**
  * @}
  */

/** @defgroup HAL_NOR_Aliased_Defines HAL NOR Aliased Defines maintained for legacy purpose
  * @{
  */
#define NOR_StatusTypedef HAL_NOR_StatusTypeDef
#define NOR_SUCCESS HAL_NOR_STATUS_SUCCESS
#define NOR_ONGOING HAL_NOR_STATUS_ONGOING
#define NOR_ERROR HAL_NOR_STATUS_ERROR
#define NOR_TIMEOUT HAL_NOR_STATUS_TIMEOUT

#define __NOR_WRITE NOR_WRITE
#define __NOR_ADDR_SHIFT NOR_ADDR_SHIFT
/**
  * @}
  */

/** @defgroup HAL_OPAMP_Aliased_Defines HAL OPAMP Aliased Defines maintained for legacy purpose
  * @{
  */

#define OPAMP_NONINVERTINGINPUT_VP0 OPAMP_NONINVERTINGINPUT_IO0
#define OPAMP_NONINVERTINGINPUT_VP1 OPAMP_NONINVERTINGINPUT_IO1
#define OPAMP_NONINVERTINGINPUT_VP2 OPAMP_NONINVERTINGINPUT_IO2
#define OPAMP_NONINVERTINGINPUT_VP3 OPAMP_NONINVERTINGINPUT_IO3

#define OPAMP_SEC_NONINVERTINGINPUT_VP0 OPAMP_SEC_NONINVERTINGINPUT_IO0
#define OPAMP_SEC_NONINVERTINGINPUT_VP1 OPAMP_SEC_NONINVERTINGINPUT_IO1
#define OPAMP_SEC_NONINVERTINGINPUT_VP2 OPAMP_SEC_NONINVERTINGINPUT_IO2
#define OPAMP_SEC_NONINVERTINGINPUT_VP3 OPAMP_SEC_NONINVERTINGINPUT_IO3

#define OPAMP_INVERTINGINPUT_VM0 OPAMP_INVERTINGINPUT_IO0
#define OPAMP_INVERTINGINPUT_VM1 OPAMP_INVERTINGINPUT_IO1

#define IOPAMP_INVERTINGINPUT_VM0 OPAMP_INVERTINGINPUT_IO0
#define IOPAMP_INVERTINGINPUT_VM1 OPAMP_INVERTINGINPUT_IO1

#define OPAMP_SEC_INVERTINGINPUT_VM0 OPAMP_SEC_INVERTINGINPUT_IO0
#define OPAMP_SEC_INVERTINGINPUT_VM1 OPAMP_SEC_INVERTINGINPUT_IO1

#define OPAMP_INVERTINGINPUT_VINM OPAMP_SEC_INVERTINGINPUT_IO1

#define OPAMP_PGACONNECT_NO OPAMP_PGA_CONNECT_INVERTINGINPUT_NO
#define OPAMP_PGACONNECT_VM0 OPAMP_PGA_CONNECT_INVERTINGINPUT_IO0
#define OPAMP_PGACONNECT_VM1 OPAMP_PGA_CONNECT_INVERTINGINPUT_IO1


#define HAL_OPAMP_MSP_INIT_CB_ID HAL_OPAMP_MSPINIT_CB_ID
#define HAL_OPAMP_MSP_DEINIT_CB_ID HAL_OPAMP_MSPDEINIT_CB_ID





#define OPAMP_POWERMODE_NORMAL OPAMP_POWERMODE_NORMALSPEED


/**
  * @}
  */

/** @defgroup HAL_I2S_Aliased_Defines HAL I2S Aliased Defines maintained for legacy purpose
  * @{
  */
#define I2S_STANDARD_PHILLIPS I2S_STANDARD_PHILIPS












/**
  * @}
  */

/** @defgroup HAL_PCCARD_Aliased_Defines HAL PCCARD Aliased Defines maintained for legacy purpose
  * @{
  */

/* Compact Flash-ATA registers description */
#define CF_DATA ATA_DATA
#define CF_SECTOR_COUNT ATA_SECTOR_COUNT
#define CF_SECTOR_NUMBER ATA_SECTOR_NUMBER
#define CF_CYLINDER_LOW ATA_CYLINDER_LOW
#define CF_CYLINDER_HIGH ATA_CYLINDER_HIGH
#define CF_CARD_HEAD ATA_CARD_HEAD
#define CF_STATUS_CMD ATA_STATUS_CMD
#define CF_STATUS_CMD_ALTERNATE ATA_STATUS_CMD_ALTERNATE
#define CF_COMMON_DATA_AREA ATA_COMMON_DATA_AREA

/* Compact Flash-ATA commands */
#define CF_READ_SECTOR_CMD ATA_READ_SECTOR_CMD
#define CF_WRITE_SECTOR_CMD ATA_WRITE_SECTOR_CMD
#define CF_ERASE_SECTOR_CMD ATA_ERASE_SECTOR_CMD
#define CF_IDENTIFY_CMD ATA_IDENTIFY_CMD

#define PCCARD_StatusTypedef HAL_PCCARD_StatusTypeDef
#define PCCARD_SUCCESS HAL_PCCARD_STATUS_SUCCESS
#define PCCARD_ONGOING HAL_PCCARD_STATUS_ONGOING
#define PCCARD_ERROR HAL_PCCARD_STATUS_ERROR
#define PCCARD_TIMEOUT HAL_PCCARD_STATUS_TIMEOUT
/**
  * @}
  */

/** @defgroup HAL_RTC_Aliased_Defines HAL RTC Aliased Defines maintained for legacy purpose
  * @{
  */

#define FORMAT_BIN RTC_FORMAT_BIN
#define FORMAT_BCD RTC_FORMAT_BCD

#define RTC_ALARMSUBSECONDMASK_None RTC_ALARMSUBSECONDMASK_NONE
#define RTC_TAMPERERASEBACKUP_DISABLED RTC_TAMPER_ERASE_BACKUP_DISABLE
#define RTC_TAMPERMASK_FLAG_DISABLED RTC_TAMPERMASK_FLAG_DISABLE
#define RTC_TAMPERMASK_FLAG_ENABLED RTC_TAMPERMASK_FLAG_ENABLE

#define RTC_MASKTAMPERFLAG_DISABLED RTC_TAMPERMASK_FLAG_DISABLE
#define RTC_MASKTAMPERFLAG_ENABLED RTC_TAMPERMASK_FLAG_ENABLE
#define RTC_TAMPERERASEBACKUP_ENABLED RTC_TAMPER_ERASE_BACKUP_ENABLE
#define RTC_TAMPER1_2_INTERRUPT RTC_ALL_TAMPER_INTERRUPT
#define RTC_TAMPER1_2_3_INTERRUPT RTC_ALL_TAMPER_INTERRUPT

#define RTC_TIMESTAMPPIN_PC13 RTC_TIMESTAMPPIN_DEFAULT
#define RTC_TIMESTAMPPIN_PA0 RTC_TIMESTAMPPIN_POS1
#define RTC_TIMESTAMPPIN_PI8 RTC_TIMESTAMPPIN_POS1
#define RTC_TIMESTAMPPIN_PC1 RTC_TIMESTAMPPIN_POS2

#define RTC_OUTPUT_REMAP_PC13 RTC_OUTPUT_REMAP_NONE
#define RTC_OUTPUT_REMAP_PB14 RTC_OUTPUT_REMAP_POS1
#define RTC_OUTPUT_REMAP_PB2 RTC_OUTPUT_REMAP_POS1

#define RTC_TAMPERPIN_PC13 RTC_TAMPERPIN_DEFAULT
#define RTC_TAMPERPIN_PA0 RTC_TAMPERPIN_POS1
#define RTC_TAMPERPIN_PI8 RTC_TAMPERPIN_POS1






# 1296 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"























/**
  * @}
  */


/** @defgroup HAL_SMARTCARD_Aliased_Defines HAL SMARTCARD Aliased Defines maintained for legacy purpose
  * @{
  */
#define SMARTCARD_NACK_ENABLED SMARTCARD_NACK_ENABLE
#define SMARTCARD_NACK_DISABLED SMARTCARD_NACK_DISABLE

#define SMARTCARD_ONEBIT_SAMPLING_DISABLED SMARTCARD_ONE_BIT_SAMPLE_DISABLE
#define SMARTCARD_ONEBIT_SAMPLING_ENABLED SMARTCARD_ONE_BIT_SAMPLE_ENABLE
#define SMARTCARD_ONEBIT_SAMPLING_DISABLE SMARTCARD_ONE_BIT_SAMPLE_DISABLE
#define SMARTCARD_ONEBIT_SAMPLING_ENABLE SMARTCARD_ONE_BIT_SAMPLE_ENABLE

#define SMARTCARD_TIMEOUT_DISABLED SMARTCARD_TIMEOUT_DISABLE
#define SMARTCARD_TIMEOUT_ENABLED SMARTCARD_TIMEOUT_ENABLE

#define SMARTCARD_LASTBIT_DISABLED SMARTCARD_LASTBIT_DISABLE
#define SMARTCARD_LASTBIT_ENABLED SMARTCARD_LASTBIT_ENABLE
/**
  * @}
  */


/** @defgroup HAL_SMBUS_Aliased_Defines HAL SMBUS Aliased Defines maintained for legacy purpose
  * @{
  */
#define SMBUS_DUALADDRESS_DISABLED SMBUS_DUALADDRESS_DISABLE
#define SMBUS_DUALADDRESS_ENABLED SMBUS_DUALADDRESS_ENABLE
#define SMBUS_GENERALCALL_DISABLED SMBUS_GENERALCALL_DISABLE
#define SMBUS_GENERALCALL_ENABLED SMBUS_GENERALCALL_ENABLE
#define SMBUS_NOSTRETCH_DISABLED SMBUS_NOSTRETCH_DISABLE
#define SMBUS_NOSTRETCH_ENABLED SMBUS_NOSTRETCH_ENABLE
#define SMBUS_ANALOGFILTER_ENABLED SMBUS_ANALOGFILTER_ENABLE
#define SMBUS_ANALOGFILTER_DISABLED SMBUS_ANALOGFILTER_DISABLE
#define SMBUS_PEC_DISABLED SMBUS_PEC_DISABLE
#define SMBUS_PEC_ENABLED SMBUS_PEC_ENABLE
#define HAL_SMBUS_STATE_SLAVE_LISTEN HAL_SMBUS_STATE_LISTEN
/**
  * @}
  */

/** @defgroup HAL_SPI_Aliased_Defines HAL SPI Aliased Defines maintained for legacy purpose
  * @{
  */
#define SPI_TIMODE_DISABLED SPI_TIMODE_DISABLE
#define SPI_TIMODE_ENABLED SPI_TIMODE_ENABLE

#define SPI_CRCCALCULATION_DISABLED SPI_CRCCALCULATION_DISABLE
#define SPI_CRCCALCULATION_ENABLED SPI_CRCCALCULATION_ENABLE

#define SPI_NSS_PULSE_DISABLED SPI_NSS_PULSE_DISABLE
#define SPI_NSS_PULSE_ENABLED SPI_NSS_PULSE_ENABLE

# 1389 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

/**
  * @}
  */

/** @defgroup HAL_TIM_Aliased_Defines HAL TIM Aliased Defines maintained for legacy purpose
  * @{
  */
#define CCER_CCxE_MASK TIM_CCER_CCxE_MASK
#define CCER_CCxNE_MASK TIM_CCER_CCxNE_MASK

#define TIM_DMABase_CR1 TIM_DMABASE_CR1
#define TIM_DMABase_CR2 TIM_DMABASE_CR2
#define TIM_DMABase_SMCR TIM_DMABASE_SMCR
#define TIM_DMABase_DIER TIM_DMABASE_DIER
#define TIM_DMABase_SR TIM_DMABASE_SR
#define TIM_DMABase_EGR TIM_DMABASE_EGR
#define TIM_DMABase_CCMR1 TIM_DMABASE_CCMR1
#define TIM_DMABase_CCMR2 TIM_DMABASE_CCMR2
#define TIM_DMABase_CCER TIM_DMABASE_CCER
#define TIM_DMABase_CNT TIM_DMABASE_CNT
#define TIM_DMABase_PSC TIM_DMABASE_PSC
#define TIM_DMABase_ARR TIM_DMABASE_ARR
#define TIM_DMABase_RCR TIM_DMABASE_RCR
#define TIM_DMABase_CCR1 TIM_DMABASE_CCR1
#define TIM_DMABase_CCR2 TIM_DMABASE_CCR2
#define TIM_DMABase_CCR3 TIM_DMABASE_CCR3
#define TIM_DMABase_CCR4 TIM_DMABASE_CCR4
#define TIM_DMABase_BDTR TIM_DMABASE_BDTR
#define TIM_DMABase_DCR TIM_DMABASE_DCR
#define TIM_DMABase_DMAR TIM_DMABASE_DMAR
#define TIM_DMABase_OR1 TIM_DMABASE_OR1
#define TIM_DMABase_CCMR3 TIM_DMABASE_CCMR3
#define TIM_DMABase_CCR5 TIM_DMABASE_CCR5
#define TIM_DMABase_CCR6 TIM_DMABASE_CCR6
#define TIM_DMABase_OR2 TIM_DMABASE_OR2
#define TIM_DMABase_OR3 TIM_DMABASE_OR3
#define TIM_DMABase_OR TIM_DMABASE_OR

#define TIM_EventSource_Update TIM_EVENTSOURCE_UPDATE
#define TIM_EventSource_CC1 TIM_EVENTSOURCE_CC1
#define TIM_EventSource_CC2 TIM_EVENTSOURCE_CC2
#define TIM_EventSource_CC3 TIM_EVENTSOURCE_CC3
#define TIM_EventSource_CC4 TIM_EVENTSOURCE_CC4
#define TIM_EventSource_COM TIM_EVENTSOURCE_COM
#define TIM_EventSource_Trigger TIM_EVENTSOURCE_TRIGGER
#define TIM_EventSource_Break TIM_EVENTSOURCE_BREAK
#define TIM_EventSource_Break2 TIM_EVENTSOURCE_BREAK2

#define TIM_DMABurstLength_1Transfer TIM_DMABURSTLENGTH_1TRANSFER
#define TIM_DMABurstLength_2Transfers TIM_DMABURSTLENGTH_2TRANSFERS
#define TIM_DMABurstLength_3Transfers TIM_DMABURSTLENGTH_3TRANSFERS
#define TIM_DMABurstLength_4Transfers TIM_DMABURSTLENGTH_4TRANSFERS
#define TIM_DMABurstLength_5Transfers TIM_DMABURSTLENGTH_5TRANSFERS
#define TIM_DMABurstLength_6Transfers TIM_DMABURSTLENGTH_6TRANSFERS
#define TIM_DMABurstLength_7Transfers TIM_DMABURSTLENGTH_7TRANSFERS
#define TIM_DMABurstLength_8Transfers TIM_DMABURSTLENGTH_8TRANSFERS
#define TIM_DMABurstLength_9Transfers TIM_DMABURSTLENGTH_9TRANSFERS
#define TIM_DMABurstLength_10Transfers TIM_DMABURSTLENGTH_10TRANSFERS
#define TIM_DMABurstLength_11Transfers TIM_DMABURSTLENGTH_11TRANSFERS
#define TIM_DMABurstLength_12Transfers TIM_DMABURSTLENGTH_12TRANSFERS
#define TIM_DMABurstLength_13Transfers TIM_DMABURSTLENGTH_13TRANSFERS
#define TIM_DMABurstLength_14Transfers TIM_DMABURSTLENGTH_14TRANSFERS
#define TIM_DMABurstLength_15Transfers TIM_DMABURSTLENGTH_15TRANSFERS
#define TIM_DMABurstLength_16Transfers TIM_DMABURSTLENGTH_16TRANSFERS
#define TIM_DMABurstLength_17Transfers TIM_DMABURSTLENGTH_17TRANSFERS
#define TIM_DMABurstLength_18Transfers TIM_DMABURSTLENGTH_18TRANSFERS










# 1483 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"





/**
  * @}
  */

/** @defgroup HAL_TSC_Aliased_Defines HAL TSC Aliased Defines maintained for legacy purpose
  * @{
  */
#define TSC_SYNC_POL_FALL TSC_SYNC_POLARITY_FALLING
#define TSC_SYNC_POL_RISE_HIGH TSC_SYNC_POLARITY_RISING
/**
  * @}
  */

/** @defgroup HAL_UART_Aliased_Defines HAL UART Aliased Defines maintained for legacy purpose
  * @{
  */
#define UART_ONEBIT_SAMPLING_DISABLED UART_ONE_BIT_SAMPLE_DISABLE
#define UART_ONEBIT_SAMPLING_ENABLED UART_ONE_BIT_SAMPLE_ENABLE
#define UART_ONE_BIT_SAMPLE_DISABLED UART_ONE_BIT_SAMPLE_DISABLE
#define UART_ONE_BIT_SAMPLE_ENABLED UART_ONE_BIT_SAMPLE_ENABLE

#define __HAL_UART_ONEBIT_ENABLE __HAL_UART_ONE_BIT_SAMPLE_ENABLE
#define __HAL_UART_ONEBIT_DISABLE __HAL_UART_ONE_BIT_SAMPLE_DISABLE

#define __DIV_SAMPLING16 UART_DIV_SAMPLING16
#define __DIVMANT_SAMPLING16 UART_DIVMANT_SAMPLING16
#define __DIVFRAQ_SAMPLING16 UART_DIVFRAQ_SAMPLING16
#define __UART_BRR_SAMPLING16 UART_BRR_SAMPLING16

#define __DIV_SAMPLING8 UART_DIV_SAMPLING8
#define __DIVMANT_SAMPLING8 UART_DIVMANT_SAMPLING8
#define __DIVFRAQ_SAMPLING8 UART_DIVFRAQ_SAMPLING8
#define __UART_BRR_SAMPLING8 UART_BRR_SAMPLING8

#define __DIV_LPUART UART_DIV_LPUART

#define UART_WAKEUPMETHODE_IDLELINE UART_WAKEUPMETHOD_IDLELINE
#define UART_WAKEUPMETHODE_ADDRESSMARK UART_WAKEUPMETHOD_ADDRESSMARK

/**
  * @}
  */


/** @defgroup HAL_USART_Aliased_Defines HAL USART Aliased Defines maintained for legacy purpose
  * @{
  */

#define USART_CLOCK_DISABLED USART_CLOCK_DISABLE
#define USART_CLOCK_ENABLED USART_CLOCK_ENABLE

#define USARTNACK_ENABLED USART_NACK_ENABLE
#define USARTNACK_DISABLED USART_NACK_DISABLE
/**
  * @}
  */

/** @defgroup HAL_WWDG_Aliased_Defines HAL WWDG Aliased Defines maintained for legacy purpose
  * @{
  */
#define CFR_BASE WWDG_CFR_BASE

/**
  * @}
  */

/** @defgroup HAL_CAN_Aliased_Defines HAL CAN Aliased Defines maintained for legacy purpose
  * @{
  */
#define CAN_FilterFIFO0 CAN_FILTER_FIFO0
#define CAN_FilterFIFO1 CAN_FILTER_FIFO1
#define CAN_IT_RQCP0 CAN_IT_TME
#define CAN_IT_RQCP1 CAN_IT_TME
#define CAN_IT_RQCP2 CAN_IT_TME
#define INAK_TIMEOUT CAN_TIMEOUT_VALUE
#define SLAK_TIMEOUT CAN_TIMEOUT_VALUE
#define CAN_TXSTATUS_FAILED ((uint8_t)0x00U)
#define CAN_TXSTATUS_OK ((uint8_t)0x01U)
#define CAN_TXSTATUS_PENDING ((uint8_t)0x02U)

/**
  * @}
  */

/** @defgroup HAL_ETH_Aliased_Defines HAL ETH Aliased Defines maintained for legacy purpose
  * @{
  */

#define VLAN_TAG ETH_VLAN_TAG
#define MIN_ETH_PAYLOAD ETH_MIN_ETH_PAYLOAD
#define MAX_ETH_PAYLOAD ETH_MAX_ETH_PAYLOAD
#define JUMBO_FRAME_PAYLOAD ETH_JUMBO_FRAME_PAYLOAD
#define MACMIIAR_CR_MASK ETH_MACMIIAR_CR_MASK
#define MACCR_CLEAR_MASK ETH_MACCR_CLEAR_MASK
#define MACFCR_CLEAR_MASK ETH_MACFCR_CLEAR_MASK
#define DMAOMR_CLEAR_MASK ETH_DMAOMR_CLEAR_MASK

#define ETH_MMCCR 0x00000100U
#define ETH_MMCRIR 0x00000104U
#define ETH_MMCTIR 0x00000108U
#define ETH_MMCRIMR 0x0000010CU
#define ETH_MMCTIMR 0x00000110U
#define ETH_MMCTGFSCCR 0x0000014CU
#define ETH_MMCTGFMSCCR 0x00000150U
#define ETH_MMCTGFCR 0x00000168U
#define ETH_MMCRFCECR 0x00000194U
#define ETH_MMCRFAECR 0x00000198U
#define ETH_MMCRGUFCR 0x000001C4U

#define ETH_MAC_TXFIFO_FULL 0x02000000U
#define ETH_MAC_TXFIFONOT_EMPTY 0x01000000U
#define ETH_MAC_TXFIFO_WRITE_ACTIVE 0x00400000U
#define ETH_MAC_TXFIFO_IDLE 0x00000000U
#define ETH_MAC_TXFIFO_READ 0x00100000U

#define ETH_MAC_TXFIFO_WAITING 0x00200000U

#define ETH_MAC_TXFIFO_WRITING 0x00300000U

#define ETH_MAC_TRANSMISSION_PAUSE 0x00080000U
#define ETH_MAC_TRANSMITFRAMECONTROLLER_IDLE 0x00000000U
#define ETH_MAC_TRANSMITFRAMECONTROLLER_WAITING 0x00020000U

#define ETH_MAC_TRANSMITFRAMECONTROLLER_GENRATING_PCF 0x00040000U

#define ETH_MAC_TRANSMITFRAMECONTROLLER_TRANSFERRING 0x00060000U

#define ETH_MAC_MII_TRANSMIT_ACTIVE 0x00010000U
#define ETH_MAC_RXFIFO_EMPTY 0x00000000U
#define ETH_MAC_RXFIFO_BELOW_THRESHOLD 0x00000100U

#define ETH_MAC_RXFIFO_ABOVE_THRESHOLD 0x00000200U

#define ETH_MAC_RXFIFO_FULL 0x00000300U


#define ETH_MAC_READCONTROLLER_IDLE 0x00000000U
#define ETH_MAC_READCONTROLLER_READING_DATA 0x00000020U
#define ETH_MAC_READCONTROLLER_READING_STATUS 0x00000040U


#define ETH_MAC_READCONTROLLER_FLUSHING 0x00000060U

#define ETH_MAC_RXFIFO_WRITE_ACTIVE 0x00000010U
#define ETH_MAC_SMALL_FIFO_NOTACTIVE 0x00000000U
#define ETH_MAC_SMALL_FIFO_READ_ACTIVE 0x00000002U
#define ETH_MAC_SMALL_FIFO_WRITE_ACTIVE 0x00000004U
#define ETH_MAC_SMALL_FIFO_RW_ACTIVE 0x00000006U
#define ETH_MAC_MII_RECEIVE_PROTOCOL_ACTIVE 0x00000001U

#define ETH_TxPacketConfig ETH_TxPacketConfigTypeDef

/**
  * @}
  */

/** @defgroup HAL_DCMI_Aliased_Defines HAL DCMI Aliased Defines maintained for legacy purpose
  * @{
  */
#define HAL_DCMI_ERROR_OVF HAL_DCMI_ERROR_OVR
#define DCMI_IT_OVF DCMI_IT_OVR
#define DCMI_FLAG_OVFRI DCMI_FLAG_OVRRI
#define DCMI_FLAG_OVFMI DCMI_FLAG_OVRMI

#define HAL_DCMI_ConfigCROP HAL_DCMI_ConfigCrop
#define HAL_DCMI_EnableCROP HAL_DCMI_EnableCrop
#define HAL_DCMI_DisableCROP HAL_DCMI_DisableCrop

/**
  * @}
  */

# 1687 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

# 1701 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

/** @defgroup HAL_PPP_Aliased_Defines HAL PPP Aliased Defines maintained for legacy purpose
  * @{
  */

/**
  * @}
  */

/* Exported functions --------------------------------------------------------*/

/** @defgroup HAL_CRYP_Aliased_Functions HAL CRYP Aliased Functions maintained for legacy purpose
  * @{
  */
#define HAL_CRYP_ComputationCpltCallback HAL_CRYPEx_ComputationCpltCallback
/**
  * @}
  */

/** @defgroup HAL_DCACHE_Aliased_Functions HAL DCACHE Aliased Functions maintained for legacy purpose
  * @{
  */






/**
  * @}
  */


/** @defgroup HASH_alias HASH API alias
  * @{
  */
#define HAL_HASHEx_IRQHandler HAL_HASH_IRQHandler
/**
  *
  * @}
  */

/** @defgroup HAL_HASH_Aliased_Functions HAL HASH Aliased Functions maintained for legacy purpose
  * @{
  */
#define HAL_HASH_STATETypeDef HAL_HASH_StateTypeDef
#define HAL_HASHPhaseTypeDef HAL_HASH_PhaseTypeDef
#define HAL_HMAC_MD5_Finish HAL_HASH_MD5_Finish
#define HAL_HMAC_SHA1_Finish HAL_HASH_SHA1_Finish
#define HAL_HMAC_SHA224_Finish HAL_HASH_SHA224_Finish
#define HAL_HMAC_SHA256_Finish HAL_HASH_SHA256_Finish

/*HASH Algorithm Selection*/

#define HASH_AlgoSelection_SHA1 HASH_ALGOSELECTION_SHA1
#define HASH_AlgoSelection_SHA224 HASH_ALGOSELECTION_SHA224
#define HASH_AlgoSelection_SHA256 HASH_ALGOSELECTION_SHA256
#define HASH_AlgoSelection_MD5 HASH_ALGOSELECTION_MD5

#define HASH_AlgoMode_HASH HASH_ALGOMODE_HASH
#define HASH_AlgoMode_HMAC HASH_ALGOMODE_HMAC

#define HASH_HMACKeyType_ShortKey HASH_HMAC_KEYTYPE_SHORTKEY
#define HASH_HMACKeyType_LongKey HASH_HMAC_KEYTYPE_LONGKEY

# 1789 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"
/**
  * @}
  */

/** @defgroup HAL_Aliased_Functions HAL Generic Aliased Functions maintained for legacy purpose
  * @{
  */
#define HAL_EnableDBGSleepMode HAL_DBGMCU_EnableDBGSleepMode
#define HAL_DisableDBGSleepMode HAL_DBGMCU_DisableDBGSleepMode
#define HAL_EnableDBGStopMode HAL_DBGMCU_EnableDBGStopMode
#define HAL_DisableDBGStopMode HAL_DBGMCU_DisableDBGStopMode
#define HAL_EnableDBGStandbyMode HAL_DBGMCU_EnableDBGStandbyMode
#define HAL_DisableDBGStandbyMode HAL_DBGMCU_DisableDBGStandbyMode
#define HAL_DBG_LowPowerConfig(Periph,cmd) (((cmd )==ENABLE)? HAL_DBGMCU_DBG_EnableLowPowerConfig(Periph) : HAL_DBGMCU_DBG_DisableLowPowerConfig(Periph))


#define HAL_VREFINT_OutputSelect HAL_SYSCFG_VREFINT_OutputSelect
#define HAL_Lock_Cmd(cmd) (((cmd)==ENABLE) ? HAL_SYSCFG_Enable_Lock_VREFINT() : HAL_SYSCFG_Disable_Lock_VREFINT())


#define HAL_VREFINT_Cmd(cmd) (((cmd)==ENABLE)? HAL_SYSCFG_EnableVREFINT() : HAL_SYSCFG_DisableVREFINT())

#define HAL_ADC_EnableBuffer_Cmd(cmd) (((cmd)==ENABLE) ? HAL_ADCEx_EnableVREFINT() : HAL_ADCEx_DisableVREFINT())
#define HAL_ADC_EnableBufferSensor_Cmd(cmd) (((cmd )==ENABLE) ? HAL_ADCEx_EnableVREFINTTempSensor() : HAL_ADCEx_DisableVREFINTTempSensor())










/**
  * @}
  */

/** @defgroup HAL_FLASH_Aliased_Functions HAL FLASH Aliased Functions maintained for legacy purpose
  * @{
  */
#define FLASH_HalfPageProgram HAL_FLASHEx_HalfPageProgram
#define FLASH_EnableRunPowerDown HAL_FLASHEx_EnableRunPowerDown
#define FLASH_DisableRunPowerDown HAL_FLASHEx_DisableRunPowerDown
#define HAL_DATA_EEPROMEx_Unlock HAL_FLASHEx_DATAEEPROM_Unlock
#define HAL_DATA_EEPROMEx_Lock HAL_FLASHEx_DATAEEPROM_Lock
#define HAL_DATA_EEPROMEx_Erase HAL_FLASHEx_DATAEEPROM_Erase
#define HAL_DATA_EEPROMEx_Program HAL_FLASHEx_DATAEEPROM_Program

/**
  * @}
 */

/** @defgroup HAL_I2C_Aliased_Functions HAL I2C Aliased Functions maintained for legacy purpose
  * @{
  */
#define HAL_I2CEx_AnalogFilter_Config HAL_I2CEx_ConfigAnalogFilter
#define HAL_I2CEx_DigitalFilter_Config HAL_I2CEx_ConfigDigitalFilter
#define HAL_FMPI2CEx_AnalogFilter_Config HAL_FMPI2CEx_ConfigAnalogFilter
#define HAL_FMPI2CEx_DigitalFilter_Config HAL_FMPI2CEx_ConfigDigitalFilter

#define HAL_I2CFastModePlusConfig(SYSCFG_I2CFastModePlus,cmd) (((cmd) == ENABLE)? HAL_I2CEx_EnableFastModePlus(SYSCFG_I2CFastModePlus): HAL_I2CEx_DisableFastModePlus(SYSCFG_I2CFastModePlus))






#define HAL_I2C_Master_Sequential_Transmit_IT HAL_I2C_Master_Seq_Transmit_IT
#define HAL_I2C_Master_Sequential_Receive_IT HAL_I2C_Master_Seq_Receive_IT
#define HAL_I2C_Slave_Sequential_Transmit_IT HAL_I2C_Slave_Seq_Transmit_IT
#define HAL_I2C_Slave_Sequential_Receive_IT HAL_I2C_Slave_Seq_Receive_IT




#define HAL_I2C_Master_Sequential_Transmit_DMA HAL_I2C_Master_Seq_Transmit_DMA
#define HAL_I2C_Master_Sequential_Receive_DMA HAL_I2C_Master_Seq_Receive_DMA
#define HAL_I2C_Slave_Sequential_Transmit_DMA HAL_I2C_Slave_Seq_Transmit_DMA
#define HAL_I2C_Slave_Sequential_Receive_DMA HAL_I2C_Slave_Seq_Receive_DMA


# 1881 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"
/**
  * @}
 */

/** @defgroup HAL_PWR_Aliased HAL PWR Aliased maintained for legacy purpose
  * @{
  */







#define HAL_PWR_PVDConfig HAL_PWR_ConfigPVD
#define HAL_PWR_DisableBkUpReg HAL_PWREx_DisableBkUpReg
#define HAL_PWR_DisableFlashPowerDown HAL_PWREx_DisableFlashPowerDown
#define HAL_PWR_DisableVddio2Monitor HAL_PWREx_DisableVddio2Monitor
#define HAL_PWR_EnableBkUpReg HAL_PWREx_EnableBkUpReg
#define HAL_PWR_EnableFlashPowerDown HAL_PWREx_EnableFlashPowerDown
#define HAL_PWR_EnableVddio2Monitor HAL_PWREx_EnableVddio2Monitor
#define HAL_PWR_PVD_PVM_IRQHandler HAL_PWREx_PVD_PVM_IRQHandler
#define HAL_PWR_PVDLevelConfig HAL_PWR_ConfigPVD
#define HAL_PWR_Vddio2Monitor_IRQHandler HAL_PWREx_Vddio2Monitor_IRQHandler
#define HAL_PWR_Vddio2MonitorCallback HAL_PWREx_Vddio2MonitorCallback
#define HAL_PWREx_ActivateOverDrive HAL_PWREx_EnableOverDrive
#define HAL_PWREx_DeactivateOverDrive HAL_PWREx_DisableOverDrive
#define HAL_PWREx_DisableSDADCAnalog HAL_PWREx_DisableSDADC
#define HAL_PWREx_EnableSDADCAnalog HAL_PWREx_EnableSDADC
#define HAL_PWREx_PVMConfig HAL_PWREx_ConfigPVM

#define PWR_MODE_NORMAL PWR_PVD_MODE_NORMAL
#define PWR_MODE_IT_RISING PWR_PVD_MODE_IT_RISING
#define PWR_MODE_IT_FALLING PWR_PVD_MODE_IT_FALLING
#define PWR_MODE_IT_RISING_FALLING PWR_PVD_MODE_IT_RISING_FALLING
#define PWR_MODE_EVENT_RISING PWR_PVD_MODE_EVENT_RISING
#define PWR_MODE_EVENT_FALLING PWR_PVD_MODE_EVENT_FALLING
#define PWR_MODE_EVENT_RISING_FALLING PWR_PVD_MODE_EVENT_RISING_FALLING

#define CR_OFFSET_BB PWR_CR_OFFSET_BB
#define CSR_OFFSET_BB PWR_CSR_OFFSET_BB
#define PMODE_BIT_NUMBER VOS_BIT_NUMBER
#define CR_PMODE_BB CR_VOS_BB

#define DBP_BitNumber DBP_BIT_NUMBER
#define PVDE_BitNumber PVDE_BIT_NUMBER
#define PMODE_BitNumber PMODE_BIT_NUMBER
#define EWUP_BitNumber EWUP_BIT_NUMBER
#define FPDS_BitNumber FPDS_BIT_NUMBER
#define ODEN_BitNumber ODEN_BIT_NUMBER
#define ODSWEN_BitNumber ODSWEN_BIT_NUMBER
#define MRLVDS_BitNumber MRLVDS_BIT_NUMBER
#define LPLVDS_BitNumber LPLVDS_BIT_NUMBER
#define BRE_BitNumber BRE_BIT_NUMBER

#define PWR_MODE_EVT PWR_PVD_MODE_NORMAL

# 2024 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

/**
  * @}
 */

/** @defgroup HAL_RTC_Aliased_Functions HAL RTC Aliased Functions maintained for legacy purpose
  * @{
  */







/**
  * @}
  */

/** @defgroup HAL_SMBUS_Aliased_Functions HAL SMBUS Aliased Functions maintained for legacy purpose
  * @{
  */
#define HAL_SMBUS_Slave_Listen_IT HAL_SMBUS_EnableListen_IT
#define HAL_SMBUS_SlaveAddrCallback HAL_SMBUS_AddrCallback
#define HAL_SMBUS_SlaveListenCpltCallback HAL_SMBUS_ListenCpltCallback
/**
  * @}
  */

/** @defgroup HAL_SPI_Aliased_Functions HAL SPI Aliased Functions maintained for legacy purpose
  * @{
  */
#define HAL_SPI_FlushRxFifo HAL_SPIEx_FlushRxFifo
/**
  * @}
  */

/** @defgroup HAL_TIM_Aliased_Functions HAL TIM Aliased Functions maintained for legacy purpose
  * @{
  */
#define HAL_TIM_DMADelayPulseCplt TIM_DMADelayPulseCplt
#define HAL_TIM_DMAError TIM_DMAError
#define HAL_TIM_DMACaptureCplt TIM_DMACaptureCplt
#define HAL_TIMEx_DMACommutationCplt TIMEx_DMACommutationCplt
# 2077 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"
/**
  * @}
  */

/** @defgroup HAL_UART_Aliased_Functions HAL UART Aliased Functions maintained for legacy purpose
  * @{
  */
#define HAL_UART_WakeupCallback HAL_UARTEx_WakeupCallback
/**
  * @}
  */

/** @defgroup HAL_LTDC_Aliased_Functions HAL LTDC Aliased Functions maintained for legacy purpose
  * @{
  */
#define HAL_LTDC_LineEvenCallback HAL_LTDC_LineEventCallback
#define HAL_LTDC_Relaod HAL_LTDC_Reload
#define HAL_LTDC_StructInitFromVideoConfig HAL_LTDCEx_StructInitFromVideoConfig
#define HAL_LTDC_StructInitFromAdaptedCommandConfig HAL_LTDCEx_StructInitFromAdaptedCommandConfig
/**
  * @}
  */


/** @defgroup HAL_PPP_Aliased_Functions HAL PPP Aliased Functions maintained for legacy purpose
  * @{
  */

/**
  * @}
  */

/* Exported macros ------------------------------------------------------------*/

/** @defgroup HAL_AES_Aliased_Macros HAL CRYP Aliased Macros maintained for legacy purpose
  * @{
  */
#define AES_IT_CC CRYP_IT_CC
#define AES_IT_ERR CRYP_IT_ERR
#define AES_FLAG_CCF CRYP_FLAG_CCF
/**
  * @}
  */

/** @defgroup HAL_Aliased_Macros HAL Generic Aliased Macros maintained for legacy purpose
  * @{
  */
#define __HAL_GET_BOOT_MODE __HAL_SYSCFG_GET_BOOT_MODE
#define __HAL_REMAPMEMORY_FLASH __HAL_SYSCFG_REMAPMEMORY_FLASH
#define __HAL_REMAPMEMORY_SYSTEMFLASH __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH
#define __HAL_REMAPMEMORY_SRAM __HAL_SYSCFG_REMAPMEMORY_SRAM
#define __HAL_REMAPMEMORY_FMC __HAL_SYSCFG_REMAPMEMORY_FMC
#define __HAL_REMAPMEMORY_FMC_SDRAM __HAL_SYSCFG_REMAPMEMORY_FMC_SDRAM
#define __HAL_REMAPMEMORY_FSMC __HAL_SYSCFG_REMAPMEMORY_FSMC
#define __HAL_REMAPMEMORY_QUADSPI __HAL_SYSCFG_REMAPMEMORY_QUADSPI
#define __HAL_FMC_BANK __HAL_SYSCFG_FMC_BANK
#define __HAL_GET_FLAG __HAL_SYSCFG_GET_FLAG
#define __HAL_CLEAR_FLAG __HAL_SYSCFG_CLEAR_FLAG
#define __HAL_VREFINT_OUT_ENABLE __HAL_SYSCFG_VREFINT_OUT_ENABLE
#define __HAL_VREFINT_OUT_DISABLE __HAL_SYSCFG_VREFINT_OUT_DISABLE
#define __HAL_SYSCFG_SRAM2_WRP_ENABLE __HAL_SYSCFG_SRAM2_WRP_0_31_ENABLE

#define SYSCFG_FLAG_VREF_READY SYSCFG_FLAG_VREFINT_READY
#define SYSCFG_FLAG_RC48 RCC_FLAG_HSI48
#define IS_SYSCFG_FASTMODEPLUS_CONFIG IS_I2C_FASTMODEPLUS
#define UFB_MODE_BitNumber UFB_MODE_BIT_NUMBER
#define CMP_PD_BitNumber CMP_PD_BIT_NUMBER

/**
  * @}
  */


/** @defgroup HAL_ADC_Aliased_Macros HAL ADC Aliased Macros maintained for legacy purpose
  * @{
  */
#define __ADC_ENABLE __HAL_ADC_ENABLE
#define __ADC_DISABLE __HAL_ADC_DISABLE
#define __HAL_ADC_ENABLING_CONDITIONS ADC_ENABLING_CONDITIONS
#define __HAL_ADC_DISABLING_CONDITIONS ADC_DISABLING_CONDITIONS
#define __HAL_ADC_IS_ENABLED ADC_IS_ENABLE
#define __ADC_IS_ENABLED ADC_IS_ENABLE
#define __HAL_ADC_IS_SOFTWARE_START_REGULAR ADC_IS_SOFTWARE_START_REGULAR
#define __HAL_ADC_IS_SOFTWARE_START_INJECTED ADC_IS_SOFTWARE_START_INJECTED
#define __HAL_ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED
#define __HAL_ADC_IS_CONVERSION_ONGOING_REGULAR ADC_IS_CONVERSION_ONGOING_REGULAR
#define __HAL_ADC_IS_CONVERSION_ONGOING_INJECTED ADC_IS_CONVERSION_ONGOING_INJECTED
#define __HAL_ADC_IS_CONVERSION_ONGOING ADC_IS_CONVERSION_ONGOING
#define __HAL_ADC_CLEAR_ERRORCODE ADC_CLEAR_ERRORCODE

#define __HAL_ADC_GET_RESOLUTION ADC_GET_RESOLUTION
#define __HAL_ADC_JSQR_RK ADC_JSQR_RK
#define __HAL_ADC_CFGR_AWD1CH ADC_CFGR_AWD1CH_SHIFT
#define __HAL_ADC_CFGR_AWD23CR ADC_CFGR_AWD23CR
#define __HAL_ADC_CFGR_INJECT_AUTO_CONVERSION ADC_CFGR_INJECT_AUTO_CONVERSION
#define __HAL_ADC_CFGR_INJECT_CONTEXT_QUEUE ADC_CFGR_INJECT_CONTEXT_QUEUE
#define __HAL_ADC_CFGR_INJECT_DISCCONTINUOUS ADC_CFGR_INJECT_DISCCONTINUOUS
#define __HAL_ADC_CFGR_REG_DISCCONTINUOUS ADC_CFGR_REG_DISCCONTINUOUS
#define __HAL_ADC_CFGR_DISCONTINUOUS_NUM ADC_CFGR_DISCONTINUOUS_NUM
#define __HAL_ADC_CFGR_AUTOWAIT ADC_CFGR_AUTOWAIT
#define __HAL_ADC_CFGR_CONTINUOUS ADC_CFGR_CONTINUOUS
#define __HAL_ADC_CFGR_OVERRUN ADC_CFGR_OVERRUN
#define __HAL_ADC_CFGR_DMACONTREQ ADC_CFGR_DMACONTREQ
#define __HAL_ADC_CFGR_EXTSEL ADC_CFGR_EXTSEL_SET
#define __HAL_ADC_JSQR_JEXTSEL ADC_JSQR_JEXTSEL_SET
#define __HAL_ADC_OFR_CHANNEL ADC_OFR_CHANNEL
#define __HAL_ADC_DIFSEL_CHANNEL ADC_DIFSEL_CHANNEL
#define __HAL_ADC_CALFACT_DIFF_SET ADC_CALFACT_DIFF_SET
#define __HAL_ADC_CALFACT_DIFF_GET ADC_CALFACT_DIFF_GET
#define __HAL_ADC_TRX_HIGHTHRESHOLD ADC_TRX_HIGHTHRESHOLD

#define __HAL_ADC_OFFSET_SHIFT_RESOLUTION ADC_OFFSET_SHIFT_RESOLUTION
#define __HAL_ADC_AWD1THRESHOLD_SHIFT_RESOLUTION ADC_AWD1THRESHOLD_SHIFT_RESOLUTION
#define __HAL_ADC_AWD23THRESHOLD_SHIFT_RESOLUTION ADC_AWD23THRESHOLD_SHIFT_RESOLUTION
#define __HAL_ADC_COMMON_REGISTER ADC_COMMON_REGISTER
#define __HAL_ADC_COMMON_CCR_MULTI ADC_COMMON_CCR_MULTI
#define __HAL_ADC_MULTIMODE_IS_ENABLED ADC_MULTIMODE_IS_ENABLE
#define __ADC_MULTIMODE_IS_ENABLED ADC_MULTIMODE_IS_ENABLE
#define __HAL_ADC_NONMULTIMODE_OR_MULTIMODEMASTER ADC_NONMULTIMODE_OR_MULTIMODEMASTER
#define __HAL_ADC_COMMON_ADC_OTHER ADC_COMMON_ADC_OTHER
#define __HAL_ADC_MULTI_SLAVE ADC_MULTI_SLAVE

#define __HAL_ADC_SQR1_L ADC_SQR1_L_SHIFT
#define __HAL_ADC_JSQR_JL ADC_JSQR_JL_SHIFT
#define __HAL_ADC_JSQR_RK_JL ADC_JSQR_RK_JL
#define __HAL_ADC_CR1_DISCONTINUOUS_NUM ADC_CR1_DISCONTINUOUS_NUM
#define __HAL_ADC_CR1_SCAN ADC_CR1_SCAN_SET
#define __HAL_ADC_CONVCYCLES_MAX_RANGE ADC_CONVCYCLES_MAX_RANGE
#define __HAL_ADC_CLOCK_PRESCALER_RANGE ADC_CLOCK_PRESCALER_RANGE
#define __HAL_ADC_GET_CLOCK_PRESCALER ADC_GET_CLOCK_PRESCALER

#define __HAL_ADC_SQR1 ADC_SQR1
#define __HAL_ADC_SMPR1 ADC_SMPR1
#define __HAL_ADC_SMPR2 ADC_SMPR2
#define __HAL_ADC_SQR3_RK ADC_SQR3_RK
#define __HAL_ADC_SQR2_RK ADC_SQR2_RK
#define __HAL_ADC_SQR1_RK ADC_SQR1_RK
#define __HAL_ADC_CR2_CONTINUOUS ADC_CR2_CONTINUOUS
#define __HAL_ADC_CR1_DISCONTINUOUS ADC_CR1_DISCONTINUOUS
#define __HAL_ADC_CR1_SCANCONV ADC_CR1_SCANCONV
#define __HAL_ADC_CR2_EOCSelection ADC_CR2_EOCSelection
#define __HAL_ADC_CR2_DMAContReq ADC_CR2_DMAContReq
#define __HAL_ADC_JSQR ADC_JSQR

#define __HAL_ADC_CHSELR_CHANNEL ADC_CHSELR_CHANNEL
#define __HAL_ADC_CFGR1_REG_DISCCONTINUOUS ADC_CFGR1_REG_DISCCONTINUOUS
#define __HAL_ADC_CFGR1_AUTOOFF ADC_CFGR1_AUTOOFF
#define __HAL_ADC_CFGR1_AUTOWAIT ADC_CFGR1_AUTOWAIT
#define __HAL_ADC_CFGR1_CONTINUOUS ADC_CFGR1_CONTINUOUS
#define __HAL_ADC_CFGR1_OVERRUN ADC_CFGR1_OVERRUN
#define __HAL_ADC_CFGR1_SCANDIR ADC_CFGR1_SCANDIR
#define __HAL_ADC_CFGR1_DMACONTREQ ADC_CFGR1_DMACONTREQ

/**
  * @}
  */

/** @defgroup HAL_DAC_Aliased_Macros HAL DAC Aliased Macros maintained for legacy purpose
  * @{
  */
#define __HAL_DHR12R1_ALIGNEMENT DAC_DHR12R1_ALIGNMENT
#define __HAL_DHR12R2_ALIGNEMENT DAC_DHR12R2_ALIGNMENT
#define __HAL_DHR12RD_ALIGNEMENT DAC_DHR12RD_ALIGNMENT
#define IS_DAC_GENERATE_WAVE IS_DAC_WAVE

/**
  * @}
  */

/** @defgroup HAL_DBGMCU_Aliased_Macros HAL DBGMCU Aliased Macros maintained for legacy purpose
  * @{
  */
#define __HAL_FREEZE_TIM1_DBGMCU __HAL_DBGMCU_FREEZE_TIM1
#define __HAL_UNFREEZE_TIM1_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM1
#define __HAL_FREEZE_TIM2_DBGMCU __HAL_DBGMCU_FREEZE_TIM2
#define __HAL_UNFREEZE_TIM2_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM2
#define __HAL_FREEZE_TIM3_DBGMCU __HAL_DBGMCU_FREEZE_TIM3
#define __HAL_UNFREEZE_TIM3_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM3
#define __HAL_FREEZE_TIM4_DBGMCU __HAL_DBGMCU_FREEZE_TIM4
#define __HAL_UNFREEZE_TIM4_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM4
#define __HAL_FREEZE_TIM5_DBGMCU __HAL_DBGMCU_FREEZE_TIM5
#define __HAL_UNFREEZE_TIM5_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM5
#define __HAL_FREEZE_TIM6_DBGMCU __HAL_DBGMCU_FREEZE_TIM6
#define __HAL_UNFREEZE_TIM6_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM6
#define __HAL_FREEZE_TIM7_DBGMCU __HAL_DBGMCU_FREEZE_TIM7
#define __HAL_UNFREEZE_TIM7_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM7
#define __HAL_FREEZE_TIM8_DBGMCU __HAL_DBGMCU_FREEZE_TIM8
#define __HAL_UNFREEZE_TIM8_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM8

#define __HAL_FREEZE_TIM9_DBGMCU __HAL_DBGMCU_FREEZE_TIM9
#define __HAL_UNFREEZE_TIM9_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM9
#define __HAL_FREEZE_TIM10_DBGMCU __HAL_DBGMCU_FREEZE_TIM10
#define __HAL_UNFREEZE_TIM10_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM10
#define __HAL_FREEZE_TIM11_DBGMCU __HAL_DBGMCU_FREEZE_TIM11
#define __HAL_UNFREEZE_TIM11_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM11
#define __HAL_FREEZE_TIM12_DBGMCU __HAL_DBGMCU_FREEZE_TIM12
#define __HAL_UNFREEZE_TIM12_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM12
#define __HAL_FREEZE_TIM13_DBGMCU __HAL_DBGMCU_FREEZE_TIM13
#define __HAL_UNFREEZE_TIM13_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM13
#define __HAL_FREEZE_TIM14_DBGMCU __HAL_DBGMCU_FREEZE_TIM14
#define __HAL_UNFREEZE_TIM14_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM14
#define __HAL_FREEZE_CAN2_DBGMCU __HAL_DBGMCU_FREEZE_CAN2
#define __HAL_UNFREEZE_CAN2_DBGMCU __HAL_DBGMCU_UNFREEZE_CAN2


#define __HAL_FREEZE_TIM15_DBGMCU __HAL_DBGMCU_FREEZE_TIM15
#define __HAL_UNFREEZE_TIM15_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM15
#define __HAL_FREEZE_TIM16_DBGMCU __HAL_DBGMCU_FREEZE_TIM16
#define __HAL_UNFREEZE_TIM16_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM16
#define __HAL_FREEZE_TIM17_DBGMCU __HAL_DBGMCU_FREEZE_TIM17
#define __HAL_UNFREEZE_TIM17_DBGMCU __HAL_DBGMCU_UNFREEZE_TIM17
#define __HAL_FREEZE_RTC_DBGMCU __HAL_DBGMCU_FREEZE_RTC
#define __HAL_UNFREEZE_RTC_DBGMCU __HAL_DBGMCU_UNFREEZE_RTC






#define __HAL_FREEZE_WWDG_DBGMCU __HAL_DBGMCU_FREEZE_WWDG
#define __HAL_UNFREEZE_WWDG_DBGMCU __HAL_DBGMCU_UNFREEZE_WWDG
#define __HAL_FREEZE_IWDG_DBGMCU __HAL_DBGMCU_FREEZE_IWDG
#define __HAL_UNFREEZE_IWDG_DBGMCU __HAL_DBGMCU_UNFREEZE_IWDG

#define __HAL_FREEZE_I2C1_TIMEOUT_DBGMCU __HAL_DBGMCU_FREEZE_I2C1_TIMEOUT
#define __HAL_UNFREEZE_I2C1_TIMEOUT_DBGMCU __HAL_DBGMCU_UNFREEZE_I2C1_TIMEOUT
#define __HAL_FREEZE_I2C2_TIMEOUT_DBGMCU __HAL_DBGMCU_FREEZE_I2C2_TIMEOUT
#define __HAL_UNFREEZE_I2C2_TIMEOUT_DBGMCU __HAL_DBGMCU_UNFREEZE_I2C2_TIMEOUT
#define __HAL_FREEZE_I2C3_TIMEOUT_DBGMCU __HAL_DBGMCU_FREEZE_I2C3_TIMEOUT
#define __HAL_UNFREEZE_I2C3_TIMEOUT_DBGMCU __HAL_DBGMCU_UNFREEZE_I2C3_TIMEOUT
#define __HAL_FREEZE_CAN1_DBGMCU __HAL_DBGMCU_FREEZE_CAN1
#define __HAL_UNFREEZE_CAN1_DBGMCU __HAL_DBGMCU_UNFREEZE_CAN1
#define __HAL_FREEZE_LPTIM1_DBGMCU __HAL_DBGMCU_FREEZE_LPTIM1
#define __HAL_UNFREEZE_LPTIM1_DBGMCU __HAL_DBGMCU_UNFREEZE_LPTIM1
#define __HAL_FREEZE_LPTIM2_DBGMCU __HAL_DBGMCU_FREEZE_LPTIM2
#define __HAL_UNFREEZE_LPTIM2_DBGMCU __HAL_DBGMCU_UNFREEZE_LPTIM2

/**
  * @}
  */

/** @defgroup HAL_COMP_Aliased_Macros HAL COMP Aliased Macros maintained for legacy purpose
  * @{
  */
# 2464 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"
#define __HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__) (((__EXTILINE__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() : __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE())

#define __HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() : __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE())

#define __HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__) (((__EXTILINE__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() : __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE())

#define __HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__) (((__EXTILINE__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() : __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE())

#define __HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__) (((__EXTILINE__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() : __HAL_COMP_COMP2_EXTI_ENABLE_IT())

#define __HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__) (((__EXTILINE__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() : __HAL_COMP_COMP2_EXTI_DISABLE_IT())

#define __HAL_COMP_EXTI_GET_FLAG(__FLAG__) (((__FLAG__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() : __HAL_COMP_COMP2_EXTI_GET_FLAG())

#define __HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__) (((__FLAG__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() : __HAL_COMP_COMP2_EXTI_CLEAR_FLAG())



#define __HAL_COMP_GET_EXTI_LINE COMP_GET_EXTI_LINE








/**
  * @}
  */

# 2507 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

/** @defgroup HAL_DAC_Aliased_Macros HAL DAC Aliased Macros maintained for legacy purpose
  * @{
  */

#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_WAVE_NONE) || ((WAVE) == DAC_WAVE_NOISE)|| ((WAVE) == DAC_WAVE_TRIANGLE))



/**
  * @}
  */

/** @defgroup HAL_FLASH_Aliased_Macros HAL FLASH Aliased Macros maintained for legacy purpose
  * @{
  */

#define IS_WRPAREA IS_OB_WRPAREA
#define IS_TYPEPROGRAM IS_FLASH_TYPEPROGRAM
#define IS_TYPEPROGRAMFLASH IS_FLASH_TYPEPROGRAM
#define IS_TYPEERASE IS_FLASH_TYPEERASE
#define IS_NBSECTORS IS_FLASH_NBSECTORS
#define IS_OB_WDG_SOURCE IS_OB_IWDG_SOURCE

/**
  * @}
  */

/** @defgroup HAL_I2C_Aliased_Macros HAL I2C Aliased Macros maintained for legacy purpose
  * @{
  */

#define __HAL_I2C_RESET_CR2 I2C_RESET_CR2
#define __HAL_I2C_GENERATE_START I2C_GENERATE_START



#define __HAL_I2C_FREQ_RANGE I2C_FREQ_RANGE

#define __HAL_I2C_RISE_TIME I2C_RISE_TIME
#define __HAL_I2C_SPEED_STANDARD I2C_SPEED_STANDARD
#define __HAL_I2C_SPEED_FAST I2C_SPEED_FAST
#define __HAL_I2C_SPEED I2C_SPEED
#define __HAL_I2C_7BIT_ADD_WRITE I2C_7BIT_ADD_WRITE
#define __HAL_I2C_7BIT_ADD_READ I2C_7BIT_ADD_READ
#define __HAL_I2C_10BIT_ADDRESS I2C_10BIT_ADDRESS
#define __HAL_I2C_10BIT_HEADER_WRITE I2C_10BIT_HEADER_WRITE
#define __HAL_I2C_10BIT_HEADER_READ I2C_10BIT_HEADER_READ
#define __HAL_I2C_MEM_ADD_MSB I2C_MEM_ADD_MSB
#define __HAL_I2C_MEM_ADD_LSB I2C_MEM_ADD_LSB
#define __HAL_I2C_FREQRANGE I2C_FREQRANGE
/**
  * @}
  */

/** @defgroup HAL_I2S_Aliased_Macros HAL I2S Aliased Macros maintained for legacy purpose
  * @{
  */

#define IS_I2S_INSTANCE IS_I2S_ALL_INSTANCE
#define IS_I2S_INSTANCE_EXT IS_I2S_ALL_INSTANCE_EXT





/**
  * @}
  */

/** @defgroup HAL_IRDA_Aliased_Macros HAL IRDA Aliased Macros maintained for legacy purpose
  * @{
  */

#define __IRDA_DISABLE __HAL_IRDA_DISABLE
#define __IRDA_ENABLE __HAL_IRDA_ENABLE

#define __HAL_IRDA_GETCLOCKSOURCE IRDA_GETCLOCKSOURCE
#define __HAL_IRDA_MASK_COMPUTATION IRDA_MASK_COMPUTATION
#define __IRDA_GETCLOCKSOURCE IRDA_GETCLOCKSOURCE
#define __IRDA_MASK_COMPUTATION IRDA_MASK_COMPUTATION

#define IS_IRDA_ONEBIT_SAMPLE IS_IRDA_ONE_BIT_SAMPLE


/**
  * @}
  */


/** @defgroup HAL_IWDG_Aliased_Macros HAL IWDG Aliased Macros maintained for legacy purpose
  * @{
  */
#define __HAL_IWDG_ENABLE_WRITE_ACCESS IWDG_ENABLE_WRITE_ACCESS
#define __HAL_IWDG_DISABLE_WRITE_ACCESS IWDG_DISABLE_WRITE_ACCESS
/**
  * @}
  */


/** @defgroup HAL_LPTIM_Aliased_Macros HAL LPTIM Aliased Macros maintained for legacy purpose
  * @{
  */

#define __HAL_LPTIM_ENABLE_INTERRUPT __HAL_LPTIM_ENABLE_IT
#define __HAL_LPTIM_DISABLE_INTERRUPT __HAL_LPTIM_DISABLE_IT
#define __HAL_LPTIM_GET_ITSTATUS __HAL_LPTIM_GET_IT_SOURCE

/**
  * @}
  */


/** @defgroup HAL_OPAMP_Aliased_Macros HAL OPAMP Aliased Macros maintained for legacy purpose
  * @{
  */
#define __OPAMP_CSR_OPAXPD OPAMP_CSR_OPAXPD
#define __OPAMP_CSR_S3SELX OPAMP_CSR_S3SELX
#define __OPAMP_CSR_S4SELX OPAMP_CSR_S4SELX
#define __OPAMP_CSR_S5SELX OPAMP_CSR_S5SELX
#define __OPAMP_CSR_S6SELX OPAMP_CSR_S6SELX
#define __OPAMP_CSR_OPAXCAL_L OPAMP_CSR_OPAXCAL_L
#define __OPAMP_CSR_OPAXCAL_H OPAMP_CSR_OPAXCAL_H
#define __OPAMP_CSR_OPAXLPM OPAMP_CSR_OPAXLPM
#define __OPAMP_CSR_ALL_SWITCHES OPAMP_CSR_ALL_SWITCHES
#define __OPAMP_CSR_ANAWSELX OPAMP_CSR_ANAWSELX
#define __OPAMP_CSR_OPAXCALOUT OPAMP_CSR_OPAXCALOUT
#define __OPAMP_OFFSET_TRIM_BITSPOSITION OPAMP_OFFSET_TRIM_BITSPOSITION
#define __OPAMP_OFFSET_TRIM_SET OPAMP_OFFSET_TRIM_SET

/**
  * @}
  */


/** @defgroup HAL_PWR_Aliased_Macros HAL PWR Aliased Macros maintained for legacy purpose
  * @{
  */
#define __HAL_PVD_EVENT_DISABLE __HAL_PWR_PVD_EXTI_DISABLE_EVENT
#define __HAL_PVD_EVENT_ENABLE __HAL_PWR_PVD_EXTI_ENABLE_EVENT
#define __HAL_PVD_EXTI_FALLINGTRIGGER_DISABLE __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE
#define __HAL_PVD_EXTI_FALLINGTRIGGER_ENABLE __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE
#define __HAL_PVD_EXTI_RISINGTRIGGER_DISABLE __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE
#define __HAL_PVD_EXTI_RISINGTRIGGER_ENABLE __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE
#define __HAL_PVM_EVENT_DISABLE __HAL_PWR_PVM_EVENT_DISABLE
#define __HAL_PVM_EVENT_ENABLE __HAL_PWR_PVM_EVENT_ENABLE
#define __HAL_PVM_EXTI_FALLINGTRIGGER_DISABLE __HAL_PWR_PVM_EXTI_FALLINGTRIGGER_DISABLE
#define __HAL_PVM_EXTI_FALLINGTRIGGER_ENABLE __HAL_PWR_PVM_EXTI_FALLINGTRIGGER_ENABLE
#define __HAL_PVM_EXTI_RISINGTRIGGER_DISABLE __HAL_PWR_PVM_EXTI_RISINGTRIGGER_DISABLE
#define __HAL_PVM_EXTI_RISINGTRIGGER_ENABLE __HAL_PWR_PVM_EXTI_RISINGTRIGGER_ENABLE
#define __HAL_PWR_INTERNALWAKEUP_DISABLE HAL_PWREx_DisableInternalWakeUpLine
#define __HAL_PWR_INTERNALWAKEUP_ENABLE HAL_PWREx_EnableInternalWakeUpLine
#define __HAL_PWR_PULL_UP_DOWN_CONFIG_DISABLE HAL_PWREx_DisablePullUpPullDownConfig
#define __HAL_PWR_PULL_UP_DOWN_CONFIG_ENABLE HAL_PWREx_EnablePullUpPullDownConfig
#define __HAL_PWR_PVD_EXTI_CLEAR_EGDE_TRIGGER() do { __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE(); __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); } while(0)


#define __HAL_PWR_PVD_EXTI_EVENT_DISABLE __HAL_PWR_PVD_EXTI_DISABLE_EVENT
#define __HAL_PWR_PVD_EXTI_EVENT_ENABLE __HAL_PWR_PVD_EXTI_ENABLE_EVENT
#define __HAL_PWR_PVD_EXTI_FALLINGTRIGGER_DISABLE __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE
#define __HAL_PWR_PVD_EXTI_FALLINGTRIGGER_ENABLE __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE
#define __HAL_PWR_PVD_EXTI_RISINGTRIGGER_DISABLE __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE
#define __HAL_PWR_PVD_EXTI_RISINGTRIGGER_ENABLE __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE
#define __HAL_PWR_PVD_EXTI_SET_FALLING_EGDE_TRIGGER __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE
#define __HAL_PWR_PVD_EXTI_SET_RISING_EDGE_TRIGGER __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE
#define __HAL_PWR_PVM_DISABLE() do { HAL_PWREx_DisablePVM1();HAL_PWREx_DisablePVM2(); HAL_PWREx_DisablePVM3();HAL_PWREx_DisablePVM4(); } while(0)


#define __HAL_PWR_PVM_ENABLE() do { HAL_PWREx_EnablePVM1();HAL_PWREx_EnablePVM2(); HAL_PWREx_EnablePVM3();HAL_PWREx_EnablePVM4(); } while(0)


#define __HAL_PWR_SRAM2CONTENT_PRESERVE_DISABLE HAL_PWREx_DisableSRAM2ContentRetention
#define __HAL_PWR_SRAM2CONTENT_PRESERVE_ENABLE HAL_PWREx_EnableSRAM2ContentRetention
#define __HAL_PWR_VDDIO2_DISABLE HAL_PWREx_DisableVddIO2
#define __HAL_PWR_VDDIO2_ENABLE HAL_PWREx_EnableVddIO2
#define __HAL_PWR_VDDIO2_EXTI_CLEAR_EGDE_TRIGGER __HAL_PWR_VDDIO2_EXTI_DISABLE_FALLING_EDGE
#define __HAL_PWR_VDDIO2_EXTI_SET_FALLING_EGDE_TRIGGER __HAL_PWR_VDDIO2_EXTI_ENABLE_FALLING_EDGE
#define __HAL_PWR_VDDUSB_DISABLE HAL_PWREx_DisableVddUSB
#define __HAL_PWR_VDDUSB_ENABLE HAL_PWREx_EnableVddUSB








#define __HAL_PVD_EXTI_CLEAR_FLAG __HAL_PWR_PVD_EXTI_CLEAR_FLAG
#define __HAL_PVD_EXTI_DISABLE_IT __HAL_PWR_PVD_EXTI_DISABLE_IT
#define __HAL_PVD_EXTI_ENABLE_IT __HAL_PWR_PVD_EXTI_ENABLE_IT
#define __HAL_PVD_EXTI_GENERATE_SWIT __HAL_PWR_PVD_EXTI_GENERATE_SWIT
#define __HAL_PVD_EXTI_GET_FLAG __HAL_PWR_PVD_EXTI_GET_FLAG

/**
  * @}
  */


/** @defgroup HAL_RCC_Aliased HAL RCC Aliased maintained for legacy purpose
  * @{
  */

#define RCC_StopWakeUpClock_MSI RCC_STOP_WAKEUPCLOCK_MSI
#define RCC_StopWakeUpClock_HSI RCC_STOP_WAKEUPCLOCK_HSI

#define HAL_RCC_CCSCallback HAL_RCC_CSSCallback
#define HAL_RC48_EnableBuffer_Cmd(cmd) (((cmd)==ENABLE) ? HAL_RCCEx_EnableHSI48_VREFINT() : HAL_RCCEx_DisableHSI48_VREFINT())


#define __ADC_CLK_DISABLE __HAL_RCC_ADC_CLK_DISABLE
#define __ADC_CLK_ENABLE __HAL_RCC_ADC_CLK_ENABLE
#define __ADC_CLK_SLEEP_DISABLE __HAL_RCC_ADC_CLK_SLEEP_DISABLE
#define __ADC_CLK_SLEEP_ENABLE __HAL_RCC_ADC_CLK_SLEEP_ENABLE
#define __ADC_FORCE_RESET __HAL_RCC_ADC_FORCE_RESET
#define __ADC_RELEASE_RESET __HAL_RCC_ADC_RELEASE_RESET
#define __ADC1_CLK_DISABLE __HAL_RCC_ADC1_CLK_DISABLE
#define __ADC1_CLK_ENABLE __HAL_RCC_ADC1_CLK_ENABLE
#define __ADC1_FORCE_RESET __HAL_RCC_ADC1_FORCE_RESET
#define __ADC1_RELEASE_RESET __HAL_RCC_ADC1_RELEASE_RESET
#define __ADC1_CLK_SLEEP_ENABLE __HAL_RCC_ADC1_CLK_SLEEP_ENABLE
#define __ADC1_CLK_SLEEP_DISABLE __HAL_RCC_ADC1_CLK_SLEEP_DISABLE
#define __ADC2_CLK_DISABLE __HAL_RCC_ADC2_CLK_DISABLE
#define __ADC2_CLK_ENABLE __HAL_RCC_ADC2_CLK_ENABLE
#define __ADC2_FORCE_RESET __HAL_RCC_ADC2_FORCE_RESET
#define __ADC2_RELEASE_RESET __HAL_RCC_ADC2_RELEASE_RESET
#define __ADC3_CLK_DISABLE __HAL_RCC_ADC3_CLK_DISABLE
#define __ADC3_CLK_ENABLE __HAL_RCC_ADC3_CLK_ENABLE
#define __ADC3_FORCE_RESET __HAL_RCC_ADC3_FORCE_RESET
#define __ADC3_RELEASE_RESET __HAL_RCC_ADC3_RELEASE_RESET
#define __AES_CLK_DISABLE __HAL_RCC_AES_CLK_DISABLE
#define __AES_CLK_ENABLE __HAL_RCC_AES_CLK_ENABLE
#define __AES_CLK_SLEEP_DISABLE __HAL_RCC_AES_CLK_SLEEP_DISABLE
#define __AES_CLK_SLEEP_ENABLE __HAL_RCC_AES_CLK_SLEEP_ENABLE
#define __AES_FORCE_RESET __HAL_RCC_AES_FORCE_RESET
#define __AES_RELEASE_RESET __HAL_RCC_AES_RELEASE_RESET
#define __CRYP_CLK_SLEEP_ENABLE __HAL_RCC_CRYP_CLK_SLEEP_ENABLE
#define __CRYP_CLK_SLEEP_DISABLE __HAL_RCC_CRYP_CLK_SLEEP_DISABLE
#define __CRYP_CLK_ENABLE __HAL_RCC_CRYP_CLK_ENABLE
#define __CRYP_CLK_DISABLE __HAL_RCC_CRYP_CLK_DISABLE
#define __CRYP_FORCE_RESET __HAL_RCC_CRYP_FORCE_RESET
#define __CRYP_RELEASE_RESET __HAL_RCC_CRYP_RELEASE_RESET
#define __AFIO_CLK_DISABLE __HAL_RCC_AFIO_CLK_DISABLE
#define __AFIO_CLK_ENABLE __HAL_RCC_AFIO_CLK_ENABLE
#define __AFIO_FORCE_RESET __HAL_RCC_AFIO_FORCE_RESET
#define __AFIO_RELEASE_RESET __HAL_RCC_AFIO_RELEASE_RESET
#define __AHB_FORCE_RESET __HAL_RCC_AHB_FORCE_RESET
#define __AHB_RELEASE_RESET __HAL_RCC_AHB_RELEASE_RESET
#define __AHB1_FORCE_RESET __HAL_RCC_AHB1_FORCE_RESET
#define __AHB1_RELEASE_RESET __HAL_RCC_AHB1_RELEASE_RESET
#define __AHB2_FORCE_RESET __HAL_RCC_AHB2_FORCE_RESET
#define __AHB2_RELEASE_RESET __HAL_RCC_AHB2_RELEASE_RESET
#define __AHB3_FORCE_RESET __HAL_RCC_AHB3_FORCE_RESET
#define __AHB3_RELEASE_RESET __HAL_RCC_AHB3_RELEASE_RESET
#define __APB1_FORCE_RESET __HAL_RCC_APB1_FORCE_RESET
#define __APB1_RELEASE_RESET __HAL_RCC_APB1_RELEASE_RESET
#define __APB2_FORCE_RESET __HAL_RCC_APB2_FORCE_RESET
#define __APB2_RELEASE_RESET __HAL_RCC_APB2_RELEASE_RESET






#define __BKP_CLK_DISABLE __HAL_RCC_BKP_CLK_DISABLE
#define __BKP_CLK_ENABLE __HAL_RCC_BKP_CLK_ENABLE
#define __BKP_FORCE_RESET __HAL_RCC_BKP_FORCE_RESET
#define __BKP_RELEASE_RESET __HAL_RCC_BKP_RELEASE_RESET
#define __CAN1_CLK_DISABLE __HAL_RCC_CAN1_CLK_DISABLE
#define __CAN1_CLK_ENABLE __HAL_RCC_CAN1_CLK_ENABLE
#define __CAN1_CLK_SLEEP_DISABLE __HAL_RCC_CAN1_CLK_SLEEP_DISABLE
#define __CAN1_CLK_SLEEP_ENABLE __HAL_RCC_CAN1_CLK_SLEEP_ENABLE
#define __CAN1_FORCE_RESET __HAL_RCC_CAN1_FORCE_RESET
#define __CAN1_RELEASE_RESET __HAL_RCC_CAN1_RELEASE_RESET
#define __CAN_CLK_DISABLE __HAL_RCC_CAN1_CLK_DISABLE
#define __CAN_CLK_ENABLE __HAL_RCC_CAN1_CLK_ENABLE
#define __CAN_FORCE_RESET __HAL_RCC_CAN1_FORCE_RESET
#define __CAN_RELEASE_RESET __HAL_RCC_CAN1_RELEASE_RESET
#define __CAN2_CLK_DISABLE __HAL_RCC_CAN2_CLK_DISABLE
#define __CAN2_CLK_ENABLE __HAL_RCC_CAN2_CLK_ENABLE
#define __CAN2_FORCE_RESET __HAL_RCC_CAN2_FORCE_RESET
#define __CAN2_RELEASE_RESET __HAL_RCC_CAN2_RELEASE_RESET
#define __CEC_CLK_DISABLE __HAL_RCC_CEC_CLK_DISABLE
#define __CEC_CLK_ENABLE __HAL_RCC_CEC_CLK_ENABLE
#define __COMP_CLK_DISABLE __HAL_RCC_COMP_CLK_DISABLE
#define __COMP_CLK_ENABLE __HAL_RCC_COMP_CLK_ENABLE
#define __COMP_FORCE_RESET __HAL_RCC_COMP_FORCE_RESET
#define __COMP_RELEASE_RESET __HAL_RCC_COMP_RELEASE_RESET
#define __COMP_CLK_SLEEP_ENABLE __HAL_RCC_COMP_CLK_SLEEP_ENABLE
#define __COMP_CLK_SLEEP_DISABLE __HAL_RCC_COMP_CLK_SLEEP_DISABLE
#define __CEC_FORCE_RESET __HAL_RCC_CEC_FORCE_RESET
#define __CEC_RELEASE_RESET __HAL_RCC_CEC_RELEASE_RESET
#define __CRC_CLK_DISABLE __HAL_RCC_CRC_CLK_DISABLE
#define __CRC_CLK_ENABLE __HAL_RCC_CRC_CLK_ENABLE
#define __CRC_CLK_SLEEP_DISABLE __HAL_RCC_CRC_CLK_SLEEP_DISABLE
#define __CRC_CLK_SLEEP_ENABLE __HAL_RCC_CRC_CLK_SLEEP_ENABLE
#define __CRC_FORCE_RESET __HAL_RCC_CRC_FORCE_RESET
#define __CRC_RELEASE_RESET __HAL_RCC_CRC_RELEASE_RESET
#define __DAC_CLK_DISABLE __HAL_RCC_DAC_CLK_DISABLE
#define __DAC_CLK_ENABLE __HAL_RCC_DAC_CLK_ENABLE
#define __DAC_FORCE_RESET __HAL_RCC_DAC_FORCE_RESET
#define __DAC_RELEASE_RESET __HAL_RCC_DAC_RELEASE_RESET
#define __DAC1_CLK_DISABLE __HAL_RCC_DAC1_CLK_DISABLE
#define __DAC1_CLK_ENABLE __HAL_RCC_DAC1_CLK_ENABLE
#define __DAC1_CLK_SLEEP_DISABLE __HAL_RCC_DAC1_CLK_SLEEP_DISABLE
#define __DAC1_CLK_SLEEP_ENABLE __HAL_RCC_DAC1_CLK_SLEEP_ENABLE
#define __DAC1_FORCE_RESET __HAL_RCC_DAC1_FORCE_RESET
#define __DAC1_RELEASE_RESET __HAL_RCC_DAC1_RELEASE_RESET
#define __DBGMCU_CLK_ENABLE __HAL_RCC_DBGMCU_CLK_ENABLE
#define __DBGMCU_CLK_DISABLE __HAL_RCC_DBGMCU_CLK_DISABLE
#define __DBGMCU_FORCE_RESET __HAL_RCC_DBGMCU_FORCE_RESET
#define __DBGMCU_RELEASE_RESET __HAL_RCC_DBGMCU_RELEASE_RESET
#define __DFSDM_CLK_DISABLE __HAL_RCC_DFSDM_CLK_DISABLE
#define __DFSDM_CLK_ENABLE __HAL_RCC_DFSDM_CLK_ENABLE
#define __DFSDM_CLK_SLEEP_DISABLE __HAL_RCC_DFSDM_CLK_SLEEP_DISABLE
#define __DFSDM_CLK_SLEEP_ENABLE __HAL_RCC_DFSDM_CLK_SLEEP_ENABLE
#define __DFSDM_FORCE_RESET __HAL_RCC_DFSDM_FORCE_RESET
#define __DFSDM_RELEASE_RESET __HAL_RCC_DFSDM_RELEASE_RESET
#define __DMA1_CLK_DISABLE __HAL_RCC_DMA1_CLK_DISABLE
#define __DMA1_CLK_ENABLE __HAL_RCC_DMA1_CLK_ENABLE
#define __DMA1_CLK_SLEEP_DISABLE __HAL_RCC_DMA1_CLK_SLEEP_DISABLE
#define __DMA1_CLK_SLEEP_ENABLE __HAL_RCC_DMA1_CLK_SLEEP_ENABLE
#define __DMA1_FORCE_RESET __HAL_RCC_DMA1_FORCE_RESET
#define __DMA1_RELEASE_RESET __HAL_RCC_DMA1_RELEASE_RESET
#define __DMA2_CLK_DISABLE __HAL_RCC_DMA2_CLK_DISABLE
#define __DMA2_CLK_ENABLE __HAL_RCC_DMA2_CLK_ENABLE
#define __DMA2_CLK_SLEEP_DISABLE __HAL_RCC_DMA2_CLK_SLEEP_DISABLE
#define __DMA2_CLK_SLEEP_ENABLE __HAL_RCC_DMA2_CLK_SLEEP_ENABLE
#define __DMA2_FORCE_RESET __HAL_RCC_DMA2_FORCE_RESET
#define __DMA2_RELEASE_RESET __HAL_RCC_DMA2_RELEASE_RESET
#define __ETHMAC_CLK_DISABLE __HAL_RCC_ETHMAC_CLK_DISABLE
#define __ETHMAC_CLK_ENABLE __HAL_RCC_ETHMAC_CLK_ENABLE
#define __ETHMAC_FORCE_RESET __HAL_RCC_ETHMAC_FORCE_RESET
#define __ETHMAC_RELEASE_RESET __HAL_RCC_ETHMAC_RELEASE_RESET
#define __ETHMACRX_CLK_DISABLE __HAL_RCC_ETHMACRX_CLK_DISABLE
#define __ETHMACRX_CLK_ENABLE __HAL_RCC_ETHMACRX_CLK_ENABLE
#define __ETHMACTX_CLK_DISABLE __HAL_RCC_ETHMACTX_CLK_DISABLE
#define __ETHMACTX_CLK_ENABLE __HAL_RCC_ETHMACTX_CLK_ENABLE
#define __FIREWALL_CLK_DISABLE __HAL_RCC_FIREWALL_CLK_DISABLE
#define __FIREWALL_CLK_ENABLE __HAL_RCC_FIREWALL_CLK_ENABLE
#define __FLASH_CLK_DISABLE __HAL_RCC_FLASH_CLK_DISABLE
#define __FLASH_CLK_ENABLE __HAL_RCC_FLASH_CLK_ENABLE
#define __FLASH_CLK_SLEEP_DISABLE __HAL_RCC_FLASH_CLK_SLEEP_DISABLE
#define __FLASH_CLK_SLEEP_ENABLE __HAL_RCC_FLASH_CLK_SLEEP_ENABLE
#define __FLASH_FORCE_RESET __HAL_RCC_FLASH_FORCE_RESET
#define __FLASH_RELEASE_RESET __HAL_RCC_FLASH_RELEASE_RESET
#define __FLITF_CLK_DISABLE __HAL_RCC_FLITF_CLK_DISABLE
#define __FLITF_CLK_ENABLE __HAL_RCC_FLITF_CLK_ENABLE
#define __FLITF_FORCE_RESET __HAL_RCC_FLITF_FORCE_RESET
#define __FLITF_RELEASE_RESET __HAL_RCC_FLITF_RELEASE_RESET
#define __FLITF_CLK_SLEEP_ENABLE __HAL_RCC_FLITF_CLK_SLEEP_ENABLE
#define __FLITF_CLK_SLEEP_DISABLE __HAL_RCC_FLITF_CLK_SLEEP_DISABLE
#define __FMC_CLK_DISABLE __HAL_RCC_FMC_CLK_DISABLE
#define __FMC_CLK_ENABLE __HAL_RCC_FMC_CLK_ENABLE
#define __FMC_CLK_SLEEP_DISABLE __HAL_RCC_FMC_CLK_SLEEP_DISABLE
#define __FMC_CLK_SLEEP_ENABLE __HAL_RCC_FMC_CLK_SLEEP_ENABLE
#define __FMC_FORCE_RESET __HAL_RCC_FMC_FORCE_RESET
#define __FMC_RELEASE_RESET __HAL_RCC_FMC_RELEASE_RESET
#define __FSMC_CLK_DISABLE __HAL_RCC_FSMC_CLK_DISABLE
#define __FSMC_CLK_ENABLE __HAL_RCC_FSMC_CLK_ENABLE
#define __GPIOA_CLK_DISABLE __HAL_RCC_GPIOA_CLK_DISABLE
#define __GPIOA_CLK_ENABLE __HAL_RCC_GPIOA_CLK_ENABLE
#define __GPIOA_CLK_SLEEP_DISABLE __HAL_RCC_GPIOA_CLK_SLEEP_DISABLE
#define __GPIOA_CLK_SLEEP_ENABLE __HAL_RCC_GPIOA_CLK_SLEEP_ENABLE
#define __GPIOA_FORCE_RESET __HAL_RCC_GPIOA_FORCE_RESET
#define __GPIOA_RELEASE_RESET __HAL_RCC_GPIOA_RELEASE_RESET
#define __GPIOB_CLK_DISABLE __HAL_RCC_GPIOB_CLK_DISABLE
#define __GPIOB_CLK_ENABLE __HAL_RCC_GPIOB_CLK_ENABLE
#define __GPIOB_CLK_SLEEP_DISABLE __HAL_RCC_GPIOB_CLK_SLEEP_DISABLE
#define __GPIOB_CLK_SLEEP_ENABLE __HAL_RCC_GPIOB_CLK_SLEEP_ENABLE
#define __GPIOB_FORCE_RESET __HAL_RCC_GPIOB_FORCE_RESET
#define __GPIOB_RELEASE_RESET __HAL_RCC_GPIOB_RELEASE_RESET
#define __GPIOC_CLK_DISABLE __HAL_RCC_GPIOC_CLK_DISABLE
#define __GPIOC_CLK_ENABLE __HAL_RCC_GPIOC_CLK_ENABLE
#define __GPIOC_CLK_SLEEP_DISABLE __HAL_RCC_GPIOC_CLK_SLEEP_DISABLE
#define __GPIOC_CLK_SLEEP_ENABLE __HAL_RCC_GPIOC_CLK_SLEEP_ENABLE
#define __GPIOC_FORCE_RESET __HAL_RCC_GPIOC_FORCE_RESET
#define __GPIOC_RELEASE_RESET __HAL_RCC_GPIOC_RELEASE_RESET
#define __GPIOD_CLK_DISABLE __HAL_RCC_GPIOD_CLK_DISABLE
#define __GPIOD_CLK_ENABLE __HAL_RCC_GPIOD_CLK_ENABLE
#define __GPIOD_CLK_SLEEP_DISABLE __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE
#define __GPIOD_CLK_SLEEP_ENABLE __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE
#define __GPIOD_FORCE_RESET __HAL_RCC_GPIOD_FORCE_RESET
#define __GPIOD_RELEASE_RESET __HAL_RCC_GPIOD_RELEASE_RESET
#define __GPIOE_CLK_DISABLE __HAL_RCC_GPIOE_CLK_DISABLE
#define __GPIOE_CLK_ENABLE __HAL_RCC_GPIOE_CLK_ENABLE
#define __GPIOE_CLK_SLEEP_DISABLE __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE
#define __GPIOE_CLK_SLEEP_ENABLE __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE
#define __GPIOE_FORCE_RESET __HAL_RCC_GPIOE_FORCE_RESET
#define __GPIOE_RELEASE_RESET __HAL_RCC_GPIOE_RELEASE_RESET
#define __GPIOF_CLK_DISABLE __HAL_RCC_GPIOF_CLK_DISABLE
#define __GPIOF_CLK_ENABLE __HAL_RCC_GPIOF_CLK_ENABLE
#define __GPIOF_CLK_SLEEP_DISABLE __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE
#define __GPIOF_CLK_SLEEP_ENABLE __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE
#define __GPIOF_FORCE_RESET __HAL_RCC_GPIOF_FORCE_RESET
#define __GPIOF_RELEASE_RESET __HAL_RCC_GPIOF_RELEASE_RESET
#define __GPIOG_CLK_DISABLE __HAL_RCC_GPIOG_CLK_DISABLE
#define __GPIOG_CLK_ENABLE __HAL_RCC_GPIOG_CLK_ENABLE
#define __GPIOG_CLK_SLEEP_DISABLE __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE
#define __GPIOG_CLK_SLEEP_ENABLE __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE
#define __GPIOG_FORCE_RESET __HAL_RCC_GPIOG_FORCE_RESET
#define __GPIOG_RELEASE_RESET __HAL_RCC_GPIOG_RELEASE_RESET
#define __GPIOH_CLK_DISABLE __HAL_RCC_GPIOH_CLK_DISABLE
#define __GPIOH_CLK_ENABLE __HAL_RCC_GPIOH_CLK_ENABLE
#define __GPIOH_CLK_SLEEP_DISABLE __HAL_RCC_GPIOH_CLK_SLEEP_DISABLE
#define __GPIOH_CLK_SLEEP_ENABLE __HAL_RCC_GPIOH_CLK_SLEEP_ENABLE
#define __GPIOH_FORCE_RESET __HAL_RCC_GPIOH_FORCE_RESET
#define __GPIOH_RELEASE_RESET __HAL_RCC_GPIOH_RELEASE_RESET
#define __I2C1_CLK_DISABLE __HAL_RCC_I2C1_CLK_DISABLE
#define __I2C1_CLK_ENABLE __HAL_RCC_I2C1_CLK_ENABLE
#define __I2C1_CLK_SLEEP_DISABLE __HAL_RCC_I2C1_CLK_SLEEP_DISABLE
#define __I2C1_CLK_SLEEP_ENABLE __HAL_RCC_I2C1_CLK_SLEEP_ENABLE
#define __I2C1_FORCE_RESET __HAL_RCC_I2C1_FORCE_RESET
#define __I2C1_RELEASE_RESET __HAL_RCC_I2C1_RELEASE_RESET
#define __I2C2_CLK_DISABLE __HAL_RCC_I2C2_CLK_DISABLE
#define __I2C2_CLK_ENABLE __HAL_RCC_I2C2_CLK_ENABLE
#define __I2C2_CLK_SLEEP_DISABLE __HAL_RCC_I2C2_CLK_SLEEP_DISABLE
#define __I2C2_CLK_SLEEP_ENABLE __HAL_RCC_I2C2_CLK_SLEEP_ENABLE
#define __I2C2_FORCE_RESET __HAL_RCC_I2C2_FORCE_RESET
#define __I2C2_RELEASE_RESET __HAL_RCC_I2C2_RELEASE_RESET
#define __I2C3_CLK_DISABLE __HAL_RCC_I2C3_CLK_DISABLE
#define __I2C3_CLK_ENABLE __HAL_RCC_I2C3_CLK_ENABLE
#define __I2C3_CLK_SLEEP_DISABLE __HAL_RCC_I2C3_CLK_SLEEP_DISABLE
#define __I2C3_CLK_SLEEP_ENABLE __HAL_RCC_I2C3_CLK_SLEEP_ENABLE
#define __I2C3_FORCE_RESET __HAL_RCC_I2C3_FORCE_RESET
#define __I2C3_RELEASE_RESET __HAL_RCC_I2C3_RELEASE_RESET
#define __LCD_CLK_DISABLE __HAL_RCC_LCD_CLK_DISABLE
#define __LCD_CLK_ENABLE __HAL_RCC_LCD_CLK_ENABLE
#define __LCD_CLK_SLEEP_DISABLE __HAL_RCC_LCD_CLK_SLEEP_DISABLE
#define __LCD_CLK_SLEEP_ENABLE __HAL_RCC_LCD_CLK_SLEEP_ENABLE
#define __LCD_FORCE_RESET __HAL_RCC_LCD_FORCE_RESET
#define __LCD_RELEASE_RESET __HAL_RCC_LCD_RELEASE_RESET
#define __LPTIM1_CLK_DISABLE __HAL_RCC_LPTIM1_CLK_DISABLE
#define __LPTIM1_CLK_ENABLE __HAL_RCC_LPTIM1_CLK_ENABLE
#define __LPTIM1_CLK_SLEEP_DISABLE __HAL_RCC_LPTIM1_CLK_SLEEP_DISABLE
#define __LPTIM1_CLK_SLEEP_ENABLE __HAL_RCC_LPTIM1_CLK_SLEEP_ENABLE
#define __LPTIM1_FORCE_RESET __HAL_RCC_LPTIM1_FORCE_RESET
#define __LPTIM1_RELEASE_RESET __HAL_RCC_LPTIM1_RELEASE_RESET
#define __LPTIM2_CLK_DISABLE __HAL_RCC_LPTIM2_CLK_DISABLE
#define __LPTIM2_CLK_ENABLE __HAL_RCC_LPTIM2_CLK_ENABLE
#define __LPTIM2_CLK_SLEEP_DISABLE __HAL_RCC_LPTIM2_CLK_SLEEP_DISABLE
#define __LPTIM2_CLK_SLEEP_ENABLE __HAL_RCC_LPTIM2_CLK_SLEEP_ENABLE
#define __LPTIM2_FORCE_RESET __HAL_RCC_LPTIM2_FORCE_RESET
#define __LPTIM2_RELEASE_RESET __HAL_RCC_LPTIM2_RELEASE_RESET
#define __LPUART1_CLK_DISABLE __HAL_RCC_LPUART1_CLK_DISABLE
#define __LPUART1_CLK_ENABLE __HAL_RCC_LPUART1_CLK_ENABLE
#define __LPUART1_CLK_SLEEP_DISABLE __HAL_RCC_LPUART1_CLK_SLEEP_DISABLE
#define __LPUART1_CLK_SLEEP_ENABLE __HAL_RCC_LPUART1_CLK_SLEEP_ENABLE
#define __LPUART1_FORCE_RESET __HAL_RCC_LPUART1_FORCE_RESET
#define __LPUART1_RELEASE_RESET __HAL_RCC_LPUART1_RELEASE_RESET
#define __OPAMP_CLK_DISABLE __HAL_RCC_OPAMP_CLK_DISABLE
#define __OPAMP_CLK_ENABLE __HAL_RCC_OPAMP_CLK_ENABLE
#define __OPAMP_CLK_SLEEP_DISABLE __HAL_RCC_OPAMP_CLK_SLEEP_DISABLE
#define __OPAMP_CLK_SLEEP_ENABLE __HAL_RCC_OPAMP_CLK_SLEEP_ENABLE
#define __OPAMP_FORCE_RESET __HAL_RCC_OPAMP_FORCE_RESET
#define __OPAMP_RELEASE_RESET __HAL_RCC_OPAMP_RELEASE_RESET
#define __OTGFS_CLK_DISABLE __HAL_RCC_OTGFS_CLK_DISABLE
#define __OTGFS_CLK_ENABLE __HAL_RCC_OTGFS_CLK_ENABLE
#define __OTGFS_CLK_SLEEP_DISABLE __HAL_RCC_OTGFS_CLK_SLEEP_DISABLE
#define __OTGFS_CLK_SLEEP_ENABLE __HAL_RCC_OTGFS_CLK_SLEEP_ENABLE
#define __OTGFS_FORCE_RESET __HAL_RCC_OTGFS_FORCE_RESET
#define __OTGFS_RELEASE_RESET __HAL_RCC_OTGFS_RELEASE_RESET
#define __PWR_CLK_DISABLE __HAL_RCC_PWR_CLK_DISABLE
#define __PWR_CLK_ENABLE __HAL_RCC_PWR_CLK_ENABLE
#define __PWR_CLK_SLEEP_DISABLE __HAL_RCC_PWR_CLK_SLEEP_DISABLE
#define __PWR_CLK_SLEEP_ENABLE __HAL_RCC_PWR_CLK_SLEEP_ENABLE
#define __PWR_FORCE_RESET __HAL_RCC_PWR_FORCE_RESET
#define __PWR_RELEASE_RESET __HAL_RCC_PWR_RELEASE_RESET
#define __QSPI_CLK_DISABLE __HAL_RCC_QSPI_CLK_DISABLE
#define __QSPI_CLK_ENABLE __HAL_RCC_QSPI_CLK_ENABLE
#define __QSPI_CLK_SLEEP_DISABLE __HAL_RCC_QSPI_CLK_SLEEP_DISABLE
#define __QSPI_CLK_SLEEP_ENABLE __HAL_RCC_QSPI_CLK_SLEEP_ENABLE
#define __QSPI_FORCE_RESET __HAL_RCC_QSPI_FORCE_RESET
#define __QSPI_RELEASE_RESET __HAL_RCC_QSPI_RELEASE_RESET

# 2994 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

#define __RNG_CLK_DISABLE __HAL_RCC_RNG_CLK_DISABLE
#define __RNG_CLK_ENABLE __HAL_RCC_RNG_CLK_ENABLE
#define __RNG_CLK_SLEEP_DISABLE __HAL_RCC_RNG_CLK_SLEEP_DISABLE
#define __RNG_CLK_SLEEP_ENABLE __HAL_RCC_RNG_CLK_SLEEP_ENABLE
#define __RNG_FORCE_RESET __HAL_RCC_RNG_FORCE_RESET
#define __RNG_RELEASE_RESET __HAL_RCC_RNG_RELEASE_RESET
#define __SAI1_CLK_DISABLE __HAL_RCC_SAI1_CLK_DISABLE
#define __SAI1_CLK_ENABLE __HAL_RCC_SAI1_CLK_ENABLE
#define __SAI1_CLK_SLEEP_DISABLE __HAL_RCC_SAI1_CLK_SLEEP_DISABLE
#define __SAI1_CLK_SLEEP_ENABLE __HAL_RCC_SAI1_CLK_SLEEP_ENABLE
#define __SAI1_FORCE_RESET __HAL_RCC_SAI1_FORCE_RESET
#define __SAI1_RELEASE_RESET __HAL_RCC_SAI1_RELEASE_RESET
#define __SAI2_CLK_DISABLE __HAL_RCC_SAI2_CLK_DISABLE
#define __SAI2_CLK_ENABLE __HAL_RCC_SAI2_CLK_ENABLE
#define __SAI2_CLK_SLEEP_DISABLE __HAL_RCC_SAI2_CLK_SLEEP_DISABLE
#define __SAI2_CLK_SLEEP_ENABLE __HAL_RCC_SAI2_CLK_SLEEP_ENABLE
#define __SAI2_FORCE_RESET __HAL_RCC_SAI2_FORCE_RESET
#define __SAI2_RELEASE_RESET __HAL_RCC_SAI2_RELEASE_RESET
#define __SDIO_CLK_DISABLE __HAL_RCC_SDIO_CLK_DISABLE
#define __SDIO_CLK_ENABLE __HAL_RCC_SDIO_CLK_ENABLE
#define __SDMMC_CLK_DISABLE __HAL_RCC_SDMMC_CLK_DISABLE
#define __SDMMC_CLK_ENABLE __HAL_RCC_SDMMC_CLK_ENABLE
#define __SDMMC_CLK_SLEEP_DISABLE __HAL_RCC_SDMMC_CLK_SLEEP_DISABLE
#define __SDMMC_CLK_SLEEP_ENABLE __HAL_RCC_SDMMC_CLK_SLEEP_ENABLE
#define __SDMMC_FORCE_RESET __HAL_RCC_SDMMC_FORCE_RESET
#define __SDMMC_RELEASE_RESET __HAL_RCC_SDMMC_RELEASE_RESET
#define __SPI1_CLK_DISABLE __HAL_RCC_SPI1_CLK_DISABLE
#define __SPI1_CLK_ENABLE __HAL_RCC_SPI1_CLK_ENABLE
#define __SPI1_CLK_SLEEP_DISABLE __HAL_RCC_SPI1_CLK_SLEEP_DISABLE
#define __SPI1_CLK_SLEEP_ENABLE __HAL_RCC_SPI1_CLK_SLEEP_ENABLE
#define __SPI1_FORCE_RESET __HAL_RCC_SPI1_FORCE_RESET
#define __SPI1_RELEASE_RESET __HAL_RCC_SPI1_RELEASE_RESET
#define __SPI2_CLK_DISABLE __HAL_RCC_SPI2_CLK_DISABLE
#define __SPI2_CLK_ENABLE __HAL_RCC_SPI2_CLK_ENABLE
#define __SPI2_CLK_SLEEP_DISABLE __HAL_RCC_SPI2_CLK_SLEEP_DISABLE
#define __SPI2_CLK_SLEEP_ENABLE __HAL_RCC_SPI2_CLK_SLEEP_ENABLE
#define __SPI2_FORCE_RESET __HAL_RCC_SPI2_FORCE_RESET
#define __SPI2_RELEASE_RESET __HAL_RCC_SPI2_RELEASE_RESET
#define __SPI3_CLK_DISABLE __HAL_RCC_SPI3_CLK_DISABLE
#define __SPI3_CLK_ENABLE __HAL_RCC_SPI3_CLK_ENABLE
#define __SPI3_CLK_SLEEP_DISABLE __HAL_RCC_SPI3_CLK_SLEEP_DISABLE
#define __SPI3_CLK_SLEEP_ENABLE __HAL_RCC_SPI3_CLK_SLEEP_ENABLE
#define __SPI3_FORCE_RESET __HAL_RCC_SPI3_FORCE_RESET
#define __SPI3_RELEASE_RESET __HAL_RCC_SPI3_RELEASE_RESET
#define __SRAM_CLK_DISABLE __HAL_RCC_SRAM_CLK_DISABLE
#define __SRAM_CLK_ENABLE __HAL_RCC_SRAM_CLK_ENABLE
#define __SRAM1_CLK_SLEEP_DISABLE __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE
#define __SRAM1_CLK_SLEEP_ENABLE __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE
#define __SRAM2_CLK_SLEEP_DISABLE __HAL_RCC_SRAM2_CLK_SLEEP_DISABLE
#define __SRAM2_CLK_SLEEP_ENABLE __HAL_RCC_SRAM2_CLK_SLEEP_ENABLE
#define __SWPMI1_CLK_DISABLE __HAL_RCC_SWPMI1_CLK_DISABLE
#define __SWPMI1_CLK_ENABLE __HAL_RCC_SWPMI1_CLK_ENABLE
#define __SWPMI1_CLK_SLEEP_DISABLE __HAL_RCC_SWPMI1_CLK_SLEEP_DISABLE
#define __SWPMI1_CLK_SLEEP_ENABLE __HAL_RCC_SWPMI1_CLK_SLEEP_ENABLE
#define __SWPMI1_FORCE_RESET __HAL_RCC_SWPMI1_FORCE_RESET
#define __SWPMI1_RELEASE_RESET __HAL_RCC_SWPMI1_RELEASE_RESET
#define __SYSCFG_CLK_DISABLE __HAL_RCC_SYSCFG_CLK_DISABLE
#define __SYSCFG_CLK_ENABLE __HAL_RCC_SYSCFG_CLK_ENABLE
#define __SYSCFG_CLK_SLEEP_DISABLE __HAL_RCC_SYSCFG_CLK_SLEEP_DISABLE
#define __SYSCFG_CLK_SLEEP_ENABLE __HAL_RCC_SYSCFG_CLK_SLEEP_ENABLE
#define __SYSCFG_FORCE_RESET __HAL_RCC_SYSCFG_FORCE_RESET
#define __SYSCFG_RELEASE_RESET __HAL_RCC_SYSCFG_RELEASE_RESET
#define __TIM1_CLK_DISABLE __HAL_RCC_TIM1_CLK_DISABLE
#define __TIM1_CLK_ENABLE __HAL_RCC_TIM1_CLK_ENABLE
#define __TIM1_CLK_SLEEP_DISABLE __HAL_RCC_TIM1_CLK_SLEEP_DISABLE
#define __TIM1_CLK_SLEEP_ENABLE __HAL_RCC_TIM1_CLK_SLEEP_ENABLE
#define __TIM1_FORCE_RESET __HAL_RCC_TIM1_FORCE_RESET
#define __TIM1_RELEASE_RESET __HAL_RCC_TIM1_RELEASE_RESET
#define __TIM10_CLK_DISABLE __HAL_RCC_TIM10_CLK_DISABLE
#define __TIM10_CLK_ENABLE __HAL_RCC_TIM10_CLK_ENABLE
#define __TIM10_FORCE_RESET __HAL_RCC_TIM10_FORCE_RESET
#define __TIM10_RELEASE_RESET __HAL_RCC_TIM10_RELEASE_RESET
#define __TIM11_CLK_DISABLE __HAL_RCC_TIM11_CLK_DISABLE
#define __TIM11_CLK_ENABLE __HAL_RCC_TIM11_CLK_ENABLE
#define __TIM11_FORCE_RESET __HAL_RCC_TIM11_FORCE_RESET
#define __TIM11_RELEASE_RESET __HAL_RCC_TIM11_RELEASE_RESET
#define __TIM12_CLK_DISABLE __HAL_RCC_TIM12_CLK_DISABLE
#define __TIM12_CLK_ENABLE __HAL_RCC_TIM12_CLK_ENABLE
#define __TIM12_FORCE_RESET __HAL_RCC_TIM12_FORCE_RESET
#define __TIM12_RELEASE_RESET __HAL_RCC_TIM12_RELEASE_RESET
#define __TIM13_CLK_DISABLE __HAL_RCC_TIM13_CLK_DISABLE
#define __TIM13_CLK_ENABLE __HAL_RCC_TIM13_CLK_ENABLE
#define __TIM13_FORCE_RESET __HAL_RCC_TIM13_FORCE_RESET
#define __TIM13_RELEASE_RESET __HAL_RCC_TIM13_RELEASE_RESET
#define __TIM14_CLK_DISABLE __HAL_RCC_TIM14_CLK_DISABLE
#define __TIM14_CLK_ENABLE __HAL_RCC_TIM14_CLK_ENABLE
#define __TIM14_FORCE_RESET __HAL_RCC_TIM14_FORCE_RESET
#define __TIM14_RELEASE_RESET __HAL_RCC_TIM14_RELEASE_RESET
#define __TIM15_CLK_DISABLE __HAL_RCC_TIM15_CLK_DISABLE
#define __TIM15_CLK_ENABLE __HAL_RCC_TIM15_CLK_ENABLE
#define __TIM15_CLK_SLEEP_DISABLE __HAL_RCC_TIM15_CLK_SLEEP_DISABLE
#define __TIM15_CLK_SLEEP_ENABLE __HAL_RCC_TIM15_CLK_SLEEP_ENABLE
#define __TIM15_FORCE_RESET __HAL_RCC_TIM15_FORCE_RESET
#define __TIM15_RELEASE_RESET __HAL_RCC_TIM15_RELEASE_RESET
#define __TIM16_CLK_DISABLE __HAL_RCC_TIM16_CLK_DISABLE
#define __TIM16_CLK_ENABLE __HAL_RCC_TIM16_CLK_ENABLE
#define __TIM16_CLK_SLEEP_DISABLE __HAL_RCC_TIM16_CLK_SLEEP_DISABLE
#define __TIM16_CLK_SLEEP_ENABLE __HAL_RCC_TIM16_CLK_SLEEP_ENABLE
#define __TIM16_FORCE_RESET __HAL_RCC_TIM16_FORCE_RESET
#define __TIM16_RELEASE_RESET __HAL_RCC_TIM16_RELEASE_RESET
#define __TIM17_CLK_DISABLE __HAL_RCC_TIM17_CLK_DISABLE
#define __TIM17_CLK_ENABLE __HAL_RCC_TIM17_CLK_ENABLE
#define __TIM17_CLK_SLEEP_DISABLE __HAL_RCC_TIM17_CLK_SLEEP_DISABLE
#define __TIM17_CLK_SLEEP_ENABLE __HAL_RCC_TIM17_CLK_SLEEP_ENABLE
#define __TIM17_FORCE_RESET __HAL_RCC_TIM17_FORCE_RESET
#define __TIM17_RELEASE_RESET __HAL_RCC_TIM17_RELEASE_RESET
#define __TIM2_CLK_DISABLE __HAL_RCC_TIM2_CLK_DISABLE
#define __TIM2_CLK_ENABLE __HAL_RCC_TIM2_CLK_ENABLE
#define __TIM2_CLK_SLEEP_DISABLE __HAL_RCC_TIM2_CLK_SLEEP_DISABLE
#define __TIM2_CLK_SLEEP_ENABLE __HAL_RCC_TIM2_CLK_SLEEP_ENABLE
#define __TIM2_FORCE_RESET __HAL_RCC_TIM2_FORCE_RESET
#define __TIM2_RELEASE_RESET __HAL_RCC_TIM2_RELEASE_RESET
#define __TIM3_CLK_DISABLE __HAL_RCC_TIM3_CLK_DISABLE
#define __TIM3_CLK_ENABLE __HAL_RCC_TIM3_CLK_ENABLE
#define __TIM3_CLK_SLEEP_DISABLE __HAL_RCC_TIM3_CLK_SLEEP_DISABLE
#define __TIM3_CLK_SLEEP_ENABLE __HAL_RCC_TIM3_CLK_SLEEP_ENABLE
#define __TIM3_FORCE_RESET __HAL_RCC_TIM3_FORCE_RESET
#define __TIM3_RELEASE_RESET __HAL_RCC_TIM3_RELEASE_RESET
#define __TIM4_CLK_DISABLE __HAL_RCC_TIM4_CLK_DISABLE
#define __TIM4_CLK_ENABLE __HAL_RCC_TIM4_CLK_ENABLE
#define __TIM4_CLK_SLEEP_DISABLE __HAL_RCC_TIM4_CLK_SLEEP_DISABLE
#define __TIM4_CLK_SLEEP_ENABLE __HAL_RCC_TIM4_CLK_SLEEP_ENABLE
#define __TIM4_FORCE_RESET __HAL_RCC_TIM4_FORCE_RESET
#define __TIM4_RELEASE_RESET __HAL_RCC_TIM4_RELEASE_RESET
#define __TIM5_CLK_DISABLE __HAL_RCC_TIM5_CLK_DISABLE
#define __TIM5_CLK_ENABLE __HAL_RCC_TIM5_CLK_ENABLE
#define __TIM5_CLK_SLEEP_DISABLE __HAL_RCC_TIM5_CLK_SLEEP_DISABLE
#define __TIM5_CLK_SLEEP_ENABLE __HAL_RCC_TIM5_CLK_SLEEP_ENABLE
#define __TIM5_FORCE_RESET __HAL_RCC_TIM5_FORCE_RESET
#define __TIM5_RELEASE_RESET __HAL_RCC_TIM5_RELEASE_RESET
#define __TIM6_CLK_DISABLE __HAL_RCC_TIM6_CLK_DISABLE
#define __TIM6_CLK_ENABLE __HAL_RCC_TIM6_CLK_ENABLE
#define __TIM6_CLK_SLEEP_DISABLE __HAL_RCC_TIM6_CLK_SLEEP_DISABLE
#define __TIM6_CLK_SLEEP_ENABLE __HAL_RCC_TIM6_CLK_SLEEP_ENABLE
#define __TIM6_FORCE_RESET __HAL_RCC_TIM6_FORCE_RESET
#define __TIM6_RELEASE_RESET __HAL_RCC_TIM6_RELEASE_RESET
#define __TIM7_CLK_DISABLE __HAL_RCC_TIM7_CLK_DISABLE
#define __TIM7_CLK_ENABLE __HAL_RCC_TIM7_CLK_ENABLE
#define __TIM7_CLK_SLEEP_DISABLE __HAL_RCC_TIM7_CLK_SLEEP_DISABLE
#define __TIM7_CLK_SLEEP_ENABLE __HAL_RCC_TIM7_CLK_SLEEP_ENABLE
#define __TIM7_FORCE_RESET __HAL_RCC_TIM7_FORCE_RESET
#define __TIM7_RELEASE_RESET __HAL_RCC_TIM7_RELEASE_RESET
#define __TIM8_CLK_DISABLE __HAL_RCC_TIM8_CLK_DISABLE
#define __TIM8_CLK_ENABLE __HAL_RCC_TIM8_CLK_ENABLE
#define __TIM8_CLK_SLEEP_DISABLE __HAL_RCC_TIM8_CLK_SLEEP_DISABLE
#define __TIM8_CLK_SLEEP_ENABLE __HAL_RCC_TIM8_CLK_SLEEP_ENABLE
#define __TIM8_FORCE_RESET __HAL_RCC_TIM8_FORCE_RESET
#define __TIM8_RELEASE_RESET __HAL_RCC_TIM8_RELEASE_RESET
#define __TIM9_CLK_DISABLE __HAL_RCC_TIM9_CLK_DISABLE
#define __TIM9_CLK_ENABLE __HAL_RCC_TIM9_CLK_ENABLE
#define __TIM9_FORCE_RESET __HAL_RCC_TIM9_FORCE_RESET
#define __TIM9_RELEASE_RESET __HAL_RCC_TIM9_RELEASE_RESET
#define __TSC_CLK_DISABLE __HAL_RCC_TSC_CLK_DISABLE
#define __TSC_CLK_ENABLE __HAL_RCC_TSC_CLK_ENABLE
#define __TSC_CLK_SLEEP_DISABLE __HAL_RCC_TSC_CLK_SLEEP_DISABLE
#define __TSC_CLK_SLEEP_ENABLE __HAL_RCC_TSC_CLK_SLEEP_ENABLE
#define __TSC_FORCE_RESET __HAL_RCC_TSC_FORCE_RESET
#define __TSC_RELEASE_RESET __HAL_RCC_TSC_RELEASE_RESET
#define __UART4_CLK_DISABLE __HAL_RCC_UART4_CLK_DISABLE
#define __UART4_CLK_ENABLE __HAL_RCC_UART4_CLK_ENABLE
#define __UART4_CLK_SLEEP_DISABLE __HAL_RCC_UART4_CLK_SLEEP_DISABLE
#define __UART4_CLK_SLEEP_ENABLE __HAL_RCC_UART4_CLK_SLEEP_ENABLE
#define __UART4_FORCE_RESET __HAL_RCC_UART4_FORCE_RESET
#define __UART4_RELEASE_RESET __HAL_RCC_UART4_RELEASE_RESET
#define __UART5_CLK_DISABLE __HAL_RCC_UART5_CLK_DISABLE
#define __UART5_CLK_ENABLE __HAL_RCC_UART5_CLK_ENABLE
#define __UART5_CLK_SLEEP_DISABLE __HAL_RCC_UART5_CLK_SLEEP_DISABLE
#define __UART5_CLK_SLEEP_ENABLE __HAL_RCC_UART5_CLK_SLEEP_ENABLE
#define __UART5_FORCE_RESET __HAL_RCC_UART5_FORCE_RESET
#define __UART5_RELEASE_RESET __HAL_RCC_UART5_RELEASE_RESET
#define __USART1_CLK_DISABLE __HAL_RCC_USART1_CLK_DISABLE
#define __USART1_CLK_ENABLE __HAL_RCC_USART1_CLK_ENABLE
#define __USART1_CLK_SLEEP_DISABLE __HAL_RCC_USART1_CLK_SLEEP_DISABLE
#define __USART1_CLK_SLEEP_ENABLE __HAL_RCC_USART1_CLK_SLEEP_ENABLE
#define __USART1_FORCE_RESET __HAL_RCC_USART1_FORCE_RESET
#define __USART1_RELEASE_RESET __HAL_RCC_USART1_RELEASE_RESET
#define __USART2_CLK_DISABLE __HAL_RCC_USART2_CLK_DISABLE
#define __USART2_CLK_ENABLE __HAL_RCC_USART2_CLK_ENABLE
#define __USART2_CLK_SLEEP_DISABLE __HAL_RCC_USART2_CLK_SLEEP_DISABLE
#define __USART2_CLK_SLEEP_ENABLE __HAL_RCC_USART2_CLK_SLEEP_ENABLE
#define __USART2_FORCE_RESET __HAL_RCC_USART2_FORCE_RESET
#define __USART2_RELEASE_RESET __HAL_RCC_USART2_RELEASE_RESET
#define __USART3_CLK_DISABLE __HAL_RCC_USART3_CLK_DISABLE
#define __USART3_CLK_ENABLE __HAL_RCC_USART3_CLK_ENABLE
#define __USART3_CLK_SLEEP_DISABLE __HAL_RCC_USART3_CLK_SLEEP_DISABLE
#define __USART3_CLK_SLEEP_ENABLE __HAL_RCC_USART3_CLK_SLEEP_ENABLE
#define __USART3_FORCE_RESET __HAL_RCC_USART3_FORCE_RESET
#define __USART3_RELEASE_RESET __HAL_RCC_USART3_RELEASE_RESET
#define __USART4_CLK_DISABLE __HAL_RCC_UART4_CLK_DISABLE
#define __USART4_CLK_ENABLE __HAL_RCC_UART4_CLK_ENABLE
#define __USART4_CLK_SLEEP_ENABLE __HAL_RCC_UART4_CLK_SLEEP_ENABLE
#define __USART4_CLK_SLEEP_DISABLE __HAL_RCC_UART4_CLK_SLEEP_DISABLE
#define __USART4_FORCE_RESET __HAL_RCC_UART4_FORCE_RESET
#define __USART4_RELEASE_RESET __HAL_RCC_UART4_RELEASE_RESET
#define __USART5_CLK_DISABLE __HAL_RCC_UART5_CLK_DISABLE
#define __USART5_CLK_ENABLE __HAL_RCC_UART5_CLK_ENABLE
#define __USART5_CLK_SLEEP_ENABLE __HAL_RCC_UART5_CLK_SLEEP_ENABLE
#define __USART5_CLK_SLEEP_DISABLE __HAL_RCC_UART5_CLK_SLEEP_DISABLE
#define __USART5_FORCE_RESET __HAL_RCC_UART5_FORCE_RESET
#define __USART5_RELEASE_RESET __HAL_RCC_UART5_RELEASE_RESET
#define __USART7_CLK_DISABLE __HAL_RCC_UART7_CLK_DISABLE
#define __USART7_CLK_ENABLE __HAL_RCC_UART7_CLK_ENABLE
#define __USART7_FORCE_RESET __HAL_RCC_UART7_FORCE_RESET
#define __USART7_RELEASE_RESET __HAL_RCC_UART7_RELEASE_RESET
#define __USART8_CLK_DISABLE __HAL_RCC_UART8_CLK_DISABLE
#define __USART8_CLK_ENABLE __HAL_RCC_UART8_CLK_ENABLE
#define __USART8_FORCE_RESET __HAL_RCC_UART8_FORCE_RESET
#define __USART8_RELEASE_RESET __HAL_RCC_UART8_RELEASE_RESET
#define __USB_CLK_DISABLE __HAL_RCC_USB_CLK_DISABLE
#define __USB_CLK_ENABLE __HAL_RCC_USB_CLK_ENABLE
#define __USB_FORCE_RESET __HAL_RCC_USB_FORCE_RESET
#define __USB_CLK_SLEEP_ENABLE __HAL_RCC_USB_CLK_SLEEP_ENABLE
#define __USB_CLK_SLEEP_DISABLE __HAL_RCC_USB_CLK_SLEEP_DISABLE
#define __USB_OTG_FS_CLK_DISABLE __HAL_RCC_USB_OTG_FS_CLK_DISABLE
#define __USB_OTG_FS_CLK_ENABLE __HAL_RCC_USB_OTG_FS_CLK_ENABLE
#define __USB_RELEASE_RESET __HAL_RCC_USB_RELEASE_RESET

# 3230 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

#define __WWDG_CLK_DISABLE __HAL_RCC_WWDG_CLK_DISABLE
#define __WWDG_CLK_ENABLE __HAL_RCC_WWDG_CLK_ENABLE
#define __WWDG_CLK_SLEEP_DISABLE __HAL_RCC_WWDG_CLK_SLEEP_DISABLE
#define __WWDG_CLK_SLEEP_ENABLE __HAL_RCC_WWDG_CLK_SLEEP_ENABLE
#define __WWDG_FORCE_RESET __HAL_RCC_WWDG_FORCE_RESET
#define __WWDG_RELEASE_RESET __HAL_RCC_WWDG_RELEASE_RESET

#define __TIM21_CLK_ENABLE __HAL_RCC_TIM21_CLK_ENABLE
#define __TIM21_CLK_DISABLE __HAL_RCC_TIM21_CLK_DISABLE
#define __TIM21_FORCE_RESET __HAL_RCC_TIM21_FORCE_RESET
#define __TIM21_RELEASE_RESET __HAL_RCC_TIM21_RELEASE_RESET
#define __TIM21_CLK_SLEEP_ENABLE __HAL_RCC_TIM21_CLK_SLEEP_ENABLE
#define __TIM21_CLK_SLEEP_DISABLE __HAL_RCC_TIM21_CLK_SLEEP_DISABLE
#define __TIM22_CLK_ENABLE __HAL_RCC_TIM22_CLK_ENABLE
#define __TIM22_CLK_DISABLE __HAL_RCC_TIM22_CLK_DISABLE
#define __TIM22_FORCE_RESET __HAL_RCC_TIM22_FORCE_RESET
#define __TIM22_RELEASE_RESET __HAL_RCC_TIM22_RELEASE_RESET
#define __TIM22_CLK_SLEEP_ENABLE __HAL_RCC_TIM22_CLK_SLEEP_ENABLE
#define __TIM22_CLK_SLEEP_DISABLE __HAL_RCC_TIM22_CLK_SLEEP_DISABLE
#define __CRS_CLK_DISABLE __HAL_RCC_CRS_CLK_DISABLE
#define __CRS_CLK_ENABLE __HAL_RCC_CRS_CLK_ENABLE
#define __CRS_CLK_SLEEP_DISABLE __HAL_RCC_CRS_CLK_SLEEP_DISABLE
#define __CRS_CLK_SLEEP_ENABLE __HAL_RCC_CRS_CLK_SLEEP_ENABLE
#define __CRS_FORCE_RESET __HAL_RCC_CRS_FORCE_RESET
#define __CRS_RELEASE_RESET __HAL_RCC_CRS_RELEASE_RESET
#define __RCC_BACKUPRESET_FORCE __HAL_RCC_BACKUPRESET_FORCE
#define __RCC_BACKUPRESET_RELEASE __HAL_RCC_BACKUPRESET_RELEASE

#define __USB_OTG_FS_FORCE_RESET __HAL_RCC_USB_OTG_FS_FORCE_RESET
#define __USB_OTG_FS_RELEASE_RESET __HAL_RCC_USB_OTG_FS_RELEASE_RESET
#define __USB_OTG_FS_CLK_SLEEP_ENABLE __HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE
#define __USB_OTG_FS_CLK_SLEEP_DISABLE __HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE
#define __USB_OTG_HS_CLK_DISABLE __HAL_RCC_USB_OTG_HS_CLK_DISABLE
#define __USB_OTG_HS_CLK_ENABLE __HAL_RCC_USB_OTG_HS_CLK_ENABLE
#define __USB_OTG_HS_ULPI_CLK_ENABLE __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE
#define __USB_OTG_HS_ULPI_CLK_DISABLE __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE
#define __TIM9_CLK_SLEEP_ENABLE __HAL_RCC_TIM9_CLK_SLEEP_ENABLE
#define __TIM9_CLK_SLEEP_DISABLE __HAL_RCC_TIM9_CLK_SLEEP_DISABLE
#define __TIM10_CLK_SLEEP_ENABLE __HAL_RCC_TIM10_CLK_SLEEP_ENABLE
#define __TIM10_CLK_SLEEP_DISABLE __HAL_RCC_TIM10_CLK_SLEEP_DISABLE
#define __TIM11_CLK_SLEEP_ENABLE __HAL_RCC_TIM11_CLK_SLEEP_ENABLE
#define __TIM11_CLK_SLEEP_DISABLE __HAL_RCC_TIM11_CLK_SLEEP_DISABLE
#define __ETHMACPTP_CLK_SLEEP_ENABLE __HAL_RCC_ETHMACPTP_CLK_SLEEP_ENABLE
#define __ETHMACPTP_CLK_SLEEP_DISABLE __HAL_RCC_ETHMACPTP_CLK_SLEEP_DISABLE
#define __ETHMACPTP_CLK_ENABLE __HAL_RCC_ETHMACPTP_CLK_ENABLE
#define __ETHMACPTP_CLK_DISABLE __HAL_RCC_ETHMACPTP_CLK_DISABLE
#define __HASH_CLK_ENABLE __HAL_RCC_HASH_CLK_ENABLE
#define __HASH_FORCE_RESET __HAL_RCC_HASH_FORCE_RESET
#define __HASH_RELEASE_RESET __HAL_RCC_HASH_RELEASE_RESET
#define __HASH_CLK_SLEEP_ENABLE __HAL_RCC_HASH_CLK_SLEEP_ENABLE
#define __HASH_CLK_SLEEP_DISABLE __HAL_RCC_HASH_CLK_SLEEP_DISABLE
#define __HASH_CLK_DISABLE __HAL_RCC_HASH_CLK_DISABLE
#define __SPI5_CLK_ENABLE __HAL_RCC_SPI5_CLK_ENABLE
#define __SPI5_CLK_DISABLE __HAL_RCC_SPI5_CLK_DISABLE
#define __SPI5_FORCE_RESET __HAL_RCC_SPI5_FORCE_RESET
#define __SPI5_RELEASE_RESET __HAL_RCC_SPI5_RELEASE_RESET
#define __SPI5_CLK_SLEEP_ENABLE __HAL_RCC_SPI5_CLK_SLEEP_ENABLE
#define __SPI5_CLK_SLEEP_DISABLE __HAL_RCC_SPI5_CLK_SLEEP_DISABLE
#define __SPI6_CLK_ENABLE __HAL_RCC_SPI6_CLK_ENABLE
#define __SPI6_CLK_DISABLE __HAL_RCC_SPI6_CLK_DISABLE
#define __SPI6_FORCE_RESET __HAL_RCC_SPI6_FORCE_RESET
#define __SPI6_RELEASE_RESET __HAL_RCC_SPI6_RELEASE_RESET
#define __SPI6_CLK_SLEEP_ENABLE __HAL_RCC_SPI6_CLK_SLEEP_ENABLE
#define __SPI6_CLK_SLEEP_DISABLE __HAL_RCC_SPI6_CLK_SLEEP_DISABLE
#define __LTDC_CLK_ENABLE __HAL_RCC_LTDC_CLK_ENABLE
#define __LTDC_CLK_DISABLE __HAL_RCC_LTDC_CLK_DISABLE
#define __LTDC_FORCE_RESET __HAL_RCC_LTDC_FORCE_RESET
#define __LTDC_RELEASE_RESET __HAL_RCC_LTDC_RELEASE_RESET
#define __LTDC_CLK_SLEEP_ENABLE __HAL_RCC_LTDC_CLK_SLEEP_ENABLE
#define __ETHMAC_CLK_SLEEP_ENABLE __HAL_RCC_ETHMAC_CLK_SLEEP_ENABLE
#define __ETHMAC_CLK_SLEEP_DISABLE __HAL_RCC_ETHMAC_CLK_SLEEP_DISABLE
#define __ETHMACTX_CLK_SLEEP_ENABLE __HAL_RCC_ETHMACTX_CLK_SLEEP_ENABLE
#define __ETHMACTX_CLK_SLEEP_DISABLE __HAL_RCC_ETHMACTX_CLK_SLEEP_DISABLE
#define __ETHMACRX_CLK_SLEEP_ENABLE __HAL_RCC_ETHMACRX_CLK_SLEEP_ENABLE
#define __ETHMACRX_CLK_SLEEP_DISABLE __HAL_RCC_ETHMACRX_CLK_SLEEP_DISABLE
#define __TIM12_CLK_SLEEP_ENABLE __HAL_RCC_TIM12_CLK_SLEEP_ENABLE
#define __TIM12_CLK_SLEEP_DISABLE __HAL_RCC_TIM12_CLK_SLEEP_DISABLE
#define __TIM13_CLK_SLEEP_ENABLE __HAL_RCC_TIM13_CLK_SLEEP_ENABLE
#define __TIM13_CLK_SLEEP_DISABLE __HAL_RCC_TIM13_CLK_SLEEP_DISABLE
#define __TIM14_CLK_SLEEP_ENABLE __HAL_RCC_TIM14_CLK_SLEEP_ENABLE
#define __TIM14_CLK_SLEEP_DISABLE __HAL_RCC_TIM14_CLK_SLEEP_DISABLE
#define __BKPSRAM_CLK_ENABLE __HAL_RCC_BKPSRAM_CLK_ENABLE
#define __BKPSRAM_CLK_DISABLE __HAL_RCC_BKPSRAM_CLK_DISABLE
#define __BKPSRAM_CLK_SLEEP_ENABLE __HAL_RCC_BKPSRAM_CLK_SLEEP_ENABLE
#define __BKPSRAM_CLK_SLEEP_DISABLE __HAL_RCC_BKPSRAM_CLK_SLEEP_DISABLE
#define __CCMDATARAMEN_CLK_ENABLE __HAL_RCC_CCMDATARAMEN_CLK_ENABLE
#define __CCMDATARAMEN_CLK_DISABLE __HAL_RCC_CCMDATARAMEN_CLK_DISABLE
#define __USART6_CLK_ENABLE __HAL_RCC_USART6_CLK_ENABLE
#define __USART6_CLK_DISABLE __HAL_RCC_USART6_CLK_DISABLE
#define __USART6_FORCE_RESET __HAL_RCC_USART6_FORCE_RESET
#define __USART6_RELEASE_RESET __HAL_RCC_USART6_RELEASE_RESET
#define __USART6_CLK_SLEEP_ENABLE __HAL_RCC_USART6_CLK_SLEEP_ENABLE
#define __USART6_CLK_SLEEP_DISABLE __HAL_RCC_USART6_CLK_SLEEP_DISABLE
#define __SPI4_CLK_ENABLE __HAL_RCC_SPI4_CLK_ENABLE
#define __SPI4_CLK_DISABLE __HAL_RCC_SPI4_CLK_DISABLE
#define __SPI4_FORCE_RESET __HAL_RCC_SPI4_FORCE_RESET
#define __SPI4_RELEASE_RESET __HAL_RCC_SPI4_RELEASE_RESET
#define __SPI4_CLK_SLEEP_ENABLE __HAL_RCC_SPI4_CLK_SLEEP_ENABLE
#define __SPI4_CLK_SLEEP_DISABLE __HAL_RCC_SPI4_CLK_SLEEP_DISABLE
#define __GPIOI_CLK_ENABLE __HAL_RCC_GPIOI_CLK_ENABLE
#define __GPIOI_CLK_DISABLE __HAL_RCC_GPIOI_CLK_DISABLE
#define __GPIOI_FORCE_RESET __HAL_RCC_GPIOI_FORCE_RESET
#define __GPIOI_RELEASE_RESET __HAL_RCC_GPIOI_RELEASE_RESET
#define __GPIOI_CLK_SLEEP_ENABLE __HAL_RCC_GPIOI_CLK_SLEEP_ENABLE
#define __GPIOI_CLK_SLEEP_DISABLE __HAL_RCC_GPIOI_CLK_SLEEP_DISABLE
#define __GPIOJ_CLK_ENABLE __HAL_RCC_GPIOJ_CLK_ENABLE
#define __GPIOJ_CLK_DISABLE __HAL_RCC_GPIOJ_CLK_DISABLE
#define __GPIOJ_FORCE_RESET __HAL_RCC_GPIOJ_FORCE_RESET
#define __GPIOJ_RELEASE_RESET __HAL_RCC_GPIOJ_RELEASE_RESET
#define __GPIOJ_CLK_SLEEP_ENABLE __HAL_RCC_GPIOJ_CLK_SLEEP_ENABLE
#define __GPIOJ_CLK_SLEEP_DISABLE __HAL_RCC_GPIOJ_CLK_SLEEP_DISABLE
#define __GPIOK_CLK_ENABLE __HAL_RCC_GPIOK_CLK_ENABLE
#define __GPIOK_CLK_DISABLE __HAL_RCC_GPIOK_CLK_DISABLE
#define __GPIOK_RELEASE_RESET __HAL_RCC_GPIOK_RELEASE_RESET
#define __GPIOK_CLK_SLEEP_ENABLE __HAL_RCC_GPIOK_CLK_SLEEP_ENABLE
#define __GPIOK_CLK_SLEEP_DISABLE __HAL_RCC_GPIOK_CLK_SLEEP_DISABLE
#define __ETH_CLK_ENABLE __HAL_RCC_ETH_CLK_ENABLE
#define __ETH_CLK_DISABLE __HAL_RCC_ETH_CLK_DISABLE
#define __DCMI_CLK_ENABLE __HAL_RCC_DCMI_CLK_ENABLE
#define __DCMI_CLK_DISABLE __HAL_RCC_DCMI_CLK_DISABLE
#define __DCMI_FORCE_RESET __HAL_RCC_DCMI_FORCE_RESET
#define __DCMI_RELEASE_RESET __HAL_RCC_DCMI_RELEASE_RESET
#define __DCMI_CLK_SLEEP_ENABLE __HAL_RCC_DCMI_CLK_SLEEP_ENABLE
#define __DCMI_CLK_SLEEP_DISABLE __HAL_RCC_DCMI_CLK_SLEEP_DISABLE
#define __UART7_CLK_ENABLE __HAL_RCC_UART7_CLK_ENABLE
#define __UART7_CLK_DISABLE __HAL_RCC_UART7_CLK_DISABLE
#define __UART7_RELEASE_RESET __HAL_RCC_UART7_RELEASE_RESET
#define __UART7_FORCE_RESET __HAL_RCC_UART7_FORCE_RESET
#define __UART7_CLK_SLEEP_ENABLE __HAL_RCC_UART7_CLK_SLEEP_ENABLE
#define __UART7_CLK_SLEEP_DISABLE __HAL_RCC_UART7_CLK_SLEEP_DISABLE
#define __UART8_CLK_ENABLE __HAL_RCC_UART8_CLK_ENABLE
#define __UART8_CLK_DISABLE __HAL_RCC_UART8_CLK_DISABLE
#define __UART8_FORCE_RESET __HAL_RCC_UART8_FORCE_RESET
#define __UART8_RELEASE_RESET __HAL_RCC_UART8_RELEASE_RESET
#define __UART8_CLK_SLEEP_ENABLE __HAL_RCC_UART8_CLK_SLEEP_ENABLE
#define __UART8_CLK_SLEEP_DISABLE __HAL_RCC_UART8_CLK_SLEEP_DISABLE
#define __OTGHS_CLK_SLEEP_ENABLE __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE
#define __OTGHS_CLK_SLEEP_DISABLE __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE
#define __OTGHS_FORCE_RESET __HAL_RCC_USB_OTG_HS_FORCE_RESET
#define __OTGHS_RELEASE_RESET __HAL_RCC_USB_OTG_HS_RELEASE_RESET
#define __OTGHSULPI_CLK_SLEEP_ENABLE __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE
#define __OTGHSULPI_CLK_SLEEP_DISABLE __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE
#define __HAL_RCC_OTGHS_CLK_SLEEP_ENABLE __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE
#define __HAL_RCC_OTGHS_CLK_SLEEP_DISABLE __HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE
#define __HAL_RCC_OTGHS_IS_CLK_SLEEP_ENABLED __HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_ENABLED
#define __HAL_RCC_OTGHS_IS_CLK_SLEEP_DISABLED __HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_DISABLED
#define __HAL_RCC_OTGHS_FORCE_RESET __HAL_RCC_USB_OTG_HS_FORCE_RESET
#define __HAL_RCC_OTGHS_RELEASE_RESET __HAL_RCC_USB_OTG_HS_RELEASE_RESET
#define __HAL_RCC_OTGHSULPI_CLK_SLEEP_ENABLE __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE
#define __HAL_RCC_OTGHSULPI_CLK_SLEEP_DISABLE __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE
#define __HAL_RCC_OTGHSULPI_IS_CLK_SLEEP_ENABLED __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_ENABLED
#define __HAL_RCC_OTGHSULPI_IS_CLK_SLEEP_DISABLED __HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_DISABLED
#define __SRAM3_CLK_SLEEP_ENABLE __HAL_RCC_SRAM3_CLK_SLEEP_ENABLE
#define __CAN2_CLK_SLEEP_ENABLE __HAL_RCC_CAN2_CLK_SLEEP_ENABLE
#define __CAN2_CLK_SLEEP_DISABLE __HAL_RCC_CAN2_CLK_SLEEP_DISABLE
#define __DAC_CLK_SLEEP_ENABLE __HAL_RCC_DAC_CLK_SLEEP_ENABLE
#define __DAC_CLK_SLEEP_DISABLE __HAL_RCC_DAC_CLK_SLEEP_DISABLE
#define __ADC2_CLK_SLEEP_ENABLE __HAL_RCC_ADC2_CLK_SLEEP_ENABLE
#define __ADC2_CLK_SLEEP_DISABLE __HAL_RCC_ADC2_CLK_SLEEP_DISABLE
#define __ADC3_CLK_SLEEP_ENABLE __HAL_RCC_ADC3_CLK_SLEEP_ENABLE
#define __ADC3_CLK_SLEEP_DISABLE __HAL_RCC_ADC3_CLK_SLEEP_DISABLE
#define __FSMC_FORCE_RESET __HAL_RCC_FSMC_FORCE_RESET
#define __FSMC_RELEASE_RESET __HAL_RCC_FSMC_RELEASE_RESET
#define __FSMC_CLK_SLEEP_ENABLE __HAL_RCC_FSMC_CLK_SLEEP_ENABLE
#define __FSMC_CLK_SLEEP_DISABLE __HAL_RCC_FSMC_CLK_SLEEP_DISABLE
#define __SDIO_FORCE_RESET __HAL_RCC_SDIO_FORCE_RESET
#define __SDIO_RELEASE_RESET __HAL_RCC_SDIO_RELEASE_RESET
#define __SDIO_CLK_SLEEP_DISABLE __HAL_RCC_SDIO_CLK_SLEEP_DISABLE
#define __SDIO_CLK_SLEEP_ENABLE __HAL_RCC_SDIO_CLK_SLEEP_ENABLE
#define __DMA2D_CLK_ENABLE __HAL_RCC_DMA2D_CLK_ENABLE
#define __DMA2D_CLK_DISABLE __HAL_RCC_DMA2D_CLK_DISABLE
#define __DMA2D_FORCE_RESET __HAL_RCC_DMA2D_FORCE_RESET
#define __DMA2D_RELEASE_RESET __HAL_RCC_DMA2D_RELEASE_RESET
#define __DMA2D_CLK_SLEEP_ENABLE __HAL_RCC_DMA2D_CLK_SLEEP_ENABLE
#define __DMA2D_CLK_SLEEP_DISABLE __HAL_RCC_DMA2D_CLK_SLEEP_DISABLE

/* alias define maintained for legacy */
#define __HAL_RCC_OTGFS_FORCE_RESET __HAL_RCC_USB_OTG_FS_FORCE_RESET
#define __HAL_RCC_OTGFS_RELEASE_RESET __HAL_RCC_USB_OTG_FS_RELEASE_RESET

#define __ADC12_CLK_ENABLE __HAL_RCC_ADC12_CLK_ENABLE
#define __ADC12_CLK_DISABLE __HAL_RCC_ADC12_CLK_DISABLE
#define __ADC34_CLK_ENABLE __HAL_RCC_ADC34_CLK_ENABLE
#define __ADC34_CLK_DISABLE __HAL_RCC_ADC34_CLK_DISABLE
#define __DAC2_CLK_ENABLE __HAL_RCC_DAC2_CLK_ENABLE
#define __DAC2_CLK_DISABLE __HAL_RCC_DAC2_CLK_DISABLE
#define __TIM18_CLK_ENABLE __HAL_RCC_TIM18_CLK_ENABLE
#define __TIM18_CLK_DISABLE __HAL_RCC_TIM18_CLK_DISABLE
#define __TIM19_CLK_ENABLE __HAL_RCC_TIM19_CLK_ENABLE
#define __TIM19_CLK_DISABLE __HAL_RCC_TIM19_CLK_DISABLE
#define __TIM20_CLK_ENABLE __HAL_RCC_TIM20_CLK_ENABLE
#define __TIM20_CLK_DISABLE __HAL_RCC_TIM20_CLK_DISABLE
#define __HRTIM1_CLK_ENABLE __HAL_RCC_HRTIM1_CLK_ENABLE
#define __HRTIM1_CLK_DISABLE __HAL_RCC_HRTIM1_CLK_DISABLE
#define __SDADC1_CLK_ENABLE __HAL_RCC_SDADC1_CLK_ENABLE
#define __SDADC2_CLK_ENABLE __HAL_RCC_SDADC2_CLK_ENABLE
#define __SDADC3_CLK_ENABLE __HAL_RCC_SDADC3_CLK_ENABLE
#define __SDADC1_CLK_DISABLE __HAL_RCC_SDADC1_CLK_DISABLE
#define __SDADC2_CLK_DISABLE __HAL_RCC_SDADC2_CLK_DISABLE
#define __SDADC3_CLK_DISABLE __HAL_RCC_SDADC3_CLK_DISABLE

#define __ADC12_FORCE_RESET __HAL_RCC_ADC12_FORCE_RESET
#define __ADC12_RELEASE_RESET __HAL_RCC_ADC12_RELEASE_RESET
#define __ADC34_FORCE_RESET __HAL_RCC_ADC34_FORCE_RESET
#define __ADC34_RELEASE_RESET __HAL_RCC_ADC34_RELEASE_RESET
#define __DAC2_FORCE_RESET __HAL_RCC_DAC2_FORCE_RESET
#define __DAC2_RELEASE_RESET __HAL_RCC_DAC2_RELEASE_RESET
#define __TIM18_FORCE_RESET __HAL_RCC_TIM18_FORCE_RESET
#define __TIM18_RELEASE_RESET __HAL_RCC_TIM18_RELEASE_RESET
#define __TIM19_FORCE_RESET __HAL_RCC_TIM19_FORCE_RESET
#define __TIM19_RELEASE_RESET __HAL_RCC_TIM19_RELEASE_RESET
#define __TIM20_FORCE_RESET __HAL_RCC_TIM20_FORCE_RESET
#define __TIM20_RELEASE_RESET __HAL_RCC_TIM20_RELEASE_RESET
#define __HRTIM1_FORCE_RESET __HAL_RCC_HRTIM1_FORCE_RESET
#define __HRTIM1_RELEASE_RESET __HAL_RCC_HRTIM1_RELEASE_RESET
#define __SDADC1_FORCE_RESET __HAL_RCC_SDADC1_FORCE_RESET
#define __SDADC2_FORCE_RESET __HAL_RCC_SDADC2_FORCE_RESET
#define __SDADC3_FORCE_RESET __HAL_RCC_SDADC3_FORCE_RESET
#define __SDADC1_RELEASE_RESET __HAL_RCC_SDADC1_RELEASE_RESET
#define __SDADC2_RELEASE_RESET __HAL_RCC_SDADC2_RELEASE_RESET
#define __SDADC3_RELEASE_RESET __HAL_RCC_SDADC3_RELEASE_RESET

#define __ADC1_IS_CLK_ENABLED __HAL_RCC_ADC1_IS_CLK_ENABLED
#define __ADC1_IS_CLK_DISABLED __HAL_RCC_ADC1_IS_CLK_DISABLED
#define __ADC12_IS_CLK_ENABLED __HAL_RCC_ADC12_IS_CLK_ENABLED
#define __ADC12_IS_CLK_DISABLED __HAL_RCC_ADC12_IS_CLK_DISABLED
#define __ADC34_IS_CLK_ENABLED __HAL_RCC_ADC34_IS_CLK_ENABLED
#define __ADC34_IS_CLK_DISABLED __HAL_RCC_ADC34_IS_CLK_DISABLED
#define __CEC_IS_CLK_ENABLED __HAL_RCC_CEC_IS_CLK_ENABLED
#define __CEC_IS_CLK_DISABLED __HAL_RCC_CEC_IS_CLK_DISABLED
#define __CRC_IS_CLK_ENABLED __HAL_RCC_CRC_IS_CLK_ENABLED
#define __CRC_IS_CLK_DISABLED __HAL_RCC_CRC_IS_CLK_DISABLED
#define __DAC1_IS_CLK_ENABLED __HAL_RCC_DAC1_IS_CLK_ENABLED
#define __DAC1_IS_CLK_DISABLED __HAL_RCC_DAC1_IS_CLK_DISABLED
#define __DAC2_IS_CLK_ENABLED __HAL_RCC_DAC2_IS_CLK_ENABLED
#define __DAC2_IS_CLK_DISABLED __HAL_RCC_DAC2_IS_CLK_DISABLED
#define __DMA1_IS_CLK_ENABLED __HAL_RCC_DMA1_IS_CLK_ENABLED
#define __DMA1_IS_CLK_DISABLED __HAL_RCC_DMA1_IS_CLK_DISABLED
#define __DMA2_IS_CLK_ENABLED __HAL_RCC_DMA2_IS_CLK_ENABLED
#define __DMA2_IS_CLK_DISABLED __HAL_RCC_DMA2_IS_CLK_DISABLED
#define __FLITF_IS_CLK_ENABLED __HAL_RCC_FLITF_IS_CLK_ENABLED
#define __FLITF_IS_CLK_DISABLED __HAL_RCC_FLITF_IS_CLK_DISABLED
#define __FMC_IS_CLK_ENABLED __HAL_RCC_FMC_IS_CLK_ENABLED
#define __FMC_IS_CLK_DISABLED __HAL_RCC_FMC_IS_CLK_DISABLED
#define __GPIOA_IS_CLK_ENABLED __HAL_RCC_GPIOA_IS_CLK_ENABLED
#define __GPIOA_IS_CLK_DISABLED __HAL_RCC_GPIOA_IS_CLK_DISABLED
#define __GPIOB_IS_CLK_ENABLED __HAL_RCC_GPIOB_IS_CLK_ENABLED
#define __GPIOB_IS_CLK_DISABLED __HAL_RCC_GPIOB_IS_CLK_DISABLED
#define __GPIOC_IS_CLK_ENABLED __HAL_RCC_GPIOC_IS_CLK_ENABLED
#define __GPIOC_IS_CLK_DISABLED __HAL_RCC_GPIOC_IS_CLK_DISABLED
#define __GPIOD_IS_CLK_ENABLED __HAL_RCC_GPIOD_IS_CLK_ENABLED
#define __GPIOD_IS_CLK_DISABLED __HAL_RCC_GPIOD_IS_CLK_DISABLED
#define __GPIOE_IS_CLK_ENABLED __HAL_RCC_GPIOE_IS_CLK_ENABLED
#define __GPIOE_IS_CLK_DISABLED __HAL_RCC_GPIOE_IS_CLK_DISABLED
#define __GPIOF_IS_CLK_ENABLED __HAL_RCC_GPIOF_IS_CLK_ENABLED
#define __GPIOF_IS_CLK_DISABLED __HAL_RCC_GPIOF_IS_CLK_DISABLED
#define __GPIOG_IS_CLK_ENABLED __HAL_RCC_GPIOG_IS_CLK_ENABLED
#define __GPIOG_IS_CLK_DISABLED __HAL_RCC_GPIOG_IS_CLK_DISABLED
#define __GPIOH_IS_CLK_ENABLED __HAL_RCC_GPIOH_IS_CLK_ENABLED
#define __GPIOH_IS_CLK_DISABLED __HAL_RCC_GPIOH_IS_CLK_DISABLED
#define __HRTIM1_IS_CLK_ENABLED __HAL_RCC_HRTIM1_IS_CLK_ENABLED
#define __HRTIM1_IS_CLK_DISABLED __HAL_RCC_HRTIM1_IS_CLK_DISABLED
#define __I2C1_IS_CLK_ENABLED __HAL_RCC_I2C1_IS_CLK_ENABLED
#define __I2C1_IS_CLK_DISABLED __HAL_RCC_I2C1_IS_CLK_DISABLED
#define __I2C2_IS_CLK_ENABLED __HAL_RCC_I2C2_IS_CLK_ENABLED
#define __I2C2_IS_CLK_DISABLED __HAL_RCC_I2C2_IS_CLK_DISABLED
#define __I2C3_IS_CLK_ENABLED __HAL_RCC_I2C3_IS_CLK_ENABLED
#define __I2C3_IS_CLK_DISABLED __HAL_RCC_I2C3_IS_CLK_DISABLED
#define __PWR_IS_CLK_ENABLED __HAL_RCC_PWR_IS_CLK_ENABLED
#define __PWR_IS_CLK_DISABLED __HAL_RCC_PWR_IS_CLK_DISABLED
#define __SYSCFG_IS_CLK_ENABLED __HAL_RCC_SYSCFG_IS_CLK_ENABLED
#define __SYSCFG_IS_CLK_DISABLED __HAL_RCC_SYSCFG_IS_CLK_DISABLED
#define __SPI1_IS_CLK_ENABLED __HAL_RCC_SPI1_IS_CLK_ENABLED
#define __SPI1_IS_CLK_DISABLED __HAL_RCC_SPI1_IS_CLK_DISABLED
#define __SPI2_IS_CLK_ENABLED __HAL_RCC_SPI2_IS_CLK_ENABLED
#define __SPI2_IS_CLK_DISABLED __HAL_RCC_SPI2_IS_CLK_DISABLED
#define __SPI3_IS_CLK_ENABLED __HAL_RCC_SPI3_IS_CLK_ENABLED
#define __SPI3_IS_CLK_DISABLED __HAL_RCC_SPI3_IS_CLK_DISABLED
#define __SPI4_IS_CLK_ENABLED __HAL_RCC_SPI4_IS_CLK_ENABLED
#define __SPI4_IS_CLK_DISABLED __HAL_RCC_SPI4_IS_CLK_DISABLED
#define __SDADC1_IS_CLK_ENABLED __HAL_RCC_SDADC1_IS_CLK_ENABLED
#define __SDADC1_IS_CLK_DISABLED __HAL_RCC_SDADC1_IS_CLK_DISABLED
#define __SDADC2_IS_CLK_ENABLED __HAL_RCC_SDADC2_IS_CLK_ENABLED
#define __SDADC2_IS_CLK_DISABLED __HAL_RCC_SDADC2_IS_CLK_DISABLED
#define __SDADC3_IS_CLK_ENABLED __HAL_RCC_SDADC3_IS_CLK_ENABLED
#define __SDADC3_IS_CLK_DISABLED __HAL_RCC_SDADC3_IS_CLK_DISABLED
#define __SRAM_IS_CLK_ENABLED __HAL_RCC_SRAM_IS_CLK_ENABLED
#define __SRAM_IS_CLK_DISABLED __HAL_RCC_SRAM_IS_CLK_DISABLED
#define __TIM1_IS_CLK_ENABLED __HAL_RCC_TIM1_IS_CLK_ENABLED
#define __TIM1_IS_CLK_DISABLED __HAL_RCC_TIM1_IS_CLK_DISABLED
#define __TIM2_IS_CLK_ENABLED __HAL_RCC_TIM2_IS_CLK_ENABLED
#define __TIM2_IS_CLK_DISABLED __HAL_RCC_TIM2_IS_CLK_DISABLED
#define __TIM3_IS_CLK_ENABLED __HAL_RCC_TIM3_IS_CLK_ENABLED
#define __TIM3_IS_CLK_DISABLED __HAL_RCC_TIM3_IS_CLK_DISABLED
#define __TIM4_IS_CLK_ENABLED __HAL_RCC_TIM4_IS_CLK_ENABLED
#define __TIM4_IS_CLK_DISABLED __HAL_RCC_TIM4_IS_CLK_DISABLED
#define __TIM5_IS_CLK_ENABLED __HAL_RCC_TIM5_IS_CLK_ENABLED
#define __TIM5_IS_CLK_DISABLED __HAL_RCC_TIM5_IS_CLK_DISABLED
#define __TIM6_IS_CLK_ENABLED __HAL_RCC_TIM6_IS_CLK_ENABLED
#define __TIM6_IS_CLK_DISABLED __HAL_RCC_TIM6_IS_CLK_DISABLED
#define __TIM7_IS_CLK_ENABLED __HAL_RCC_TIM7_IS_CLK_ENABLED
#define __TIM7_IS_CLK_DISABLED __HAL_RCC_TIM7_IS_CLK_DISABLED
#define __TIM8_IS_CLK_ENABLED __HAL_RCC_TIM8_IS_CLK_ENABLED
#define __TIM8_IS_CLK_DISABLED __HAL_RCC_TIM8_IS_CLK_DISABLED
#define __TIM12_IS_CLK_ENABLED __HAL_RCC_TIM12_IS_CLK_ENABLED
#define __TIM12_IS_CLK_DISABLED __HAL_RCC_TIM12_IS_CLK_DISABLED
#define __TIM13_IS_CLK_ENABLED __HAL_RCC_TIM13_IS_CLK_ENABLED
#define __TIM13_IS_CLK_DISABLED __HAL_RCC_TIM13_IS_CLK_DISABLED
#define __TIM14_IS_CLK_ENABLED __HAL_RCC_TIM14_IS_CLK_ENABLED
#define __TIM14_IS_CLK_DISABLED __HAL_RCC_TIM14_IS_CLK_DISABLED
#define __TIM15_IS_CLK_ENABLED __HAL_RCC_TIM15_IS_CLK_ENABLED
#define __TIM15_IS_CLK_DISABLED __HAL_RCC_TIM15_IS_CLK_DISABLED
#define __TIM16_IS_CLK_ENABLED __HAL_RCC_TIM16_IS_CLK_ENABLED
#define __TIM16_IS_CLK_DISABLED __HAL_RCC_TIM16_IS_CLK_DISABLED
#define __TIM17_IS_CLK_ENABLED __HAL_RCC_TIM17_IS_CLK_ENABLED
#define __TIM17_IS_CLK_DISABLED __HAL_RCC_TIM17_IS_CLK_DISABLED
#define __TIM18_IS_CLK_ENABLED __HAL_RCC_TIM18_IS_CLK_ENABLED
#define __TIM18_IS_CLK_DISABLED __HAL_RCC_TIM18_IS_CLK_DISABLED
#define __TIM19_IS_CLK_ENABLED __HAL_RCC_TIM19_IS_CLK_ENABLED
#define __TIM19_IS_CLK_DISABLED __HAL_RCC_TIM19_IS_CLK_DISABLED
#define __TIM20_IS_CLK_ENABLED __HAL_RCC_TIM20_IS_CLK_ENABLED
#define __TIM20_IS_CLK_DISABLED __HAL_RCC_TIM20_IS_CLK_DISABLED
#define __TSC_IS_CLK_ENABLED __HAL_RCC_TSC_IS_CLK_ENABLED
#define __TSC_IS_CLK_DISABLED __HAL_RCC_TSC_IS_CLK_DISABLED
#define __UART4_IS_CLK_ENABLED __HAL_RCC_UART4_IS_CLK_ENABLED
#define __UART4_IS_CLK_DISABLED __HAL_RCC_UART4_IS_CLK_DISABLED
#define __UART5_IS_CLK_ENABLED __HAL_RCC_UART5_IS_CLK_ENABLED
#define __UART5_IS_CLK_DISABLED __HAL_RCC_UART5_IS_CLK_DISABLED
#define __USART1_IS_CLK_ENABLED __HAL_RCC_USART1_IS_CLK_ENABLED
#define __USART1_IS_CLK_DISABLED __HAL_RCC_USART1_IS_CLK_DISABLED
#define __USART2_IS_CLK_ENABLED __HAL_RCC_USART2_IS_CLK_ENABLED
#define __USART2_IS_CLK_DISABLED __HAL_RCC_USART2_IS_CLK_DISABLED
#define __USART3_IS_CLK_ENABLED __HAL_RCC_USART3_IS_CLK_ENABLED
#define __USART3_IS_CLK_DISABLED __HAL_RCC_USART3_IS_CLK_DISABLED
#define __USB_IS_CLK_ENABLED __HAL_RCC_USB_IS_CLK_ENABLED
#define __USB_IS_CLK_DISABLED __HAL_RCC_USB_IS_CLK_DISABLED
#define __WWDG_IS_CLK_ENABLED __HAL_RCC_WWDG_IS_CLK_ENABLED
#define __WWDG_IS_CLK_DISABLED __HAL_RCC_WWDG_IS_CLK_DISABLED

# 3578 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

# 3595 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

# 3610 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"






# 3639 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

#define __HAL_RCC_I2SCLK __HAL_RCC_I2S_CONFIG
#define __HAL_RCC_I2SCLK_CONFIG __HAL_RCC_I2S_CONFIG

#define __RCC_PLLSRC RCC_GET_PLL_OSCSOURCE

#define IS_RCC_MSIRANGE IS_RCC_MSI_CLOCK_RANGE
#define IS_RCC_RTCCLK_SOURCE IS_RCC_RTCCLKSOURCE
#define IS_RCC_SYSCLK_DIV IS_RCC_HCLK
#define IS_RCC_HCLK_DIV IS_RCC_PCLK
#define IS_RCC_PERIPHCLK IS_RCC_PERIPHCLOCK

#define RCC_IT_HSI14 RCC_IT_HSI14RDY

#define RCC_IT_CSSLSE RCC_IT_LSECSS
#define RCC_IT_CSSHSE RCC_IT_CSS

#define RCC_PLLMUL_3 RCC_PLL_MUL3
#define RCC_PLLMUL_4 RCC_PLL_MUL4
#define RCC_PLLMUL_6 RCC_PLL_MUL6
#define RCC_PLLMUL_8 RCC_PLL_MUL8
#define RCC_PLLMUL_12 RCC_PLL_MUL12
#define RCC_PLLMUL_16 RCC_PLL_MUL16
#define RCC_PLLMUL_24 RCC_PLL_MUL24
#define RCC_PLLMUL_32 RCC_PLL_MUL32
#define RCC_PLLMUL_48 RCC_PLL_MUL48

#define RCC_PLLDIV_2 RCC_PLL_DIV2
#define RCC_PLLDIV_3 RCC_PLL_DIV3
#define RCC_PLLDIV_4 RCC_PLL_DIV4

#define IS_RCC_MCOSOURCE IS_RCC_MCO1SOURCE
#define __HAL_RCC_MCO_CONFIG __HAL_RCC_MCO1_CONFIG
#define RCC_MCO_NODIV RCC_MCODIV_1
#define RCC_MCO_DIV1 RCC_MCODIV_1
#define RCC_MCO_DIV2 RCC_MCODIV_2
#define RCC_MCO_DIV4 RCC_MCODIV_4
#define RCC_MCO_DIV8 RCC_MCODIV_8
#define RCC_MCO_DIV16 RCC_MCODIV_16
#define RCC_MCO_DIV32 RCC_MCODIV_32
#define RCC_MCO_DIV64 RCC_MCODIV_64
#define RCC_MCO_DIV128 RCC_MCODIV_128
#define RCC_MCOSOURCE_NONE RCC_MCO1SOURCE_NOCLOCK
#define RCC_MCOSOURCE_LSI RCC_MCO1SOURCE_LSI
#define RCC_MCOSOURCE_LSE RCC_MCO1SOURCE_LSE
#define RCC_MCOSOURCE_SYSCLK RCC_MCO1SOURCE_SYSCLK
#define RCC_MCOSOURCE_HSI RCC_MCO1SOURCE_HSI
#define RCC_MCOSOURCE_HSI14 RCC_MCO1SOURCE_HSI14
#define RCC_MCOSOURCE_HSI48 RCC_MCO1SOURCE_HSI48
#define RCC_MCOSOURCE_HSE RCC_MCO1SOURCE_HSE
#define RCC_MCOSOURCE_PLLCLK_DIV1 RCC_MCO1SOURCE_PLLCLK
#define RCC_MCOSOURCE_PLLCLK_NODIV RCC_MCO1SOURCE_PLLCLK
#define RCC_MCOSOURCE_PLLCLK_DIV2 RCC_MCO1SOURCE_PLLCLK_DIV2







#define RCC_RTCCLKSOURCE_NO_CLK RCC_RTCCLKSOURCE_NONE




#define RCC_USBCLK_PLLSAI1 RCC_USBCLKSOURCE_PLLSAI1
#define RCC_USBCLK_PLL RCC_USBCLKSOURCE_PLL
#define RCC_USBCLK_MSI RCC_USBCLKSOURCE_MSI
#define RCC_USBCLKSOURCE_PLLCLK RCC_USBCLKSOURCE_PLL
#define RCC_USBPLLCLK_DIV1 RCC_USBCLKSOURCE_PLL
#define RCC_USBPLLCLK_DIV1_5 RCC_USBCLKSOURCE_PLL_DIV1_5
#define RCC_USBPLLCLK_DIV2 RCC_USBCLKSOURCE_PLL_DIV2
#define RCC_USBPLLCLK_DIV3 RCC_USBCLKSOURCE_PLL_DIV3

#define HSION_BitNumber RCC_HSION_BIT_NUMBER
#define HSION_BITNUMBER RCC_HSION_BIT_NUMBER
#define HSEON_BitNumber RCC_HSEON_BIT_NUMBER
#define HSEON_BITNUMBER RCC_HSEON_BIT_NUMBER
#define MSION_BITNUMBER RCC_MSION_BIT_NUMBER
#define CSSON_BitNumber RCC_CSSON_BIT_NUMBER
#define CSSON_BITNUMBER RCC_CSSON_BIT_NUMBER
#define PLLON_BitNumber RCC_PLLON_BIT_NUMBER
#define PLLON_BITNUMBER RCC_PLLON_BIT_NUMBER
#define PLLI2SON_BitNumber RCC_PLLI2SON_BIT_NUMBER
#define I2SSRC_BitNumber RCC_I2SSRC_BIT_NUMBER
#define RTCEN_BitNumber RCC_RTCEN_BIT_NUMBER
#define RTCEN_BITNUMBER RCC_RTCEN_BIT_NUMBER
#define BDRST_BitNumber RCC_BDRST_BIT_NUMBER
#define BDRST_BITNUMBER RCC_BDRST_BIT_NUMBER
#define RTCRST_BITNUMBER RCC_RTCRST_BIT_NUMBER
#define LSION_BitNumber RCC_LSION_BIT_NUMBER
#define LSION_BITNUMBER RCC_LSION_BIT_NUMBER
#define LSEON_BitNumber RCC_LSEON_BIT_NUMBER
#define LSEON_BITNUMBER RCC_LSEON_BIT_NUMBER
#define LSEBYP_BITNUMBER RCC_LSEBYP_BIT_NUMBER
#define PLLSAION_BitNumber RCC_PLLSAION_BIT_NUMBER
#define TIMPRE_BitNumber RCC_TIMPRE_BIT_NUMBER
#define RMVF_BitNumber RCC_RMVF_BIT_NUMBER
#define RMVF_BITNUMBER RCC_RMVF_BIT_NUMBER
#define RCC_CR2_HSI14TRIM_BitNumber RCC_HSI14TRIM_BIT_NUMBER
#define CR_BYTE2_ADDRESS RCC_CR_BYTE2_ADDRESS
#define CIR_BYTE1_ADDRESS RCC_CIR_BYTE1_ADDRESS
#define CIR_BYTE2_ADDRESS RCC_CIR_BYTE2_ADDRESS
#define BDCR_BYTE0_ADDRESS RCC_BDCR_BYTE0_ADDRESS
#define DBP_TIMEOUT_VALUE RCC_DBP_TIMEOUT_VALUE
#define LSE_TIMEOUT_VALUE RCC_LSE_TIMEOUT_VALUE

#define CR_HSION_BB RCC_CR_HSION_BB
#define CR_CSSON_BB RCC_CR_CSSON_BB
#define CR_PLLON_BB RCC_CR_PLLON_BB
#define CR_PLLI2SON_BB RCC_CR_PLLI2SON_BB
#define CR_MSION_BB RCC_CR_MSION_BB
#define CSR_LSION_BB RCC_CSR_LSION_BB
#define CSR_LSEON_BB RCC_CSR_LSEON_BB
#define CSR_LSEBYP_BB RCC_CSR_LSEBYP_BB
#define CSR_RTCEN_BB RCC_CSR_RTCEN_BB
#define CSR_RTCRST_BB RCC_CSR_RTCRST_BB
#define CFGR_I2SSRC_BB RCC_CFGR_I2SSRC_BB
#define BDCR_RTCEN_BB RCC_BDCR_RTCEN_BB
#define BDCR_BDRST_BB RCC_BDCR_BDRST_BB
#define CR_HSEON_BB RCC_CR_HSEON_BB
#define CSR_RMVF_BB RCC_CSR_RMVF_BB
#define CR_PLLSAION_BB RCC_CR_PLLSAION_BB
#define DCKCFGR_TIMPRE_BB RCC_DCKCFGR_TIMPRE_BB

#define __HAL_RCC_CRS_ENABLE_FREQ_ERROR_COUNTER __HAL_RCC_CRS_FREQ_ERROR_COUNTER_ENABLE
#define __HAL_RCC_CRS_DISABLE_FREQ_ERROR_COUNTER __HAL_RCC_CRS_FREQ_ERROR_COUNTER_DISABLE
#define __HAL_RCC_CRS_ENABLE_AUTOMATIC_CALIB __HAL_RCC_CRS_AUTOMATIC_CALIB_ENABLE
#define __HAL_RCC_CRS_DISABLE_AUTOMATIC_CALIB __HAL_RCC_CRS_AUTOMATIC_CALIB_DISABLE
#define __HAL_RCC_CRS_CALCULATE_RELOADVALUE __HAL_RCC_CRS_RELOADVALUE_CALCULATE

#define __HAL_RCC_GET_IT_SOURCE __HAL_RCC_GET_IT

#define RCC_CRS_SYNCWARM RCC_CRS_SYNCWARN
#define RCC_CRS_TRIMOV RCC_CRS_TRIMOVF

#define RCC_PERIPHCLK_CK48 RCC_PERIPHCLK_CLK48
#define RCC_CK48CLKSOURCE_PLLQ RCC_CLK48CLKSOURCE_PLLQ
#define RCC_CK48CLKSOURCE_PLLSAIP RCC_CLK48CLKSOURCE_PLLSAIP
#define RCC_CK48CLKSOURCE_PLLI2SQ RCC_CLK48CLKSOURCE_PLLI2SQ
#define IS_RCC_CK48CLKSOURCE IS_RCC_CLK48CLKSOURCE
#define RCC_SDIOCLKSOURCE_CK48 RCC_SDIOCLKSOURCE_CLK48

#define __HAL_RCC_DFSDM_CLK_ENABLE __HAL_RCC_DFSDM1_CLK_ENABLE
#define __HAL_RCC_DFSDM_CLK_DISABLE __HAL_RCC_DFSDM1_CLK_DISABLE
#define __HAL_RCC_DFSDM_IS_CLK_ENABLED __HAL_RCC_DFSDM1_IS_CLK_ENABLED
#define __HAL_RCC_DFSDM_IS_CLK_DISABLED __HAL_RCC_DFSDM1_IS_CLK_DISABLED
#define __HAL_RCC_DFSDM_FORCE_RESET __HAL_RCC_DFSDM1_FORCE_RESET
#define __HAL_RCC_DFSDM_RELEASE_RESET __HAL_RCC_DFSDM1_RELEASE_RESET
#define __HAL_RCC_DFSDM_CLK_SLEEP_ENABLE __HAL_RCC_DFSDM1_CLK_SLEEP_ENABLE
#define __HAL_RCC_DFSDM_CLK_SLEEP_DISABLE __HAL_RCC_DFSDM1_CLK_SLEEP_DISABLE
#define __HAL_RCC_DFSDM_IS_CLK_SLEEP_ENABLED __HAL_RCC_DFSDM1_IS_CLK_SLEEP_ENABLED
#define __HAL_RCC_DFSDM_IS_CLK_SLEEP_DISABLED __HAL_RCC_DFSDM1_IS_CLK_SLEEP_DISABLED
#define DfsdmClockSelection Dfsdm1ClockSelection
#define RCC_PERIPHCLK_DFSDM RCC_PERIPHCLK_DFSDM1
#define RCC_DFSDMCLKSOURCE_PCLK RCC_DFSDM1CLKSOURCE_PCLK2
#define RCC_DFSDMCLKSOURCE_SYSCLK RCC_DFSDM1CLKSOURCE_SYSCLK
#define __HAL_RCC_DFSDM_CONFIG __HAL_RCC_DFSDM1_CONFIG
#define __HAL_RCC_GET_DFSDM_SOURCE __HAL_RCC_GET_DFSDM1_SOURCE
#define RCC_DFSDM1CLKSOURCE_PCLK RCC_DFSDM1CLKSOURCE_PCLK2
#define RCC_SWPMI1CLKSOURCE_PCLK RCC_SWPMI1CLKSOURCE_PCLK1

#define RCC_LPTIM1CLKSOURCE_PCLK RCC_LPTIM1CLKSOURCE_PCLK1
#define RCC_LPTIM2CLKSOURCE_PCLK RCC_LPTIM2CLKSOURCE_PCLK1


#define RCC_DFSDM1AUDIOCLKSOURCE_I2SAPB1 RCC_DFSDM1AUDIOCLKSOURCE_I2S1
#define RCC_DFSDM1AUDIOCLKSOURCE_I2SAPB2 RCC_DFSDM1AUDIOCLKSOURCE_I2S2
#define RCC_DFSDM2AUDIOCLKSOURCE_I2SAPB1 RCC_DFSDM2AUDIOCLKSOURCE_I2S1
#define RCC_DFSDM2AUDIOCLKSOURCE_I2SAPB2 RCC_DFSDM2AUDIOCLKSOURCE_I2S2
#define RCC_DFSDM1CLKSOURCE_APB2 RCC_DFSDM1CLKSOURCE_PCLK2
#define RCC_DFSDM2CLKSOURCE_APB2 RCC_DFSDM2CLKSOURCE_PCLK2
#define RCC_FMPI2C1CLKSOURCE_APB RCC_FMPI2C1CLKSOURCE_PCLK1
# 3844 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

# 3930 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

/**
  * @}
  */

/** @defgroup HAL_RNG_Aliased_Macros HAL RNG Aliased Macros maintained for legacy purpose
  * @{
  */
#define HAL_RNG_ReadyCallback(__HANDLE__) HAL_RNG_ReadyDataCallback((__HANDLE__), uint32_t random32bit)

/**
  * @}
  */

/** @defgroup HAL_RTC_Aliased_Macros HAL RTC Aliased Macros maintained for legacy purpose
  * @{
  */






#define __HAL_RTC_DISABLE_IT __HAL_RTC_EXTI_DISABLE_IT
#define __HAL_RTC_ENABLE_IT __HAL_RTC_EXTI_ENABLE_IT

# 3967 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"
#define __HAL_RTC_EXTI_CLEAR_FLAG(__EXTI_LINE__) (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_CLEAR_FLAG() : (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG() : __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG()))


#define __HAL_RTC_EXTI_ENABLE_IT(__EXTI_LINE__) (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_ENABLE_IT() : (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT() : __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT()))


#define __HAL_RTC_EXTI_DISABLE_IT(__EXTI_LINE__) (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_DISABLE_IT() : (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_IT() : __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_IT()))


#define __HAL_RTC_EXTI_GET_FLAG(__EXTI_LINE__) (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GET_FLAG() : (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GET_FLAG() : __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GET_FLAG()))


#define __HAL_RTC_EXTI_GENERATE_SWIT(__EXTI_LINE__) (((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GENERATE_SWIT() : (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GENERATE_SWIT() : __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GENERATE_SWIT()))











#define IS_ALARM IS_RTC_ALARM
#define IS_ALARM_MASK IS_RTC_ALARM_MASK
#define IS_TAMPER IS_RTC_TAMPER
#define IS_TAMPER_ERASE_MODE IS_RTC_TAMPER_ERASE_MODE
#define IS_TAMPER_FILTER IS_RTC_TAMPER_FILTER
#define IS_TAMPER_INTERRUPT IS_RTC_TAMPER_INTERRUPT
#define IS_TAMPER_MASKFLAG_STATE IS_RTC_TAMPER_MASKFLAG_STATE
#define IS_TAMPER_PRECHARGE_DURATION IS_RTC_TAMPER_PRECHARGE_DURATION
#define IS_TAMPER_PULLUP_STATE IS_RTC_TAMPER_PULLUP_STATE
#define IS_TAMPER_SAMPLING_FREQ IS_RTC_TAMPER_SAMPLING_FREQ
#define IS_TAMPER_TIMESTAMPONTAMPER_DETECTION IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION
#define IS_TAMPER_TRIGGER IS_RTC_TAMPER_TRIGGER
#define IS_WAKEUP_CLOCK IS_RTC_WAKEUP_CLOCK
#define IS_WAKEUP_COUNTER IS_RTC_WAKEUP_COUNTER

#define __RTC_WRITEPROTECTION_ENABLE __HAL_RTC_WRITEPROTECTION_ENABLE
#define __RTC_WRITEPROTECTION_DISABLE __HAL_RTC_WRITEPROTECTION_DISABLE






/**
  * @}
  */

/** @defgroup HAL_SD_Aliased_Macros HAL SD/MMC Aliased Macros maintained for legacy purpose
  * @{
  */

#define SD_OCR_CID_CSD_OVERWRIETE SD_OCR_CID_CSD_OVERWRITE
#define SD_CMD_SD_APP_STAUS SD_CMD_SD_APP_STATUS


#define eMMC_HIGH_VOLTAGE_RANGE EMMC_HIGH_VOLTAGE_RANGE
#define eMMC_DUAL_VOLTAGE_RANGE EMMC_DUAL_VOLTAGE_RANGE
#define eMMC_LOW_VOLTAGE_RANGE EMMC_LOW_VOLTAGE_RANGE

#define SDMMC_NSpeed_CLK_DIV SDMMC_NSPEED_CLK_DIV
#define SDMMC_HSpeed_CLK_DIV SDMMC_HSPEED_CLK_DIV


# 4059 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"

# 4085 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"








# 4104 "Drivers/STM32G4xx_HAL_Driver/Inc/Legacy/stm32_hal_legacy.h"
/**
  * @}
  */

/** @defgroup HAL_SMARTCARD_Aliased_Macros HAL SMARTCARD Aliased Macros maintained for legacy purpose
  * @{
  */

#define __SMARTCARD_ENABLE_IT __HAL_SMARTCARD_ENABLE_IT
#define __SMARTCARD_DISABLE_IT __HAL_SMARTCARD_DISABLE_IT
#define __SMARTCARD_ENABLE __HAL_SMARTCARD_ENABLE
#define __SMARTCARD_DISABLE __HAL_SMARTCARD_DISABLE
#define __SMARTCARD_DMA_REQUEST_ENABLE __HAL_SMARTCARD_DMA_REQUEST_ENABLE
#define __SMARTCARD_DMA_REQUEST_DISABLE __HAL_SMARTCARD_DMA_REQUEST_DISABLE

#define __HAL_SMARTCARD_GETCLOCKSOURCE SMARTCARD_GETCLOCKSOURCE
#define __SMARTCARD_GETCLOCKSOURCE SMARTCARD_GETCLOCKSOURCE

#define IS_SMARTCARD_ONEBIT_SAMPLING IS_SMARTCARD_ONE_BIT_SAMPLE

/**
  * @}
  */

/** @defgroup HAL_SMBUS_Aliased_Macros HAL SMBUS Aliased Macros maintained for legacy purpose
  * @{
  */
#define __HAL_SMBUS_RESET_CR1 SMBUS_RESET_CR1
#define __HAL_SMBUS_RESET_CR2 SMBUS_RESET_CR2
#define __HAL_SMBUS_GENERATE_START SMBUS_GENERATE_START
#define __HAL_SMBUS_GET_ADDR_MATCH SMBUS_GET_ADDR_MATCH
#define __HAL_SMBUS_GET_DIR SMBUS_GET_DIR
#define __HAL_SMBUS_GET_STOP_MODE SMBUS_GET_STOP_MODE
#define __HAL_SMBUS_GET_PEC_MODE SMBUS_GET_PEC_MODE
#define __HAL_SMBUS_GET_ALERT_ENABLED SMBUS_GET_ALERT_ENABLED
/**
  * @}
  */

/** @defgroup HAL_SPI_Aliased_Macros HAL SPI Aliased Macros maintained for legacy purpose
  * @{
  */

#define __HAL_SPI_1LINE_TX SPI_1LINE_TX
#define __HAL_SPI_1LINE_RX SPI_1LINE_RX
#define __HAL_SPI_RESET_CRC SPI_RESET_CRC

/**
  * @}
  */

/** @defgroup HAL_UART_Aliased_Macros HAL UART Aliased Macros maintained for legacy purpose
  * @{
  */

#define __HAL_UART_GETCLOCKSOURCE UART_GETCLOCKSOURCE
#define __HAL_UART_MASK_COMPUTATION UART_MASK_COMPUTATION
#define __UART_GETCLOCKSOURCE UART_GETCLOCKSOURCE
#define __UART_MASK_COMPUTATION UART_MASK_COMPUTATION

#define IS_UART_WAKEUPMETHODE IS_UART_WAKEUPMETHOD

#define IS_UART_ONEBIT_SAMPLE IS_UART_ONE_BIT_SAMPLE
#define IS_UART_ONEBIT_SAMPLING IS_UART_ONE_BIT_SAMPLE

/**
  * @}
  */


/** @defgroup HAL_USART_Aliased_Macros HAL USART Aliased Macros maintained for legacy purpose
  * @{
  */

#define __USART_ENABLE_IT __HAL_USART_ENABLE_IT
#define __USART_DISABLE_IT __HAL_USART_DISABLE_IT
#define __USART_ENABLE __HAL_USART_ENABLE
#define __USART_DISABLE __HAL_USART_DISABLE

#define __HAL_USART_GETCLOCKSOURCE USART_GETCLOCKSOURCE
#define __USART_GETCLOCKSOURCE USART_GETCLOCKSOURCE








/**
  * @}
  */

/** @defgroup HAL_USB_Aliased_Macros HAL USB Aliased Macros maintained for legacy purpose
  * @{
  */
#define USB_EXTI_LINE_WAKEUP USB_WAKEUP_EXTI_LINE

#define USB_FS_EXTI_TRIGGER_RISING_EDGE USB_OTG_FS_WAKEUP_EXTI_RISING_EDGE
#define USB_FS_EXTI_TRIGGER_FALLING_EDGE USB_OTG_FS_WAKEUP_EXTI_FALLING_EDGE
#define USB_FS_EXTI_TRIGGER_BOTH_EDGE USB_OTG_FS_WAKEUP_EXTI_RISING_FALLING_EDGE
#define USB_FS_EXTI_LINE_WAKEUP USB_OTG_FS_WAKEUP_EXTI_LINE

#define USB_HS_EXTI_TRIGGER_RISING_EDGE USB_OTG_HS_WAKEUP_EXTI_RISING_EDGE
#define USB_HS_EXTI_TRIGGER_FALLING_EDGE USB_OTG_HS_WAKEUP_EXTI_FALLING_EDGE
#define USB_HS_EXTI_TRIGGER_BOTH_EDGE USB_OTG_HS_WAKEUP_EXTI_RISING_FALLING_EDGE
#define USB_HS_EXTI_LINE_WAKEUP USB_OTG_HS_WAKEUP_EXTI_LINE

#define __HAL_USB_EXTI_ENABLE_IT __HAL_USB_WAKEUP_EXTI_ENABLE_IT
#define __HAL_USB_EXTI_DISABLE_IT __HAL_USB_WAKEUP_EXTI_DISABLE_IT
#define __HAL_USB_EXTI_GET_FLAG __HAL_USB_WAKEUP_EXTI_GET_FLAG
#define __HAL_USB_EXTI_CLEAR_FLAG __HAL_USB_WAKEUP_EXTI_CLEAR_FLAG
#define __HAL_USB_EXTI_SET_RISING_EDGE_TRIGGER __HAL_USB_WAKEUP_EXTI_ENABLE_RISING_EDGE
#define __HAL_USB_EXTI_SET_FALLING_EDGE_TRIGGER __HAL_USB_WAKEUP_EXTI_ENABLE_FALLING_EDGE
#define __HAL_USB_EXTI_SET_FALLINGRISING_TRIGGER __HAL_USB_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE

#define __HAL_USB_FS_EXTI_ENABLE_IT __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_IT
#define __HAL_USB_FS_EXTI_DISABLE_IT __HAL_USB_OTG_FS_WAKEUP_EXTI_DISABLE_IT
#define __HAL_USB_FS_EXTI_GET_FLAG __HAL_USB_OTG_FS_WAKEUP_EXTI_GET_FLAG
#define __HAL_USB_FS_EXTI_CLEAR_FLAG __HAL_USB_OTG_FS_WAKEUP_EXTI_CLEAR_FLAG
#define __HAL_USB_FS_EXTI_SET_RISING_EGDE_TRIGGER __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_RISING_EDGE
#define __HAL_USB_FS_EXTI_SET_FALLING_EGDE_TRIGGER __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_FALLING_EDGE
#define __HAL_USB_FS_EXTI_SET_FALLINGRISING_TRIGGER __HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE
#define __HAL_USB_FS_EXTI_GENERATE_SWIT __HAL_USB_OTG_FS_WAKEUP_EXTI_GENERATE_SWIT

#define __HAL_USB_HS_EXTI_ENABLE_IT __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_IT
#define __HAL_USB_HS_EXTI_DISABLE_IT __HAL_USB_OTG_HS_WAKEUP_EXTI_DISABLE_IT
#define __HAL_USB_HS_EXTI_GET_FLAG __HAL_USB_OTG_HS_WAKEUP_EXTI_GET_FLAG
#define __HAL_USB_HS_EXTI_CLEAR_FLAG __HAL_USB_OTG_HS_WAKEUP_EXTI_CLEAR_FLAG
#define __HAL_USB_HS_EXTI_SET_RISING_EGDE_TRIGGER __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_RISING_EDGE
#define __HAL_USB_HS_EXTI_SET_FALLING_EGDE_TRIGGER __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_FALLING_EDGE
#define __HAL_USB_HS_EXTI_SET_FALLINGRISING_TRIGGER __HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE
#define __HAL_USB_HS_EXTI_GENERATE_SWIT __HAL_USB_OTG_HS_WAKEUP_EXTI_GENERATE_SWIT

#define HAL_PCD_ActiveRemoteWakeup HAL_PCD_ActivateRemoteWakeup
#define HAL_PCD_DeActiveRemoteWakeup HAL_PCD_DeActivateRemoteWakeup

#define HAL_PCD_SetTxFiFo HAL_PCDEx_SetTxFiFo
#define HAL_PCD_SetRxFiFo HAL_PCDEx_SetRxFiFo
/**
  * @}
  */

/** @defgroup HAL_TIM_Aliased_Macros HAL TIM Aliased Macros maintained for legacy purpose
  * @{
  */
#define __HAL_TIM_SetICPrescalerValue TIM_SET_ICPRESCALERVALUE
#define __HAL_TIM_ResetICPrescalerValue TIM_RESET_ICPRESCALERVALUE

#define TIM_GET_ITSTATUS __HAL_TIM_GET_IT_SOURCE
#define TIM_GET_CLEAR_IT __HAL_TIM_CLEAR_IT

#define __HAL_TIM_GET_ITSTATUS __HAL_TIM_GET_IT_SOURCE

#define __HAL_TIM_DIRECTION_STATUS __HAL_TIM_IS_TIM_COUNTING_DOWN
#define __HAL_TIM_PRESCALER __HAL_TIM_SET_PRESCALER
#define __HAL_TIM_SetCounter __HAL_TIM_SET_COUNTER
#define __HAL_TIM_GetCounter __HAL_TIM_GET_COUNTER
#define __HAL_TIM_SetAutoreload __HAL_TIM_SET_AUTORELOAD
#define __HAL_TIM_GetAutoreload __HAL_TIM_GET_AUTORELOAD
#define __HAL_TIM_SetClockDivision __HAL_TIM_SET_CLOCKDIVISION
#define __HAL_TIM_GetClockDivision __HAL_TIM_GET_CLOCKDIVISION
#define __HAL_TIM_SetICPrescaler __HAL_TIM_SET_ICPRESCALER
#define __HAL_TIM_GetICPrescaler __HAL_TIM_GET_ICPRESCALER
#define __HAL_TIM_SetCompare __HAL_TIM_SET_COMPARE
#define __HAL_TIM_GetCompare __HAL_TIM_GET_COMPARE

#define TIM_BREAKINPUTSOURCE_DFSDM TIM_BREAKINPUTSOURCE_DFSDM1

#define TIM_OCMODE_ASSYMETRIC_PWM1 TIM_OCMODE_ASYMMETRIC_PWM1
#define TIM_OCMODE_ASSYMETRIC_PWM2 TIM_OCMODE_ASYMMETRIC_PWM2
/**
  * @}
  */

/** @defgroup HAL_ETH_Aliased_Macros HAL ETH Aliased Macros maintained for legacy purpose
  * @{
  */

#define __HAL_ETH_EXTI_ENABLE_IT __HAL_ETH_WAKEUP_EXTI_ENABLE_IT
#define __HAL_ETH_EXTI_DISABLE_IT __HAL_ETH_WAKEUP_EXTI_DISABLE_IT
#define __HAL_ETH_EXTI_GET_FLAG __HAL_ETH_WAKEUP_EXTI_GET_FLAG
#define __HAL_ETH_EXTI_CLEAR_FLAG __HAL_ETH_WAKEUP_EXTI_CLEAR_FLAG
#define __HAL_ETH_EXTI_SET_RISING_EGDE_TRIGGER __HAL_ETH_WAKEUP_EXTI_ENABLE_RISING_EDGE_TRIGGER
#define __HAL_ETH_EXTI_SET_FALLING_EGDE_TRIGGER __HAL_ETH_WAKEUP_EXTI_ENABLE_FALLING_EDGE_TRIGGER
#define __HAL_ETH_EXTI_SET_FALLINGRISING_TRIGGER __HAL_ETH_WAKEUP_EXTI_ENABLE_FALLINGRISING_TRIGGER

#define ETH_PROMISCIOUSMODE_ENABLE ETH_PROMISCUOUS_MODE_ENABLE
#define ETH_PROMISCIOUSMODE_DISABLE ETH_PROMISCUOUS_MODE_DISABLE
#define IS_ETH_PROMISCIOUS_MODE IS_ETH_PROMISCUOUS_MODE
/**
  * @}
  */

/** @defgroup HAL_LTDC_Aliased_Macros HAL LTDC Aliased Macros maintained for legacy purpose
  * @{
  */
#define __HAL_LTDC_LAYER LTDC_LAYER
#define __HAL_LTDC_RELOAD_CONFIG __HAL_LTDC_RELOAD_IMMEDIATE_CONFIG
/**
  * @}
  */

/** @defgroup HAL_SAI_Aliased_Macros HAL SAI Aliased Macros maintained for legacy purpose
  * @{
  */
#define SAI_OUTPUTDRIVE_DISABLED SAI_OUTPUTDRIVE_DISABLE
#define SAI_OUTPUTDRIVE_ENABLED SAI_OUTPUTDRIVE_ENABLE
#define SAI_MASTERDIVIDER_ENABLED SAI_MASTERDIVIDER_ENABLE
#define SAI_MASTERDIVIDER_DISABLED SAI_MASTERDIVIDER_DISABLE
#define SAI_STREOMODE SAI_STEREOMODE
#define SAI_FIFOStatus_Empty SAI_FIFOSTATUS_EMPTY
#define SAI_FIFOStatus_Less1QuarterFull SAI_FIFOSTATUS_LESS1QUARTERFULL
#define SAI_FIFOStatus_1QuarterFull SAI_FIFOSTATUS_1QUARTERFULL
#define SAI_FIFOStatus_HalfFull SAI_FIFOSTATUS_HALFFULL
#define SAI_FIFOStatus_3QuartersFull SAI_FIFOSTATUS_3QUARTERFULL
#define SAI_FIFOStatus_Full SAI_FIFOSTATUS_FULL
#define IS_SAI_BLOCK_MONO_STREO_MODE IS_SAI_BLOCK_MONO_STEREO_MODE
#define SAI_SYNCHRONOUS_EXT SAI_SYNCHRONOUS_EXT_SAI1
#define SAI_SYNCEXT_IN_ENABLE SAI_SYNCEXT_OUTBLOCKA_ENABLE
/**
  * @}
  */

/** @defgroup HAL_SPDIFRX_Aliased_Macros HAL SPDIFRX Aliased Macros maintained for legacy purpose
  * @{
  */





/**
  * @}
  */

/** @defgroup HAL_HRTIM_Aliased_Functions HAL HRTIM Aliased Functions maintained for legacy purpose
  * @{
  */

#define HAL_HRTIM_WaveformCounterStart_IT HAL_HRTIM_WaveformCountStart_IT
#define HAL_HRTIM_WaveformCounterStart_DMA HAL_HRTIM_WaveformCountStart_DMA
#define HAL_HRTIM_WaveformCounterStart HAL_HRTIM_WaveformCountStart
#define HAL_HRTIM_WaveformCounterStop_IT HAL_HRTIM_WaveformCountStop_IT
#define HAL_HRTIM_WaveformCounterStop_DMA HAL_HRTIM_WaveformCountStop_DMA
#define HAL_HRTIM_WaveformCounterStop HAL_HRTIM_WaveformCountStop

/**
  * @}
  */

/** @defgroup HAL_QSPI_Aliased_Macros HAL QSPI Aliased Macros maintained for legacy purpose
  * @{
  */



/**
  * @}
  */

/** @defgroup HAL_Generic_Aliased_Macros HAL Generic Aliased Macros maintained for legacy purpose
  * @{
  */



/**
  * @}
  */

/** @defgroup HAL_PPP_Aliased_Macros HAL PPP Aliased Macros maintained for legacy purpose
  * @{
  */

/**
  * @}
  */








# 31 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_def.h" 2
# 1 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/stddef.h" 1 3 4
# 1 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 1 3 4
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */



# 33 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 435 "C:/ProgramData/mingw64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4

# 2 "C:/ProgramData/mingw64/mingw64/lib/gcc/x86_64-w64-mingw32/15.2.0/include/stddef.h" 2 3 4
/* Copyright (C) 1989-2025 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 32 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_def.h" 2

/* Exported types ------------------------------------------------------------*/

/**
  * @brief  HAL Status structures definition
  */
typedef enum
{
  HAL_OK       = 0x00U,
  HAL_ERROR    = 0x01U,
  HAL_BUSY     = 0x02U,
  HAL_TIMEOUT  = 0x03U
} HAL_StatusTypeDef;

/**
  * @brief  HAL Lock structures definition
  */
typedef enum
{
  HAL_UNLOCKED = 0x00U,
  HAL_LOCKED   = 0x01U
} HAL_LockTypeDef;

/* Exported macros -----------------------------------------------------------*/

#define HAL_MAX_DELAY 0xFFFFFFFFU

#define HAL_IS_BIT_SET(REG,BIT) (((REG) & (BIT)) == (BIT))
#define HAL_IS_BIT_CLR(REG,BIT) (((REG) & (BIT)) == 0U)

#define __HAL_LINKDMA(__HANDLE__,__PPP_DMA_FIELD__,__DMA_HANDLE__) do{ (__HANDLE__)->__PPP_DMA_FIELD__ = &(__DMA_HANDLE__); (__DMA_HANDLE__).Parent = (__HANDLE__); } while(0)






#define UNUSED(X) (void)X


/** @brief Reset the Handle's State field.
  * @param __HANDLE__: specifies the Peripheral Handle.
  * @note  This macro can be used for the following purpose:
  *          - When the Handle is declared as local variable; before passing it as parameter
  *            to HAL_PPP_Init() for the first time, it is mandatory to use this macro
  *            to set to 0 the Handle's "State" field.
  *            Otherwise, "State" field may have any random value and the first time the function
  *            HAL_PPP_Init() is called, the low level hardware initialization will be missed
  *            (i.e. HAL_PPP_MspInit() will not be executed).
  *          - When there is a need to reconfigure the low level hardware: instead of calling
  *            HAL_PPP_DeInit() then HAL_PPP_Init(), user can make a call to this macro then HAL_PPP_Init().
  *            In this later function, when the Handle's "State" field is set to 0, it will execute the function
  *            HAL_PPP_MspInit() which will reconfigure the low level hardware.
  * @retval None
  */
#define __HAL_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = 0)





#define __HAL_LOCK(__HANDLE__) do{ if((__HANDLE__)->Lock == HAL_LOCKED) { return HAL_BUSY; } else { (__HANDLE__)->Lock = HAL_LOCKED; } }while (0U)
# 104 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_def.h"

#define __HAL_UNLOCK(__HANDLE__) do{ (__HANDLE__)->Lock = HAL_UNLOCKED; }while (0U)





# 119 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_def.h"

#define __weak __attribute__((weak))


#define __packed __attribute__((__packed__))




/* Macro to get variable aligned on 4-bytes, for __ICCARM__ the directive "#pragma data_alignment=4" must be used instead */
# 137 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_def.h"

#define __ALIGN_END __attribute__ ((aligned (4U)))


#define __ALIGN_BEGIN 

# 155 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_def.h"

/**
  * @brief  __RAM_FUNC definition
  */
# 179 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_def.h"
/* GNU Compiler
   ------------
  RAM functions are defined using a specific toolchain attribute
   "__attribute__((section(".RamFunc")))".
*/
#define __RAM_FUNC __attribute__((section(".RamFunc")))



/**
  * @brief  __NOINLINE definition
  */

/* ARM V4/V5 and V6 & GNU Compiler
   -------------------------------
*/
#define __NOINLINE __attribute__ ( (noinline) )
















# 28 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_rcc.h" 2

/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup RCC
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/** @defgroup RCC_Exported_Types RCC Exported Types
  * @{
  */

/**
  * @brief  RCC PLL configuration structure definition
  */
typedef struct
{
  uint32_t PLLState;   /*!< The new state of the PLL.
                            This parameter can be a value of @ref RCC_PLL_Config                      */

  uint32_t PLLSource;  /*!< RCC_PLLSource: PLL entry clock source.
                            This parameter must be a value of @ref RCC_PLL_Clock_Source               */

  uint32_t PLLM;       /*!< PLLM: Division factor for PLL VCO input clock.
                            This parameter must be a value of @ref RCC_PLLM_Clock_Divider             */

  uint32_t PLLN;       /*!< PLLN: Multiplication factor for PLL VCO output clock.
                            This parameter must be a number between Min_Data = 8 and Max_Data = 127    */

  uint32_t PLLP;       /*!< PLLP: Division factor for ADC clock.
                            This parameter must be a value of @ref RCC_PLLP_Clock_Divider             */

  uint32_t PLLQ;       /*!< PLLQ: Division factor for SAI, I2S, USB, FDCAN and QUADSPI clocks.
                            This parameter must be a value of @ref RCC_PLLQ_Clock_Divider             */

  uint32_t PLLR;       /*!< PLLR: Division for the main system clock.
                            User have to set the PLLR parameter correctly to not exceed max frequency 170MHZ.
                            This parameter must be a value of @ref RCC_PLLR_Clock_Divider             */

}RCC_PLLInitTypeDef;

/**
  * @brief  RCC Internal/External Oscillator (HSE, HSI, LSE and LSI) configuration structure definition
  */
typedef struct
{
  uint32_t OscillatorType;       /*!< The oscillators to be configured.
                                      This parameter can be a value of @ref RCC_Oscillator_Type                   */

  uint32_t HSEState;             /*!< The new state of the HSE.
                                      This parameter can be a value of @ref RCC_HSE_Config                        */

  uint32_t LSEState;             /*!< The new state of the LSE.
                                      This parameter can be a value of @ref RCC_LSE_Config                        */

  uint32_t HSIState;             /*!< The new state of the HSI.
                                      This parameter can be a value of @ref RCC_HSI_Config                        */

  uint32_t HSICalibrationValue;  /*!< The calibration trimming value (default is RCC_HSICALIBRATION_DEFAULT).
                                      This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF */

  uint32_t LSIState;             /*!< The new state of the LSI.
                                      This parameter can be a value of @ref RCC_LSI_Config                        */

  uint32_t HSI48State;             /*!< The new state of the HSI48.
                                        This parameter can be a value of @ref RCC_HSI48_Config */

  RCC_PLLInitTypeDef PLL;        /*!< Main PLL structure parameters                                               */

}RCC_OscInitTypeDef;

/**
  * @brief  RCC System, AHB and APB busses clock configuration structure definition
  */
typedef struct
{
  uint32_t ClockType;             /*!< The clock to be configured.
                                       This parameter can be a value of @ref RCC_System_Clock_Type      */

  uint32_t SYSCLKSource;          /*!< The clock source used as system clock (SYSCLK).
                                       This parameter can be a value of @ref RCC_System_Clock_Source    */

  uint32_t AHBCLKDivider;         /*!< The AHB clock (HCLK) divider. This clock is derived from the system clock (SYSCLK).
                                       This parameter can be a value of @ref RCC_AHB_Clock_Source       */

  uint32_t APB1CLKDivider;        /*!< The APB1 clock (PCLK1) divider. This clock is derived from the AHB clock (HCLK).
                                       This parameter can be a value of @ref RCC_APB1_APB2_Clock_Source */

  uint32_t APB2CLKDivider;        /*!< The APB2 clock (PCLK2) divider. This clock is derived from the AHB clock (HCLK).
                                       This parameter can be a value of @ref RCC_APB1_APB2_Clock_Source */

}RCC_ClkInitTypeDef;

/**
  * @}
  */

/* Exported constants --------------------------------------------------------*/
/** @defgroup RCC_Exported_Constants RCC Exported Constants
  * @{
  */

/** @defgroup RCC_Timeout_Value Timeout Values
  * @{
  */
#define RCC_DBP_TIMEOUT_VALUE 2U
#define RCC_LSE_TIMEOUT_VALUE LSE_STARTUP_TIMEOUT
/**
  * @}
  */

/** @defgroup RCC_Oscillator_Type Oscillator Type
  * @{
  */
#define RCC_OSCILLATORTYPE_NONE 0x00000000U
#define RCC_OSCILLATORTYPE_HSE 0x00000001U
#define RCC_OSCILLATORTYPE_HSI 0x00000002U
#define RCC_OSCILLATORTYPE_LSE 0x00000004U
#define RCC_OSCILLATORTYPE_LSI 0x00000008U
#define RCC_OSCILLATORTYPE_HSI48 0x00000020U
/**
  * @}
  */

/** @defgroup RCC_HSE_Config HSE Config
  * @{
  */
#define RCC_HSE_OFF 0x00000000U
#define RCC_HSE_ON RCC_CR_HSEON
#define RCC_HSE_BYPASS (RCC_CR_HSEBYP | RCC_CR_HSEON)
/**
  * @}
  */

/** @defgroup RCC_LSE_Config LSE Config
  * @{
  */
#define RCC_LSE_OFF 0x00000000U
#define RCC_LSE_ON RCC_BDCR_LSEON
#define RCC_LSE_BYPASS (RCC_BDCR_LSEBYP | RCC_BDCR_LSEON)
/**
  * @}
  */

/** @defgroup RCC_HSI_Config HSI Config
  * @{
  */
#define RCC_HSI_OFF 0x00000000U
#define RCC_HSI_ON RCC_CR_HSION
#define RCC_HSICALIBRATION_DEFAULT 0x40U
/**
  * @}
  */

/** @defgroup RCC_LSI_Config LSI Config
  * @{
  */
#define RCC_LSI_OFF 0x00000000U
#define RCC_LSI_ON RCC_CSR_LSION
/**
  * @}
  */

/** @defgroup RCC_HSI48_Config HSI48 Config
  * @{
  */
#define RCC_HSI48_OFF 0x00000000U
#define RCC_HSI48_ON RCC_CRRCR_HSI48ON
/**
  * @}
  */

/** @defgroup RCC_PLL_Config PLL Config
  * @{
  */
#define RCC_PLL_NONE 0x00000000U
#define RCC_PLL_OFF 0x00000001U
#define RCC_PLL_ON 0x00000002U
/**
  * @}
  */

/** @defgroup RCC_PLLM_Clock_Divider PLLM Clock Divider
  * @{
  */
#define RCC_PLLM_DIV1 0x00000001U
#define RCC_PLLM_DIV2 0x00000002U
#define RCC_PLLM_DIV3 0x00000003U
#define RCC_PLLM_DIV4 0x00000004U
#define RCC_PLLM_DIV5 0x00000005U
#define RCC_PLLM_DIV6 0x00000006U
#define RCC_PLLM_DIV7 0x00000007U
#define RCC_PLLM_DIV8 0x00000008U
#define RCC_PLLM_DIV9 0x00000009U
#define RCC_PLLM_DIV10 0x0000000AU
#define RCC_PLLM_DIV11 0x0000000BU
#define RCC_PLLM_DIV12 0x0000000CU
#define RCC_PLLM_DIV13 0x0000000DU
#define RCC_PLLM_DIV14 0x0000000EU
#define RCC_PLLM_DIV15 0x0000000FU
#define RCC_PLLM_DIV16 0x00000010U
/**
  * @}
  */

/** @defgroup RCC_PLLP_Clock_Divider PLLP Clock Divider
  * @{
  */
#define RCC_PLLP_DIV2 0x00000002U
#define RCC_PLLP_DIV3 0x00000003U
#define RCC_PLLP_DIV4 0x00000004U
#define RCC_PLLP_DIV5 0x00000005U
#define RCC_PLLP_DIV6 0x00000006U
#define RCC_PLLP_DIV7 0x00000007U
#define RCC_PLLP_DIV8 0x00000008U
#define RCC_PLLP_DIV9 0x00000009U
#define RCC_PLLP_DIV10 0x0000000AU
#define RCC_PLLP_DIV11 0x0000000BU
#define RCC_PLLP_DIV12 0x0000000CU
#define RCC_PLLP_DIV13 0x0000000DU
#define RCC_PLLP_DIV14 0x0000000EU
#define RCC_PLLP_DIV15 0x0000000FU
#define RCC_PLLP_DIV16 0x00000010U
#define RCC_PLLP_DIV17 0x00000011U
#define RCC_PLLP_DIV18 0x00000012U
#define RCC_PLLP_DIV19 0x00000013U
#define RCC_PLLP_DIV20 0x00000014U
#define RCC_PLLP_DIV21 0x00000015U
#define RCC_PLLP_DIV22 0x00000016U
#define RCC_PLLP_DIV23 0x00000017U
#define RCC_PLLP_DIV24 0x00000018U
#define RCC_PLLP_DIV25 0x00000019U
#define RCC_PLLP_DIV26 0x0000001AU
#define RCC_PLLP_DIV27 0x0000001BU
#define RCC_PLLP_DIV28 0x0000001CU
#define RCC_PLLP_DIV29 0x0000001DU
#define RCC_PLLP_DIV30 0x0000001EU
#define RCC_PLLP_DIV31 0x0000001FU
/**
  * @}
  */

/** @defgroup RCC_PLLQ_Clock_Divider PLLQ Clock Divider
  * @{
  */
#define RCC_PLLQ_DIV2 0x00000002U
#define RCC_PLLQ_DIV4 0x00000004U
#define RCC_PLLQ_DIV6 0x00000006U
#define RCC_PLLQ_DIV8 0x00000008U
/**
  * @}
  */

/** @defgroup RCC_PLLR_Clock_Divider PLLR Clock Divider
  * @{
  */
#define RCC_PLLR_DIV2 0x00000002U
#define RCC_PLLR_DIV4 0x00000004U
#define RCC_PLLR_DIV6 0x00000006U
#define RCC_PLLR_DIV8 0x00000008U
/**
  * @}
  */

/** @defgroup RCC_PLL_Clock_Source PLL Clock Source
  * @{
  */
#define RCC_PLLSOURCE_NONE 0x00000000U
#define RCC_PLLSOURCE_HSI RCC_PLLCFGR_PLLSRC_HSI
#define RCC_PLLSOURCE_HSE RCC_PLLCFGR_PLLSRC_HSE
/**
  * @}
  */

/** @defgroup RCC_PLL_Clock_Output PLL Clock Output
  * @{
  */
#define RCC_PLL_ADCCLK RCC_PLLCFGR_PLLPEN
#define RCC_PLL_48M1CLK RCC_PLLCFGR_PLLQEN
#define RCC_PLL_SYSCLK RCC_PLLCFGR_PLLREN
/**
  * @}
  */

/** @defgroup RCC_System_Clock_Type System Clock Type
  * @{
  */
#define RCC_CLOCKTYPE_SYSCLK 0x00000001U
#define RCC_CLOCKTYPE_HCLK 0x00000002U
#define RCC_CLOCKTYPE_PCLK1 0x00000004U
#define RCC_CLOCKTYPE_PCLK2 0x00000008U
/**
  * @}
  */

/** @defgroup RCC_System_Clock_Source System Clock Source
  * @{
  */
#define RCC_SYSCLKSOURCE_HSI RCC_CFGR_SW_HSI
#define RCC_SYSCLKSOURCE_HSE RCC_CFGR_SW_HSE
#define RCC_SYSCLKSOURCE_PLLCLK RCC_CFGR_SW_PLL
/**
  * @}
  */

/** @defgroup RCC_System_Clock_Source_Status System Clock Source Status
  * @{
  */
#define RCC_SYSCLKSOURCE_STATUS_HSI RCC_CFGR_SWS_HSI
#define RCC_SYSCLKSOURCE_STATUS_HSE RCC_CFGR_SWS_HSE
#define RCC_SYSCLKSOURCE_STATUS_PLLCLK RCC_CFGR_SWS_PLL
/**
  * @}
  */

/** @defgroup RCC_AHB_Clock_Source AHB Clock Source
  * @{
  */
#define RCC_SYSCLK_DIV1 RCC_CFGR_HPRE_DIV1
#define RCC_SYSCLK_DIV2 RCC_CFGR_HPRE_DIV2
#define RCC_SYSCLK_DIV4 RCC_CFGR_HPRE_DIV4
#define RCC_SYSCLK_DIV8 RCC_CFGR_HPRE_DIV8
#define RCC_SYSCLK_DIV16 RCC_CFGR_HPRE_DIV16
#define RCC_SYSCLK_DIV64 RCC_CFGR_HPRE_DIV64
#define RCC_SYSCLK_DIV128 RCC_CFGR_HPRE_DIV128
#define RCC_SYSCLK_DIV256 RCC_CFGR_HPRE_DIV256
#define RCC_SYSCLK_DIV512 RCC_CFGR_HPRE_DIV512
/**
  * @}
  */

/** @defgroup RCC_APB1_APB2_Clock_Source APB1 APB2 Clock Source
  * @{
  */
#define RCC_HCLK_DIV1 RCC_CFGR_PPRE1_DIV1
#define RCC_HCLK_DIV2 RCC_CFGR_PPRE1_DIV2
#define RCC_HCLK_DIV4 RCC_CFGR_PPRE1_DIV4
#define RCC_HCLK_DIV8 RCC_CFGR_PPRE1_DIV8
#define RCC_HCLK_DIV16 RCC_CFGR_PPRE1_DIV16
/**
  * @}
  */

/** @defgroup RCC_RTC_Clock_Source RTC Clock Source
  * @{
  */
#define RCC_RTCCLKSOURCE_NONE 0x00000000U
#define RCC_RTCCLKSOURCE_LSE RCC_BDCR_RTCSEL_0
#define RCC_RTCCLKSOURCE_LSI RCC_BDCR_RTCSEL_1
#define RCC_RTCCLKSOURCE_HSE_DIV32 RCC_BDCR_RTCSEL
/**
  * @}
  */

/** @defgroup RCC_MCO_Index MCO Index
  * @{
  */
/* 32     28      20       16      0
   --------------------------------
   | MCO   | GPIO  | GPIO  | GPIO  |
   | Index |  AF   | Port  |  Pin  |
   -------------------------------*/

#define RCC_MCO_GPIOPORT_POS 16U
#define RCC_MCO_GPIOPORT_MASK (0xFUL << RCC_MCO_GPIOPORT_POS)
#define RCC_MCO_GPIOAF_POS 20U
#define RCC_MCO_GPIOAF_MASK (0xFFUL << RCC_MCO_GPIOAF_POS)
#define RCC_MCO_INDEX_POS 28U
#define RCC_MCO_INDEX_MASK (0x1UL << RCC_MCO_INDEX_POS)
#define RCC_MCO1_INDEX (0x0UL << RCC_MCO_INDEX_POS)
#define RCC_MCO_PA8 (RCC_MCO1_INDEX | (GPIO_AF0_MCO << RCC_MCO_GPIOAF_POS) | (GPIO_GET_INDEX(GPIOA) << RCC_MCO_GPIOPORT_POS) | GPIO_PIN_8)
#define RCC_MCO_PG10 (RCC_MCO1_INDEX | (GPIO_AF0_MCO << RCC_MCO_GPIOAF_POS) | (GPIO_GET_INDEX(GPIOG) << RCC_MCO_GPIOPORT_POS) | GPIO_PIN_10)

/* Legacy Defines*/
#define RCC_MCO1 RCC_MCO_PA8
#define RCC_MCO RCC_MCO1
/**
  * @}
  */

/** @defgroup RCC_MCO1_Clock_Source MCO1 Clock Source
  * @{
  */
#define RCC_MCO1SOURCE_NOCLOCK 0x00000000U
#define RCC_MCO1SOURCE_SYSCLK RCC_CFGR_MCOSEL_0
#define RCC_MCO1SOURCE_HSI (RCC_CFGR_MCOSEL_0| RCC_CFGR_MCOSEL_1)
#define RCC_MCO1SOURCE_HSE RCC_CFGR_MCOSEL_2
#define RCC_MCO1SOURCE_PLLCLK (RCC_CFGR_MCOSEL_0|RCC_CFGR_MCOSEL_2)
#define RCC_MCO1SOURCE_LSI (RCC_CFGR_MCOSEL_1|RCC_CFGR_MCOSEL_2)
#define RCC_MCO1SOURCE_LSE (RCC_CFGR_MCOSEL_0|RCC_CFGR_MCOSEL_1|RCC_CFGR_MCOSEL_2)
#define RCC_MCO1SOURCE_HSI48 RCC_CFGR_MCOSEL_3
/**
  * @}
  */

/** @defgroup RCC_MCOx_Clock_Prescaler MCO1 Clock Prescaler
  * @{
  */
#define RCC_MCODIV_1 RCC_CFGR_MCOPRE_DIV1
#define RCC_MCODIV_2 RCC_CFGR_MCOPRE_DIV2
#define RCC_MCODIV_4 RCC_CFGR_MCOPRE_DIV4
#define RCC_MCODIV_8 RCC_CFGR_MCOPRE_DIV8
#define RCC_MCODIV_16 RCC_CFGR_MCOPRE_DIV16
/**
  * @}
  */

/** @defgroup RCC_Interrupt Interrupts
  * @{
  */
#define RCC_IT_LSIRDY RCC_CIFR_LSIRDYF
#define RCC_IT_LSERDY RCC_CIFR_LSERDYF
#define RCC_IT_HSIRDY RCC_CIFR_HSIRDYF
#define RCC_IT_HSERDY RCC_CIFR_HSERDYF
#define RCC_IT_PLLRDY RCC_CIFR_PLLRDYF
#define RCC_IT_CSS RCC_CIFR_CSSF
#define RCC_IT_LSECSS RCC_CIFR_LSECSSF
#define RCC_IT_HSI48RDY RCC_CIFR_HSI48RDYF
/**
  * @}
  */

/** @defgroup RCC_Flag Flags
  *        Elements values convention: XXXYYYYYb
  *           - YYYYY  : Flag position in the register
  *           - XXX  : Register index
  *                 - 001: CR register
  *                 - 010: BDCR register
  *                 - 011: CSR register
  *                 - 100: CRRCR register
  * @{
  */
/* Flags in the CR register */
#define RCC_FLAG_HSIRDY ((CR_REG_INDEX << 5U) | RCC_CR_HSIRDY_Pos)
#define RCC_FLAG_HSERDY ((CR_REG_INDEX << 5U) | RCC_CR_HSERDY_Pos)
#define RCC_FLAG_PLLRDY ((CR_REG_INDEX << 5U) | RCC_CR_PLLRDY_Pos)

/* Flags in the BDCR register */
#define RCC_FLAG_LSERDY ((BDCR_REG_INDEX << 5U) | RCC_BDCR_LSERDY_Pos)
#define RCC_FLAG_LSECSSD ((BDCR_REG_INDEX << 5U) | RCC_BDCR_LSECSSD_Pos)

/* Flags in the CSR register */
#define RCC_FLAG_LSIRDY ((CSR_REG_INDEX << 5U) | RCC_CSR_LSIRDY_Pos)
#define RCC_FLAG_OBLRST ((CSR_REG_INDEX << 5U) | RCC_CSR_OBLRSTF_Pos)
#define RCC_FLAG_PINRST ((CSR_REG_INDEX << 5U) | RCC_CSR_PINRSTF_Pos)
#define RCC_FLAG_BORRST ((CSR_REG_INDEX << 5U) | RCC_CSR_BORRSTF_Pos)
#define RCC_FLAG_SFTRST ((CSR_REG_INDEX << 5U) | RCC_CSR_SFTRSTF_Pos)
#define RCC_FLAG_IWDGRST ((CSR_REG_INDEX << 5U) | RCC_CSR_IWDGRSTF_Pos)
#define RCC_FLAG_WWDGRST ((CSR_REG_INDEX << 5U) | RCC_CSR_WWDGRSTF_Pos)
#define RCC_FLAG_LPWRRST ((CSR_REG_INDEX << 5U) | RCC_CSR_LPWRRSTF_Pos)

/* Flags in the CRRCR register */
#define RCC_FLAG_HSI48RDY ((CRRCR_REG_INDEX << 5U) | RCC_CRRCR_HSI48RDY_Pos)
/**
  * @}
  */

/** @defgroup RCC_LSEDrive_Config LSE Drive Config
  * @{
  */
#define RCC_LSEDRIVE_LOW 0x00000000U
#define RCC_LSEDRIVE_MEDIUMLOW RCC_BDCR_LSEDRV_0
#define RCC_LSEDRIVE_MEDIUMHIGH RCC_BDCR_LSEDRV_1
#define RCC_LSEDRIVE_HIGH RCC_BDCR_LSEDRV
/**
  * @}
  */

/**
  * @}
  */

/* Exported macros -----------------------------------------------------------*/

/** @defgroup RCC_Exported_Macros RCC Exported Macros
  * @{
  */

/** @defgroup RCC_AHB1_Peripheral_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
  * @brief  Enable or disable the AHB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  */

#define __HAL_RCC_DMA1_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_DMA2_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_DMAMUX1_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMAMUX1EN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMAMUX1EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_CORDIC_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CORDICEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CORDICEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_FMAC_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_FMACEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_FMACEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_FLASH_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_FLASHEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_FLASHEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_CRC_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_DMA1_CLK_DISABLE() CLEAR_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN)

#define __HAL_RCC_DMA2_CLK_DISABLE() CLEAR_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN)

#define __HAL_RCC_DMAMUX1_CLK_DISABLE() CLEAR_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMAMUX1EN)

#define __HAL_RCC_CORDIC_CLK_DISABLE() CLEAR_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CORDICEN)

#define __HAL_RCC_FMAC_CLK_DISABLE() CLEAR_BIT(RCC->AHB1ENR, RCC_AHB1ENR_FMACEN)

#define __HAL_RCC_FLASH_CLK_DISABLE() CLEAR_BIT(RCC->AHB1ENR, RCC_AHB1ENR_FLASHEN)

#define __HAL_RCC_CRC_CLK_DISABLE() CLEAR_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN)

/**
  * @}
  */

/** @defgroup RCC_AHB2_Peripheral_Clock_Enable_Disable AHB2 Peripheral Clock Enable Disable
  * @brief  Enable or disable the AHB2 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  */

#define __HAL_RCC_GPIOA_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOAEN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOAEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_GPIOB_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOBEN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOBEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_GPIOC_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOCEN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOCEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_GPIOD_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIODEN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIODEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_GPIOE_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOEEN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOEEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_GPIOF_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOFEN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOFEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_GPIOG_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOGEN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOGEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_ADC12_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_ADC12EN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_ADC12EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_ADC345_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_ADC345EN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_ADC345EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_DAC1_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC1EN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC1EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_DAC2_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC2EN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC2EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_DAC3_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC3EN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC3EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_DAC4_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC4EN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC4EN); UNUSED(tmpreg); } while(0)








# 717 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_rcc.h"

#define __HAL_RCC_RNG_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_GPIOA_CLK_DISABLE() CLEAR_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOAEN)

#define __HAL_RCC_GPIOB_CLK_DISABLE() CLEAR_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOBEN)

#define __HAL_RCC_GPIOC_CLK_DISABLE() CLEAR_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOCEN)

#define __HAL_RCC_GPIOD_CLK_DISABLE() CLEAR_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIODEN)

#define __HAL_RCC_GPIOE_CLK_DISABLE() CLEAR_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOEEN)

#define __HAL_RCC_GPIOF_CLK_DISABLE() CLEAR_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOFEN)

#define __HAL_RCC_GPIOG_CLK_DISABLE() CLEAR_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOGEN)

#define __HAL_RCC_ADC12_CLK_DISABLE() CLEAR_BIT(RCC->AHB2ENR, RCC_AHB2ENR_ADC12EN)


#define __HAL_RCC_ADC345_CLK_DISABLE() CLEAR_BIT(RCC->AHB2ENR, RCC_AHB2ENR_ADC345EN)


#define __HAL_RCC_DAC1_CLK_DISABLE() CLEAR_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC1EN)


#define __HAL_RCC_DAC2_CLK_DISABLE() CLEAR_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC2EN)


#define __HAL_RCC_DAC3_CLK_DISABLE() CLEAR_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC3EN)


#define __HAL_RCC_DAC4_CLK_DISABLE() CLEAR_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC4EN)






#define __HAL_RCC_RNG_CLK_DISABLE() CLEAR_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN)

/**
  * @}
  */

/** @defgroup RCC_AHB3_Clock_Enable_Disable AHB3 Peripheral Clock Enable Disable
  * @brief  Enable or disable the AHB3 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  */


#define __HAL_RCC_FMC_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN); tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN); UNUSED(tmpreg); } while(0)









#define __HAL_RCC_QSPI_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN); tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN); UNUSED(tmpreg); } while(0)









#define __HAL_RCC_FMC_CLK_DISABLE() CLEAR_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN)



#define __HAL_RCC_QSPI_CLK_DISABLE() CLEAR_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN)


/**
  * @}
  */

/** @defgroup RCC_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
  * @brief  Enable or disable the APB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  */

#define __HAL_RCC_TIM2_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM2EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM2EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_TIM3_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM3EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM3EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_TIM4_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM4EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM4EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_TIM5_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM5EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM5EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_TIM6_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM6EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM6EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_TIM7_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM7EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM7EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_CRS_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_CRSEN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_CRSEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_RTCAPB_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_RTCAPBEN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_RTCAPBEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_WWDG_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_WWDGEN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_WWDGEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_SPI2_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_SPI2EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_SPI2EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_SPI3_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_SPI3EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_SPI3EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_USART2_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USART2EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USART2EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_USART3_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USART3EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USART3EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_UART4_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_UART4EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_UART4EN); UNUSED(tmpreg); } while(0)









#define __HAL_RCC_UART5_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_UART5EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_UART5EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_I2C1_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C1EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C1EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_I2C2_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C2EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C2EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_USB_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USBEN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USBEN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_FDCAN_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_FDCANEN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_FDCANEN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_PWR_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_PWREN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_PWREN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_I2C3_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C3EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C3EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_LPTIM1_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR1, RCC_APB1ENR1_LPTIM1EN); tmpreg = READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_LPTIM1EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_LPUART1_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR2, RCC_APB1ENR2_LPUART1EN); tmpreg = READ_BIT(RCC->APB1ENR2, RCC_APB1ENR2_LPUART1EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_I2C4_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR2, RCC_APB1ENR2_I2C4EN); tmpreg = READ_BIT(RCC->APB1ENR2, RCC_APB1ENR2_I2C4EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_UCPD1_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR2, RCC_APB1ENR2_UCPD1EN); tmpreg = READ_BIT(RCC->APB1ENR2, RCC_APB1ENR2_UCPD1EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_TIM2_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM2EN)

#define __HAL_RCC_TIM3_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM3EN)

#define __HAL_RCC_TIM4_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM4EN)


#define __HAL_RCC_TIM5_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM5EN)


#define __HAL_RCC_TIM6_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM6EN)

#define __HAL_RCC_TIM7_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM7EN)

#define __HAL_RCC_CRS_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_CRSEN);

#define __HAL_RCC_RTCAPB_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_RTCAPBEN);

#define __HAL_RCC_WWDG_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_WWDGEN)

#define __HAL_RCC_SPI2_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_SPI2EN)

#define __HAL_RCC_SPI3_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_SPI3EN)

#define __HAL_RCC_USART2_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USART2EN)

#define __HAL_RCC_USART3_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USART3EN)


#define __HAL_RCC_UART4_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_UART4EN)



#define __HAL_RCC_UART5_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_UART5EN)


#define __HAL_RCC_I2C1_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C1EN)

#define __HAL_RCC_I2C2_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C2EN)

#define __HAL_RCC_USB_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USBEN)


#define __HAL_RCC_FDCAN_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_FDCANEN)


#define __HAL_RCC_PWR_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_PWREN)

#define __HAL_RCC_I2C3_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C3EN)

#define __HAL_RCC_LPTIM1_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR1, RCC_APB1ENR1_LPTIM1EN)

#define __HAL_RCC_LPUART1_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR2, RCC_APB1ENR2_LPUART1EN)


#define __HAL_RCC_I2C4_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR2, RCC_APB1ENR2_I2C4EN)


#define __HAL_RCC_UCPD1_CLK_DISABLE() CLEAR_BIT(RCC->APB1ENR2, RCC_APB1ENR2_UCPD1EN)

/**
  * @}
  */

/** @defgroup RCC_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable
  * @brief  Enable or disable the APB2 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  */

#define __HAL_RCC_SYSCFG_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_TIM1_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_SPI1_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_TIM8_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_USART1_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_SPI4_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_TIM15_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM15EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM15EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_TIM16_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM16EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM16EN); UNUSED(tmpreg); } while(0)







#define __HAL_RCC_TIM17_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM17EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM17EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_TIM20_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM20EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM20EN); UNUSED(tmpreg); } while(0)








#define __HAL_RCC_SAI1_CLK_ENABLE() do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN); UNUSED(tmpreg); } while(0)







# 1200 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_rcc.h"

#define __HAL_RCC_SYSCFG_CLK_DISABLE() CLEAR_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN)

#define __HAL_RCC_TIM1_CLK_DISABLE() CLEAR_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN)

#define __HAL_RCC_SPI1_CLK_DISABLE() CLEAR_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN)

#define __HAL_RCC_TIM8_CLK_DISABLE() CLEAR_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN)

#define __HAL_RCC_USART1_CLK_DISABLE() CLEAR_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN)


#define __HAL_RCC_SPI4_CLK_DISABLE() CLEAR_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN)


#define __HAL_RCC_TIM15_CLK_DISABLE() CLEAR_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM15EN)

#define __HAL_RCC_TIM16_CLK_DISABLE() CLEAR_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM16EN)

#define __HAL_RCC_TIM17_CLK_DISABLE() CLEAR_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM17EN)


#define __HAL_RCC_TIM20_CLK_DISABLE() CLEAR_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM20EN)


#define __HAL_RCC_SAI1_CLK_DISABLE() CLEAR_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN)





/**
  * @}
  */

/** @defgroup RCC_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enabled or Disabled Status
  * @brief  Check whether the AHB1 peripheral clock is enabled or not.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  */

#define __HAL_RCC_DMA1_IS_CLK_ENABLED() (READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN) != 0U)

#define __HAL_RCC_DMA2_IS_CLK_ENABLED() (READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN) != 0U)

#define __HAL_RCC_DMAMUX1_IS_CLK_ENABLED() (READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMAMUX1EN) != 0U)

#define __HAL_RCC_CORDIC_IS_CLK_ENABLED() (READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CORDICEN) != 0U)

#define __HAL_RCC_FMAC_IS_CLK_ENABLED() (READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_FMACEN) != 0U)

#define __HAL_RCC_FLASH_IS_CLK_ENABLED() (READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_FLASHEN) != 0U)

#define __HAL_RCC_CRC_IS_CLK_ENABLED() (READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN) != 0U)

#define __HAL_RCC_DMA1_IS_CLK_DISABLED() (READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN) == 0U)

#define __HAL_RCC_DMA2_IS_CLK_DISABLED() (READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN) == 0U)

#define __HAL_RCC_DMAMUX1_IS_CLK_DISABLED() (READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMAMUX1EN) == 0U)

#define __HAL_RCC_CORDIC_IS_CLK_DISABLED() (READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CORDICEN) == 0U)

#define __HAL_RCC_FMAC_IS_CLK_DISABLED() (READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_FMACEN) == 0U)

#define __HAL_RCC_FLASH_IS_CLK_DISABLED() (READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_FLASHEN) == 0U)

#define __HAL_RCC_CRC_IS_CLK_DISABLED() (READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN) == 0U)

/**
  * @}
  */

/** @defgroup RCC_AHB2_Clock_Enable_Disable_Status AHB2 Peripheral Clock Enabled or Disabled Status
  * @brief  Check whether the AHB2 peripheral clock is enabled or not.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  */

#define __HAL_RCC_GPIOA_IS_CLK_ENABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOAEN) != 0U)

#define __HAL_RCC_GPIOB_IS_CLK_ENABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOBEN) != 0U)

#define __HAL_RCC_GPIOC_IS_CLK_ENABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOCEN) != 0U)

#define __HAL_RCC_GPIOD_IS_CLK_ENABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIODEN) != 0U)

#define __HAL_RCC_GPIOE_IS_CLK_ENABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOEEN) != 0U)

#define __HAL_RCC_GPIOF_IS_CLK_ENABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOFEN) != 0U)

#define __HAL_RCC_GPIOG_IS_CLK_ENABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOGEN) != 0U)

#define __HAL_RCC_ADC12_IS_CLK_ENABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_ADC12EN) != 0U)


#define __HAL_RCC_ADC345_IS_CLK_ENABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_ADC345EN) != 0U)


#define __HAL_RCC_DAC1_IS_CLK_ENABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC1EN) != 0U)


#define __HAL_RCC_DAC2_IS_CLK_ENABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC2EN) != 0U)


#define __HAL_RCC_DAC3_IS_CLK_ENABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC3EN) != 0U)


#define __HAL_RCC_DAC4_IS_CLK_ENABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC4EN) != 0U)






#define __HAL_RCC_RNG_IS_CLK_ENABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN) != 0U)


#define __HAL_RCC_GPIOA_IS_CLK_DISABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOAEN) == 0U)

#define __HAL_RCC_GPIOB_IS_CLK_DISABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOBEN) == 0U)

#define __HAL_RCC_GPIOC_IS_CLK_DISABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOCEN) == 0U)

#define __HAL_RCC_GPIOD_IS_CLK_DISABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIODEN) == 0U)

#define __HAL_RCC_GPIOE_IS_CLK_DISABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOEEN) == 0U)

#define __HAL_RCC_GPIOF_IS_CLK_DISABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOFEN) == 0U)

#define __HAL_RCC_GPIOG_IS_CLK_DISABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_GPIOGEN) == 0U)

#define __HAL_RCC_ADC12_IS_CLK_DISABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_ADC12EN) == 0U)


#define __HAL_RCC_ADC345_IS_CLK_DISABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_ADC345EN) == 0U)


#define __HAL_RCC_DAC1_IS_CLK_DISABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC1EN) == 0U)


#define __HAL_RCC_DAC2_IS_CLK_DISABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC2EN) == 0U)


#define __HAL_RCC_DAC3_IS_CLK_DISABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC3EN) == 0U)


#define __HAL_RCC_DAC4_IS_CLK_DISABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DAC4EN) == 0U)






#define __HAL_RCC_RNG_IS_CLK_DISABLED() (READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN) == 0U)

/**
  * @}
  */

/** @defgroup RCC_AHB3_Clock_Enable_Disable_Status AHB3 Peripheral Clock Enabled or Disabled Status
  * @brief  Check whether the AHB3 peripheral clock is enabled or not.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  */


#define __HAL_RCC_FMC_IS_CLK_ENABLED() (READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN) != 0U)



#define __HAL_RCC_QSPI_IS_CLK_ENABLED() (READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN) != 0U)



#define __HAL_RCC_FMC_IS_CLK_DISABLED() (READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN) == 0U)



#define __HAL_RCC_QSPI_IS_CLK_DISABLED() (READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN) == 0U)


/**
  * @}
  */

/** @defgroup RCC_APB1_Clock_Enable_Disable_Status APB1 Peripheral Clock Enabled or Disabled Status
  * @brief  Check whether the APB1 peripheral clock is enabled or not.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  */

#define __HAL_RCC_TIM2_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM2EN) != 0U)

#define __HAL_RCC_TIM3_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM3EN) != 0U)

#define __HAL_RCC_TIM4_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM4EN) != 0U)


#define __HAL_RCC_TIM5_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM5EN) != 0U)


#define __HAL_RCC_TIM6_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM6EN) != 0U)

#define __HAL_RCC_TIM7_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM7EN) != 0U)

#define __HAL_RCC_CRS_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_CRSEN) != 0U)

#define __HAL_RCC_RTCAPB_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_RTCAPBEN) != 0U)

#define __HAL_RCC_WWDG_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_WWDGEN) != 0U)

#define __HAL_RCC_SPI2_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_SPI2EN) != 0U)

#define __HAL_RCC_SPI3_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_SPI3EN) != 0U)

#define __HAL_RCC_USART2_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USART2EN) != 0U)

#define __HAL_RCC_USART3_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USART3EN) != 0U)


#define __HAL_RCC_UART4_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_UART4EN) != 0U)



#define __HAL_RCC_UART5_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_UART5EN) != 0U)


#define __HAL_RCC_I2C1_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C1EN) != 0U)

#define __HAL_RCC_I2C2_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C2EN) != 0U)

#define __HAL_RCC_USB_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USBEN) != 0U)


#define __HAL_RCC_FDCAN_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_FDCANEN) != 0U)


#define __HAL_RCC_PWR_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_PWREN) != 0U)

#define __HAL_RCC_I2C3_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C3EN) != 0U)

#define __HAL_RCC_LPTIM1_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_LPTIM1EN) != 0U)

#define __HAL_RCC_LPUART1_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR2, RCC_APB1ENR2_LPUART1EN) != 0U)


#define __HAL_RCC_I2C4_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR2, RCC_APB1ENR2_I2C4EN) != 0U)


#define __HAL_RCC_UCPD1_IS_CLK_ENABLED() (READ_BIT(RCC->APB1ENR2, RCC_APB1ENR2_UCPD1EN) != 0U)

#define __HAL_RCC_TIM2_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM2EN) == 0U)

#define __HAL_RCC_TIM3_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM3EN) == 0U)

#define __HAL_RCC_TIM4_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM4EN) == 0U)


#define __HAL_RCC_TIM5_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM5EN) == 0U)


#define __HAL_RCC_TIM6_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM6EN) == 0U)

#define __HAL_RCC_TIM7_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_TIM7EN) == 0U)

#define __HAL_RCC_CRS_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_CRSEN) == 0U)

#define __HAL_RCC_RTCAPB_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_RTCAPBEN) == 0U)

#define __HAL_RCC_WWDG_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_WWDGEN) == 0U)

#define __HAL_RCC_SPI2_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_SPI2EN) == 0U)

#define __HAL_RCC_SPI3_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_SPI3EN) == 0U)

#define __HAL_RCC_USART2_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USART2EN) == 0U)

#define __HAL_RCC_USART3_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USART3EN) == 0U)


#define __HAL_RCC_UART4_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_UART4EN) == 0U)



#define __HAL_RCC_UART5_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_UART5EN) == 0U)


#define __HAL_RCC_I2C1_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C1EN) == 0U)

#define __HAL_RCC_I2C2_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C2EN) == 0U)


#define __HAL_RCC_USB_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_USBEN) == 0U)



#define __HAL_RCC_FDCAN_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_FDCANEN) == 0U)


#define __HAL_RCC_PWR_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_PWREN) == 0U)

#define __HAL_RCC_I2C3_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_I2C3EN) == 0U)

#define __HAL_RCC_LPTIM1_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR1, RCC_APB1ENR1_LPTIM1EN) == 0U)

#define __HAL_RCC_LPUART1_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR2, RCC_APB1ENR2_LPUART1EN) == 0U)


#define __HAL_RCC_I2C4_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR2, RCC_APB1ENR2_I2C4EN) == 0U)


#define __HAL_RCC_UCPD1_IS_CLK_DISABLED() (READ_BIT(RCC->APB1ENR2, RCC_APB1ENR2_UCPD1EN) == 0U)

/**
  * @}
  */

/** @defgroup RCC_APB2_Clock_Enable_Disable_Status APB2 Peripheral Clock Enabled or Disabled Status
  * @brief  Check whether the APB2 peripheral clock is enabled or not.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  */

#define __HAL_RCC_SYSCFG_IS_CLK_ENABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN) != 0U)

#define __HAL_RCC_TIM1_IS_CLK_ENABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN) != 0U)

#define __HAL_RCC_SPI1_IS_CLK_ENABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN) != 0U)

#define __HAL_RCC_TIM8_IS_CLK_ENABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN) != 0U)

#define __HAL_RCC_USART1_IS_CLK_ENABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN) != 0U)


#define __HAL_RCC_SPI4_IS_CLK_ENABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN) != 0U)


#define __HAL_RCC_TIM15_IS_CLK_ENABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM15EN) != 0U)

#define __HAL_RCC_TIM16_IS_CLK_ENABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM16EN) != 0U)

#define __HAL_RCC_TIM17_IS_CLK_ENABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM17EN) != 0U)


#define __HAL_RCC_TIM20_IS_CLK_ENABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM20EN) != 0U)


#define __HAL_RCC_SAI1_IS_CLK_ENABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN) != 0U)






#define __HAL_RCC_SYSCFG_IS_CLK_DISABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN) == 0U)

#define __HAL_RCC_TIM1_IS_CLK_DISABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN) == 0U)

#define __HAL_RCC_SPI1_IS_CLK_DISABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN) == 0U)

#define __HAL_RCC_TIM8_IS_CLK_DISABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN) == 0U)

#define __HAL_RCC_USART1_IS_CLK_DISABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN) == 0U)


#define __HAL_RCC_SPI4_IS_CLK_DISABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN) == 0U)


#define __HAL_RCC_TIM15_IS_CLK_DISABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM15EN) == 0U)

#define __HAL_RCC_TIM16_IS_CLK_DISABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM16EN) == 0U)

#define __HAL_RCC_TIM17_IS_CLK_DISABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM17EN) == 0U)


#define __HAL_RCC_TIM20_IS_CLK_DISABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM20EN) == 0U)


#define __HAL_RCC_SAI1_IS_CLK_DISABLED() (READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN) == 0U)





/**
  * @}
  */

/** @defgroup RCC_AHB1_Force_Release_Reset AHB1 Peripheral Force Release Reset
  * @brief  Force or release AHB1 peripheral reset.
  * @{
  */
#define __HAL_RCC_AHB1_FORCE_RESET() WRITE_REG(RCC->AHB1RSTR, 0xFFFFFFFFU)

#define __HAL_RCC_DMA1_FORCE_RESET() SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_DMA1RST)

#define __HAL_RCC_DMA2_FORCE_RESET() SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_DMA2RST)

#define __HAL_RCC_DMAMUX1_FORCE_RESET() SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_DMAMUX1RST)

#define __HAL_RCC_CORDIC_FORCE_RESET() SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_CORDICRST)

#define __HAL_RCC_FMAC_FORCE_RESET() SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_FMACRST)

#define __HAL_RCC_FLASH_FORCE_RESET() SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_FLASHRST)

#define __HAL_RCC_CRC_FORCE_RESET() SET_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_CRCRST)


#define __HAL_RCC_AHB1_RELEASE_RESET() WRITE_REG(RCC->AHB1RSTR, 0x00000000U)

#define __HAL_RCC_DMA1_RELEASE_RESET() CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_DMA1RST)

#define __HAL_RCC_DMA2_RELEASE_RESET() CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_DMA2RST)

#define __HAL_RCC_DMAMUX1_RELEASE_RESET() CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_DMAMUX1RST)

#define __HAL_RCC_CORDIC_RELEASE_RESET() CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_CORDICRST)

#define __HAL_RCC_FMAC_RELEASE_RESET() CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_FMACRST)

#define __HAL_RCC_FLASH_RELEASE_RESET() CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_FLASHRST)

#define __HAL_RCC_CRC_RELEASE_RESET() CLEAR_BIT(RCC->AHB1RSTR, RCC_AHB1RSTR_CRCRST)

/**
  * @}
  */

/** @defgroup RCC_AHB2_Force_Release_Reset AHB2 Peripheral Force Release Reset
  * @brief  Force or release AHB2 peripheral reset.
  * @{
  */
#define __HAL_RCC_AHB2_FORCE_RESET() WRITE_REG(RCC->AHB2RSTR, 0xFFFFFFFFU)

#define __HAL_RCC_GPIOA_FORCE_RESET() SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOARST)

#define __HAL_RCC_GPIOB_FORCE_RESET() SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOBRST)

#define __HAL_RCC_GPIOC_FORCE_RESET() SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOCRST)

#define __HAL_RCC_GPIOD_FORCE_RESET() SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIODRST)

#define __HAL_RCC_GPIOE_FORCE_RESET() SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOERST)

#define __HAL_RCC_GPIOF_FORCE_RESET() SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOFRST)

#define __HAL_RCC_GPIOG_FORCE_RESET() SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOGRST)

#define __HAL_RCC_ADC12_FORCE_RESET() SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_ADC12RST)


#define __HAL_RCC_ADC345_FORCE_RESET() SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_ADC345RST)


#define __HAL_RCC_DAC1_FORCE_RESET() SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_DAC1RST)


#define __HAL_RCC_DAC2_FORCE_RESET() SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_DAC2RST)


#define __HAL_RCC_DAC3_FORCE_RESET() SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_DAC3RST)


#define __HAL_RCC_DAC4_FORCE_RESET() SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_DAC4RST)






#define __HAL_RCC_RNG_FORCE_RESET() SET_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_RNGRST)


#define __HAL_RCC_AHB2_RELEASE_RESET() WRITE_REG(RCC->AHB2RSTR, 0x00000000U)

#define __HAL_RCC_GPIOA_RELEASE_RESET() CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOARST)

#define __HAL_RCC_GPIOB_RELEASE_RESET() CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOBRST)

#define __HAL_RCC_GPIOC_RELEASE_RESET() CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOCRST)

#define __HAL_RCC_GPIOD_RELEASE_RESET() CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIODRST)

#define __HAL_RCC_GPIOE_RELEASE_RESET() CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOERST)

#define __HAL_RCC_GPIOF_RELEASE_RESET() CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOFRST)

#define __HAL_RCC_GPIOG_RELEASE_RESET() CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_GPIOGRST)

#define __HAL_RCC_ADC12_RELEASE_RESET() CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_ADC12RST)


#define __HAL_RCC_ADC345_RELEASE_RESET() CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_ADC345RST)


#define __HAL_RCC_DAC1_RELEASE_RESET() CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_DAC1RST)


#define __HAL_RCC_DAC2_RELEASE_RESET() CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_DAC2RST)


#define __HAL_RCC_DAC3_RELEASE_RESET() CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_DAC3RST)


#define __HAL_RCC_DAC4_RELEASE_RESET() CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_DAC4RST)






#define __HAL_RCC_RNG_RELEASE_RESET() CLEAR_BIT(RCC->AHB2RSTR, RCC_AHB2RSTR_RNGRST)

/**
  * @}
  */

/** @defgroup RCC_AHB3_Force_Release_Reset AHB3 Peripheral Force Release Reset
  * @brief  Force or release AHB3 peripheral reset.
  * @{
  */
#define __HAL_RCC_AHB3_FORCE_RESET() WRITE_REG(RCC->AHB3RSTR, 0xFFFFFFFFU)


#define __HAL_RCC_FMC_FORCE_RESET() SET_BIT(RCC->AHB3RSTR, RCC_AHB3RSTR_FMCRST)



#define __HAL_RCC_QSPI_FORCE_RESET() SET_BIT(RCC->AHB3RSTR, RCC_AHB3RSTR_QSPIRST)


#define __HAL_RCC_AHB3_RELEASE_RESET() WRITE_REG(RCC->AHB3RSTR, 0x00000000U)


#define __HAL_RCC_FMC_RELEASE_RESET() CLEAR_BIT(RCC->AHB3RSTR, RCC_AHB3RSTR_FMCRST)



#define __HAL_RCC_QSPI_RELEASE_RESET() CLEAR_BIT(RCC->AHB3RSTR, RCC_AHB3RSTR_QSPIRST)


/**
  * @}
  */

/** @defgroup RCC_APB1_Force_Release_Reset APB1 Peripheral Force Release Reset
  * @brief  Force or release APB1 peripheral reset.
  * @{
  */
#define __HAL_RCC_APB1_FORCE_RESET() WRITE_REG(RCC->APB1RSTR1, 0xFFFFFFFFU)

#define __HAL_RCC_TIM2_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM2RST)

#define __HAL_RCC_TIM3_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM3RST)

#define __HAL_RCC_TIM4_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM4RST)


#define __HAL_RCC_TIM5_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM5RST)


#define __HAL_RCC_TIM6_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM6RST)

#define __HAL_RCC_TIM7_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM7RST)

#define __HAL_RCC_CRS_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_CRSRST)

#define __HAL_RCC_SPI2_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_SPI2RST)

#define __HAL_RCC_SPI3_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_SPI3RST)

#define __HAL_RCC_USART2_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_USART2RST)

#define __HAL_RCC_USART3_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_USART3RST)


#define __HAL_RCC_UART4_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_UART4RST)



#define __HAL_RCC_UART5_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_UART5RST)


#define __HAL_RCC_I2C1_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_I2C1RST)

#define __HAL_RCC_I2C2_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_I2C2RST)

#define __HAL_RCC_USB_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_USBRST)


#define __HAL_RCC_FDCAN_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_FDCANRST)


#define __HAL_RCC_PWR_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_PWRRST)

#define __HAL_RCC_I2C3_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_I2C3RST)

#define __HAL_RCC_LPTIM1_FORCE_RESET() SET_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_LPTIM1RST)

#define __HAL_RCC_LPUART1_FORCE_RESET() SET_BIT(RCC->APB1RSTR2, RCC_APB1RSTR2_LPUART1RST)


#define __HAL_RCC_I2C4_FORCE_RESET() SET_BIT(RCC->APB1RSTR2, RCC_APB1RSTR2_I2C4RST)


#define __HAL_RCC_UCPD1_FORCE_RESET() SET_BIT(RCC->APB1RSTR2, RCC_APB1RSTR2_UCPD1RST)

#define __HAL_RCC_APB1_RELEASE_RESET() WRITE_REG(RCC->APB1RSTR1, 0x00000000U)

#define __HAL_RCC_TIM2_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM2RST)

#define __HAL_RCC_TIM3_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM3RST)

#define __HAL_RCC_TIM4_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM4RST)


#define __HAL_RCC_TIM5_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM5RST)


#define __HAL_RCC_TIM6_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM6RST)

#define __HAL_RCC_TIM7_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_TIM7RST)

#define __HAL_RCC_CRS_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_CRSRST)

#define __HAL_RCC_SPI2_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_SPI2RST)

#define __HAL_RCC_SPI3_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_SPI3RST)

#define __HAL_RCC_USART2_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_USART2RST)

#define __HAL_RCC_USART3_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_USART3RST)


#define __HAL_RCC_UART4_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_UART4RST)



#define __HAL_RCC_UART5_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_UART5RST)


#define __HAL_RCC_I2C1_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_I2C1RST)

#define __HAL_RCC_I2C2_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_I2C2RST)

#define __HAL_RCC_USB_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_USBRST)


#define __HAL_RCC_FDCAN_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_FDCANRST)


#define __HAL_RCC_PWR_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_PWRRST)

#define __HAL_RCC_I2C3_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_I2C3RST)

#define __HAL_RCC_LPTIM1_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR1, RCC_APB1RSTR1_LPTIM1RST)

#define __HAL_RCC_LPUART1_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR2, RCC_APB1RSTR2_LPUART1RST)


#define __HAL_RCC_I2C4_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR2, RCC_APB1RSTR2_I2C4RST)


#define __HAL_RCC_UCPD1_RELEASE_RESET() CLEAR_BIT(RCC->APB1RSTR2, RCC_APB1RSTR2_UCPD1RST)

/**
  * @}
  */

/** @defgroup RCC_APB2_Force_Release_Reset APB2 Peripheral Force Release Reset
  * @brief  Force or release APB2 peripheral reset.
  * @{
  */
#define __HAL_RCC_APB2_FORCE_RESET() WRITE_REG(RCC->APB2RSTR, 0xFFFFFFFFU)

#define __HAL_RCC_SYSCFG_FORCE_RESET() SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SYSCFGRST)

#define __HAL_RCC_TIM1_FORCE_RESET() SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM1RST)

#define __HAL_RCC_SPI1_FORCE_RESET() SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SPI1RST)

#define __HAL_RCC_TIM8_FORCE_RESET() SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM8RST)

#define __HAL_RCC_USART1_FORCE_RESET() SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_USART1RST)


#define __HAL_RCC_SPI4_FORCE_RESET() SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SPI4RST)


#define __HAL_RCC_TIM15_FORCE_RESET() SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM15RST)

#define __HAL_RCC_TIM16_FORCE_RESET() SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM16RST)

#define __HAL_RCC_TIM17_FORCE_RESET() SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM17RST)


#define __HAL_RCC_TIM20_FORCE_RESET() SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM20RST)


#define __HAL_RCC_SAI1_FORCE_RESET() SET_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SAI1RST)






#define __HAL_RCC_APB2_RELEASE_RESET() WRITE_REG(RCC->APB2RSTR, 0x00000000U)

#define __HAL_RCC_SYSCFG_RELEASE_RESET() CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SYSCFGRST)

#define __HAL_RCC_TIM1_RELEASE_RESET() CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM1RST)

#define __HAL_RCC_SPI1_RELEASE_RESET() CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SPI1RST)

#define __HAL_RCC_TIM8_RELEASE_RESET() CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM8RST)

#define __HAL_RCC_USART1_RELEASE_RESET() CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_USART1RST)


#define __HAL_RCC_SPI4_RELEASE_RESET() CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SPI4RST)


#define __HAL_RCC_TIM15_RELEASE_RESET() CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM15RST)

#define __HAL_RCC_TIM16_RELEASE_RESET() CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM16RST)

#define __HAL_RCC_TIM17_RELEASE_RESET() CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM17RST)


#define __HAL_RCC_TIM20_RELEASE_RESET() CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_TIM20RST)


#define __HAL_RCC_SAI1_RELEASE_RESET() CLEAR_BIT(RCC->APB2RSTR, RCC_APB2RSTR_SAI1RST)





/**
  * @}
  */

/** @defgroup RCC_AHB1_Clock_Sleep_Enable_Disable AHB1 Peripheral Clock Sleep Enable Disable
  * @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  */

#define __HAL_RCC_DMA1_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_DMA1SMEN)

#define __HAL_RCC_DMA2_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_DMA2SMEN)

#define __HAL_RCC_DMAMUX1_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_DMAMUX1SMEN)

#define __HAL_RCC_CORDIC_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_CORDICSMEN)

#define __HAL_RCC_FMAC_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_FMACSMEN)

#define __HAL_RCC_FLASH_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_FLASHSMEN)

#define __HAL_RCC_SRAM1_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_SRAM1SMEN)

#define __HAL_RCC_CRC_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_CRCSMEN)


#define __HAL_RCC_DMA1_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_DMA1SMEN)

#define __HAL_RCC_DMA2_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_DMA2SMEN)

#define __HAL_RCC_DMAMUX1_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_DMAMUX1SMEN)

#define __HAL_RCC_CORDIC_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_CORDICSMEN)

#define __HAL_RCC_FMAC_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_FMACSMEN)

#define __HAL_RCC_FLASH_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_FLASHSMEN)

#define __HAL_RCC_SRAM1_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_SRAM1SMEN)

#define __HAL_RCC_CRC_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_CRCSMEN)

/**
  * @}
  */

/** @defgroup RCC_AHB2_Clock_Sleep_Enable_Disable AHB2 Peripheral Clock Sleep Enable Disable
  * @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  */

#define __HAL_RCC_GPIOA_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOASMEN)

#define __HAL_RCC_GPIOB_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOBSMEN)

#define __HAL_RCC_GPIOC_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOCSMEN)

#define __HAL_RCC_GPIOD_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIODSMEN)

#define __HAL_RCC_GPIOE_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOESMEN)

#define __HAL_RCC_GPIOF_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOFSMEN)

#define __HAL_RCC_GPIOG_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOGSMEN)

#define __HAL_RCC_SRAM2_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_SRAM2SMEN)

#define __HAL_RCC_CCM_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_CCMSRAMSMEN)

#define __HAL_RCC_ADC12_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_ADC12SMEN)


#define __HAL_RCC_ADC345_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_ADC345SMEN)


#define __HAL_RCC_DAC1_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC1SMEN)


#define __HAL_RCC_DAC2_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC2SMEN)


#define __HAL_RCC_DAC3_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC3SMEN)


#define __HAL_RCC_DAC4_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC4SMEN)






#define __HAL_RCC_RNG_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_RNGSMEN)


#define __HAL_RCC_GPIOA_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOASMEN)

#define __HAL_RCC_GPIOB_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOBSMEN)

#define __HAL_RCC_GPIOC_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOCSMEN)

#define __HAL_RCC_GPIOD_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIODSMEN)

#define __HAL_RCC_GPIOE_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOESMEN)

#define __HAL_RCC_GPIOF_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOFSMEN)

#define __HAL_RCC_GPIOG_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOGSMEN)

#define __HAL_RCC_SRAM2_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_SRAM2SMEN)

#define __HAL_RCC_CCM_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_CCMSRAMSMEN)

#define __HAL_RCC_ADC12_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_ADC12SMEN)


#define __HAL_RCC_ADC345_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_ADC345SMEN)


#define __HAL_RCC_DAC1_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC1SMEN)


#define __HAL_RCC_DAC2_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC2SMEN)


#define __HAL_RCC_DAC3_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC3SMEN)


#define __HAL_RCC_DAC4_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC4SMEN)






#define __HAL_RCC_RNG_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_RNGSMEN)

/**
  * @}
  */

/** @defgroup RCC_AHB3_Clock_Sleep_Enable_Disable AHB3 Peripheral Clock Sleep Enable Disable
  * @brief  Enable or disable the AHB3 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  */


#define __HAL_RCC_FMC_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB3SMENR, RCC_AHB3SMENR_FMCSMEN)



#define __HAL_RCC_QSPI_CLK_SLEEP_ENABLE() SET_BIT(RCC->AHB3SMENR, RCC_AHB3SMENR_QSPISMEN)



#define __HAL_RCC_FMC_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB3SMENR, RCC_AHB3SMENR_FMCSMEN)



#define __HAL_RCC_QSPI_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->AHB3SMENR, RCC_AHB3SMENR_QSPISMEN)


/**
  * @}
  */

/** @defgroup RCC_APB1_Clock_Sleep_Enable_Disable APB1 Peripheral Clock Sleep Enable Disable
  * @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  */

#define __HAL_RCC_TIM2_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM2SMEN)

#define __HAL_RCC_TIM3_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM3SMEN)

#define __HAL_RCC_TIM4_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM4SMEN)


#define __HAL_RCC_TIM5_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM5SMEN)


#define __HAL_RCC_TIM6_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM6SMEN)

#define __HAL_RCC_TIM7_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM7SMEN)

#define __HAL_RCC_CRS_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_CRSSMEN)

#define __HAL_RCC_RTCAPB_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_RTCAPBSMEN)

#define __HAL_RCC_WWDG_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_WWDGSMEN)

#define __HAL_RCC_SPI2_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_SPI2SMEN)

#define __HAL_RCC_SPI3_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_SPI3SMEN)

#define __HAL_RCC_USART2_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_USART2SMEN)

#define __HAL_RCC_USART3_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_USART3SMEN)


#define __HAL_RCC_UART4_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_UART4SMEN)



#define __HAL_RCC_UART5_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_UART5SMEN)


#define __HAL_RCC_I2C1_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_I2C1SMEN)

#define __HAL_RCC_I2C2_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_I2C2SMEN)


#define __HAL_RCC_USB_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_USBSMEN)



#define __HAL_RCC_FDCAN_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_FDCANSMEN)


#define __HAL_RCC_PWR_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_PWRSMEN)

#define __HAL_RCC_I2C3_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_I2C3SMEN)

#define __HAL_RCC_LPTIM1_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_LPTIM1SMEN)

#define __HAL_RCC_LPUART1_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR2, RCC_APB1SMENR2_LPUART1SMEN)


#define __HAL_RCC_I2C4_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR2, RCC_APB1SMENR2_I2C4SMEN)


#define __HAL_RCC_UCPD1_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB1SMENR2, RCC_APB1SMENR2_UCPD1SMEN)


#define __HAL_RCC_TIM2_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM2SMEN)

#define __HAL_RCC_TIM3_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM3SMEN)

#define __HAL_RCC_TIM4_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM4SMEN)


#define __HAL_RCC_TIM5_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM5SMEN)


#define __HAL_RCC_TIM6_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM6SMEN)

#define __HAL_RCC_TIM7_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM7SMEN)

#define __HAL_RCC_CRS_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_CRSSMEN)

#define __HAL_RCC_RTCAPB_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_RTCAPBSMEN)

#define __HAL_RCC_WWDG_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_WWDGSMEN)

#define __HAL_RCC_SPI2_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_SPI2SMEN)

#define __HAL_RCC_SPI3_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_SPI3SMEN)

#define __HAL_RCC_USART2_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_USART2SMEN)

#define __HAL_RCC_USART3_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_USART3SMEN)


#define __HAL_RCC_UART4_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_UART4SMEN)



#define __HAL_RCC_UART5_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_UART5SMEN)


#define __HAL_RCC_I2C1_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_I2C1SMEN)

#define __HAL_RCC_I2C2_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_I2C2SMEN)


#define __HAL_RCC_USB_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_USBSMEN)



#define __HAL_RCC_FDCAN_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_FDCANSMEN)


#define __HAL_RCC_PWR_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_PWRSMEN)

#define __HAL_RCC_I2C3_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_I2C3SMEN)

#define __HAL_RCC_LPTIM1_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_LPTIM1SMEN)

#define __HAL_RCC_LPUART1_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR2, RCC_APB1SMENR2_LPUART1SMEN)


#define __HAL_RCC_I2C4_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR2, RCC_APB1SMENR2_I2C4SMEN)


#define __HAL_RCC_UCPD1_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB1SMENR2, RCC_APB1SMENR2_UCPD1SMEN)

/**
  * @}
  */

/** @defgroup RCC_APB2_Clock_Sleep_Enable_Disable APB2 Peripheral Clock Sleep Enable Disable
  * @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  */

#define __HAL_RCC_SYSCFG_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SYSCFGSMEN)

#define __HAL_RCC_TIM1_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM1SMEN)

#define __HAL_RCC_SPI1_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SPI1SMEN)

#define __HAL_RCC_TIM8_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM8SMEN)

#define __HAL_RCC_USART1_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB2SMENR, RCC_APB2SMENR_USART1SMEN)


#define __HAL_RCC_SPI4_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SPI4SMEN)


#define __HAL_RCC_TIM15_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM15SMEN)

#define __HAL_RCC_TIM16_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM16SMEN)

#define __HAL_RCC_TIM17_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM17SMEN)


#define __HAL_RCC_TIM20_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM20SMEN)


#define __HAL_RCC_SAI1_CLK_SLEEP_ENABLE() SET_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SAI1SMEN)






#define __HAL_RCC_SYSCFG_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SYSCFGSMEN)

#define __HAL_RCC_TIM1_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM1SMEN)

#define __HAL_RCC_SPI1_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SPI1SMEN)

#define __HAL_RCC_TIM8_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM8SMEN)

#define __HAL_RCC_USART1_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB2SMENR, RCC_APB2SMENR_USART1SMEN)


#define __HAL_RCC_SPI4_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SPI4SMEN)


#define __HAL_RCC_TIM15_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM15SMEN)

#define __HAL_RCC_TIM16_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM16SMEN)

#define __HAL_RCC_TIM17_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM17SMEN)


#define __HAL_RCC_TIM20_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM20SMEN)


#define __HAL_RCC_SAI1_CLK_SLEEP_DISABLE() CLEAR_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SAI1SMEN)





/**
  * @}
  */

/** @defgroup RCC_AHB1_Clock_Sleep_Enable_Disable_Status AHB1 Peripheral Clock Sleep Enabled or Disabled Status
  * @brief  Check whether the AHB1 peripheral clock during Low Power (Sleep) mode is enabled or not.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  */

#define __HAL_RCC_DMA1_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_DMA1SMEN) != 0U)

#define __HAL_RCC_DMA2_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_DMA2SMEN) != 0U)

#define __HAL_RCC_DMAMUX1_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_DMAMUX1SMEN) != 0U)

#define __HAL_RCC_CORDIC_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_CORDICSMEN) != 0U)

#define __HAL_RCC_FMAC_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_FMACSMEN) != 0U)

#define __HAL_RCC_FLASH_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_FLASHSMEN) != 0U)

#define __HAL_RCC_SRAM1_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_SRAM1SMEN) != 0U)

#define __HAL_RCC_CRC_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_CRCSMEN) != 0U)


#define __HAL_RCC_DMA1_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_DMA1SMEN) == 0U)

#define __HAL_RCC_DMA2_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_DMA2SMEN) == 0U)

#define __HAL_RCC_DMAMUX1_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_DMAMUX1SMEN) == 0U)

#define __HAL_RCC_CORDIC_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_CORDICSMEN) == 0U)

#define __HAL_RCC_FMAC_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_FMACSMEN) == 0U)

#define __HAL_RCC_FLASH_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_FLASHSMEN) == 0U)

#define __HAL_RCC_SRAM1_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_SRAM1SMEN) == 0U)

#define __HAL_RCC_CRC_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB1SMENR, RCC_AHB1SMENR_CRCSMEN) == 0U)

/**
  * @}
  */

/** @defgroup RCC_AHB2_Clock_Sleep_Enable_Disable_Status AHB2 Peripheral Clock Sleep Enabled or Disabled Status
  * @brief  Check whether the AHB2 peripheral clock during Low Power (Sleep) mode is enabled or not.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  */

#define __HAL_RCC_GPIOA_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOASMEN) != 0U)

#define __HAL_RCC_GPIOB_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOBSMEN) != 0U)

#define __HAL_RCC_GPIOC_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOCSMEN) != 0U)

#define __HAL_RCC_GPIOD_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIODSMEN) != 0U)

#define __HAL_RCC_GPIOE_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOESMEN) != 0U)

#define __HAL_RCC_GPIOF_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOFSMEN) != 0U)

#define __HAL_RCC_GPIOG_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOGSMEN) != 0U)

#define __HAL_RCC_SRAM2_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_SRAM2SMEN) != 0U)

#define __HAL_RCC_CCM_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_CCMSRAMSMEN) != 0U)

#define __HAL_RCC_ADC12_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_ADC12SMEN) != 0U)


#define __HAL_RCC_ADC345_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_ADC345SMEN) != 0U)


#define __HAL_RCC_DAC1_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC1SMEN) != 0U)


#define __HAL_RCC_DAC2_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC2SMEN) != 0U)


#define __HAL_RCC_DAC3_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC3SMEN) != 0U)


#define __HAL_RCC_DAC4_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC4SMEN) != 0U)






#define __HAL_RCC_RNG_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_RNGSMEN) != 0U)


#define __HAL_RCC_GPIOA_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOASMEN) == 0U)

#define __HAL_RCC_GPIOB_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOBSMEN) == 0U)

#define __HAL_RCC_GPIOC_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOCSMEN) == 0U)

#define __HAL_RCC_GPIOD_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIODSMEN) == 0U)

#define __HAL_RCC_GPIOE_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOESMEN) == 0U)

#define __HAL_RCC_GPIOF_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOFSMEN) == 0U)

#define __HAL_RCC_GPIOG_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_GPIOGSMEN) == 0U)

#define __HAL_RCC_SRAM2_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_SRAM2SMEN) == 0U)

#define __HAL_RCC_CCM_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_CCMSRAMSMEN) == 0U)

#define __HAL_RCC_ADC12_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_ADC12SMEN) == 0U)


#define __HAL_RCC_ADC345_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_ADC345SMEN) == 0U)


#define __HAL_RCC_DAC1_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC1SMEN) == 0U)


#define __HAL_RCC_DAC2_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC2SMEN) == 0U)


#define __HAL_RCC_DAC3_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC3SMEN) == 0U)


#define __HAL_RCC_DAC4_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_DAC4SMEN) == 0U)






#define __HAL_RCC_RNG_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB2SMENR, RCC_AHB2SMENR_RNGSMEN) == 0U)

/**
  * @}
  */

/** @defgroup RCC_AHB3_Clock_Sleep_Enable_Disable_Status AHB3 Peripheral Clock Sleep Enabled or Disabled Status
  * @brief  Check whether the AHB3 peripheral clock during Low Power (Sleep) mode is enabled or not.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  */


#define __HAL_RCC_FMC_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB3SMENR, RCC_AHB3SMENR_FMCSMEN) != 0U)



#define __HAL_RCC_QSPI_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->AHB3SMENR, RCC_AHB3SMENR_QSPISMEN) != 0U)



#define __HAL_RCC_FMC_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB3SMENR, RCC_AHB3SMENR_FMCSMEN) == 0U)



#define __HAL_RCC_QSPI_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->AHB3SMENR, RCC_AHB3SMENR_QSPISMEN) == 0U)


/**
  * @}
  */

/** @defgroup RCC_APB1_Clock_Sleep_Enable_Disable_Status APB1 Peripheral Clock Sleep Enabled or Disabled Status
  * @brief  Check whether the APB1 peripheral clock during Low Power (Sleep) mode is enabled or not.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  */

#define __HAL_RCC_TIM2_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM2SMEN) != 0U)

#define __HAL_RCC_TIM3_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM3SMEN) != 0U)

#define __HAL_RCC_TIM4_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM4SMEN) != 0U)


#define __HAL_RCC_TIM5_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM5SMEN) != 0U)


#define __HAL_RCC_TIM6_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM6SMEN) != 0U)

#define __HAL_RCC_TIM7_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM7SMEN) != 0U)

#define __HAL_RCC_CRS_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_CRSSMEN) != 0U)

#define __HAL_RCC_RTCAPB_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_RTCAPBSMEN) != 0U)

#define __HAL_RCC_WWDG_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_WWDGSMEN) != 0U)

#define __HAL_RCC_SPI2_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_SPI2SMEN) != 0U)

#define __HAL_RCC_SPI3_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_SPI3SMEN) != 0U)

#define __HAL_RCC_USART2_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_USART2SMEN) != 0U)

#define __HAL_RCC_USART3_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_USART3SMEN) != 0U)


#define __HAL_RCC_UART4_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_UART4SMEN) != 0U)



#define __HAL_RCC_UART5_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_UART5SMEN) != 0U)


#define __HAL_RCC_I2C1_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_I2C1SMEN) != 0U)

#define __HAL_RCC_I2C2_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_I2C2SMEN) != 0U)

#define __HAL_RCC_USB_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_USBSMEN) != 0U)


#define __HAL_RCC_FDCAN_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_FDCANSMEN) != 0U)


#define __HAL_RCC_PWR_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_PWRSMEN) != 0U)

#define __HAL_RCC_I2C3_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_I2C3SMEN) != 0U)

#define __HAL_RCC_LPTIM1_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_LPTIM1SMEN) != 0U)

#define __HAL_RCC_LPUART1_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR2, RCC_APB1SMENR2_LPUART1SMEN) != 0U)


#define __HAL_RCC_I2C4_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR2, RCC_APB1SMENR2_I2C4SMEN) != 0U)


#define __HAL_RCC_UCPD1_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB1SMENR2, RCC_APB1SMENR2_UCPD1SMEN) != 0U)


#define __HAL_RCC_TIM2_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM2SMEN) == 0U)

#define __HAL_RCC_TIM3_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM3SMEN) == 0U)

#define __HAL_RCC_TIM4_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM4SMEN) == 0U)


#define __HAL_RCC_TIM5_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM5SMEN) == 0U)


#define __HAL_RCC_TIM6_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM6SMEN) == 0U)

#define __HAL_RCC_TIM7_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_TIM7SMEN) == 0U)

#define __HAL_RCC_CRS_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_CRSSMEN) == 0U)

#define __HAL_RCC_RTCAPB_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_RTCAPBSMEN) == 0U)

#define __HAL_RCC_WWDG_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_WWDGSMEN) == 0U)

#define __HAL_RCC_SPI2_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_SPI2SMEN) == 0U)

#define __HAL_RCC_SPI3_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_SPI3SMEN) == 0U)

#define __HAL_RCC_USART2_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_USART2SMEN) == 0U)

#define __HAL_RCC_USART3_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_USART3SMEN) == 0U)


#define __HAL_RCC_UART4_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_UART4SMEN) == 0U)



#define __HAL_RCC_UART5_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_UART5SMEN) == 0U)


#define __HAL_RCC_I2C1_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_I2C1SMEN) == 0U)

#define __HAL_RCC_I2C2_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_I2C2SMEN) == 0U)

#define __HAL_RCC_USB_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_USBSMEN) == 0U)


#define __HAL_RCC_FDCAN_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_FDCANSMEN) == 0U)


#define __HAL_RCC_PWR_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_PWRSMEN) == 0U)

#define __HAL_RCC_I2C3_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_I2C3SMEN) == 0U)

#define __HAL_RCC_LPTIM1_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR1, RCC_APB1SMENR1_LPTIM1SMEN) == 0U)

#define __HAL_RCC_LPUART1_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR2, RCC_APB1SMENR2_LPUART1SMEN) == 0U)


#define __HAL_RCC_I2C4_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR2, RCC_APB1SMENR2_I2C4SMEN) == 0U)


#define __HAL_RCC_UCPD1_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB1SMENR2, RCC_APB1SMENR2_UCPD1SMEN) == 0U)

/**
  * @}
  */

/** @defgroup RCC_APB2_Clock_Sleep_Enable_Disable_Status APB2 Peripheral Clock Sleep Enabled or Disabled Status
  * @brief  Check whether the APB2 peripheral clock during Low Power (Sleep) mode is enabled or not.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  */

#define __HAL_RCC_SYSCFG_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SYSCFGSMEN) != 0U)

#define __HAL_RCC_TIM1_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM1SMEN) != 0U)

#define __HAL_RCC_SPI1_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SPI1SMEN) != 0U)

#define __HAL_RCC_TIM8_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM8SMEN) != 0U)

#define __HAL_RCC_USART1_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_USART1SMEN) != 0U)


#define __HAL_RCC_SPI4_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SPI4SMEN) != 0U)


#define __HAL_RCC_TIM15_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM15SMEN) != 0U)

#define __HAL_RCC_TIM16_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM16SMEN) != 0U)

#define __HAL_RCC_TIM17_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM17SMEN) != 0U)


#define __HAL_RCC_TIM20_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM20SMEN) != 0U)


#define __HAL_RCC_SAI1_IS_CLK_SLEEP_ENABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SAI1SMEN) != 0U)






#define __HAL_RCC_SYSCFG_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SYSCFGSMEN) == 0U)

#define __HAL_RCC_TIM1_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM1SMEN) == 0U)

#define __HAL_RCC_SPI1_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SPI1SMEN) == 0U)

#define __HAL_RCC_TIM8_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM8SMEN) == 0U)

#define __HAL_RCC_USART1_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_USART1SMEN) == 0U)


#define __HAL_RCC_SPI4_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SPI4SMEN) == 0U)


#define __HAL_RCC_TIM15_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM15SMEN) == 0U)

#define __HAL_RCC_TIM16_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM16SMEN) == 0U)

#define __HAL_RCC_TIM17_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM17SMEN) == 0U)


#define __HAL_RCC_TIM20_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_TIM20SMEN) == 0U)


#define __HAL_RCC_SAI1_IS_CLK_SLEEP_DISABLED() (READ_BIT(RCC->APB2SMENR, RCC_APB2SMENR_SAI1SMEN) == 0U)






/**
  * @}
  */

/** @defgroup RCC_Backup_Domain_Reset RCC Backup Domain Reset
  * @{
  */

/** @brief  Macros to force or release the Backup domain reset.
  * @note   This function resets the RTC peripheral (including the backup registers)
  *         and the RTC clock source selection in RCC_CSR register.
  * @note   The BKPSRAM is not affected by this reset.
  * @retval None
  */
#define __HAL_RCC_BACKUPRESET_FORCE() SET_BIT(RCC->BDCR, RCC_BDCR_BDRST)

#define __HAL_RCC_BACKUPRESET_RELEASE() CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST)

/**
  * @}
  */

/** @defgroup RCC_RTC_Clock_Configuration RCC RTC Clock Configuration
  * @{
  */

/** @brief  Macros to enable or disable the RTC clock.
  * @note   As the RTC is in the Backup domain and write access is denied to
  *         this domain after reset, you have to enable write access using
  *         HAL_PWR_EnableBkUpAccess() function before to configure the RTC
  *         (to be done once after reset).
  * @note   These macros must be used after the RTC clock source was selected.
  * @retval None
  */
#define __HAL_RCC_RTC_ENABLE() SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN)

#define __HAL_RCC_RTC_DISABLE() CLEAR_BIT(RCC->BDCR, RCC_BDCR_RTCEN)

/**
  * @}
  */

/** @brief  Macros to enable or disable the Internal High Speed 16MHz oscillator (HSI).
  * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes.
  *         It is used (enabled by hardware) as system clock source after startup
  *         from Reset, wakeup from STOP and STANDBY mode, or in case of failure
  *         of the HSE used directly or indirectly as system clock (if the Clock
  *         Security System CSS is enabled).
  * @note   HSI can not be stopped if it is used as system clock source. In this case,
  *         you have to select another source of the system clock then stop the HSI.
  * @note   After enabling the HSI, the application software should wait on HSIRDY
  *         flag to be set indicating that HSI clock is stable and can be used as
  *         system clock source.
  *         This parameter can be: ENABLE or DISABLE.
  * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
  *         clock cycles.
  * @retval None
  */
#define __HAL_RCC_HSI_ENABLE() SET_BIT(RCC->CR, RCC_CR_HSION)

#define __HAL_RCC_HSI_DISABLE() CLEAR_BIT(RCC->CR, RCC_CR_HSION)

/** @brief  Macro to adjust the Internal High Speed 16MHz oscillator (HSI) calibration value.
  * @note   The calibration is used to compensate for the variations in voltage
  *         and temperature that influence the frequency of the internal HSI RC.
  * @param  __HSICALIBRATIONVALUE__ specifies the calibration trimming value
  *         (default is RCC_HSICALIBRATION_DEFAULT).
  *         This parameter must be a number between 0 and 0x7F.
  * @retval None
  */
#define __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(__HSICALIBRATIONVALUE__) MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, (__HSICALIBRATIONVALUE__) << RCC_ICSCR_HSITRIM_Pos)


/**
  * @brief    Macros to enable or disable the force of the Internal High Speed oscillator (HSI)
  *           in STOP mode to be quickly available as kernel clock for USARTs and I2Cs.
  * @note     Keeping the HSI ON in STOP mode allows to avoid slowing down the communication
  *           speed because of the HSI startup time.
  * @note     The enable of this function has not effect on the HSION bit.
  *           This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
#define __HAL_RCC_HSISTOP_ENABLE() SET_BIT(RCC->CR, RCC_CR_HSIKERON)

#define __HAL_RCC_HSISTOP_DISABLE() CLEAR_BIT(RCC->CR, RCC_CR_HSIKERON)

/** @brief  Macros to enable or disable the Internal Low Speed oscillator (LSI).
  * @note   After enabling the LSI, the application software should wait on
  *         LSIRDY flag to be set indicating that LSI clock is stable and can
  *         be used to clock the IWDG and/or the RTC.
  * @note   LSI can not be disabled if the IWDG is running.
  * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
  *         clock cycles.
  * @retval None
  */
#define __HAL_RCC_LSI_ENABLE() SET_BIT(RCC->CSR, RCC_CSR_LSION)

#define __HAL_RCC_LSI_DISABLE() CLEAR_BIT(RCC->CSR, RCC_CSR_LSION)

/**
  * @brief  Macro to configure the External High Speed oscillator (HSE).
  * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
  *         software should wait on HSERDY flag to be set indicating that HSE clock
  *         is stable and can be used to clock the PLL and/or system clock.
  * @note   HSE state can not be changed if it is used directly or through the
  *         PLL as system clock. In this case, you have to select another source
  *         of the system clock then change the HSE state (ex. disable it).
  * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.
  * @note   This function reset the CSSON bit, so if the clock security system(CSS)
  *         was previously enabled you have to enable it again after calling this
  *         function.
  * @param  __STATE__ specifies the new state of the HSE.
  *         This parameter can be one of the following values:
  *            @arg @ref RCC_HSE_OFF  Turn OFF the HSE oscillator, HSERDY flag goes low after
  *                                   6 HSE oscillator clock cycles.
  *            @arg @ref RCC_HSE_ON  Turn ON the HSE oscillator.
  *            @arg @ref RCC_HSE_BYPASS  HSE oscillator bypassed with external clock.
  * @retval None
  */
#define __HAL_RCC_HSE_CONFIG(__STATE__) do { if((__STATE__) == RCC_HSE_ON) { SET_BIT(RCC->CR, RCC_CR_HSEON); } else if((__STATE__) == RCC_HSE_BYPASS) { SET_BIT(RCC->CR, RCC_CR_HSEBYP); SET_BIT(RCC->CR, RCC_CR_HSEON); } else { CLEAR_BIT(RCC->CR, RCC_CR_HSEON); CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP); } } while(0)
# 2856 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_rcc.h"

/**
  * @brief  Macro to configure the External Low Speed oscillator (LSE).
  * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not
  *         supported by this macro. User should request a transition to LSE Off
  *         first and then LSE On or LSE Bypass.
  * @note   As the LSE is in the Backup domain and write access is denied to
  *         this domain after reset, you have to enable write access using
  *         HAL_PWR_EnableBkUpAccess() function before to configure the LSE
  *         (to be done once after reset).
  * @note   After enabling the LSE (RCC_LSE_ON or RCC_LSE_BYPASS), the application
  *         software should wait on LSERDY flag to be set indicating that LSE clock
  *         is stable and can be used to clock the RTC.
  * @param  __STATE__ specifies the new state of the LSE.
  *         This parameter can be one of the following values:
  *            @arg @ref RCC_LSE_OFF  Turn OFF the LSE oscillator, LSERDY flag goes low after
  *                                   6 LSE oscillator clock cycles.
  *            @arg @ref RCC_LSE_ON  Turn ON the LSE oscillator.
  *            @arg @ref RCC_LSE_BYPASS  LSE oscillator bypassed with external clock.
  * @retval None
  */
#define __HAL_RCC_LSE_CONFIG(__STATE__) do { if((__STATE__) == RCC_LSE_ON) { SET_BIT(RCC->BDCR, RCC_BDCR_LSEON); } else if((__STATE__) == RCC_LSE_BYPASS) { SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP); SET_BIT(RCC->BDCR, RCC_BDCR_LSEON); } else { CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON); CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP); } } while(0)
# 2894 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_rcc.h"

/** @brief  Macros to enable or disable the Internal High Speed 48MHz oscillator (HSI48).
  * @note   The HSI48 is stopped by hardware when entering STOP and STANDBY modes.
  * @note   After enabling the HSI48, the application software should wait on HSI48RDY
  *         flag to be set indicating that HSI48 clock is stable.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
#define __HAL_RCC_HSI48_ENABLE() SET_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON)

#define __HAL_RCC_HSI48_DISABLE() CLEAR_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON)

/** @brief  Macros to configure the RTC clock (RTCCLK).
  * @note   As the RTC clock configuration bits are in the Backup domain and write
  *         access is denied to this domain after reset, you have to enable write
  *         access using the Power Backup Access macro before to configure
  *         the RTC clock source (to be done once after reset).
  * @note   Once the RTC clock is configured it cannot be changed unless the
  *         Backup domain is reset using __HAL_RCC_BACKUPRESET_FORCE() macro, or by
  *         a Power On Reset (POR).
  *
  * @param  __RTC_CLKSOURCE__ specifies the RTC clock source.
  *         This parameter can be one of the following values:
  *            @arg @ref RCC_RTCCLKSOURCE_NONE  No clock selected as RTC clock.
  *            @arg @ref RCC_RTCCLKSOURCE_LSE  LSE selected as RTC clock.
  *            @arg @ref RCC_RTCCLKSOURCE_LSI  LSI selected as RTC clock.
  *            @arg @ref RCC_RTCCLKSOURCE_HSE_DIV32  HSE clock divided by 32 selected
  *
  * @note   If the LSE or LSI is used as RTC clock source, the RTC continues to
  *         work in STOP and STANDBY modes, and can be used as wakeup source.
  *         However, when the HSE clock is used as RTC clock source, the RTC
  *         cannot be used in STOP and STANDBY modes.
  * @note   The maximum input clock frequency for RTC is 1MHz (when using HSE as
  *         RTC clock source).
  * @retval None
  */
#define __HAL_RCC_RTC_CONFIG(__RTC_CLKSOURCE__) MODIFY_REG( RCC->BDCR, RCC_BDCR_RTCSEL, (__RTC_CLKSOURCE__))



/** @brief  Macro to get the RTC clock source.
  * @retval The returned value can be one of the following:
  *            @arg @ref RCC_RTCCLKSOURCE_NONE  No clock selected as RTC clock.
  *            @arg @ref RCC_RTCCLKSOURCE_LSE  LSE selected as RTC clock.
  *            @arg @ref RCC_RTCCLKSOURCE_LSI  LSI selected as RTC clock.
  *            @arg @ref RCC_RTCCLKSOURCE_HSE_DIV32  HSE clock divided by 32 selected
  */
#define __HAL_RCC_GET_RTC_SOURCE() (READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL))

/** @brief  Macros to enable or disable the main PLL.
  * @note   After enabling the main PLL, the application software should wait on
  *         PLLRDY flag to be set indicating that PLL clock is stable and can
  *         be used as system clock source.
  * @note   The main PLL can not be disabled if it is used as system clock source
  * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
  * @retval None
  */
#define __HAL_RCC_PLL_ENABLE() SET_BIT(RCC->CR, RCC_CR_PLLON)

#define __HAL_RCC_PLL_DISABLE() CLEAR_BIT(RCC->CR, RCC_CR_PLLON)

/** @brief  Macro to configure the PLL clock source.
  * @note   This function must be used only when the main PLL is disabled.
  * @param  __PLLSOURCE__ specifies the PLL entry clock source.
  *         This parameter can be one of the following values:
  *            @arg @ref RCC_PLLSOURCE_NONE  No clock selected as PLL clock entry
  *            @arg @ref RCC_PLLSOURCE_HSI  HSI oscillator clock selected as PLL clock entry
  *            @arg @ref RCC_PLLSOURCE_HSE  HSE oscillator clock selected as PLL clock entry
  * @retval None
  *
  */
#define __HAL_RCC_PLL_PLLSOURCE_CONFIG(__PLLSOURCE__) MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, (__PLLSOURCE__))


/** @brief  Macro to configure the PLL source division factor M.
  * @note   This function must be used only when the main PLL is disabled.
  * @param  __PLLM__ specifies the division factor for PLL VCO input clock
  *         This parameter must be a value of @ref RCC_PLLM_Clock_Divider.
  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
  *         frequency ranges from 2.66 to 8 MHz. It is recommended to select a frequency
  *         of 8 MHz to limit PLL jitter.
  * @retval None
  *
  */
#define __HAL_RCC_PLL_PLLM_CONFIG(__PLLM__) MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLM, ((__PLLM__) - 1) << RCC_PLLCFGR_PLLM_Pos)


/**
  * @brief  Macro to configure the main PLL clock source, multiplication and division factors.
  * @note   This macro must be used only when the main PLL is disabled.
  * @note   This macro preserves the PLL's output clocks enable state.
  *
  * @param  __PLLSOURCE__ specifies the PLL entry clock source.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_PLLSOURCE_NONE  No clock selected as PLL clock entry
  *            @arg @ref RCC_PLLSOURCE_HSI  HSI oscillator clock selected as PLL clock entry
  *            @arg @ref RCC_PLLSOURCE_HSE  HSE oscillator clock selected as PLL clock entry
  *
  * @param  __PLLM__ specifies the division factor for PLL VCO input clock.
  *          This parameter must be a value of @ref RCC_PLLM_Clock_Divider
  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
  *         frequency ranges from 2.66 to 8 MHz. It is recommended to select a frequency
  *         of 8 MHz to limit PLL jitter.
  *
  * @param  __PLLN__ specifies the multiplication factor for PLL VCO output clock.
  *          This parameter must be a number between 8 and 127.
  * @note   You have to set the PLLN parameter correctly to ensure that the VCO
  *         output frequency is between 64 and 344 MHz.
  *
  * @param  __PLLP__ specifies the division factor for SAI clock.
  *          This parameter must be a number in the range (2 to 31).
  *
  * @param  __PLLQ__ specifies the division factor for OTG FS, SDMMC1 and RNG clocks.
  *          This parameter must be in the range (2, 4, 6 or 8).
  * @note   If the USB OTG FS is used in your application, you have to set the
  *         PLLQ parameter correctly to have 48 MHz clock for the USB. However,
  *         the SDMMC1 and RNG need a frequency lower than or equal to 48 MHz to work
  *         correctly.
  * @param  __PLLR__ specifies the division factor for the main system clock.
  * @note   You have to set the PLLR parameter correctly to not exceed 170MHZ.
  *          This parameter must be in the range (2, 4, 6 or 8).
  * @retval None
  */
#define __HAL_RCC_PLL_CONFIG(__PLLSOURCE__,__PLLM__,__PLLN__,__PLLP__,__PLLQ__,__PLLR__) MODIFY_REG(RCC->PLLCFGR, (RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN | RCC_PLLCFGR_PLLQ | RCC_PLLCFGR_PLLR | RCC_PLLCFGR_PLLPDIV), ((__PLLSOURCE__) | (((__PLLM__) - 1U) << RCC_PLLCFGR_PLLM_Pos) | ((__PLLN__) << RCC_PLLCFGR_PLLN_Pos) | ((((__PLLQ__) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos) | ((((__PLLR__) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos) | ((__PLLP__) << RCC_PLLCFGR_PLLPDIV_Pos)))
# 3027 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_rcc.h"

/** @brief  Macro to get the oscillator used as PLL clock source.
  * @retval The oscillator used as PLL clock source. The returned value can be one
  *         of the following:
  *              - RCC_PLLSOURCE_NONE: No oscillator is used as PLL clock source.
  *              - RCC_PLLSOURCE_HSI: HSI oscillator is used as PLL clock source.
  *              - RCC_PLLSOURCE_HSE: HSE oscillator is used as PLL clock source.
  */
#define __HAL_RCC_GET_PLL_OSCSOURCE() (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC))

/**
  * @brief  Enable or disable each clock output (RCC_PLL_SYSCLK, RCC_PLL_48M1CLK, RCC_PLL_ADCCLK)
  * @note   Enabling/disabling clock outputs RCC_PLL_ADCCLK and RCC_PLL_48M1CLK can be done at anytime
  *         without the need to stop the PLL in order to save power. But RCC_PLL_SYSCLK cannot
  *         be stopped if used as System Clock.
  * @param  __PLLCLOCKOUT__ specifies the PLL clock to be output.
  *          This parameter can be one or a combination of the following values:
  *            @arg @ref RCC_PLL_ADCCLK  This clock is used to generate a clock on ADC.
  *            @arg @ref RCC_PLL_48M1CLK  This Clock is used to generate the clock for the USB (48 MHz),
  *                                   FDCAN (<=48 MHz) and QSPI (<=48 MHz).
  *            @arg @ref RCC_PLL_SYSCLK  This Clock is used to generate the high speed system clock (up to 170MHz)
  * @retval None
  */
#define __HAL_RCC_PLLCLKOUT_ENABLE(__PLLCLOCKOUT__) SET_BIT(RCC->PLLCFGR, (__PLLCLOCKOUT__))

#define __HAL_RCC_PLLCLKOUT_DISABLE(__PLLCLOCKOUT__) CLEAR_BIT(RCC->PLLCFGR, (__PLLCLOCKOUT__))

/**
  * @brief  Get clock output enable status (RCC_PLL_SYSCLK, RCC_PLL_48M1CLK, RCC_PLL_SAI3CLK)
  * @param  __PLLCLOCKOUT__ specifies the output PLL clock to be checked.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_PLL_ADCCLK  This clock is used to generate a clock on ADC.
  *            @arg @ref RCC_PLL_48M1CLK  This Clock is used to generate the clock for the USB (48 MHz),
  *                                   FDCAN (<=48 MHz) and QSPI (<=48 MHz).
  *            @arg @ref RCC_PLL_SYSCLK  This Clock is used to generate the high speed system clock (up to 170MHz)
  * @retval SET / RESET
  */
#define __HAL_RCC_GET_PLLCLKOUT_CONFIG(__PLLCLOCKOUT__) READ_BIT(RCC->PLLCFGR, (__PLLCLOCKOUT__))

/**
  * @brief  Macro to configure the system clock source.
  * @param  __SYSCLKSOURCE__ specifies the system clock source.
  *          This parameter can be one of the following values:
  *              - RCC_SYSCLKSOURCE_HSI: HSI oscillator is used as system clock source.
  *              - RCC_SYSCLKSOURCE_HSE: HSE oscillator is used as system clock source.
  *              - RCC_SYSCLKSOURCE_PLLCLK: PLL output is used as system clock source.
  * @retval None
  */
#define __HAL_RCC_SYSCLK_CONFIG(__SYSCLKSOURCE__) MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, (__SYSCLKSOURCE__))


/** @brief  Macro to get the clock source used as system clock.
  * @retval The clock source used as system clock. The returned value can be one
  *         of the following:
  *              - RCC_SYSCLKSOURCE_STATUS_HSI: HSI used as system clock.
  *              - RCC_SYSCLKSOURCE_STATUS_HSE: HSE used as system clock.
  *              - RCC_SYSCLKSOURCE_STATUS_PLLCLK: PLL used as system clock.
  */
#define __HAL_RCC_GET_SYSCLK_SOURCE() (READ_BIT(RCC->CFGR, RCC_CFGR_SWS))

/**
  * @brief  Macro to configure the External Low Speed oscillator (LSE) drive capability.
  * @note   As the LSE is in the Backup domain and write access is denied to
  *         this domain after reset, you have to enable write access using
  *         HAL_PWR_EnableBkUpAccess() function before to configure the LSE
  *         (to be done once after reset).
  * @param  __LSEDRIVE__ specifies the new state of the LSE drive capability.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_LSEDRIVE_LOW  LSE oscillator low drive capability.
  *            @arg @ref RCC_LSEDRIVE_MEDIUMLOW  LSE oscillator medium low drive capability.
  *            @arg @ref RCC_LSEDRIVE_MEDIUMHIGH  LSE oscillator medium high drive capability.
  *            @arg @ref RCC_LSEDRIVE_HIGH  LSE oscillator high drive capability.
  * @retval None
  */
#define __HAL_RCC_LSEDRIVE_CONFIG(__LSEDRIVE__) MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, (__LSEDRIVE__))


/** @brief  Macro to configure the MCO clock.
  * @param  __MCOCLKSOURCE__ specifies the MCO clock source.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_MCO1SOURCE_NOCLOCK  MCO output disabled
  *            @arg @ref RCC_MCO1SOURCE_SYSCLK  System  clock selected as MCO source
  *            @arg @ref RCC_MCO1SOURCE_HSI  HSI clock selected as MCO source
  *            @arg @ref RCC_MCO1SOURCE_HSE  HSE clock selected as MCO source
  *            @arg @ref RCC_MCO1SOURCE_PLLCLK  Main PLL clock selected as MCO source
  *            @arg @ref RCC_MCO1SOURCE_LSI  LSI clock selected as MCO source
  *            @arg @ref RCC_MCO1SOURCE_LSE  LSE clock selected as MCO source
  *            @arg @ref RCC_MCO1SOURCE_HSI48  HSI48 clock selected as MCO source for devices with HSI48
  * @param  __MCODIV__ specifies the MCO clock prescaler.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_MCODIV_1   MCO clock source is divided by 1
  *            @arg @ref RCC_MCODIV_2   MCO clock source is divided by 2
  *            @arg @ref RCC_MCODIV_4   MCO clock source is divided by 4
  *            @arg @ref RCC_MCODIV_8   MCO clock source is divided by 8
  *            @arg @ref RCC_MCODIV_16  MCO clock source is divided by 16
  */
#define __HAL_RCC_MCO1_CONFIG(__MCOCLKSOURCE__,__MCODIV__) MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCOSEL | RCC_CFGR_MCOPRE), ((__MCOCLKSOURCE__) | (__MCODIV__)))


/** @defgroup RCC_Flags_Interrupts_Management Flags Interrupts Management
  * @brief macros to manage the specified RCC Flags and interrupts.
  * @{
  */

/** @brief  Enable RCC interrupt (Perform Byte access to RCC_CIR[14:8] bits to enable
  *         the selected interrupts).
  * @param  __INTERRUPT__ specifies the RCC interrupt sources to be enabled.
  *         This parameter can be any combination of the following values:
  *            @arg @ref RCC_IT_LSIRDY  LSI ready interrupt
  *            @arg @ref RCC_IT_LSERDY  LSE ready interrupt
  *            @arg @ref RCC_IT_HSIRDY  HSI ready interrupt
  *            @arg @ref RCC_IT_HSERDY  HSE ready interrupt
  *            @arg @ref RCC_IT_PLLRDY  Main PLL ready interrupt
  *            @arg @ref RCC_IT_LSECSS  LSE Clock security system interrupt
  *            @arg @ref RCC_IT_HSI48RDY  HSI48 ready interrupt for devices with HSI48
  * @retval None
  */
#define __HAL_RCC_ENABLE_IT(__INTERRUPT__) SET_BIT(RCC->CIER, (__INTERRUPT__))

/** @brief Disable RCC interrupt (Perform Byte access to RCC_CIR[14:8] bits to disable
  *        the selected interrupts).
  * @param  __INTERRUPT__ specifies the RCC interrupt sources to be disabled.
  *         This parameter can be any combination of the following values:
  *            @arg @ref RCC_IT_LSIRDY  LSI ready interrupt
  *            @arg @ref RCC_IT_LSERDY  LSE ready interrupt
  *            @arg @ref RCC_IT_HSIRDY  HSI ready interrupt
  *            @arg @ref RCC_IT_HSERDY  HSE ready interrupt
  *            @arg @ref RCC_IT_PLLRDY  Main PLL ready interrupt
  *            @arg @ref RCC_IT_LSECSS  LSE Clock security system interrupt
  *            @arg @ref RCC_IT_HSI48RDY  HSI48 ready interrupt for devices with HSI48
  * @retval None
  */
#define __HAL_RCC_DISABLE_IT(__INTERRUPT__) CLEAR_BIT(RCC->CIER, (__INTERRUPT__))

/** @brief  Clear the RCC's interrupt pending bits (Perform Byte access to RCC_CIR[23:16]
  *         bits to clear the selected interrupt pending bits.
  * @param  __INTERRUPT__ specifies the interrupt pending bit to clear.
  *         This parameter can be any combination of the following values:
  *            @arg @ref RCC_IT_LSIRDY  LSI ready interrupt
  *            @arg @ref RCC_IT_LSERDY  LSE ready interrupt
  *            @arg @ref RCC_IT_HSIRDY  HSI ready interrupt
  *            @arg @ref RCC_IT_HSERDY  HSE ready interrupt
  *            @arg @ref RCC_IT_PLLRDY  Main PLL ready interrupt
  *            @arg @ref RCC_IT_CSS  HSE Clock security system interrupt
  *            @arg @ref RCC_IT_LSECSS  LSE Clock security system interrupt
  *            @arg @ref RCC_IT_HSI48RDY  HSI48 ready interrupt for devices with HSI48
  * @retval None
  */
#define __HAL_RCC_CLEAR_IT(__INTERRUPT__) (RCC->CICR = (__INTERRUPT__))

/** @brief  Check whether the RCC interrupt has occurred or not.
  * @param  __INTERRUPT__ specifies the RCC interrupt source to check.
  *         This parameter can be one of the following values:
  *            @arg @ref RCC_IT_LSIRDY  LSI ready interrupt
  *            @arg @ref RCC_IT_LSERDY  LSE ready interrupt
  *            @arg @ref RCC_IT_HSIRDY  HSI ready interrupt
  *            @arg @ref RCC_IT_HSERDY  HSE ready interrupt
  *            @arg @ref RCC_IT_PLLRDY  Main PLL ready interrupt
  *            @arg @ref RCC_IT_CSS  HSE Clock security system interrupt
  *            @arg @ref RCC_IT_LSECSS  LSE Clock security system interrupt
  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt for devices with HSI48
  * @retval The new state of __INTERRUPT__ (TRUE or FALSE).
  */
#define __HAL_RCC_GET_IT(__INTERRUPT__) ((RCC->CIFR & (__INTERRUPT__)) == (__INTERRUPT__))

/** @brief Set RMVF bit to clear the reset flags.
  *        The reset flags are: RCC_FLAG_FWRRST, RCC_FLAG_OBLRST, RCC_FLAG_PINRST, RCC_FLAG_BORRST,
  *        RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST and RCC_FLAG_LPWRRST.
  * @retval None
 */
#define __HAL_RCC_CLEAR_RESET_FLAGS() (RCC->CSR |= RCC_CSR_RMVF)

/** @brief  Check whether the selected RCC flag is set or not.
  * @param  __FLAG__ specifies the flag to check.
  *         This parameter can be one of the following values:
  *            @arg @ref RCC_FLAG_HSIRDY  HSI oscillator clock ready
  *            @arg @ref RCC_FLAG_HSERDY  HSE oscillator clock ready
  *            @arg @ref RCC_FLAG_PLLRDY  Main PLL clock ready
  *            @arg @ref RCC_FLAG_HSI48RDY  HSI48 clock ready for devices with HSI48
  *            @arg @ref RCC_FLAG_LSERDY  LSE oscillator clock ready
  *            @arg @ref RCC_FLAG_LSECSSD  Clock security system failure on LSE oscillator detection
  *            @arg @ref RCC_FLAG_LSIRDY  LSI oscillator clock ready
  *            @arg @ref RCC_FLAG_BORRST  BOR reset
  *            @arg @ref RCC_FLAG_OBLRST  OBLRST reset
  *            @arg @ref RCC_FLAG_PINRST  Pin reset
  *            @arg @ref RCC_FLAG_SFTRST  Software reset
  *            @arg @ref RCC_FLAG_IWDGRST  Independent Watchdog reset
  *            @arg @ref RCC_FLAG_WWDGRST  Window Watchdog reset
  *            @arg @ref RCC_FLAG_LPWRRST  Low Power reset
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  */
#define __HAL_RCC_GET_FLAG(__FLAG__) (((((((__FLAG__) >> 5U) == 1U) ? RCC->CR : ((((__FLAG__) >> 5U) == 4U) ? RCC->CRRCR : ((((__FLAG__) >> 5U) == 2U) ? RCC->BDCR : ((((__FLAG__) >> 5U) == 3U) ? RCC->CSR : RCC->CIFR)))) & ((uint32_t)1U << ((__FLAG__) & RCC_FLAG_MASK))) != 0U) ? 1U : 0U)






/**
  * @}
  */

/**
  * @}
  */

/* Private constants ---------------------------------------------------------*/
/** @addtogroup RCC_Private_Constants
  * @{
  */
/* Defines used for Flags */
#define CR_REG_INDEX 1U
#define BDCR_REG_INDEX 2U
#define CSR_REG_INDEX 3U
#define CRRCR_REG_INDEX 4U

#define RCC_FLAG_MASK 0x1FU

/* Define used for IS_RCC_CLOCKTYPE() */
#define RCC_CLOCKTYPE_ALL (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2)

/**
  * @}
  */

/* Private macros ------------------------------------------------------------*/
/** @addtogroup RCC_Private_Macros
  * @{
  */

#define IS_RCC_OSCILLATORTYPE(__OSCILLATOR__) (((__OSCILLATOR__) == RCC_OSCILLATORTYPE_NONE) || (((__OSCILLATOR__) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE) || (((__OSCILLATOR__) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI) || (((__OSCILLATOR__) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48) || (((__OSCILLATOR__) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI) || (((__OSCILLATOR__) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE))






#define IS_RCC_HSE(__HSE__) (((__HSE__) == RCC_HSE_OFF) || ((__HSE__) == RCC_HSE_ON) || ((__HSE__) == RCC_HSE_BYPASS))


#define IS_RCC_LSE(__LSE__) (((__LSE__) == RCC_LSE_OFF) || ((__LSE__) == RCC_LSE_ON) || ((__LSE__) == RCC_LSE_BYPASS))


#define IS_RCC_HSI(__HSI__) (((__HSI__) == RCC_HSI_OFF) || ((__HSI__) == RCC_HSI_ON))

#define IS_RCC_HSI_CALIBRATION_VALUE(__VALUE__) ((__VALUE__) <= (RCC_ICSCR_HSITRIM >> RCC_ICSCR_HSITRIM_Pos))

#define IS_RCC_LSI(__LSI__) (((__LSI__) == RCC_LSI_OFF) || ((__LSI__) == RCC_LSI_ON))

#define IS_RCC_HSI48(__HSI48__) (((__HSI48__) == RCC_HSI48_OFF) || ((__HSI48__) == RCC_HSI48_ON))

#define IS_RCC_PLL(__PLL__) (((__PLL__) == RCC_PLL_NONE) ||((__PLL__) == RCC_PLL_OFF) || ((__PLL__) == RCC_PLL_ON))


#define IS_RCC_PLLSOURCE(__SOURCE__) (((__SOURCE__) == RCC_PLLSOURCE_NONE) || ((__SOURCE__) == RCC_PLLSOURCE_HSI) || ((__SOURCE__) == RCC_PLLSOURCE_HSE))



#define IS_RCC_PLLM_VALUE(__VALUE__) ((1U <= (__VALUE__)) && ((__VALUE__) <= 16U))

#define IS_RCC_PLLN_VALUE(__VALUE__) ((8U <= (__VALUE__)) && ((__VALUE__) <= 127U))

#define IS_RCC_PLLP_VALUE(__VALUE__) (((__VALUE__) >= 2U) && ((__VALUE__) <= 31U))

#define IS_RCC_PLLQ_VALUE(__VALUE__) (((__VALUE__) == 2U) || ((__VALUE__) == 4U) || ((__VALUE__) == 6U) || ((__VALUE__) == 8U))


#define IS_RCC_PLLR_VALUE(__VALUE__) (((__VALUE__) == 2U) || ((__VALUE__) == 4U) || ((__VALUE__) == 6U) || ((__VALUE__) == 8U))


#define IS_RCC_CLOCKTYPE(__CLK__) ((((__CLK__) & RCC_CLOCKTYPE_ALL) != 0x00UL) && (((__CLK__) & ~RCC_CLOCKTYPE_ALL) == 0x00UL))

#define IS_RCC_SYSCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_SYSCLKSOURCE_HSI) || ((__SOURCE__) == RCC_SYSCLKSOURCE_HSE) || ((__SOURCE__) == RCC_SYSCLKSOURCE_PLLCLK))



#define IS_RCC_HCLK(__HCLK__) (((__HCLK__) == RCC_SYSCLK_DIV1) || ((__HCLK__) == RCC_SYSCLK_DIV2) || ((__HCLK__) == RCC_SYSCLK_DIV4) || ((__HCLK__) == RCC_SYSCLK_DIV8) || ((__HCLK__) == RCC_SYSCLK_DIV16) || ((__HCLK__) == RCC_SYSCLK_DIV64) || ((__HCLK__) == RCC_SYSCLK_DIV128) || ((__HCLK__) == RCC_SYSCLK_DIV256) || ((__HCLK__) == RCC_SYSCLK_DIV512))





#define IS_RCC_PCLK(__PCLK__) (((__PCLK__) == RCC_HCLK_DIV1) || ((__PCLK__) == RCC_HCLK_DIV2) || ((__PCLK__) == RCC_HCLK_DIV4) || ((__PCLK__) == RCC_HCLK_DIV8) || ((__PCLK__) == RCC_HCLK_DIV16))



#define IS_RCC_RTCCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_RTCCLKSOURCE_NONE) || ((__SOURCE__) == RCC_RTCCLKSOURCE_LSE) || ((__SOURCE__) == RCC_RTCCLKSOURCE_LSI) || ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV32))




#define IS_RCC_MCO(__MCOX__) (((__MCOX__) == RCC_MCO_PA8) || ((__MCOX__) == RCC_MCO_PG10))


#define IS_RCC_MCO1SOURCE(__SOURCE__) (((__SOURCE__) == RCC_MCO1SOURCE_NOCLOCK) || ((__SOURCE__) == RCC_MCO1SOURCE_SYSCLK) || ((__SOURCE__) == RCC_MCO1SOURCE_HSI) || ((__SOURCE__) == RCC_MCO1SOURCE_HSE) || ((__SOURCE__) == RCC_MCO1SOURCE_PLLCLK) || ((__SOURCE__) == RCC_MCO1SOURCE_LSI) || ((__SOURCE__) == RCC_MCO1SOURCE_LSE) || ((__SOURCE__) == RCC_MCO1SOURCE_HSI48))








#define IS_RCC_MCODIV(__DIV__) (((__DIV__) == RCC_MCODIV_1) || ((__DIV__) == RCC_MCODIV_2) || ((__DIV__) == RCC_MCODIV_4) || ((__DIV__) == RCC_MCODIV_8) || ((__DIV__) == RCC_MCODIV_16))



#define IS_RCC_LSE_DRIVE(__DRIVE__) (((__DRIVE__) == RCC_LSEDRIVE_LOW) || ((__DRIVE__) == RCC_LSEDRIVE_MEDIUMLOW) || ((__DRIVE__) == RCC_LSEDRIVE_MEDIUMHIGH) || ((__DRIVE__) == RCC_LSEDRIVE_HIGH))




/**
  * @}
  */

/* Include RCC HAL Extended module */
# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_rcc_ex.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_rcc_ex.h
  * @author  MCD Application Team
  * @brief   Header file of RCC HAL Extended module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_RCC_EX_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup RCCEx
  * @{
  */

/* Exported types ------------------------------------------------------------*/

/** @defgroup RCCEx_Exported_Types RCCEx Exported Types
  * @{
  */

/**
  * @brief  RCC extended clocks structure definition
  */
typedef struct
{
  uint32_t PeriphClockSelection;   /*!< The Extended Clock to be configured.
                                        This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */

  uint32_t Usart1ClockSelection;   /*!< Specifies USART1 clock source.
                                        This parameter can be a value of @ref RCCEx_USART1_Clock_Source */

  uint32_t Usart2ClockSelection;   /*!< Specifies USART2 clock source.
                                        This parameter can be a value of @ref RCCEx_USART2_Clock_Source */

  uint32_t Usart3ClockSelection;   /*!< Specifies USART3 clock source.
                                        This parameter can be a value of @ref RCCEx_USART3_Clock_Source */



  uint32_t Uart4ClockSelection;    /*!< Specifies UART4 clock source.
                                        This parameter can be a value of @ref RCCEx_UART4_Clock_Source */



  uint32_t Uart5ClockSelection;    /*!< Specifies UART5 clock source.
                                        This parameter can be a value of @ref RCCEx_UART5_Clock_Source */



  uint32_t Lpuart1ClockSelection;  /*!< Specifies LPUART1 clock source.
                                        This parameter can be a value of @ref RCCEx_LPUART1_Clock_Source */

  uint32_t I2c1ClockSelection;     /*!< Specifies I2C1 clock source.
                                        This parameter can be a value of @ref RCCEx_I2C1_Clock_Source */

  uint32_t I2c2ClockSelection;     /*!< Specifies I2C2 clock source.
                                        This parameter can be a value of @ref RCCEx_I2C2_Clock_Source */

  uint32_t I2c3ClockSelection;     /*!< Specifies I2C3 clock source.
                                        This parameter can be a value of @ref RCCEx_I2C3_Clock_Source */



  uint32_t I2c4ClockSelection;     /*!< Specifies I2C4 clock source.
                                        This parameter can be a value of @ref RCCEx_I2C4_Clock_Source */


  uint32_t Lptim1ClockSelection;   /*!< Specifies LPTIM1 clock source.
                                        This parameter can be a value of @ref RCCEx_LPTIM1_Clock_Source */

  uint32_t Sai1ClockSelection;     /*!< Specifies SAI1 clock source.
                                        This parameter can be a value of @ref RCCEx_SAI1_Clock_Source */

  uint32_t I2sClockSelection;     /*!< Specifies I2S clock source.
                                        This parameter can be a value of @ref RCCEx_I2S_Clock_Source */


  uint32_t FdcanClockSelection;     /*!< Specifies FDCAN clock source.
                                        This parameter can be a value of @ref RCCEx_FDCAN_Clock_Source */



  uint32_t UsbClockSelection;      /*!< Specifies USB clock source (warning: same source for RNG).
                                        This parameter can be a value of @ref RCCEx_USB_Clock_Source */


  uint32_t RngClockSelection;      /*!< Specifies RNG clock source (warning: same source for USB).
                                        This parameter can be a value of @ref RCCEx_RNG_Clock_Source */

  uint32_t Adc12ClockSelection;    /*!< Specifies ADC12 interface clock source.
                                        This parameter can be a value of @ref RCCEx_ADC12_Clock_Source */


  uint32_t Adc345ClockSelection;   /*!< Specifies ADC345 interface clock source.
                                        This parameter can be a value of @ref RCCEx_ADC345_Clock_Source */



  uint32_t QspiClockSelection;     /*!< Specifies QuadSPI clock source.
                                        This parameter can be a value of @ref RCCEx_QSPI_Clock_Source */


  uint32_t RTCClockSelection;      /*!< Specifies RTC clock source.
                                        This parameter can be a value of @ref RCC_RTC_Clock_Source */
}RCC_PeriphCLKInitTypeDef;

/**
  * @brief RCC_CRS Init structure definition
  */
typedef struct
{
  uint32_t Prescaler;             /*!< Specifies the division factor of the SYNC signal.
                                       This parameter can be a value of @ref RCCEx_CRS_SynchroDivider */

  uint32_t Source;                /*!< Specifies the SYNC signal source.
                                       This parameter can be a value of @ref RCCEx_CRS_SynchroSource */

  uint32_t Polarity;              /*!< Specifies the input polarity for the SYNC signal source.
                                       This parameter can be a value of @ref RCCEx_CRS_SynchroPolarity */

  uint32_t ReloadValue;           /*!< Specifies the value to be loaded in the frequency error counter with each SYNC event.
                                       It can be calculated in using macro __HAL_RCC_CRS_RELOADVALUE_CALCULATE(__FTARGET__, __FSYNC__)
                                       This parameter must be a number between 0 and 0xFFFF or a value of @ref RCCEx_CRS_ReloadValueDefault .*/

  uint32_t ErrorLimitValue;       /*!< Specifies the value to be used to evaluate the captured frequency error value.
                                       This parameter must be a number between 0 and 0xFF or a value of @ref RCCEx_CRS_ErrorLimitDefault */

  uint32_t HSI48CalibrationValue; /*!< Specifies a user-programmable trimming value to the HSI48 oscillator.
                                       This parameter must be a number between 0 and 0x7F or a value of @ref RCCEx_CRS_HSI48CalibrationDefault */

}RCC_CRSInitTypeDef;

/**
  * @brief RCC_CRS Synchronization structure definition
  */
typedef struct
{
  uint32_t ReloadValue;           /*!< Specifies the value loaded in the Counter reload value.
                                       This parameter must be a number between 0 and 0xFFFF */

  uint32_t HSI48CalibrationValue; /*!< Specifies value loaded in HSI48 oscillator smooth trimming.
                                       This parameter must be a number between 0 and 0x7F */

  uint32_t FreqErrorCapture;      /*!< Specifies the value loaded in the .FECAP, the frequency error counter
                                       value latched in the time of the last SYNC event.
                                       This parameter must be a number between 0 and 0xFFFF */

  uint32_t FreqErrorDirection;    /*!< Specifies the value loaded in the .FEDIR, the counting direction of the
                                       frequency error counter latched in the time of the last SYNC event.
                                       It shows whether the actual frequency is below or above the target.
                                       This parameter must be a value of @ref RCCEx_CRS_FreqErrorDirection*/

}RCC_CRSSynchroInfoTypeDef;

/**
  * @}
  */

/* Exported constants --------------------------------------------------------*/
/** @defgroup RCCEx_Exported_Constants RCCEx Exported Constants
  * @{
  */

/** @defgroup RCCEx_LSCO_Clock_Source Low Speed Clock Source
  * @{
  */
#define RCC_LSCOSOURCE_LSI 0x00000000U
#define RCC_LSCOSOURCE_LSE RCC_BDCR_LSCOSEL
/**
  * @}
  */

/** @defgroup RCCEx_Periph_Clock_Selection Periph Clock Selection
  * @{
  */
#define RCC_PERIPHCLK_USART1 0x00000001U
#define RCC_PERIPHCLK_USART2 0x00000002U
#define RCC_PERIPHCLK_USART3 0x00000004U

#define RCC_PERIPHCLK_UART4 0x00000008U


#define RCC_PERIPHCLK_UART5 0x00000010U

#define RCC_PERIPHCLK_LPUART1 0x00000020U
#define RCC_PERIPHCLK_I2C1 0x00000040U
#define RCC_PERIPHCLK_I2C2 0x00000080U
#define RCC_PERIPHCLK_I2C3 0x00000100U
#define RCC_PERIPHCLK_LPTIM1 0x00000200U
#define RCC_PERIPHCLK_SAI1 0x00000400U
#define RCC_PERIPHCLK_I2S 0x00000800U

#define RCC_PERIPHCLK_FDCAN 0x00001000U

#define RCC_PERIPHCLK_USB 0x00002000U
#define RCC_PERIPHCLK_RNG 0x00004000U
#define RCC_PERIPHCLK_ADC12 0x00008000U

#define RCC_PERIPHCLK_ADC345 0x00010000U


#define RCC_PERIPHCLK_I2C4 0x00020000U


#define RCC_PERIPHCLK_QSPI 0x00040000U

#define RCC_PERIPHCLK_RTC 0x00080000U
/**
  * @}
  */


/** @defgroup RCCEx_USART1_Clock_Source USART1 Clock Source
  * @{
  */
#define RCC_USART1CLKSOURCE_PCLK2 0x00000000U
#define RCC_USART1CLKSOURCE_SYSCLK RCC_CCIPR_USART1SEL_0
#define RCC_USART1CLKSOURCE_HSI RCC_CCIPR_USART1SEL_1
#define RCC_USART1CLKSOURCE_LSE (RCC_CCIPR_USART1SEL_0 | RCC_CCIPR_USART1SEL_1)
/**
  * @}
  */

/** @defgroup RCCEx_USART2_Clock_Source USART2 Clock Source
  * @{
  */
#define RCC_USART2CLKSOURCE_PCLK1 0x00000000U
#define RCC_USART2CLKSOURCE_SYSCLK RCC_CCIPR_USART2SEL_0
#define RCC_USART2CLKSOURCE_HSI RCC_CCIPR_USART2SEL_1
#define RCC_USART2CLKSOURCE_LSE (RCC_CCIPR_USART2SEL_0 | RCC_CCIPR_USART2SEL_1)
/**
  * @}
  */

/** @defgroup RCCEx_USART3_Clock_Source USART3 Clock Source
  * @{
  */
#define RCC_USART3CLKSOURCE_PCLK1 0x00000000U
#define RCC_USART3CLKSOURCE_SYSCLK RCC_CCIPR_USART3SEL_0
#define RCC_USART3CLKSOURCE_HSI RCC_CCIPR_USART3SEL_1
#define RCC_USART3CLKSOURCE_LSE (RCC_CCIPR_USART3SEL_0 | RCC_CCIPR_USART3SEL_1)
/**
  * @}
  */


/** @defgroup RCCEx_UART4_Clock_Source UART4 Clock Source
  * @{
  */
#define RCC_UART4CLKSOURCE_PCLK1 0x00000000U
#define RCC_UART4CLKSOURCE_SYSCLK RCC_CCIPR_UART4SEL_0
#define RCC_UART4CLKSOURCE_HSI RCC_CCIPR_UART4SEL_1
#define RCC_UART4CLKSOURCE_LSE (RCC_CCIPR_UART4SEL_0 | RCC_CCIPR_UART4SEL_1)
/**
  * @}
  */



/** @defgroup RCCEx_UART5_Clock_Source UART5 Clock Source
  * @{
  */
#define RCC_UART5CLKSOURCE_PCLK1 0x00000000U
#define RCC_UART5CLKSOURCE_SYSCLK RCC_CCIPR_UART5SEL_0
#define RCC_UART5CLKSOURCE_HSI RCC_CCIPR_UART5SEL_1
#define RCC_UART5CLKSOURCE_LSE (RCC_CCIPR_UART5SEL_0 | RCC_CCIPR_UART5SEL_1)
/**
  * @}
  */


/** @defgroup RCCEx_LPUART1_Clock_Source LPUART1 Clock Source
  * @{
  */
#define RCC_LPUART1CLKSOURCE_PCLK1 0x00000000U
#define RCC_LPUART1CLKSOURCE_SYSCLK RCC_CCIPR_LPUART1SEL_0
#define RCC_LPUART1CLKSOURCE_HSI RCC_CCIPR_LPUART1SEL_1
#define RCC_LPUART1CLKSOURCE_LSE (RCC_CCIPR_LPUART1SEL_0 | RCC_CCIPR_LPUART1SEL_1)
/**
  * @}
  */

/** @defgroup RCCEx_I2C1_Clock_Source I2C1 Clock Source
  * @{
  */
#define RCC_I2C1CLKSOURCE_PCLK1 0x00000000U
#define RCC_I2C1CLKSOURCE_SYSCLK RCC_CCIPR_I2C1SEL_0
#define RCC_I2C1CLKSOURCE_HSI RCC_CCIPR_I2C1SEL_1
/**
  * @}
  */

/** @defgroup RCCEx_I2C2_Clock_Source I2C2 Clock Source
  * @{
  */
#define RCC_I2C2CLKSOURCE_PCLK1 0x00000000U
#define RCC_I2C2CLKSOURCE_SYSCLK RCC_CCIPR_I2C2SEL_0
#define RCC_I2C2CLKSOURCE_HSI RCC_CCIPR_I2C2SEL_1
/**
  * @}
  */

/** @defgroup RCCEx_I2C3_Clock_Source I2C3 Clock Source
  * @{
  */
#define RCC_I2C3CLKSOURCE_PCLK1 0x00000000U
#define RCC_I2C3CLKSOURCE_SYSCLK RCC_CCIPR_I2C3SEL_0
#define RCC_I2C3CLKSOURCE_HSI RCC_CCIPR_I2C3SEL_1
/**
  * @}
  */

/** @defgroup RCCEx_LPTIM1_Clock_Source LPTIM1 Clock Source
  * @{
  */
#define RCC_LPTIM1CLKSOURCE_PCLK1 0x00000000U
#define RCC_LPTIM1CLKSOURCE_LSI RCC_CCIPR_LPTIM1SEL_0
#define RCC_LPTIM1CLKSOURCE_HSI RCC_CCIPR_LPTIM1SEL_1
#define RCC_LPTIM1CLKSOURCE_LSE RCC_CCIPR_LPTIM1SEL
/**
  * @}
  */

/** @defgroup RCCEx_SAI1_Clock_Source SAI1 Clock Source
  * @{
  */
#define RCC_SAI1CLKSOURCE_SYSCLK 0x00000000U
#define RCC_SAI1CLKSOURCE_PLL RCC_CCIPR_SAI1SEL_0
#define RCC_SAI1CLKSOURCE_EXT RCC_CCIPR_SAI1SEL_1
#define RCC_SAI1CLKSOURCE_HSI (RCC_CCIPR_SAI1SEL_1 | RCC_CCIPR_SAI1SEL_0)
/**
  * @}
  */


/** @defgroup RCCEx_I2S_Clock_Source I2S Clock Source
  * @{
  */
#define RCC_I2SCLKSOURCE_SYSCLK 0x00000000U
#define RCC_I2SCLKSOURCE_PLL RCC_CCIPR_I2S23SEL_0
#define RCC_I2SCLKSOURCE_EXT RCC_CCIPR_I2S23SEL_1
#define RCC_I2SCLKSOURCE_HSI (RCC_CCIPR_I2S23SEL_1 | RCC_CCIPR_I2S23SEL_0)
/**
  * @}
  */



/** @defgroup RCCEx_FDCAN_Clock_Source FDCAN Clock Source
  * @{
  */
#define RCC_FDCANCLKSOURCE_HSE 0x00000000U
#define RCC_FDCANCLKSOURCE_PLL RCC_CCIPR_FDCANSEL_0
#define RCC_FDCANCLKSOURCE_PCLK1 RCC_CCIPR_FDCANSEL_1
/**
  * @}
  */


/** @defgroup RCCEx_RNG_Clock_Source RNG Clock Source
  * @{
  */
#define RCC_RNGCLKSOURCE_HSI48 0x00000000U
#define RCC_RNGCLKSOURCE_PLL RCC_CCIPR_CLK48SEL_1
/**
  * @}
  */

/** @defgroup RCCEx_USB_Clock_Source USB Clock Source
  * @{
  */
#define RCC_USBCLKSOURCE_HSI48 0x00000000U
#define RCC_USBCLKSOURCE_PLL RCC_CCIPR_CLK48SEL_1
/**
  * @}
  */

/** @defgroup RCCEx_ADC12_Clock_Source ADC12 Clock Source
  * @{
  */
#define RCC_ADC12CLKSOURCE_NONE 0x00000000U
#define RCC_ADC12CLKSOURCE_PLL RCC_CCIPR_ADC12SEL_0
#define RCC_ADC12CLKSOURCE_SYSCLK RCC_CCIPR_ADC12SEL_1
/**
  * @}
  */


/** @defgroup RCCEx_ADC345_Clock_Source ADC345 Clock Source
  * @{
  */
#define RCC_ADC345CLKSOURCE_NONE 0x00000000U
#define RCC_ADC345CLKSOURCE_PLL RCC_CCIPR_ADC345SEL_0
#define RCC_ADC345CLKSOURCE_SYSCLK RCC_CCIPR_ADC345SEL_1
/**
  * @}
  */



/** @defgroup RCCEx_I2C4_Clock_Source I2C4 Clock Source
  * @{
  */
#define RCC_I2C4CLKSOURCE_PCLK1 0x00000000U
#define RCC_I2C4CLKSOURCE_SYSCLK RCC_CCIPR2_I2C4SEL_0
#define RCC_I2C4CLKSOURCE_HSI RCC_CCIPR2_I2C4SEL_1
/**
  * @}
  */



/** @defgroup RCCEx_QSPI_Clock_Source QuadSPI Clock Source
  * @{
  */
#define RCC_QSPICLKSOURCE_SYSCLK 0x00000000U
#define RCC_QSPICLKSOURCE_HSI RCC_CCIPR2_QSPISEL_0
#define RCC_QSPICLKSOURCE_PLL RCC_CCIPR2_QSPISEL_1
/**
  * @}
  */


/** @defgroup RCCEx_EXTI_LINE_LSECSS  RCC LSE CSS external interrupt line
  * @{
  */
#define RCC_EXTI_LINE_LSECSS EXTI_IMR1_IM19
/**
  * @}
  */

/** @defgroup RCCEx_CRS_Status RCCEx CRS Status
  * @{
  */
#define RCC_CRS_NONE 0x00000000U
#define RCC_CRS_TIMEOUT 0x00000001U
#define RCC_CRS_SYNCOK 0x00000002U
#define RCC_CRS_SYNCWARN 0x00000004U
#define RCC_CRS_SYNCERR 0x00000008U
#define RCC_CRS_SYNCMISS 0x00000010U
#define RCC_CRS_TRIMOVF 0x00000020U
/**
  * @}
  */

/** @defgroup RCCEx_CRS_SynchroSource RCCEx CRS SynchroSource
  * @{
  */
#define RCC_CRS_SYNC_SOURCE_GPIO 0x00000000U
#define RCC_CRS_SYNC_SOURCE_LSE CRS_CFGR_SYNCSRC_0
#define RCC_CRS_SYNC_SOURCE_USB CRS_CFGR_SYNCSRC_1
/**
  * @}
  */

/** @defgroup RCCEx_CRS_SynchroDivider RCCEx CRS SynchroDivider
  * @{
  */
#define RCC_CRS_SYNC_DIV1 0x00000000U
#define RCC_CRS_SYNC_DIV2 CRS_CFGR_SYNCDIV_0
#define RCC_CRS_SYNC_DIV4 CRS_CFGR_SYNCDIV_1
#define RCC_CRS_SYNC_DIV8 (CRS_CFGR_SYNCDIV_1 | CRS_CFGR_SYNCDIV_0)
#define RCC_CRS_SYNC_DIV16 CRS_CFGR_SYNCDIV_2
#define RCC_CRS_SYNC_DIV32 (CRS_CFGR_SYNCDIV_2 | CRS_CFGR_SYNCDIV_0)
#define RCC_CRS_SYNC_DIV64 (CRS_CFGR_SYNCDIV_2 | CRS_CFGR_SYNCDIV_1)
#define RCC_CRS_SYNC_DIV128 CRS_CFGR_SYNCDIV
/**
  * @}
  */

/** @defgroup RCCEx_CRS_SynchroPolarity RCCEx CRS SynchroPolarity
  * @{
  */
#define RCC_CRS_SYNC_POLARITY_RISING 0x00000000U
#define RCC_CRS_SYNC_POLARITY_FALLING CRS_CFGR_SYNCPOL
/**
  * @}
  */

/** @defgroup RCCEx_CRS_ReloadValueDefault RCCEx CRS ReloadValueDefault
  * @{
  */
#define RCC_CRS_RELOADVALUE_DEFAULT 0x0000BB7FU

/**
  * @}
  */

/** @defgroup RCCEx_CRS_ErrorLimitDefault RCCEx CRS ErrorLimitDefault
  * @{
  */
#define RCC_CRS_ERRORLIMIT_DEFAULT 0x00000022U
/**
  * @}
  */

/** @defgroup RCCEx_CRS_HSI48CalibrationDefault RCCEx CRS HSI48CalibrationDefault
  * @{
  */
#define RCC_CRS_HSI48CALIBRATION_DEFAULT 0x00000040U


/**
  * @}
  */

/** @defgroup RCCEx_CRS_FreqErrorDirection RCCEx CRS FreqErrorDirection
  * @{
  */
#define RCC_CRS_FREQERRORDIR_UP 0x00000000U
#define RCC_CRS_FREQERRORDIR_DOWN CRS_ISR_FEDIR
/**
  * @}
  */

/** @defgroup RCCEx_CRS_Interrupt_Sources RCCEx CRS Interrupt Sources
  * @{
  */
#define RCC_CRS_IT_SYNCOK CRS_CR_SYNCOKIE
#define RCC_CRS_IT_SYNCWARN CRS_CR_SYNCWARNIE
#define RCC_CRS_IT_ERR CRS_CR_ERRIE
#define RCC_CRS_IT_ESYNC CRS_CR_ESYNCIE
#define RCC_CRS_IT_SYNCERR CRS_CR_ERRIE
#define RCC_CRS_IT_SYNCMISS CRS_CR_ERRIE
#define RCC_CRS_IT_TRIMOVF CRS_CR_ERRIE

/**
  * @}
  */

/** @defgroup RCCEx_CRS_Flags RCCEx CRS Flags
  * @{
  */
#define RCC_CRS_FLAG_SYNCOK CRS_ISR_SYNCOKF
#define RCC_CRS_FLAG_SYNCWARN CRS_ISR_SYNCWARNF
#define RCC_CRS_FLAG_ERR CRS_ISR_ERRF
#define RCC_CRS_FLAG_ESYNC CRS_ISR_ESYNCF
#define RCC_CRS_FLAG_SYNCERR CRS_ISR_SYNCERR
#define RCC_CRS_FLAG_SYNCMISS CRS_ISR_SYNCMISS
#define RCC_CRS_FLAG_TRIMOVF CRS_ISR_TRIMOVF

/**
  * @}
  */

/**
  * @}
  */

/* Exported macros -----------------------------------------------------------*/
/** @defgroup RCCEx_Exported_Macros RCCEx Exported Macros
 * @{
 */

/** @brief  Macro to configure the USART1 clock (USART1CLK).
  *
  * @param  __USART1_CLKSOURCE__ specifies the USART1 clock source.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_USART1CLKSOURCE_PCLK2  PCLK2 selected as USART1 clock
  *            @arg @ref RCC_USART1CLKSOURCE_HSI  HSI selected as USART1 clock
  *            @arg @ref RCC_USART1CLKSOURCE_SYSCLK  System Clock selected as USART1 clock
  *            @arg @ref RCC_USART1CLKSOURCE_LSE  LSE selected as USART1 clock
  * @retval None
  */
#define __HAL_RCC_USART1_CONFIG(__USART1_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_USART1SEL, (__USART1_CLKSOURCE__))


/** @brief  Macro to get the USART1 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_USART1CLKSOURCE_PCLK2  PCLK2 selected as USART1 clock
  *            @arg @ref RCC_USART1CLKSOURCE_HSI  HSI selected as USART1 clock
  *            @arg @ref RCC_USART1CLKSOURCE_SYSCLK  System Clock selected as USART1 clock
  *            @arg @ref RCC_USART1CLKSOURCE_LSE  LSE selected as USART1 clock
  */
#define __HAL_RCC_GET_USART1_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_USART1SEL))

/** @brief  Macro to configure the USART2 clock (USART2CLK).
  *
  * @param  __USART2_CLKSOURCE__ specifies the USART2 clock source.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_USART2CLKSOURCE_PCLK1  PCLK1 selected as USART2 clock
  *            @arg @ref RCC_USART2CLKSOURCE_HSI  HSI selected as USART2 clock
  *            @arg @ref RCC_USART2CLKSOURCE_SYSCLK  System Clock selected as USART2 clock
  *            @arg @ref RCC_USART2CLKSOURCE_LSE  LSE selected as USART2 clock
  * @retval None
  */
#define __HAL_RCC_USART2_CONFIG(__USART2_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_USART2SEL, (__USART2_CLKSOURCE__))


/** @brief  Macro to get the USART2 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_USART2CLKSOURCE_PCLK1  PCLK1 selected as USART2 clock
  *            @arg @ref RCC_USART2CLKSOURCE_HSI  HSI selected as USART2 clock
  *            @arg @ref RCC_USART2CLKSOURCE_SYSCLK  System Clock selected as USART2 clock
  *            @arg @ref RCC_USART2CLKSOURCE_LSE  LSE selected as USART2 clock
  */
#define __HAL_RCC_GET_USART2_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_USART2SEL))

/** @brief  Macro to configure the USART3 clock (USART3CLK).
  *
  * @param  __USART3_CLKSOURCE__ specifies the USART3 clock source.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_USART3CLKSOURCE_PCLK1  PCLK1 selected as USART3 clock
  *            @arg @ref RCC_USART3CLKSOURCE_HSI  HSI selected as USART3 clock
  *            @arg @ref RCC_USART3CLKSOURCE_SYSCLK  System Clock selected as USART3 clock
  *            @arg @ref RCC_USART3CLKSOURCE_LSE  LSE selected as USART3 clock
  * @retval None
  */
#define __HAL_RCC_USART3_CONFIG(__USART3_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_USART3SEL, (__USART3_CLKSOURCE__))


/** @brief  Macro to get the USART3 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_USART3CLKSOURCE_PCLK1  PCLK1 selected as USART3 clock
  *            @arg @ref RCC_USART3CLKSOURCE_HSI  HSI selected as USART3 clock
  *            @arg @ref RCC_USART3CLKSOURCE_SYSCLK  System Clock selected as USART3 clock
  *            @arg @ref RCC_USART3CLKSOURCE_LSE  LSE selected as USART3 clock
  */
#define __HAL_RCC_GET_USART3_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_USART3SEL))


/** @brief  Macro to configure the UART4 clock (UART4CLK).
  *
  * @param  __UART4_CLKSOURCE__ specifies the UART4 clock source.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_UART4CLKSOURCE_PCLK1  PCLK1 selected as UART4 clock
  *            @arg @ref RCC_UART4CLKSOURCE_HSI  HSI selected as UART4 clock
  *            @arg @ref RCC_UART4CLKSOURCE_SYSCLK  System Clock selected as UART4 clock
  *            @arg @ref RCC_UART4CLKSOURCE_LSE  LSE selected as UART4 clock
  * @retval None
  */
#define __HAL_RCC_UART4_CONFIG(__UART4_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_UART4SEL, (__UART4_CLKSOURCE__))


/** @brief  Macro to get the UART4 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_UART4CLKSOURCE_PCLK1  PCLK1 selected as UART4 clock
  *            @arg @ref RCC_UART4CLKSOURCE_HSI  HSI selected as UART4 clock
  *            @arg @ref RCC_UART4CLKSOURCE_SYSCLK  System Clock selected as UART4 clock
  *            @arg @ref RCC_UART4CLKSOURCE_LSE  LSE selected as UART4 clock
  */
#define __HAL_RCC_GET_UART4_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_UART4SEL))




/** @brief  Macro to configure the UART5 clock (UART5CLK).
  *
  * @param  __UART5_CLKSOURCE__ specifies the UART5 clock source.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_UART5CLKSOURCE_PCLK1  PCLK1 selected as UART5 clock
  *            @arg @ref RCC_UART5CLKSOURCE_HSI  HSI selected as UART5 clock
  *            @arg @ref RCC_UART5CLKSOURCE_SYSCLK  System Clock selected as UART5 clock
  *            @arg @ref RCC_UART5CLKSOURCE_LSE  LSE selected as UART5 clock
  * @retval None
  */
#define __HAL_RCC_UART5_CONFIG(__UART5_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_UART5SEL, (__UART5_CLKSOURCE__))


/** @brief  Macro to get the UART5 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_UART5CLKSOURCE_PCLK1  PCLK1 selected as UART5 clock
  *            @arg @ref RCC_UART5CLKSOURCE_HSI  HSI selected as UART5 clock
  *            @arg @ref RCC_UART5CLKSOURCE_SYSCLK  System Clock selected as UART5 clock
  *            @arg @ref RCC_UART5CLKSOURCE_LSE  LSE selected as UART5 clock
  */
#define __HAL_RCC_GET_UART5_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_UART5SEL))



/** @brief  Macro to configure the LPUART1 clock (LPUART1CLK).
  *
  * @param  __LPUART1_CLKSOURCE__ specifies the LPUART1 clock source.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_LPUART1CLKSOURCE_PCLK1  PCLK1 selected as LPUART1 clock
  *            @arg @ref RCC_LPUART1CLKSOURCE_HSI  HSI selected as LPUART1 clock
  *            @arg @ref RCC_LPUART1CLKSOURCE_SYSCLK  System Clock selected as LPUART1 clock
  *            @arg @ref RCC_LPUART1CLKSOURCE_LSE  LSE selected as LPUART1 clock
  * @retval None
  */
#define __HAL_RCC_LPUART1_CONFIG(__LPUART1_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, (__LPUART1_CLKSOURCE__))


/** @brief  Macro to get the LPUART1 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_LPUART1CLKSOURCE_PCLK1  PCLK1 selected as LPUART1 clock
  *            @arg @ref RCC_LPUART1CLKSOURCE_HSI  HSI selected as LPUART1 clock
  *            @arg @ref RCC_LPUART1CLKSOURCE_SYSCLK  System Clock selected as LPUART1 clock
  *            @arg @ref RCC_LPUART1CLKSOURCE_LSE  LSE selected as LPUART1 clock
  */
#define __HAL_RCC_GET_LPUART1_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_LPUART1SEL))

/** @brief  Macro to configure the I2C1 clock (I2C1CLK).
  *
  * @param  __I2C1_CLKSOURCE__ specifies the I2C1 clock source.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_I2C1CLKSOURCE_PCLK1  PCLK1 selected as I2C1 clock
  *            @arg @ref RCC_I2C1CLKSOURCE_HSI  HSI selected as I2C1 clock
  *            @arg @ref RCC_I2C1CLKSOURCE_SYSCLK  System Clock selected as I2C1 clock
  * @retval None
  */
#define __HAL_RCC_I2C1_CONFIG(__I2C1_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2C1SEL, (__I2C1_CLKSOURCE__))


/** @brief  Macro to get the I2C1 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_I2C1CLKSOURCE_PCLK1  PCLK1 selected as I2C1 clock
  *            @arg @ref RCC_I2C1CLKSOURCE_HSI  HSI selected as I2C1 clock
  *            @arg @ref RCC_I2C1CLKSOURCE_SYSCLK  System Clock selected as I2C1 clock
  */
#define __HAL_RCC_GET_I2C1_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_I2C1SEL))


/** @brief  Macro to configure the I2C2 clock (I2C2CLK).
  *
  * @param  __I2C2_CLKSOURCE__ specifies the I2C2 clock source.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_I2C2CLKSOURCE_PCLK1  PCLK1 selected as I2C2 clock
  *            @arg @ref RCC_I2C2CLKSOURCE_HSI  HSI selected as I2C2 clock
  *            @arg @ref RCC_I2C2CLKSOURCE_SYSCLK  System Clock selected as I2C2 clock
  * @retval None
  */
#define __HAL_RCC_I2C2_CONFIG(__I2C2_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2C2SEL, (__I2C2_CLKSOURCE__))


/** @brief  Macro to get the I2C2 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_I2C2CLKSOURCE_PCLK1  PCLK1 selected as I2C2 clock
  *            @arg @ref RCC_I2C2CLKSOURCE_HSI  HSI selected as I2C2 clock
  *            @arg @ref RCC_I2C2CLKSOURCE_SYSCLK  System Clock selected as I2C2 clock
  */
#define __HAL_RCC_GET_I2C2_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_I2C2SEL))

/** @brief  Macro to configure the I2C3 clock (I2C3CLK).
  *
  * @param  __I2C3_CLKSOURCE__ specifies the I2C3 clock source.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_I2C3CLKSOURCE_PCLK1  PCLK1 selected as I2C3 clock
  *            @arg @ref RCC_I2C3CLKSOURCE_HSI  HSI selected as I2C3 clock
  *            @arg @ref RCC_I2C3CLKSOURCE_SYSCLK  System Clock selected as I2C3 clock
  * @retval None
  */
#define __HAL_RCC_I2C3_CONFIG(__I2C3_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2C3SEL, (__I2C3_CLKSOURCE__))


/** @brief  Macro to get the I2C3 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_I2C3CLKSOURCE_PCLK1  PCLK1 selected as I2C3 clock
  *            @arg @ref RCC_I2C3CLKSOURCE_HSI  HSI selected as I2C3 clock
  *            @arg @ref RCC_I2C3CLKSOURCE_SYSCLK  System Clock selected as I2C3 clock
  */
#define __HAL_RCC_GET_I2C3_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_I2C3SEL))



/** @brief  Macro to configure the I2C4 clock (I2C4CLK).
  *
  * @param  __I2C4_CLKSOURCE__ specifies the I2C4 clock source.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_I2C4CLKSOURCE_PCLK1  PCLK1 selected as I2C4 clock
  *            @arg @ref RCC_I2C4CLKSOURCE_HSI  HSI selected as I2C4 clock
  *            @arg @ref RCC_I2C4CLKSOURCE_SYSCLK  System Clock selected as I2C4 clock
  * @retval None
  */
#define __HAL_RCC_I2C4_CONFIG(__I2C4_CLKSOURCE__) MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_I2C4SEL, (__I2C4_CLKSOURCE__))


/** @brief  Macro to get the I2C4 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_I2C4CLKSOURCE_PCLK1  PCLK1 selected as I2C4 clock
  *            @arg @ref RCC_I2C4CLKSOURCE_HSI  HSI selected as I2C4 clock
  *            @arg @ref RCC_I2C4CLKSOURCE_SYSCLK  System Clock selected as I2C4 clock
  */
#define __HAL_RCC_GET_I2C4_SOURCE() (READ_BIT(RCC->CCIPR2, RCC_CCIPR2_I2C4SEL))



/** @brief  Macro to configure the LPTIM1 clock (LPTIM1CLK).
  *
  * @param  __LPTIM1_CLKSOURCE__ specifies the LPTIM1 clock source.
  *          This parameter can be one of the following values:
  *            @arg @ref RCC_LPTIM1CLKSOURCE_PCLK1  PCLK1 selected as LPTIM1 clock
  *            @arg @ref RCC_LPTIM1CLKSOURCE_LSI  HSI selected as LPTIM1 clock
  *            @arg @ref RCC_LPTIM1CLKSOURCE_HSI  LSI selected as LPTIM1 clock
  *            @arg @ref RCC_LPTIM1CLKSOURCE_LSE  LSE selected as LPTIM1 clock
  * @retval None
  */
#define __HAL_RCC_LPTIM1_CONFIG(__LPTIM1_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPTIM1SEL, (__LPTIM1_CLKSOURCE__))


/** @brief  Macro to get the LPTIM1 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_LPTIM1CLKSOURCE_PCLK1  PCLK1 selected as LPUART1 clock
  *            @arg @ref RCC_LPTIM1CLKSOURCE_LSI  HSI selected as LPUART1 clock
  *            @arg @ref RCC_LPTIM1CLKSOURCE_HSI  System Clock selected as LPUART1 clock
  *            @arg @ref RCC_LPTIM1CLKSOURCE_LSE  LSE selected as LPUART1 clock
  */
#define __HAL_RCC_GET_LPTIM1_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_LPTIM1SEL))

/**
  * @brief  Macro to configure the SAI1 clock source.
  * @param  __SAI1_CLKSOURCE__ defines the SAI1 clock source. This clock is derived
  *         from the HSI, system PLL, System Clock or external clock.
  *          This parameter can be one of the following values:
  *             @arg @ref RCC_SAI1CLKSOURCE_SYSCLK SAI1 clock = System Clock
  *             @arg @ref RCC_SAI1CLKSOURCE_PLL    SAI1 clock = PLL "Q" clock
  *             @arg @ref RCC_SAI1CLKSOURCE_EXT    SAI1 clock = EXT
  *             @arg @ref RCC_SAI1CLKSOURCE_HSI    SAI1 clock = HSI
  *
  * @retval None
  */


#define __HAL_RCC_SAI1_CONFIG(__SAI1_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_SAI1SEL, (__SAI1_CLKSOURCE__))


/** @brief  Macro to get the SAI1 clock source.
  * @retval The clock source can be one of the following values:
  *             @arg @ref RCC_SAI1CLKSOURCE_SYSCLK SAI1 clock = System Clock
  *             @arg @ref RCC_SAI1CLKSOURCE_PLL    SAI1 clock = PLL "Q" clock
  *             @arg @ref RCC_SAI1CLKSOURCE_EXT    SAI1 clock = EXT
  *             @arg @ref RCC_SAI1CLKSOURCE_HSI    SAI1 clock = HSI
  *
  */
#define __HAL_RCC_GET_SAI1_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_SAI1SEL))



/**
  * @brief  Macro to configure the I2S clock source.
  * @param  __I2S_CLKSOURCE__ defines the I2S clock source. This clock is derived
  *         from the HSI, system PLL, System Clock or external clock.
  *          This parameter can be one of the following values:
  *             @arg @ref RCC_I2SCLKSOURCE_SYSCLK I2S clock = System Clock
  *             @arg @ref RCC_I2SCLKSOURCE_PLL    I2S clock = PLL "Q" clock
  *             @arg @ref RCC_I2SCLKSOURCE_EXT    I2S clock = EXT
  *             @arg @ref RCC_I2SCLKSOURCE_HSI    I2S clock = HSI
  *
  * @retval None
  */
#define __HAL_RCC_I2S_CONFIG(__I2S_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2S23SEL, (__I2S_CLKSOURCE__))


/** @brief  Macro to get the I2S clock source.
  * @retval The clock source can be one of the following values:
  *             @arg @ref RCC_I2SCLKSOURCE_SYSCLK I2S clock = System Clock
  *             @arg @ref RCC_I2SCLKSOURCE_PLL    I2S clock = PLL "Q" clock
  *             @arg @ref RCC_I2SCLKSOURCE_EXT    I2S clock = EXT
  *             @arg @ref RCC_I2SCLKSOURCE_HSI    I2S clock = HSI
  *
  */
#define __HAL_RCC_GET_I2S_SOURCE() ((uint32_t)(READ_BIT(RCC->CCIPR, RCC_CCIPR_I2S23SEL)))



/**
  * @brief  Macro to configure the FDCAN clock source.
  * @param  __FDCAN_CLKSOURCE__ defines the FDCAN clock source. This clock is derived
  *         from the HSE, system PLL or PCLK1.
  *          This parameter can be one of the following values:
  *             @arg @ref RCC_FDCANCLKSOURCE_HSE   FDCAN clock = HSE
  *             @arg @ref RCC_FDCANCLKSOURCE_PLL   FDCAN clock = PLL "Q" clock
  *             @arg @ref RCC_FDCANCLKSOURCE_PCLK1 FDCAN clock = PCLK1
  *
  * @retval None
  */
#define __HAL_RCC_FDCAN_CONFIG(__FDCAN_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_FDCANSEL, (uint32_t)(__FDCAN_CLKSOURCE__))


/** @brief  Macro to get the FDCAN clock source.
  * @retval The clock source can be one of the following values:
  *             @arg @ref RCC_FDCANCLKSOURCE_HSE   FDCAN clock = HSE
  *             @arg @ref RCC_FDCANCLKSOURCE_PLL   FDCAN clock = PLL "Q" clock
  *             @arg @ref RCC_FDCANCLKSOURCE_PCLK1 FDCAN clock = PCLK1
  *
  */
#define __HAL_RCC_GET_FDCAN_SOURCE() ((uint32_t)(READ_BIT(RCC->CCIPR, RCC_CCIPR_FDCANSEL)))


/** @brief  Macro to configure the RNG clock.
  *
  * @note  USB and RNG peripherals share the same 48MHz clock source.
  *
  * @param  __RNG_CLKSOURCE__ specifies the RNG clock source.
  *         This parameter can be one of the following values:
  *            @arg @ref RCC_RNGCLKSOURCE_HSI48  HSI48 selected as RNG clock for devices with HSI48
  *            @arg @ref RCC_RNGCLKSOURCE_PLL  PLL Clock selected as RNG clock
  * @retval None
  */
#define __HAL_RCC_RNG_CONFIG(__RNG_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_CLK48SEL, (__RNG_CLKSOURCE__))


/** @brief  Macro to get the RNG clock.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_RNGCLKSOURCE_HSI48  HSI48 selected as RNG clock for devices with HSI48
  *            @arg @ref RCC_RNGCLKSOURCE_PLL  PLL "Q" clock selected as RNG clock
  */
#define __HAL_RCC_GET_RNG_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL))



/** @brief  Macro to configure the USB clock (USBCLK).
  *
  * @note  USB, RNG peripherals share the same 48MHz clock source.
  *
  * @param  __USB_CLKSOURCE__ specifies the USB clock source.
  *         This parameter can be one of the following values:
  *            @arg @ref RCC_USBCLKSOURCE_HSI48  HSI48 selected as 48MHz clock for devices with HSI48
  *            @arg @ref RCC_USBCLKSOURCE_PLL  PLL "Q" clock (PLL48M1CLK) selected as USB clock
  * @retval None
  */
#define __HAL_RCC_USB_CONFIG(__USB_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_CLK48SEL, (__USB_CLKSOURCE__))


/** @brief  Macro to get the USB clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_USBCLKSOURCE_HSI48  HSI48 selected as 48MHz clock for devices with HSI48
  *            @arg @ref RCC_USBCLKSOURCE_PLL  PLL "Q" clock (PLL48M1CLK) selected as USB clock
  */
#define __HAL_RCC_GET_USB_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL))



/** @brief  Macro to configure the ADC12 interface clock.
  * @param  __ADC12_CLKSOURCE__ specifies the ADC12 digital interface clock source.
  *         This parameter can be one of the following values:
  *            @arg @ref RCC_ADC12CLKSOURCE_NONE    No clock selected as ADC12 clock
  *            @arg @ref RCC_ADC12CLKSOURCE_PLL     PLL Clock selected as ADC12 clock
  *            @arg @ref RCC_ADC12CLKSOURCE_SYSCLK  System Clock selected as ADC12 clock
  * @retval None
  */
#define __HAL_RCC_ADC12_CONFIG(__ADC12_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADC12SEL, (__ADC12_CLKSOURCE__))


/** @brief  Macro to get the ADC12 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_ADC12CLKSOURCE_NONE    No clock selected as ADC12 clock
  *            @arg @ref RCC_ADC12CLKSOURCE_PLL     PLL Clock selected as ADC12 clock
  *            @arg @ref RCC_ADC12CLKSOURCE_SYSCLK  System Clock selected as ADC12 clock
  */
#define __HAL_RCC_GET_ADC12_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_ADC12SEL))


/** @brief  Macro to configure the ADC345 interface clock.
  * @param  __ADC345_CLKSOURCE__ specifies the ADC345 digital interface clock source.
  *         This parameter can be one of the following values:
  *            @arg @ref RCC_ADC345CLKSOURCE_NONE    No clock selected as ADC345 clock
  *            @arg @ref RCC_ADC345CLKSOURCE_PLL     PLL Clock selected as ADC345 clock
  *            @arg @ref RCC_ADC345CLKSOURCE_SYSCLK  System Clock selected as ADC345 clock
  * @retval None
  */
#define __HAL_RCC_ADC345_CONFIG(__ADC345_CLKSOURCE__) MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADC345SEL, __ADC345_CLKSOURCE__)


/** @brief  Macro to get the ADC345 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_ADC345CLKSOURCE_NONE    No clock selected as ADC345 clock
  *            @arg @ref RCC_ADC345CLKSOURCE_PLL     PLL Clock selected as ADC345 clock
  *            @arg @ref RCC_ADC345CLKSOURCE_SYSCLK  System Clock selected as ADC345 clock
  */
#define __HAL_RCC_GET_ADC345_SOURCE() (READ_BIT(RCC->CCIPR, RCC_CCIPR_ADC345SEL))




/** @brief  Macro to configure the QuadSPI clock.
  * @param  __QSPI_CLKSOURCE__ specifies the QuadSPI clock source.
  *         This parameter can be one of the following values:
  *            @arg @ref RCC_QSPICLKSOURCE_SYSCLK  System Clock selected as QuadSPI clock
  *            @arg @ref RCC_QSPICLKSOURCE_HSI     HSI clock selected as QuadSPI clock
  *            @arg @ref RCC_QSPICLKSOURCE_PLL     PLL Q divider clock selected as QuadSPI clock
  * @retval None
  */
#define __HAL_RCC_QSPI_CONFIG(__QSPI_CLKSOURCE__) MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_QSPISEL, __QSPI_CLKSOURCE__)


/** @brief  Macro to get the QuadSPI clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_QSPICLKSOURCE_SYSCLK  System Clock selected as QuadSPI clock
  *            @arg @ref RCC_QSPICLKSOURCE_HSI     HSI clock selected as QuadSPI clock
  *            @arg @ref RCC_QSPICLKSOURCE_PLL     PLL Q divider clock selected as QuadSPI clock
  */
#define __HAL_RCC_GET_QSPI_SOURCE() (READ_BIT(RCC->CCIPR2, RCC_CCIPR2_QSPISEL))



/** @defgroup RCCEx_Flags_Interrupts_Management Flags Interrupts Management
  * @brief macros to manage the specified RCC Flags and interrupts.
  * @{
  */

/**
  * @brief Enable the RCC LSE CSS Extended Interrupt Line.
  * @retval None
  */
#define __HAL_RCC_LSECSS_EXTI_ENABLE_IT() SET_BIT(EXTI->IMR1, RCC_EXTI_LINE_LSECSS)

/**
  * @brief Disable the RCC LSE CSS Extended Interrupt Line.
  * @retval None
  */
#define __HAL_RCC_LSECSS_EXTI_DISABLE_IT() CLEAR_BIT(EXTI->IMR1, RCC_EXTI_LINE_LSECSS)

/**
  * @brief Enable the RCC LSE CSS Event Line.
  * @retval None.
  */
#define __HAL_RCC_LSECSS_EXTI_ENABLE_EVENT() SET_BIT(EXTI->EMR1, RCC_EXTI_LINE_LSECSS)

/**
  * @brief Disable the RCC LSE CSS Event Line.
  * @retval None.
  */
#define __HAL_RCC_LSECSS_EXTI_DISABLE_EVENT() CLEAR_BIT(EXTI->EMR1, RCC_EXTI_LINE_LSECSS)


/**
  * @brief  Enable the RCC LSE CSS Extended Interrupt Falling Trigger.
  * @retval None.
  */
#define __HAL_RCC_LSECSS_EXTI_ENABLE_FALLING_EDGE() SET_BIT(EXTI->FTSR1, RCC_EXTI_LINE_LSECSS)


/**
  * @brief Disable the RCC LSE CSS Extended Interrupt Falling Trigger.
  * @retval None.
  */
#define __HAL_RCC_LSECSS_EXTI_DISABLE_FALLING_EDGE() CLEAR_BIT(EXTI->FTSR1, RCC_EXTI_LINE_LSECSS)


/**
  * @brief  Enable the RCC LSE CSS Extended Interrupt Rising Trigger.
  * @retval None.
  */
#define __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE() SET_BIT(EXTI->RTSR1, RCC_EXTI_LINE_LSECSS)

/**
  * @brief Disable the RCC LSE CSS Extended Interrupt Rising Trigger.
  * @retval None.
  */
#define __HAL_RCC_LSECSS_EXTI_DISABLE_RISING_EDGE() CLEAR_BIT(EXTI->RTSR1, RCC_EXTI_LINE_LSECSS)

/**
  * @brief Enable the RCC LSE CSS Extended Interrupt Rising & Falling Trigger.
  * @retval None.
  */
#define __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_FALLING_EDGE() do { __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE(); __HAL_RCC_LSECSS_EXTI_ENABLE_FALLING_EDGE(); } while(0)





/**
  * @brief Disable the RCC LSE CSS Extended Interrupt Rising & Falling Trigger.
  * @retval None.
  */
#define __HAL_RCC_LSECSS_EXTI_DISABLE_RISING_FALLING_EDGE() do { __HAL_RCC_LSECSS_EXTI_DISABLE_RISING_EDGE(); __HAL_RCC_LSECSS_EXTI_DISABLE_FALLING_EDGE(); } while(0)





/**
  * @brief Check whether the specified RCC LSE CSS EXTI interrupt flag is set or not.
  * @retval EXTI RCC LSE CSS Line Status.
  */
#define __HAL_RCC_LSECSS_EXTI_GET_FLAG() (READ_BIT(EXTI->PR1, RCC_EXTI_LINE_LSECSS) == RCC_EXTI_LINE_LSECSS)

/**
  * @brief Clear the RCC LSE CSS EXTI flag.
  * @retval None.
  */
#define __HAL_RCC_LSECSS_EXTI_CLEAR_FLAG() WRITE_REG(EXTI->PR1, RCC_EXTI_LINE_LSECSS)

/**
  * @brief Generate a Software interrupt on the RCC LSE CSS EXTI line.
  * @retval None.
  */
#define __HAL_RCC_LSECSS_EXTI_GENERATE_SWIT() SET_BIT(EXTI->SWIER1, RCC_EXTI_LINE_LSECSS)


/**
  * @brief  Enable the specified CRS interrupts.
  * @param  __INTERRUPT__ specifies the CRS interrupt sources to be enabled.
  *          This parameter can be any combination of the following values:
  *              @arg @ref RCC_CRS_IT_SYNCOK  SYNC event OK interrupt
  *              @arg @ref RCC_CRS_IT_SYNCWARN  SYNC warning interrupt
  *              @arg @ref RCC_CRS_IT_ERR  Synchronization or trimming error interrupt
  *              @arg @ref RCC_CRS_IT_ESYNC  Expected SYNC interrupt
  * @retval None
  */
#define __HAL_RCC_CRS_ENABLE_IT(__INTERRUPT__) SET_BIT(CRS->CR, (__INTERRUPT__))

/**
  * @brief  Disable the specified CRS interrupts.
  * @param  __INTERRUPT__ specifies the CRS interrupt sources to be disabled.
  *          This parameter can be any combination of the following values:
  *              @arg @ref RCC_CRS_IT_SYNCOK  SYNC event OK interrupt
  *              @arg @ref RCC_CRS_IT_SYNCWARN  SYNC warning interrupt
  *              @arg @ref RCC_CRS_IT_ERR  Synchronization or trimming error interrupt
  *              @arg @ref RCC_CRS_IT_ESYNC  Expected SYNC interrupt
  * @retval None
  */
#define __HAL_RCC_CRS_DISABLE_IT(__INTERRUPT__) CLEAR_BIT(CRS->CR, (__INTERRUPT__))

/** @brief  Check whether the CRS interrupt has occurred or not.
  * @param  __INTERRUPT__ specifies the CRS interrupt source to check.
  *         This parameter can be one of the following values:
  *              @arg @ref RCC_CRS_IT_SYNCOK  SYNC event OK interrupt
  *              @arg @ref RCC_CRS_IT_SYNCWARN  SYNC warning interrupt
  *              @arg @ref RCC_CRS_IT_ERR  Synchronization or trimming error interrupt
  *              @arg @ref RCC_CRS_IT_ESYNC  Expected SYNC interrupt
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  */
#define __HAL_RCC_CRS_GET_IT_SOURCE(__INTERRUPT__) ((READ_BIT(CRS->CR, (__INTERRUPT__)) != 0U) ? SET : RESET)

/** @brief  Clear the CRS interrupt pending bits
  * @param  __INTERRUPT__ specifies the interrupt pending bit to clear.
  *         This parameter can be any combination of the following values:
  *              @arg @ref RCC_CRS_IT_SYNCOK  SYNC event OK interrupt
  *              @arg @ref RCC_CRS_IT_SYNCWARN  SYNC warning interrupt
  *              @arg @ref RCC_CRS_IT_ERR  Synchronization or trimming error interrupt
  *              @arg @ref RCC_CRS_IT_ESYNC  Expected SYNC interrupt
  *              @arg @ref RCC_CRS_IT_TRIMOVF  Trimming overflow or underflow interrupt
  *              @arg @ref RCC_CRS_IT_SYNCERR  SYNC error interrupt
  *              @arg @ref RCC_CRS_IT_SYNCMISS  SYNC missed interrupt
  */
/* CRS IT Error Mask */
#define RCC_CRS_IT_ERROR_MASK (RCC_CRS_IT_TRIMOVF | RCC_CRS_IT_SYNCERR | RCC_CRS_IT_SYNCMISS)

#define __HAL_RCC_CRS_CLEAR_IT(__INTERRUPT__) do { if(((__INTERRUPT__) & RCC_CRS_IT_ERROR_MASK) != 0U) { WRITE_REG(CRS->ICR, CRS_ICR_ERRC | ((__INTERRUPT__) & ~RCC_CRS_IT_ERROR_MASK)); } else { WRITE_REG(CRS->ICR, (__INTERRUPT__)); } } while(0)
# 1163 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_rcc_ex.h"

/**
  * @brief  Check whether the specified CRS flag is set or not.
  * @param  __FLAG__ specifies the flag to check.
  *          This parameter can be one of the following values:
  *              @arg @ref RCC_CRS_FLAG_SYNCOK  SYNC event OK
  *              @arg @ref RCC_CRS_FLAG_SYNCWARN  SYNC warning
  *              @arg @ref RCC_CRS_FLAG_ERR  Error
  *              @arg @ref RCC_CRS_FLAG_ESYNC  Expected SYNC
  *              @arg @ref RCC_CRS_FLAG_TRIMOVF  Trimming overflow or underflow
  *              @arg @ref RCC_CRS_FLAG_SYNCERR  SYNC error
  *              @arg @ref RCC_CRS_FLAG_SYNCMISS  SYNC missed
  * @retval The new state of _FLAG_ (TRUE or FALSE).
  */
#define __HAL_RCC_CRS_GET_FLAG(__FLAG__) (READ_BIT(CRS->ISR, (__FLAG__)) == (__FLAG__))

/**
  * @brief  Clear the CRS specified FLAG.
  * @param __FLAG__ specifies the flag to clear.
  *          This parameter can be one of the following values:
  *              @arg @ref RCC_CRS_FLAG_SYNCOK  SYNC event OK
  *              @arg @ref RCC_CRS_FLAG_SYNCWARN  SYNC warning
  *              @arg @ref RCC_CRS_FLAG_ERR  Error
  *              @arg @ref RCC_CRS_FLAG_ESYNC  Expected SYNC
  *              @arg @ref RCC_CRS_FLAG_TRIMOVF  Trimming overflow or underflow
  *              @arg @ref RCC_CRS_FLAG_SYNCERR  SYNC error
  *              @arg @ref RCC_CRS_FLAG_SYNCMISS  SYNC missed
  * @note RCC_CRS_FLAG_ERR clears RCC_CRS_FLAG_TRIMOVF, RCC_CRS_FLAG_SYNCERR, RCC_CRS_FLAG_SYNCMISS and consequently RCC_CRS_FLAG_ERR
  * @retval None
  */

/* CRS Flag Error Mask */
#define RCC_CRS_FLAG_ERROR_MASK (RCC_CRS_FLAG_TRIMOVF | RCC_CRS_FLAG_SYNCERR | RCC_CRS_FLAG_SYNCMISS)

#define __HAL_RCC_CRS_CLEAR_FLAG(__FLAG__) do { if(((__FLAG__) & RCC_CRS_FLAG_ERROR_MASK) != 0U) { WRITE_REG(CRS->ICR, CRS_ICR_ERRC | ((__FLAG__) & ~RCC_CRS_FLAG_ERROR_MASK)); } else { WRITE_REG(CRS->ICR, (__FLAG__)); } } while(0)
# 1207 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_rcc_ex.h"


/**
  * @}
  */

/** @defgroup RCCEx_CRS_Extended_Features RCCEx CRS Extended Features
  * @{
  */
/**
  * @brief  Enable the oscillator clock for frequency error counter.
  * @note   when the CEN bit is set the CRS_CFGR register becomes write-protected.
  * @retval None
  */
#define __HAL_RCC_CRS_FREQ_ERROR_COUNTER_ENABLE() SET_BIT(CRS->CR, CRS_CR_CEN)

/**
  * @brief  Disable the oscillator clock for frequency error counter.
  * @retval None
  */
#define __HAL_RCC_CRS_FREQ_ERROR_COUNTER_DISABLE() CLEAR_BIT(CRS->CR, CRS_CR_CEN)

/**
  * @brief  Enable the automatic hardware adjustment of TRIM bits.
  * @note   When the AUTOTRIMEN bit is set the CRS_CFGR register becomes write-protected.
  * @retval None
  */
#define __HAL_RCC_CRS_AUTOMATIC_CALIB_ENABLE() SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN)

/**
  * @brief  Enable or disable the automatic hardware adjustment of TRIM bits.
  * @retval None
  */
#define __HAL_RCC_CRS_AUTOMATIC_CALIB_DISABLE() CLEAR_BIT(CRS->CR, CRS_CR_AUTOTRIMEN)

/**
  * @brief  Macro to calculate reload value to be set in CRS register according to target and sync frequencies
  * @note   The RELOAD value should be selected according to the ratio between the target frequency and the frequency
  *             of the synchronization source after prescaling. It is then decreased by one in order to
  *             reach the expected synchronization on the zero value. The formula is the following:
  *             RELOAD = (fTARGET / fSYNC) -1
  * @param  __FTARGET__ Target frequency (value in Hz)
  * @param  __FSYNC__ Synchronization signal frequency (value in Hz)
  * @retval None
  */
#define __HAL_RCC_CRS_RELOADVALUE_CALCULATE(__FTARGET__,__FSYNC__) (((__FTARGET__) / (__FSYNC__)) - 1U)

/**
  * @}
  */

/**
  * @}
  */

/* Exported functions --------------------------------------------------------*/
/** @addtogroup RCCEx_Exported_Functions
  * @{
  */

/** @addtogroup RCCEx_Exported_Functions_Group1
  * @{
  */

HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit);
void              HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit);
uint32_t          HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk);

/**
  * @}
  */

/** @addtogroup RCCEx_Exported_Functions_Group2
  * @{
  */

void              HAL_RCCEx_EnableLSECSS(void);
void              HAL_RCCEx_DisableLSECSS(void);
void              HAL_RCCEx_EnableLSECSS_IT(void);
void              HAL_RCCEx_LSECSS_IRQHandler(void);
void              HAL_RCCEx_LSECSS_Callback(void);
void              HAL_RCCEx_EnableLSCO(uint32_t LSCOSource);
void              HAL_RCCEx_DisableLSCO(void);

/**
  * @}
  */

/** @addtogroup RCCEx_Exported_Functions_Group3
  * @{
  */

void              HAL_RCCEx_CRSConfig(RCC_CRSInitTypeDef *pInit);
void              HAL_RCCEx_CRSSoftwareSynchronizationGenerate(void);
void              HAL_RCCEx_CRSGetSynchronizationInfo(RCC_CRSSynchroInfoTypeDef *pSynchroInfo);
uint32_t          HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout);
void              HAL_RCCEx_CRS_IRQHandler(void);
void              HAL_RCCEx_CRS_SyncOkCallback(void);
void              HAL_RCCEx_CRS_SyncWarnCallback(void);
void              HAL_RCCEx_CRS_ExpectedSyncCallback(void);
void              HAL_RCCEx_CRS_ErrorCallback(uint32_t Error);

/**
  * @}
  */

/**
  * @}
  */

/* Private macros ------------------------------------------------------------*/
/** @addtogroup RCCEx_Private_Macros
  * @{
  */

#define IS_RCC_LSCOSOURCE(__SOURCE__) (((__SOURCE__) == RCC_LSCOSOURCE_LSI) || ((__SOURCE__) == RCC_LSCOSOURCE_LSE))


# 1371 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_rcc_ex.h"

#define IS_RCC_PERIPHCLOCK(__SELECTION__) ((((__SELECTION__) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1) || (((__SELECTION__) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2) || (((__SELECTION__) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3) || (((__SELECTION__) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4) || (((__SELECTION__) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5) || (((__SELECTION__) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1) || (((__SELECTION__) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1) || (((__SELECTION__) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2) || (((__SELECTION__) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3) || (((__SELECTION__) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4) || (((__SELECTION__) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1) || (((__SELECTION__) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) || (((__SELECTION__) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) || (((__SELECTION__) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN) || (((__SELECTION__) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB) || (((__SELECTION__) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG) || (((__SELECTION__) & RCC_PERIPHCLK_ADC12) == RCC_PERIPHCLK_ADC12) || (((__SELECTION__) & RCC_PERIPHCLK_ADC345) == RCC_PERIPHCLK_ADC345) || (((__SELECTION__) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI) || (((__SELECTION__) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
# 1393 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_rcc_ex.h"

# 1483 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_rcc_ex.h"

#define IS_RCC_USART1CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_USART1CLKSOURCE_PCLK2) || ((__SOURCE__) == RCC_USART1CLKSOURCE_SYSCLK) || ((__SOURCE__) == RCC_USART1CLKSOURCE_LSE) || ((__SOURCE__) == RCC_USART1CLKSOURCE_HSI))





#define IS_RCC_USART2CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_USART2CLKSOURCE_PCLK1) || ((__SOURCE__) == RCC_USART2CLKSOURCE_SYSCLK) || ((__SOURCE__) == RCC_USART2CLKSOURCE_LSE) || ((__SOURCE__) == RCC_USART2CLKSOURCE_HSI))





#define IS_RCC_USART3CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_USART3CLKSOURCE_PCLK1) || ((__SOURCE__) == RCC_USART3CLKSOURCE_SYSCLK) || ((__SOURCE__) == RCC_USART3CLKSOURCE_LSE) || ((__SOURCE__) == RCC_USART3CLKSOURCE_HSI))






#define IS_RCC_UART4CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_UART4CLKSOURCE_PCLK1) || ((__SOURCE__) == RCC_UART4CLKSOURCE_SYSCLK) || ((__SOURCE__) == RCC_UART4CLKSOURCE_LSE) || ((__SOURCE__) == RCC_UART4CLKSOURCE_HSI))







#define IS_RCC_UART5CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_UART5CLKSOURCE_PCLK1) || ((__SOURCE__) == RCC_UART5CLKSOURCE_SYSCLK) || ((__SOURCE__) == RCC_UART5CLKSOURCE_LSE) || ((__SOURCE__) == RCC_UART5CLKSOURCE_HSI))







#define IS_RCC_LPUART1CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_LPUART1CLKSOURCE_PCLK1) || ((__SOURCE__) == RCC_LPUART1CLKSOURCE_SYSCLK) || ((__SOURCE__) == RCC_LPUART1CLKSOURCE_LSE) || ((__SOURCE__) == RCC_LPUART1CLKSOURCE_HSI))





#define IS_RCC_I2C1CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_I2C1CLKSOURCE_PCLK1) || ((__SOURCE__) == RCC_I2C1CLKSOURCE_SYSCLK)|| ((__SOURCE__) == RCC_I2C1CLKSOURCE_HSI))




#define IS_RCC_I2C2CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_I2C2CLKSOURCE_PCLK1) || ((__SOURCE__) == RCC_I2C2CLKSOURCE_SYSCLK)|| ((__SOURCE__) == RCC_I2C2CLKSOURCE_HSI))




#define IS_RCC_I2C3CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_I2C3CLKSOURCE_PCLK1) || ((__SOURCE__) == RCC_I2C3CLKSOURCE_SYSCLK)|| ((__SOURCE__) == RCC_I2C3CLKSOURCE_HSI))






#define IS_RCC_I2C4CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_I2C4CLKSOURCE_PCLK1) || ((__SOURCE__) == RCC_I2C4CLKSOURCE_SYSCLK)|| ((__SOURCE__) == RCC_I2C4CLKSOURCE_HSI))






#define IS_RCC_LPTIM1CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_LPTIM1CLKSOURCE_PCLK1) || ((__SOURCE__) == RCC_LPTIM1CLKSOURCE_LSI) || ((__SOURCE__) == RCC_LPTIM1CLKSOURCE_HSI) || ((__SOURCE__) == RCC_LPTIM1CLKSOURCE_LSE))






#define IS_RCC_SAI1CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_SAI1CLKSOURCE_SYSCLK) || ((__SOURCE__) == RCC_SAI1CLKSOURCE_PLL) || ((__SOURCE__) == RCC_SAI1CLKSOURCE_EXT) || ((__SOURCE__) == RCC_SAI1CLKSOURCE_HSI))






#define IS_RCC_I2SCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_I2SCLKSOURCE_SYSCLK) || ((__SOURCE__) == RCC_I2SCLKSOURCE_PLL) || ((__SOURCE__) == RCC_I2SCLKSOURCE_EXT) || ((__SOURCE__) == RCC_I2SCLKSOURCE_HSI))






#define IS_RCC_FDCANCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_FDCANCLKSOURCE_HSE) || ((__SOURCE__) == RCC_FDCANCLKSOURCE_PLL) || ((__SOURCE__) == RCC_FDCANCLKSOURCE_PCLK1))





#define IS_RCC_RNGCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_RNGCLKSOURCE_HSI48) || ((__SOURCE__) == RCC_RNGCLKSOURCE_PLL))




#define IS_RCC_USBCLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_USBCLKSOURCE_HSI48) || ((__SOURCE__) == RCC_USBCLKSOURCE_PLL))





#define IS_RCC_ADC12CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_ADC12CLKSOURCE_NONE) || ((__SOURCE__) == RCC_ADC12CLKSOURCE_PLL) || ((__SOURCE__) == RCC_ADC12CLKSOURCE_SYSCLK))





#define IS_RCC_ADC345CLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_ADC345CLKSOURCE_NONE) || ((__SOURCE__) == RCC_ADC345CLKSOURCE_PLL) || ((__SOURCE__) == RCC_ADC345CLKSOURCE_SYSCLK))







#define IS_RCC_QSPICLKSOURCE(__SOURCE__) (((__SOURCE__) == RCC_QSPICLKSOURCE_HSI) || ((__SOURCE__) == RCC_QSPICLKSOURCE_SYSCLK)|| ((__SOURCE__) == RCC_QSPICLKSOURCE_PLL))






#define IS_RCC_CRS_SYNC_SOURCE(__SOURCE__) (((__SOURCE__) == RCC_CRS_SYNC_SOURCE_GPIO) || ((__SOURCE__) == RCC_CRS_SYNC_SOURCE_LSE) || ((__SOURCE__) == RCC_CRS_SYNC_SOURCE_USB))



#define IS_RCC_CRS_SYNC_DIV(__DIV__) (((__DIV__) == RCC_CRS_SYNC_DIV1) || ((__DIV__) == RCC_CRS_SYNC_DIV2) || ((__DIV__) == RCC_CRS_SYNC_DIV4) || ((__DIV__) == RCC_CRS_SYNC_DIV8) || ((__DIV__) == RCC_CRS_SYNC_DIV16) || ((__DIV__) == RCC_CRS_SYNC_DIV32) || ((__DIV__) == RCC_CRS_SYNC_DIV64) || ((__DIV__) == RCC_CRS_SYNC_DIV128))




#define IS_RCC_CRS_SYNC_POLARITY(__POLARITY__) (((__POLARITY__) == RCC_CRS_SYNC_POLARITY_RISING) || ((__POLARITY__) == RCC_CRS_SYNC_POLARITY_FALLING))


#define IS_RCC_CRS_RELOADVALUE(__VALUE__) (((__VALUE__) <= 0xFFFFU))

#define IS_RCC_CRS_ERRORLIMIT(__VALUE__) (((__VALUE__) <= 0xFFU))

#define IS_RCC_CRS_HSI48CALIBRATION(__VALUE__) (((__VALUE__) <= 0x3FU))

#define IS_RCC_CRS_FREQERRORDIR(__DIR__) (((__DIR__) == RCC_CRS_FREQERRORDIR_UP) || ((__DIR__) == RCC_CRS_FREQERRORDIR_DOWN))


/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */







# 3345 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_rcc.h" 2

/* Exported functions --------------------------------------------------------*/
/** @addtogroup RCC_Exported_Functions
  * @{
  */


/** @addtogroup RCC_Exported_Functions_Group1
  * @{
  */

/* Initialization and de-initialization functions  ******************************/
HAL_StatusTypeDef HAL_RCC_DeInit(void);
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct);
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct, uint32_t FLatency);

/**
  * @}
  */

/** @addtogroup RCC_Exported_Functions_Group2
  * @{
  */

/* Peripheral Control functions  ************************************************/
void              HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv);
void              HAL_RCC_EnableCSS(void);
void              HAL_RCC_EnableLSECSS(void);
void              HAL_RCC_DisableLSECSS(void);
uint32_t          HAL_RCC_GetSysClockFreq(void);
uint32_t          HAL_RCC_GetHCLKFreq(void);
uint32_t          HAL_RCC_GetPCLK1Freq(void);
uint32_t          HAL_RCC_GetPCLK2Freq(void);
void              HAL_RCC_GetOscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct);
void              HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct, uint32_t *pFLatency);
/* CSS NMI IRQ handler */
void              HAL_RCC_NMI_IRQHandler(void);
/* User Callbacks in non blocking mode (IT mode) */
void              HAL_RCC_CSSCallback(void);

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */







# 213 "Core/Inc/stm32g4xx_hal_conf.h" 2



# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_gpio.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_gpio.h
  * @author  MCD Application Team
  * @brief   Header file of GPIO HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_GPIO_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @defgroup GPIO GPIO
  * @brief GPIO HAL module driver
  * @{
  */

/* Exported types ------------------------------------------------------------*/

/** @defgroup GPIO_Exported_Types GPIO Exported Types
  * @{
  */
/**
  * @brief   GPIO Init structure definition
  */
typedef struct
{
  uint32_t Pin;        /*!< Specifies the GPIO pins to be configured.
                           This parameter can be any value of @ref GPIO_pins */

  uint32_t Mode;       /*!< Specifies the operating mode for the selected pins.
                           This parameter can be a value of @ref GPIO_mode */

  uint32_t Pull;       /*!< Specifies the Pull-up or Pull-Down activation for the selected pins.
                           This parameter can be a value of @ref GPIO_pull */

  uint32_t Speed;      /*!< Specifies the speed for the selected pins.
                           This parameter can be a value of @ref GPIO_speed */

  uint32_t Alternate;  /*!< Peripheral to be connected to the selected pins
                            This parameter can be a value of @ref GPIOEx_Alternate_function_selection */
} GPIO_InitTypeDef;

/**
  * @brief  GPIO Bit SET and Bit RESET enumeration
  */
typedef enum
{
  GPIO_PIN_RESET = 0U,
  GPIO_PIN_SET
} GPIO_PinState;
/**
  * @}
  */

/* Exported constants --------------------------------------------------------*/
/** @defgroup GPIO_Exported_Constants GPIO Exported Constants
  * @{
  */
/** @defgroup GPIO_pins GPIO pins
  * @{
  */
#define GPIO_PIN_0 ((uint16_t)0x0001)
#define GPIO_PIN_1 ((uint16_t)0x0002)
#define GPIO_PIN_2 ((uint16_t)0x0004)
#define GPIO_PIN_3 ((uint16_t)0x0008)
#define GPIO_PIN_4 ((uint16_t)0x0010)
#define GPIO_PIN_5 ((uint16_t)0x0020)
#define GPIO_PIN_6 ((uint16_t)0x0040)
#define GPIO_PIN_7 ((uint16_t)0x0080)
#define GPIO_PIN_8 ((uint16_t)0x0100)
#define GPIO_PIN_9 ((uint16_t)0x0200)
#define GPIO_PIN_10 ((uint16_t)0x0400)
#define GPIO_PIN_11 ((uint16_t)0x0800)
#define GPIO_PIN_12 ((uint16_t)0x1000)
#define GPIO_PIN_13 ((uint16_t)0x2000)
#define GPIO_PIN_14 ((uint16_t)0x4000)
#define GPIO_PIN_15 ((uint16_t)0x8000)
#define GPIO_PIN_All ((uint16_t)0xFFFF)

#define GPIO_PIN_MASK (0x0000FFFFU)
/**
  * @}
  */

/** @defgroup GPIO_mode GPIO mode
  * @brief GPIO Configuration Mode
  *        Elements values convention: 0x00WX00YZ
  *           - W  : EXTI trigger detection on 3 bits
  *           - X  : EXTI mode (IT or Event) on 2 bits
  *           - Y  : Output type (Push Pull or Open Drain) on 1 bit
  *           - Z  : GPIO mode (Input, Output, Alternate or Analog) on 2 bits
  * @{
  */ 
#define GPIO_MODE_INPUT MODE_INPUT
#define GPIO_MODE_OUTPUT_PP (MODE_OUTPUT | OUTPUT_PP)
#define GPIO_MODE_OUTPUT_OD (MODE_OUTPUT | OUTPUT_OD)
#define GPIO_MODE_AF_PP (MODE_AF | OUTPUT_PP)
#define GPIO_MODE_AF_OD (MODE_AF | OUTPUT_OD)

#define GPIO_MODE_ANALOG MODE_ANALOG
    
#define GPIO_MODE_IT_RISING (MODE_INPUT | EXTI_IT | TRIGGER_RISING)
#define GPIO_MODE_IT_FALLING (MODE_INPUT | EXTI_IT | TRIGGER_FALLING)
#define GPIO_MODE_IT_RISING_FALLING (MODE_INPUT | EXTI_IT | TRIGGER_RISING | TRIGGER_FALLING)
 
#define GPIO_MODE_EVT_RISING (MODE_INPUT | EXTI_EVT | TRIGGER_RISING)
#define GPIO_MODE_EVT_FALLING (MODE_INPUT | EXTI_EVT | TRIGGER_FALLING)
#define GPIO_MODE_EVT_RISING_FALLING (MODE_INPUT | EXTI_EVT | TRIGGER_RISING | TRIGGER_FALLING)
/**
  * @}
  */

/** @defgroup GPIO_speed GPIO speed
  * @brief GPIO Output Maximum frequency
  * @{
  */
#define GPIO_SPEED_FREQ_LOW (0x00000000U)
#define GPIO_SPEED_FREQ_MEDIUM (0x00000001U)
#define GPIO_SPEED_FREQ_HIGH (0x00000002U)
#define GPIO_SPEED_FREQ_VERY_HIGH (0x00000003U)
/**
  * @}
  */

/** @defgroup GPIO_pull GPIO pull
  * @brief GPIO Pull-Up or Pull-Down Activation
  * @{
  */
#define GPIO_NOPULL (0x00000000U)
#define GPIO_PULLUP (0x00000001U)
#define GPIO_PULLDOWN (0x00000002U)
/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/** @defgroup GPIO_Exported_Macros GPIO Exported Macros
  * @{
  */

/**
  * @brief  Check whether the specified EXTI line flag is set or not.
  * @param  __EXTI_LINE__ specifies the EXTI line flag to check.
  *         This parameter can be GPIO_PIN_x where x can be(0..15)
  * @retval The new state of __EXTI_LINE__ (SET or RESET).
  */
#define __HAL_GPIO_EXTI_GET_FLAG(__EXTI_LINE__) (EXTI->PR1 & (__EXTI_LINE__))

/**
  * @brief  Clear the EXTI's line pending flags.
  * @param  __EXTI_LINE__ specifies the EXTI lines flags to clear.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15)
  * @retval None
  */
#define __HAL_GPIO_EXTI_CLEAR_FLAG(__EXTI_LINE__) (EXTI->PR1 = (__EXTI_LINE__))

/**
  * @brief  Check whether the specified EXTI line is asserted or not.
  * @param  __EXTI_LINE__ specifies the EXTI line to check.
  *          This parameter can be GPIO_PIN_x where x can be(0..15)
  * @retval The new state of __EXTI_LINE__ (SET or RESET).
  */
#define __HAL_GPIO_EXTI_GET_IT(__EXTI_LINE__) (EXTI->PR1 & (__EXTI_LINE__))

/**
  * @brief  Clear the EXTI's line pending bits.
  * @param  __EXTI_LINE__ specifies the EXTI lines to clear.
  *          This parameter can be any combination of GPIO_PIN_x where x can be (0..15)
  * @retval None
  */
#define __HAL_GPIO_EXTI_CLEAR_IT(__EXTI_LINE__) (EXTI->PR1 = (__EXTI_LINE__))

/**
  * @brief  Generate a Software interrupt on selected EXTI line.
  * @param  __EXTI_LINE__ specifies the EXTI line to check.
  *          This parameter can be GPIO_PIN_x where x can be(0..15)
  * @retval None
  */
#define __HAL_GPIO_EXTI_GENERATE_SWIT(__EXTI_LINE__) (EXTI->SWIER1 |= (__EXTI_LINE__))

/**
  * @}
  */

/* Private macros ------------------------------------------------------------*/
/** @defgroup GPIO_Private_Constants GPIO Private Constants
  * @{
  */
#define GPIO_MODE_Pos 0U
#define GPIO_MODE (0x3UL << GPIO_MODE_Pos)
#define MODE_INPUT (0x0UL << GPIO_MODE_Pos)
#define MODE_OUTPUT (0x1UL << GPIO_MODE_Pos)
#define MODE_AF (0x2UL << GPIO_MODE_Pos)
#define MODE_ANALOG (0x3UL << GPIO_MODE_Pos)
#define OUTPUT_TYPE_Pos 4U
#define OUTPUT_TYPE (0x1UL << OUTPUT_TYPE_Pos)
#define OUTPUT_PP (0x0UL << OUTPUT_TYPE_Pos)
#define OUTPUT_OD (0x1UL << OUTPUT_TYPE_Pos)
#define EXTI_MODE_Pos 16U
#define EXTI_MODE (0x3UL << EXTI_MODE_Pos)
#define EXTI_IT (0x1UL << EXTI_MODE_Pos)
#define EXTI_EVT (0x2UL << EXTI_MODE_Pos)
#define TRIGGER_MODE_Pos 20U
#define TRIGGER_MODE (0x7UL << TRIGGER_MODE_Pos)
#define TRIGGER_RISING (0x1UL << TRIGGER_MODE_Pos)
#define TRIGGER_FALLING (0x2UL << TRIGGER_MODE_Pos)
/**
  * @}
  */

/** @defgroup GPIO_Private_Macros GPIO Private Macros
  * @{
  */
#define IS_GPIO_PIN_ACTION(ACTION) (((ACTION) == GPIO_PIN_RESET) || ((ACTION) == GPIO_PIN_SET))

#define IS_GPIO_PIN(__PIN__) ((((uint32_t)(__PIN__) & GPIO_PIN_MASK) != 0x00U) && (((uint32_t)(__PIN__) & ~GPIO_PIN_MASK) == 0x00U))


#define IS_GPIO_MODE(__MODE__) (((__MODE__) == GPIO_MODE_INPUT) || ((__MODE__) == GPIO_MODE_OUTPUT_PP) || ((__MODE__) == GPIO_MODE_OUTPUT_OD) || ((__MODE__) == GPIO_MODE_AF_PP) || ((__MODE__) == GPIO_MODE_AF_OD) || ((__MODE__) == GPIO_MODE_IT_RISING) || ((__MODE__) == GPIO_MODE_IT_FALLING) || ((__MODE__) == GPIO_MODE_IT_RISING_FALLING) || ((__MODE__) == GPIO_MODE_EVT_RISING) || ((__MODE__) == GPIO_MODE_EVT_FALLING) || ((__MODE__) == GPIO_MODE_EVT_RISING_FALLING) || ((__MODE__) == GPIO_MODE_ANALOG))
# 257 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_gpio.h"

#define IS_GPIO_SPEED(__SPEED__) (((__SPEED__) == GPIO_SPEED_FREQ_LOW) || ((__SPEED__) == GPIO_SPEED_FREQ_MEDIUM) || ((__SPEED__) == GPIO_SPEED_FREQ_HIGH) || ((__SPEED__) == GPIO_SPEED_FREQ_VERY_HIGH))




#define IS_GPIO_PULL(__PULL__) (((__PULL__) == GPIO_NOPULL) || ((__PULL__) == GPIO_PULLUP) || ((__PULL__) == GPIO_PULLDOWN))


/**
  * @}
  */

/* Include GPIO HAL Extended module */
# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_gpio_ex.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_gpio_ex.h
  * @author  MCD Application Team
  * @brief   Header file of GPIO HAL Extended module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */


/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_GPIO_EX_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @defgroup GPIOEx GPIOEx
  * @brief GPIO Extended HAL module driver
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/
/** @defgroup GPIOEx_Exported_Constants GPIOEx Exported Constants
  * @{
  */

/** @defgroup GPIOEx_Alternate_function_selection GPIOEx Alternate function selection
  * @{
  */

/**
  * @brief   AF 0 selection
  */
#define GPIO_AF0_RTC_50Hz ((uint8_t)0x00)
#define GPIO_AF0_MCO ((uint8_t)0x00)
#define GPIO_AF0_SWJ ((uint8_t)0x00)
#define GPIO_AF0_TRACE ((uint8_t)0x00)

/**
  * @brief   AF 1 selection
  */
#define GPIO_AF1_TIM2 ((uint8_t)0x01)

#define GPIO_AF1_TIM5 ((uint8_t)0x01)

#define GPIO_AF1_TIM16 ((uint8_t)0x01)
#define GPIO_AF1_TIM17 ((uint8_t)0x01)
#define GPIO_AF1_TIM17_COMP1 ((uint8_t)0x01)
#define GPIO_AF1_TIM15 ((uint8_t)0x01)
#define GPIO_AF1_LPTIM1 ((uint8_t)0x01)
#define GPIO_AF1_IR ((uint8_t)0x01)

/**
  * @brief   AF 2 selection
  */
#define GPIO_AF2_TIM1 ((uint8_t)0x02)
#define GPIO_AF2_TIM2 ((uint8_t)0x02)
#define GPIO_AF2_TIM3 ((uint8_t)0x02)
#define GPIO_AF2_TIM4 ((uint8_t)0x02)

#define GPIO_AF2_TIM5 ((uint8_t)0x02)

#define GPIO_AF2_TIM8 ((uint8_t)0x02)
#define GPIO_AF2_TIM15 ((uint8_t)0x02)
#define GPIO_AF2_TIM16 ((uint8_t)0x02)

#define GPIO_AF2_TIM20 ((uint8_t)0x02)

#define GPIO_AF2_TIM1_COMP1 ((uint8_t)0x02)
#define GPIO_AF2_TIM15_COMP1 ((uint8_t)0x02)
#define GPIO_AF2_TIM16_COMP1 ((uint8_t)0x02)

#define GPIO_AF2_TIM20_COMP1 ((uint8_t)0x02)
#define GPIO_AF2_TIM20_COMP2 ((uint8_t)0x02)

#define GPIO_AF2_I2C3 ((uint8_t)0x02)
#define GPIO_AF2_COMP1 ((uint8_t)0x02)

/**
  * @brief   AF 3 selection
  */
#define GPIO_AF3_TIM15 ((uint8_t)0x03)

#define GPIO_AF3_TIM20 ((uint8_t)0x03)

#define GPIO_AF3_UCPD1 ((uint8_t)0x03)
#define GPIO_AF3_I2C3 ((uint8_t)0x03)

#define GPIO_AF3_I2C4 ((uint8_t)0x03)





#define GPIO_AF3_QUADSPI ((uint8_t)0x03)

#define GPIO_AF3_TIM8 ((uint8_t)0x03)
#define GPIO_AF3_SAI1 ((uint8_t)0x03)
#define GPIO_AF3_COMP3 ((uint8_t)0x03)

/**
  * @brief   AF 4 selection
  */
#define GPIO_AF4_TIM1 ((uint8_t)0x04)
#define GPIO_AF4_TIM8 ((uint8_t)0x04)
#define GPIO_AF4_TIM16 ((uint8_t)0x04)
#define GPIO_AF4_TIM17 ((uint8_t)0x04)
#define GPIO_AF4_TIM8_COMP1 ((uint8_t)0x04)
#define GPIO_AF4_I2C1 ((uint8_t)0x04)
#define GPIO_AF4_I2C2 ((uint8_t)0x04)
#define GPIO_AF4_I2C3 ((uint8_t)0x04)

#define GPIO_AF4_I2C4 ((uint8_t)0x04)


/**
  * @brief   AF 5 selection
  */
#define GPIO_AF5_SPI1 ((uint8_t)0x05)
#define GPIO_AF5_SPI2 ((uint8_t)0x05)

#define GPIO_AF5_SPI4 ((uint8_t)0x05)

#define GPIO_AF5_IR ((uint8_t)0x05)
#define GPIO_AF5_TIM8 ((uint8_t)0x05)
#define GPIO_AF5_TIM8_COMP1 ((uint8_t)0x05)
#define GPIO_AF5_UART4 ((uint8_t)0x05)

#define GPIO_AF5_UART5 ((uint8_t)0x05)

#define GPIO_AF5_I2S2ext ((uint8_t)0x05)

/**
  * @brief   AF 6 selection
  */
#define GPIO_AF6_SPI2 ((uint8_t)0x06)
#define GPIO_AF6_SPI3 ((uint8_t)0x06)
#define GPIO_AF6_TIM1 ((uint8_t)0x06)

#define GPIO_AF6_TIM5 ((uint8_t)0x06)

#define GPIO_AF6_TIM8 ((uint8_t)0x06)

#define GPIO_AF6_TIM20 ((uint8_t)0x06)

#define GPIO_AF6_TIM1_COMP1 ((uint8_t)0x06)
#define GPIO_AF6_TIM1_COMP2 ((uint8_t)0x06)
#define GPIO_AF6_TIM8_COMP2 ((uint8_t)0x06)
#define GPIO_AF6_IR ((uint8_t)0x06)
#define GPIO_AF6_I2S3ext ((uint8_t)0x06)

/**
  * @brief   AF 7 selection
  */
#define GPIO_AF7_USART1 ((uint8_t)0x07)
#define GPIO_AF7_USART2 ((uint8_t)0x07)
#define GPIO_AF7_USART3 ((uint8_t)0x07)

#define GPIO_AF7_COMP5 ((uint8_t)0x07)


#define GPIO_AF7_COMP6 ((uint8_t)0x07)


#define GPIO_AF7_COMP7 ((uint8_t)0x07)


/**
  * @brief   AF 8 selection
  */
#define GPIO_AF8_COMP1 ((uint8_t)0x08)
#define GPIO_AF8_COMP2 ((uint8_t)0x08)
#define GPIO_AF8_COMP3 ((uint8_t)0x08)
#define GPIO_AF8_COMP4 ((uint8_t)0x08)

#define GPIO_AF8_COMP5 ((uint8_t)0x08)


#define GPIO_AF8_COMP6 ((uint8_t)0x08)


#define GPIO_AF8_COMP7 ((uint8_t)0x08)

#define GPIO_AF8_I2C3 ((uint8_t)0x08)

#define GPIO_AF8_I2C4 ((uint8_t)0x08)

#define GPIO_AF8_LPUART1 ((uint8_t)0x08)
#define GPIO_AF8_UART4 ((uint8_t)0x08)

#define GPIO_AF8_UART5 ((uint8_t)0x08)


/**
  * @brief   AF 9 selection
  */
#define GPIO_AF9_TIM1 ((uint8_t)0x09)
#define GPIO_AF9_TIM8 ((uint8_t)0x09)
#define GPIO_AF9_TIM15 ((uint8_t)0x09)
#define GPIO_AF9_TIM1_COMP1 ((uint8_t)0x09)
#define GPIO_AF9_TIM8_COMP1 ((uint8_t)0x09)
#define GPIO_AF9_TIM15_COMP1 ((uint8_t)0x09)
#define GPIO_AF9_FDCAN1 ((uint8_t)0x09)

#define GPIO_AF9_FDCAN2 ((uint8_t)0x09)


/**
  * @brief   AF 10 selection
  */
#define GPIO_AF10_TIM2 ((uint8_t)0x0A)
#define GPIO_AF10_TIM3 ((uint8_t)0x0A)
#define GPIO_AF10_TIM4 ((uint8_t)0x0A)
#define GPIO_AF10_TIM8 ((uint8_t)0x0A)
#define GPIO_AF10_TIM17 ((uint8_t)0x0A)
#define GPIO_AF10_TIM8_COMP2 ((uint8_t)0x0A)
#define GPIO_AF10_TIM17_COMP1 ((uint8_t)0x0A)

#define GPIO_AF10_QUADSPI ((uint8_t)0x0A)


/**
  * @brief   AF 11 selection
  */
#define GPIO_AF11_FDCAN1 ((uint8_t)0x0B)

#define GPIO_AF11_FDCAN3 ((uint8_t)0x0B)

#define GPIO_AF11_TIM1 ((uint8_t)0x0B)
#define GPIO_AF11_TIM8 ((uint8_t)0x0B)
#define GPIO_AF11_TIM8_COMP1 ((uint8_t)0x0B)
#define GPIO_AF11_LPTIM1 ((uint8_t)0x0B)

/**
  * @brief   AF 12 selection
  */
#define GPIO_AF12_LPUART1 ((uint8_t)0x0C)
#define GPIO_AF12_TIM1 ((uint8_t)0x0C)
#define GPIO_AF12_TIM1_COMP1 ((uint8_t)0x0C)
#define GPIO_AF12_TIM1_COMP2 ((uint8_t)0x0C)




#define GPIO_AF12_FMC ((uint8_t)0x0C)

#define GPIO_AF12_SAI1 ((uint8_t)0x0C)

/**
  * @brief   AF 13 selection
  */



#define GPIO_AF13_SAI1 ((uint8_t)0x0D)

/**
  * @brief   AF 14 selection
  */
#define GPIO_AF14_TIM2 ((uint8_t)0x0E)
#define GPIO_AF14_TIM15 ((uint8_t)0x0E)
#define GPIO_AF14_UCPD1 ((uint8_t)0x0E)
#define GPIO_AF14_SAI1 ((uint8_t)0x0E)
#define GPIO_AF14_UART4 ((uint8_t)0x0E)

#define GPIO_AF14_UART5 ((uint8_t)0x0E)


/**
  * @brief   AF 15 selection
  */
#define GPIO_AF15_EVENTOUT ((uint8_t)0x0F)

#define IS_GPIO_AF(AF) ((AF) <= (uint8_t)0x0F)

/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/** @defgroup GPIOEx_Exported_Macros GPIOEx Exported Macros
  * @{
  */

/** @defgroup GPIOEx_Get_Port_Index GPIOEx Get Port Index
  * @{
  */
#define GPIO_GET_INDEX(__GPIOx__) (((__GPIOx__) == (GPIOA))? 0UL : ((__GPIOx__) == (GPIOB))? 1UL : ((__GPIOx__) == (GPIOC))? 2UL : ((__GPIOx__) == (GPIOD))? 3UL : ((__GPIOx__) == (GPIOE))? 4UL : ((__GPIOx__) == (GPIOF))? 5UL : 6UL)






/**
  * @}
  */

/**
  * @}
  */

/* Exported functions --------------------------------------------------------*/
/**
  * @}
  */

/**
  * @}
  */







# 272 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_gpio.h" 2

/* Exported functions --------------------------------------------------------*/
/** @defgroup GPIO_Exported_Functions GPIO Exported Functions
  *  @brief    GPIO Exported Functions
  * @{
  */

/** @defgroup GPIO_Exported_Functions_Group1 Initialization/de-initialization functions
  *  @brief    Initialization and Configuration functions
  * @{
  */

/* Initialization and de-initialization functions *****************************/
void              HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init);
void              HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin);

/**
  * @}
  */

/** @defgroup GPIO_Exported_Functions_Group2 IO operation functions
  *  @brief    IO operation functions
  * @{
  */

/* IO operation functions *****************************************************/
GPIO_PinState     HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);
void              HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);
void              HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);
void              HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin);
void              HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin);

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */







# 217 "Core/Inc/stm32g4xx_hal_conf.h" 2



# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_dma.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_dma.h
  * @author  MCD Application Team
  * @brief   Header file of DMA HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define __STM32G4xx_HAL_DMA_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup DMA
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/** @defgroup DMA_Exported_Types DMA Exported Types
  * @{
  */

/**
  * @brief  DMA Configuration Structure definition
  */
typedef struct
{
  uint32_t Request;                   /*!< Specifies the request selected for the specified channel.
                                           This parameter can be a value of @ref DMA_request */

  uint32_t Direction;                 /*!< Specifies if the data will be transferred from memory to peripheral,
                                           from memory to memory or from peripheral to memory.
                                           This parameter can be a value of @ref DMA_Data_transfer_direction */

  uint32_t PeriphInc;                 /*!< Specifies whether the Peripheral address register should be incremented or not.
                                           This parameter can be a value of @ref DMA_Peripheral_incremented_mode */

  uint32_t MemInc;                    /*!< Specifies whether the memory address register should be incremented or not.
                                           This parameter can be a value of @ref DMA_Memory_incremented_mode */

  uint32_t PeriphDataAlignment;       /*!< Specifies the Peripheral data width.
                                           This parameter can be a value of @ref DMA_Peripheral_data_size */

  uint32_t MemDataAlignment;          /*!< Specifies the Memory data width.
                                           This parameter can be a value of @ref DMA_Memory_data_size */

  uint32_t Mode;                      /*!< Specifies the operation mode of the DMAy Channelx.
                                           This parameter can be a value of @ref DMA_mode
                                           @note The circular buffer mode cannot be used if the memory-to-memory
                                                 data transfer is configured on the selected Channel */

  uint32_t Priority;                  /*!< Specifies the software priority for the DMAy Channelx.
                                           This parameter can be a value of @ref DMA_Priority_level */
} DMA_InitTypeDef;

/**
  * @brief  HAL DMA State structures definition
  */
typedef enum
{
  HAL_DMA_STATE_RESET             = 0x00U,  /*!< DMA not yet initialized or disabled    */
  HAL_DMA_STATE_READY             = 0x01U,  /*!< DMA initialized and ready for use      */
  HAL_DMA_STATE_BUSY              = 0x02U,  /*!< DMA process is ongoing                 */
  HAL_DMA_STATE_TIMEOUT           = 0x03U,  /*!< DMA timeout state                     */
} HAL_DMA_StateTypeDef;

/**
  * @brief  HAL DMA Error Code structure definition
  */
typedef enum
{
  HAL_DMA_FULL_TRANSFER      = 0x00U,    /*!< Full transfer     */
  HAL_DMA_HALF_TRANSFER      = 0x01U     /*!< Half Transfer     */
} HAL_DMA_LevelCompleteTypeDef;


/**
  * @brief  HAL DMA Callback ID structure definition
  */
typedef enum
{
  HAL_DMA_XFER_CPLT_CB_ID          = 0x00U,    /*!< Full transfer     */
  HAL_DMA_XFER_HALFCPLT_CB_ID      = 0x01U,    /*!< Half transfer     */
  HAL_DMA_XFER_ERROR_CB_ID         = 0x02U,    /*!< Error             */
  HAL_DMA_XFER_ABORT_CB_ID         = 0x03U,    /*!< Abort             */
  HAL_DMA_XFER_ALL_CB_ID           = 0x04U     /*!< All               */

} HAL_DMA_CallbackIDTypeDef;

/**
  * @brief  DMA handle Structure definition
  */
typedef struct __DMA_HandleTypeDef
{
  DMA_Channel_TypeDef    *Instance;                                                  /*!< Register base address                */

  DMA_InitTypeDef       Init;                                                        /*!< DMA communication parameters         */

  HAL_LockTypeDef       Lock;                                                        /*!< DMA locking object                   */

  __IO HAL_DMA_StateTypeDef  State;                                                  /*!< DMA transfer state                   */

  void                  *Parent;                                                     /*!< Parent object state                  */

  void (* XferCpltCallback)(struct __DMA_HandleTypeDef *hdma);                       /*!< DMA transfer complete callback       */

  void (* XferHalfCpltCallback)(struct __DMA_HandleTypeDef *hdma);                   /*!< DMA Half transfer complete callback  */

  void (* XferErrorCallback)(struct __DMA_HandleTypeDef *hdma);                      /*!< DMA transfer error callback          */

  void (* XferAbortCallback)(struct __DMA_HandleTypeDef *hdma);                      /*!< DMA transfer abort callback          */

  __IO uint32_t          ErrorCode;                                                  /*!< DMA Error code                       */

  DMA_TypeDef            *DmaBaseAddress;                                            /*!< DMA Channel Base Address             */

  uint32_t               ChannelIndex;                                               /*!< DMA Channel Index                    */

  DMAMUX_Channel_TypeDef           *DMAmuxChannel;                                   /*!< Register base address                */

  DMAMUX_ChannelStatus_TypeDef     *DMAmuxChannelStatus;                             /*!< DMAMUX Channels Status Base Address  */

  uint32_t                         DMAmuxChannelStatusMask;                          /*!< DMAMUX Channel Status Mask           */

  DMAMUX_RequestGen_TypeDef        *DMAmuxRequestGen;                                /*!< DMAMUX request generator Base Address */

  DMAMUX_RequestGenStatus_TypeDef  *DMAmuxRequestGenStatus;                          /*!< DMAMUX request generator Address     */

  uint32_t                         DMAmuxRequestGenStatusMask;                       /*!< DMAMUX request generator Status mask */

} DMA_HandleTypeDef;
/**
  * @}
  */

/* Exported constants --------------------------------------------------------*/

/** @defgroup DMA_Exported_Constants DMA Exported Constants
  * @{
  */

/** @defgroup DMA_Error_Code DMA Error Code
  * @{
  */
#define HAL_DMA_ERROR_NONE 0x00000000U
#define HAL_DMA_ERROR_TE 0x00000001U
#define HAL_DMA_ERROR_NO_XFER 0x00000004U
#define HAL_DMA_ERROR_TIMEOUT 0x00000020U
#define HAL_DMA_ERROR_NOT_SUPPORTED 0x00000100U
#define HAL_DMA_ERROR_SYNC 0x00000200U
#define HAL_DMA_ERROR_REQGEN 0x00000400U
/**
  * @}
  */

/** @defgroup DMA_request DMA request
  * @{
  */
#define DMA_REQUEST_MEM2MEM 0U

#define DMA_REQUEST_GENERATOR0 1U
#define DMA_REQUEST_GENERATOR1 2U
#define DMA_REQUEST_GENERATOR2 3U
#define DMA_REQUEST_GENERATOR3 4U

#define DMA_REQUEST_ADC1 5U

#define DMA_REQUEST_DAC1_CHANNEL1 6U
#define DMA_REQUEST_DAC1_CHANNEL2 7U

#define DMA_REQUEST_TIM6_UP 8U
#define DMA_REQUEST_TIM7_UP 9U

#define DMA_REQUEST_SPI1_RX 10U
#define DMA_REQUEST_SPI1_TX 11U
#define DMA_REQUEST_SPI2_RX 12U
#define DMA_REQUEST_SPI2_TX 13U
#define DMA_REQUEST_SPI3_RX 14U
#define DMA_REQUEST_SPI3_TX 15U

#define DMA_REQUEST_I2C1_RX 16U
#define DMA_REQUEST_I2C1_TX 17U
#define DMA_REQUEST_I2C2_RX 18U
#define DMA_REQUEST_I2C2_TX 19U
#define DMA_REQUEST_I2C3_RX 20U
#define DMA_REQUEST_I2C3_TX 21U

#define DMA_REQUEST_I2C4_RX 22U
#define DMA_REQUEST_I2C4_TX 23U


#define DMA_REQUEST_USART1_RX 24U
#define DMA_REQUEST_USART1_TX 25U
#define DMA_REQUEST_USART2_RX 26U
#define DMA_REQUEST_USART2_TX 27U
#define DMA_REQUEST_USART3_RX 28U
#define DMA_REQUEST_USART3_TX 29U

#define DMA_REQUEST_UART4_RX 30U
#define DMA_REQUEST_UART4_TX 31U

#define DMA_REQUEST_UART5_RX 32U
#define DMA_REQUEST_UART5_TX 33U


#define DMA_REQUEST_LPUART1_RX 34U
#define DMA_REQUEST_LPUART1_TX 35U

#define DMA_REQUEST_ADC2 36U

#define DMA_REQUEST_ADC3 37U


#define DMA_REQUEST_ADC4 38U


#define DMA_REQUEST_ADC5 39U



#define DMA_REQUEST_QUADSPI 40U



#define DMA_REQUEST_DAC2_CHANNEL1 41U


#define DMA_REQUEST_TIM1_CH1 42U
#define DMA_REQUEST_TIM1_CH2 43U
#define DMA_REQUEST_TIM1_CH3 44U
#define DMA_REQUEST_TIM1_CH4 45U
#define DMA_REQUEST_TIM1_UP 46U
#define DMA_REQUEST_TIM1_TRIG 47U
#define DMA_REQUEST_TIM1_COM 48U

#define DMA_REQUEST_TIM8_CH1 49U
#define DMA_REQUEST_TIM8_CH2 50U
#define DMA_REQUEST_TIM8_CH3 51U
#define DMA_REQUEST_TIM8_CH4 52U
#define DMA_REQUEST_TIM8_UP 53U
#define DMA_REQUEST_TIM8_TRIG 54U
#define DMA_REQUEST_TIM8_COM 55U

#define DMA_REQUEST_TIM2_CH1 56U
#define DMA_REQUEST_TIM2_CH2 57U
#define DMA_REQUEST_TIM2_CH3 58U
#define DMA_REQUEST_TIM2_CH4 59U
#define DMA_REQUEST_TIM2_UP 60U

#define DMA_REQUEST_TIM3_CH1 61U
#define DMA_REQUEST_TIM3_CH2 62U
#define DMA_REQUEST_TIM3_CH3 63U
#define DMA_REQUEST_TIM3_CH4 64U
#define DMA_REQUEST_TIM3_UP 65U
#define DMA_REQUEST_TIM3_TRIG 66U

#define DMA_REQUEST_TIM4_CH1 67U
#define DMA_REQUEST_TIM4_CH2 68U
#define DMA_REQUEST_TIM4_CH3 69U
#define DMA_REQUEST_TIM4_CH4 70U
#define DMA_REQUEST_TIM4_UP 71U


#define DMA_REQUEST_TIM5_CH1 72U
#define DMA_REQUEST_TIM5_CH2 73U
#define DMA_REQUEST_TIM5_CH3 74U
#define DMA_REQUEST_TIM5_CH4 75U
#define DMA_REQUEST_TIM5_UP 76U
#define DMA_REQUEST_TIM5_TRIG 77U


#define DMA_REQUEST_TIM15_CH1 78U
#define DMA_REQUEST_TIM15_UP 79U
#define DMA_REQUEST_TIM15_TRIG 80U
#define DMA_REQUEST_TIM15_COM 81U

#define DMA_REQUEST_TIM16_CH1 82U
#define DMA_REQUEST_TIM16_UP 83U
#define DMA_REQUEST_TIM17_CH1 84U
#define DMA_REQUEST_TIM17_UP 85U


#define DMA_REQUEST_TIM20_CH1 86U
#define DMA_REQUEST_TIM20_CH2 87U
#define DMA_REQUEST_TIM20_CH3 88U
#define DMA_REQUEST_TIM20_CH4 89U
#define DMA_REQUEST_TIM20_UP 90U


#define DMA_REQUEST_AES_IN 91U
#define DMA_REQUEST_AES_OUT 92U


#define DMA_REQUEST_TIM20_TRIG 93U
#define DMA_REQUEST_TIM20_COM 94U


# 327 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_dma.h"

#define DMA_REQUEST_DAC3_CHANNEL1 102U
#define DMA_REQUEST_DAC3_CHANNEL2 103U

#define DMA_REQUEST_DAC4_CHANNEL1 104U
#define DMA_REQUEST_DAC4_CHANNEL2 105U



#define DMA_REQUEST_SPI4_RX 106U
#define DMA_REQUEST_SPI4_TX 107U


#define DMA_REQUEST_SAI1_A 108U
#define DMA_REQUEST_SAI1_B 109U

#define DMA_REQUEST_FMAC_READ 110U
#define DMA_REQUEST_FMAC_WRITE 111U

#define DMA_REQUEST_CORDIC_READ 112U
#define DMA_REQUEST_CORDIC_WRITE 113U

#define DMA_REQUEST_UCPD1_RX 114U
#define DMA_REQUEST_UCPD1_TX 115U

/**
  * @}
  */

/** @defgroup DMA_Data_transfer_direction DMA Data transfer direction
  * @{
  */
#define DMA_PERIPH_TO_MEMORY 0x00000000U
#define DMA_MEMORY_TO_PERIPH DMA_CCR_DIR
#define DMA_MEMORY_TO_MEMORY DMA_CCR_MEM2MEM
/**
  * @}
  */

/** @defgroup DMA_Peripheral_incremented_mode DMA Peripheral incremented mode
  * @{
  */
#define DMA_PINC_ENABLE DMA_CCR_PINC
#define DMA_PINC_DISABLE 0x00000000U
/**
  * @}
  */

/** @defgroup DMA_Memory_incremented_mode DMA Memory incremented mode
  * @{
  */
#define DMA_MINC_ENABLE DMA_CCR_MINC
#define DMA_MINC_DISABLE 0x00000000U
/**
  * @}
  */

/** @defgroup DMA_Peripheral_data_size DMA Peripheral data size
  * @{
  */
#define DMA_PDATAALIGN_BYTE 0x00000000U
#define DMA_PDATAALIGN_HALFWORD DMA_CCR_PSIZE_0
#define DMA_PDATAALIGN_WORD DMA_CCR_PSIZE_1
/**
  * @}
  */

/** @defgroup DMA_Memory_data_size DMA Memory data size
  * @{
  */
#define DMA_MDATAALIGN_BYTE 0x00000000U
#define DMA_MDATAALIGN_HALFWORD DMA_CCR_MSIZE_0
#define DMA_MDATAALIGN_WORD DMA_CCR_MSIZE_1
/**
  * @}
  */

/** @defgroup DMA_mode DMA mode
  * @{
  */
#define DMA_NORMAL 0x00000000U
#define DMA_CIRCULAR DMA_CCR_CIRC
/**
  * @}
  */

/** @defgroup DMA_Priority_level DMA Priority level
  * @{
  */
#define DMA_PRIORITY_LOW 0x00000000U
#define DMA_PRIORITY_MEDIUM DMA_CCR_PL_0
#define DMA_PRIORITY_HIGH DMA_CCR_PL_1
#define DMA_PRIORITY_VERY_HIGH DMA_CCR_PL
/**
  * @}
  */


/** @defgroup DMA_interrupt_enable_definitions DMA interrupt enable definitions
  * @{
  */
#define DMA_IT_TC DMA_CCR_TCIE
#define DMA_IT_HT DMA_CCR_HTIE
#define DMA_IT_TE DMA_CCR_TEIE
/**
  * @}
  */

/** @defgroup DMA_flag_definitions DMA flag definitions
  * @{
  */
#define DMA_FLAG_GL1 0x00000001U
#define DMA_FLAG_TC1 0x00000002U
#define DMA_FLAG_HT1 0x00000004U
#define DMA_FLAG_TE1 0x00000008U
#define DMA_FLAG_GL2 0x00000010U
#define DMA_FLAG_TC2 0x00000020U
#define DMA_FLAG_HT2 0x00000040U
#define DMA_FLAG_TE2 0x00000080U
#define DMA_FLAG_GL3 0x00000100U
#define DMA_FLAG_TC3 0x00000200U
#define DMA_FLAG_HT3 0x00000400U
#define DMA_FLAG_TE3 0x00000800U
#define DMA_FLAG_GL4 0x00001000U
#define DMA_FLAG_TC4 0x00002000U
#define DMA_FLAG_HT4 0x00004000U
#define DMA_FLAG_TE4 0x00008000U
#define DMA_FLAG_GL5 0x00010000U
#define DMA_FLAG_TC5 0x00020000U
#define DMA_FLAG_HT5 0x00040000U
#define DMA_FLAG_TE5 0x00080000U
#define DMA_FLAG_GL6 0x00100000U
#define DMA_FLAG_TC6 0x00200000U
#define DMA_FLAG_HT6 0x00400000U
#define DMA_FLAG_TE6 0x00800000U

#define DMA_FLAG_GL7 0x01000000U
#define DMA_FLAG_TC7 0x02000000U
#define DMA_FLAG_HT7 0x04000000U
#define DMA_FLAG_TE7 0x08000000U


#define DMA_FLAG_GL8 0x10000000U
#define DMA_FLAG_TC8 0x20000000U
#define DMA_FLAG_HT8 0x40000000U
#define DMA_FLAG_TE8 0x80000000U

/**
  * @}
  */

/**
  * @}
  */

/* Exported macros -----------------------------------------------------------*/
/** @defgroup DMA_Exported_Macros DMA Exported Macros
  * @{
  */

/** @brief  Reset DMA handle state.
  * @param  __HANDLE__ DMA handle
  * @retval None
  */
#define __HAL_DMA_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DMA_STATE_RESET)

/**
  * @brief  Enable the specified DMA Channel.
  * @param  __HANDLE__ DMA handle
  * @retval None
  */
#define __HAL_DMA_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CCR |= DMA_CCR_EN)

/**
  * @brief  Disable the specified DMA Channel.
  * @param  __HANDLE__ DMA handle
  * @retval None
  */
#define __HAL_DMA_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CCR &= ~DMA_CCR_EN)


/* Interrupt & Flag management */

/**
  * @brief  Return the current DMA Channel transfer complete flag.
  * @param  __HANDLE__ DMA handle
  * @retval The specified transfer complete flag index.
  */


#define __HAL_DMA_GET_TC_FLAG_INDEX(__HANDLE__) (((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_TC1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel1))? DMA_FLAG_TC1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_TC2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel2))? DMA_FLAG_TC2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_TC3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel3))? DMA_FLAG_TC3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_TC4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel4))? DMA_FLAG_TC4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_TC5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel5))? DMA_FLAG_TC5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_TC6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel6))? DMA_FLAG_TC6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel7))? DMA_FLAG_TC7 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel7))? DMA_FLAG_TC7 : DMA_FLAG_TC8)
# 533 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_dma.h"
# 547 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_dma.h"

/**
  * @brief  Return the current DMA Channel half transfer complete flag.
  * @param  __HANDLE__ DMA handle
  * @retval The specified half transfer complete flag index.
  */

#define __HAL_DMA_GET_HT_FLAG_INDEX(__HANDLE__) (((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_HT1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel1))? DMA_FLAG_HT1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_HT2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel2))? DMA_FLAG_HT2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_HT3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel3))? DMA_FLAG_HT3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_HT4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel4))? DMA_FLAG_HT4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_HT5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel5))? DMA_FLAG_HT5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_HT6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel6))? DMA_FLAG_HT6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel7))? DMA_FLAG_HT7 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel7))? DMA_FLAG_HT7 : DMA_FLAG_HT8)
# 570 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_dma.h"
# 584 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_dma.h"

/**
  * @brief  Return the current DMA Channel transfer error flag.
  * @param  __HANDLE__ DMA handle
  * @retval The specified transfer error flag index.
  */

#define __HAL_DMA_GET_TE_FLAG_INDEX(__HANDLE__) (((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_TE1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel1))? DMA_FLAG_TE1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_TE2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel2))? DMA_FLAG_TE2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_TE3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel3))? DMA_FLAG_TE3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_TE4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel4))? DMA_FLAG_TE4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_TE5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel5))? DMA_FLAG_TE5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_TE6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel6))? DMA_FLAG_TE6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel7))? DMA_FLAG_TE7 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel7))? DMA_FLAG_TE7 : DMA_FLAG_TE8)
# 607 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_dma.h"
# 621 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_dma.h"

/**
  * @brief  Return the current DMA Channel Global interrupt flag.
  * @param  __HANDLE__ DMA handle
  * @retval The specified transfer error flag index.
  */

#define __HAL_DMA_GET_GI_FLAG_INDEX(__HANDLE__) (((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_ISR_GIF1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel1))? DMA_ISR_GIF1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_ISR_GIF2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel2))? DMA_ISR_GIF2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_ISR_GIF3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel3))? DMA_ISR_GIF3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_ISR_GIF4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel4))? DMA_ISR_GIF4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_ISR_GIF5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel5))? DMA_ISR_GIF5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_ISR_GIF6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel6))? DMA_ISR_GIF6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel7))? DMA_ISR_GIF7 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel7))? DMA_ISR_GIF7 : DMA_ISR_GIF8)
# 644 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_dma.h"
# 658 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_dma.h"

/**
  * @brief  Get the DMA Channel pending flags.
  * @param  __HANDLE__ DMA handle
  * @param  __FLAG__ Get the specified flag.
  *          This parameter can be any combination of the following values:
  *            @arg DMA_FLAG_TCx  Transfer complete flag
  *            @arg DMA_FLAG_HTx  Half transfer complete flag
  *            @arg DMA_FLAG_TEx  Transfer error flag
  *            @arg DMA_FLAG_GLx  Global interrupt flag
  *         Where x can be from 1 to 8 to select the DMA Channel x flag.
  * @retval The state of FLAG (SET or RESET).
  */

#define __HAL_DMA_GET_FLAG(__HANDLE__,__FLAG__) (((uint32_t)((__HANDLE__)->Instance) > ((uint32_t)DMA1_Channel8))? (DMA2->ISR & (__FLAG__)) : (DMA1->ISR & (__FLAG__)))






/**
  * @brief  Clear the DMA Channel pending flags.
  * @param  __HANDLE__ DMA handle
  * @param  __FLAG__ specifies the flag to clear.
  *          This parameter can be any combination of the following values:
  *            @arg DMA_FLAG_TCx  Transfer complete flag
  *            @arg DMA_FLAG_HTx  Half transfer complete flag
  *            @arg DMA_FLAG_TEx  Transfer error flag
  *            @arg DMA_FLAG_GLx  Global interrupt flag
  *         Where x can be from 1 to 8 to select the DMA Channel x flag.
  * @retval None
  */

#define __HAL_DMA_CLEAR_FLAG(__HANDLE__,__FLAG__) (((uint32_t)((__HANDLE__)->Instance) > ((uint32_t)DMA1_Channel8))? (DMA2->IFCR = (__FLAG__)) : (DMA1->IFCR = (__FLAG__)))






/**
  * @brief  Enable the specified DMA Channel interrupts.
  * @param  __HANDLE__ DMA handle
  * @param __INTERRUPT__ specifies the DMA interrupt sources to be enabled or disabled.
  *          This parameter can be any combination of the following values:
  *            @arg DMA_IT_TC  Transfer complete interrupt mask
  *            @arg DMA_IT_HT  Half transfer complete interrupt mask
  *            @arg DMA_IT_TE  Transfer error interrupt mask
  * @retval None
  */
#define __HAL_DMA_ENABLE_IT(__HANDLE__,__INTERRUPT__) ((__HANDLE__)->Instance->CCR |= (__INTERRUPT__))

/**
  * @brief  Disable the specified DMA Channel interrupts.
  * @param  __HANDLE__ DMA handle
  * @param __INTERRUPT__ specifies the DMA interrupt sources to be enabled or disabled.
  *          This parameter can be any combination of the following values:
  *            @arg DMA_IT_TC  Transfer complete interrupt mask
  *            @arg DMA_IT_HT  Half transfer complete interrupt mask
  *            @arg DMA_IT_TE  Transfer error interrupt mask
  * @retval None
  */
#define __HAL_DMA_DISABLE_IT(__HANDLE__,__INTERRUPT__) ((__HANDLE__)->Instance->CCR &= ~(__INTERRUPT__))

/**
  * @brief  Check whether the specified DMA Channel interrupt is enabled or not.
  * @param  __HANDLE__ DMA handle
  * @param  __INTERRUPT__ specifies the DMA interrupt source to check.
  *          This parameter can be one of the following values:
  *            @arg DMA_IT_TC  Transfer complete interrupt mask
  *            @arg DMA_IT_HT  Half transfer complete interrupt mask
  *            @arg DMA_IT_TE  Transfer error interrupt mask
  * @retval The state of DMA_IT (SET or RESET).
  */
#define __HAL_DMA_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__) (((__HANDLE__)->Instance->CCR & (__INTERRUPT__)))

/**
  * @brief  Return the number of remaining data units in the current DMA Channel transfer.
  * @param  __HANDLE__ DMA handle
  * @retval The number of remaining data units in the current DMA Channel transfer.
  */
#define __HAL_DMA_GET_COUNTER(__HANDLE__) ((__HANDLE__)->Instance->CNDTR)

/**
  * @}
  */

/* Include DMA HAL Extension module */
# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_dma_ex.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_dma_ex.h
  * @author  MCD Application Team
  * @brief   Header file of DMA HAL extension module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define __STM32G4xx_HAL_DMA_EX_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup DMAEx
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/** @defgroup DMAEx_Exported_Types DMAEx Exported Types
  * @{
  */

/**
  * @brief  HAL DMA Synchro definition
  */


/**
  * @brief  HAL DMAMUX Synchronization configuration structure definition
  */
typedef struct
{
  uint32_t SyncSignalID;  /*!< Specifies the synchronization signal gating the DMA request in periodic mode.
                              This parameter can be a value of @ref DMAEx_DMAMUX_SyncSignalID_selection */

  uint32_t SyncPolarity;  /*!< Specifies the polarity of the signal on which the DMA request is synchronized.
                              This parameter can be a value of @ref DMAEx_DMAMUX_SyncPolarity_selection */

  FunctionalState SyncEnable;  /*!< Specifies if the synchronization shall be enabled or disabled
                                    This parameter can take the value ENABLE or DISABLE*/


  FunctionalState EventEnable;    /*!< Specifies if an event shall be generated once the RequestNumber is reached.
                                       This parameter can take the value ENABLE or DISABLE */

  uint32_t RequestNumber; /*!< Specifies the number of DMA request that will be authorized after a sync event
                               This parameter must be a number between Min_Data = 1 and Max_Data = 32 */


} HAL_DMA_MuxSyncConfigTypeDef;


/**
  * @brief  HAL DMAMUX request generator parameters structure definition
  */
typedef struct
{
  uint32_t SignalID;      /*!< Specifies the ID of the signal used for DMAMUX request generator
                              This parameter can be a value of @ref DMAEx_DMAMUX_SignalGeneratorID_selection */

  uint32_t Polarity;       /*!< Specifies the polarity of the signal on which the request is generated.
                             This parameter can be a value of @ref DMAEx_DMAMUX_RequestGeneneratorPolarity_selection */

  uint32_t RequestNumber;  /*!< Specifies the number of DMA request that will be generated after a signal event
                                This parameter must be a number between Min_Data = 1 and Max_Data = 32 */

} HAL_DMA_MuxRequestGeneratorConfigTypeDef;

/**
  * @}
  */

/* Exported constants --------------------------------------------------------*/
/** @defgroup DMAEx_Exported_Constants DMAEx Exported Constants
  * @{
  */

/** @defgroup DMAEx_DMAMUX_SyncSignalID_selection DMAMUX SyncSignalID selection
  * @{
  */
#define HAL_DMAMUX1_SYNC_EXTI0 0U
#define HAL_DMAMUX1_SYNC_EXTI1 1U
#define HAL_DMAMUX1_SYNC_EXTI2 2U
#define HAL_DMAMUX1_SYNC_EXTI3 3U
#define HAL_DMAMUX1_SYNC_EXTI4 4U
#define HAL_DMAMUX1_SYNC_EXTI5 5U
#define HAL_DMAMUX1_SYNC_EXTI6 6U
#define HAL_DMAMUX1_SYNC_EXTI7 7U
#define HAL_DMAMUX1_SYNC_EXTI8 8U
#define HAL_DMAMUX1_SYNC_EXTI9 9U
#define HAL_DMAMUX1_SYNC_EXTI10 10U
#define HAL_DMAMUX1_SYNC_EXTI11 11U
#define HAL_DMAMUX1_SYNC_EXTI12 12U
#define HAL_DMAMUX1_SYNC_EXTI13 13U
#define HAL_DMAMUX1_SYNC_EXTI14 14U
#define HAL_DMAMUX1_SYNC_EXTI15 15U
#define HAL_DMAMUX1_SYNC_DMAMUX1_CH0_EVT 16U
#define HAL_DMAMUX1_SYNC_DMAMUX1_CH1_EVT 17U
#define HAL_DMAMUX1_SYNC_DMAMUX1_CH2_EVT 18U
#define HAL_DMAMUX1_SYNC_DMAMUX1_CH3_EVT 19U
#define HAL_DMAMUX1_SYNC_LPTIM1_OUT 20U

/**
  * @}
  */

/** @defgroup DMAEx_DMAMUX_SyncPolarity_selection DMAMUX SyncPolarity selection
  * @{
  */
#define HAL_DMAMUX_SYNC_NO_EVENT 0U
#define HAL_DMAMUX_SYNC_RISING ((uint32_t)DMAMUX_CxCR_SPOL_0)
#define HAL_DMAMUX_SYNC_FALLING ((uint32_t)DMAMUX_CxCR_SPOL_1)
#define HAL_DMAMUX_SYNC_RISING_FALLING ((uint32_t)DMAMUX_CxCR_SPOL)

/**
  * @}
  */

/** @defgroup DMAEx_DMAMUX_SignalGeneratorID_selection DMAMUX SignalGeneratorID selection
  * @{
  */
#define HAL_DMAMUX1_REQ_GEN_EXTI0 0U
#define HAL_DMAMUX1_REQ_GEN_EXTI1 1U
#define HAL_DMAMUX1_REQ_GEN_EXTI2 2U
#define HAL_DMAMUX1_REQ_GEN_EXTI3 3U
#define HAL_DMAMUX1_REQ_GEN_EXTI4 4U
#define HAL_DMAMUX1_REQ_GEN_EXTI5 5U
#define HAL_DMAMUX1_REQ_GEN_EXTI6 6U
#define HAL_DMAMUX1_REQ_GEN_EXTI7 7U
#define HAL_DMAMUX1_REQ_GEN_EXTI8 8U
#define HAL_DMAMUX1_REQ_GEN_EXTI9 9U
#define HAL_DMAMUX1_REQ_GEN_EXTI10 10U
#define HAL_DMAMUX1_REQ_GEN_EXTI11 11U
#define HAL_DMAMUX1_REQ_GEN_EXTI12 12U
#define HAL_DMAMUX1_REQ_GEN_EXTI13 13U
#define HAL_DMAMUX1_REQ_GEN_EXTI14 14U
#define HAL_DMAMUX1_REQ_GEN_EXTI15 15U
#define HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH0_EVT 16U
#define HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH1_EVT 17U
#define HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH2_EVT 18U
#define HAL_DMAMUX1_REQ_GEN_DMAMUX1_CH3_EVT 19U
#define HAL_DMAMUX1_REQ_GEN_LPTIM1_OUT 20U

/**
  * @}
  */

/** @defgroup DMAEx_DMAMUX_RequestGeneneratorPolarity_selection DMAMUX RequestGeneneratorPolarity selection
  * @{
  */
#define HAL_DMAMUX_REQ_GEN_NO_EVENT 0x00000000U
#define HAL_DMAMUX_REQ_GEN_RISING DMAMUX_RGxCR_GPOL_0
#define HAL_DMAMUX_REQ_GEN_FALLING DMAMUX_RGxCR_GPOL_1
#define HAL_DMAMUX_REQ_GEN_RISING_FALLING DMAMUX_RGxCR_GPOL

/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/

/* Exported functions --------------------------------------------------------*/
/** @addtogroup DMAEx_Exported_Functions
  * @{
  */

/* IO operation functions *****************************************************/
/** @addtogroup DMAEx_Exported_Functions_Group1
  * @{
  */

/* ------------------------- REQUEST -----------------------------------------*/
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxRequestGenerator(DMA_HandleTypeDef *hdma,
                                                      HAL_DMA_MuxRequestGeneratorConfigTypeDef *pRequestGeneratorConfig);
HAL_StatusTypeDef HAL_DMAEx_EnableMuxRequestGenerator(DMA_HandleTypeDef *hdma);
HAL_StatusTypeDef HAL_DMAEx_DisableMuxRequestGenerator(DMA_HandleTypeDef *hdma);
/* -------------------------------------------------------------------------- */

/* ------------------------- SYNCHRO -----------------------------------------*/
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxSync(DMA_HandleTypeDef *hdma, HAL_DMA_MuxSyncConfigTypeDef *pSyncConfig);
/* -------------------------------------------------------------------------- */

void HAL_DMAEx_MUX_IRQHandler(DMA_HandleTypeDef *hdma);

/**
  * @}
  */

/**
  * @}
  */

/* Private macros ------------------------------------------------------------*/
/** @defgroup DMAEx_Private_Macros DMAEx Private Macros
  * @brief    DMAEx private macros
  * @{
  */

#define IS_DMAMUX_SYNC_SIGNAL_ID(SIGNAL_ID) ((SIGNAL_ID) <= HAL_DMAMUX1_SYNC_LPTIM1_OUT)

#define IS_DMAMUX_SYNC_REQUEST_NUMBER(REQUEST_NUMBER) (((REQUEST_NUMBER) > 0U) && ((REQUEST_NUMBER) <= 32U))

#define IS_DMAMUX_SYNC_POLARITY(POLARITY) (((POLARITY) == HAL_DMAMUX_SYNC_NO_EVENT) || ((POLARITY) == HAL_DMAMUX_SYNC_RISING) || ((POLARITY) == HAL_DMAMUX_SYNC_FALLING) || ((POLARITY) == HAL_DMAMUX_SYNC_RISING_FALLING))




#define IS_DMAMUX_SYNC_STATE(SYNC) (((SYNC) == DISABLE) || ((SYNC) == ENABLE))

#define IS_DMAMUX_SYNC_EVENT(EVENT) (((EVENT) == DISABLE) || ((EVENT) == ENABLE))


#define IS_DMAMUX_REQUEST_GEN_SIGNAL_ID(SIGNAL_ID) ((SIGNAL_ID) <= HAL_DMAMUX1_REQ_GEN_LPTIM1_OUT)

#define IS_DMAMUX_REQUEST_GEN_REQUEST_NUMBER(REQUEST_NUMBER) (((REQUEST_NUMBER) > 0U) && ((REQUEST_NUMBER) <= 32U))

#define IS_DMAMUX_REQUEST_GEN_POLARITY(POLARITY) (((POLARITY) == HAL_DMAMUX_REQ_GEN_NO_EVENT) || ((POLARITY) == HAL_DMAMUX_REQ_GEN_RISING) || ((POLARITY) == HAL_DMAMUX_REQ_GEN_FALLING) || ((POLARITY) == HAL_DMAMUX_REQ_GEN_RISING_FALLING))




/**
  * @}
  */


/**
  * @}
  */

/**
  * @}
  */







# 748 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_dma.h" 2

/* Exported functions --------------------------------------------------------*/

/** @addtogroup DMA_Exported_Functions
  * @{
  */

/** @addtogroup DMA_Exported_Functions_Group1
  * @{
  */
/* Initialization and de-initialization functions *****************************/
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma);
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma);
/**
  * @}
  */

/** @addtogroup DMA_Exported_Functions_Group2
  * @{
  */
/* IO operation functions *****************************************************/
HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress,
                                   uint32_t DataLength);
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma);
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma);
HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel,
                                          uint32_t Timeout);
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma);
HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma));
HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID);

/**
  * @}
  */

/** @addtogroup DMA_Exported_Functions_Group3
  * @{
  */
/* Peripheral State and Error functions ***************************************/
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma);
uint32_t             HAL_DMA_GetError(DMA_HandleTypeDef *hdma);
/**
  * @}
  */

/**
  * @}
  */

/* Private macros ------------------------------------------------------------*/
/** @defgroup DMA_Private_Macros DMA Private Macros
  * @{
  */

#define IS_DMA_DIRECTION(DIRECTION) (((DIRECTION) == DMA_PERIPH_TO_MEMORY ) || ((DIRECTION) == DMA_MEMORY_TO_PERIPH) || ((DIRECTION) == DMA_MEMORY_TO_MEMORY))



#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x1U) && ((SIZE) < 0x40000U))

#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PINC_ENABLE) || ((STATE) == DMA_PINC_DISABLE))


#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MINC_ENABLE) || ((STATE) == DMA_MINC_DISABLE))


#define IS_DMA_ALL_REQUEST(REQUEST) ((REQUEST) <= DMA_REQUEST_UCPD1_TX)

#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PDATAALIGN_BYTE) || ((SIZE) == DMA_PDATAALIGN_HALFWORD) || ((SIZE) == DMA_PDATAALIGN_WORD))



#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MDATAALIGN_BYTE) || ((SIZE) == DMA_MDATAALIGN_HALFWORD) || ((SIZE) == DMA_MDATAALIGN_WORD ))



#define IS_DMA_MODE(MODE) (((MODE) == DMA_NORMAL ) || ((MODE) == DMA_CIRCULAR))


#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_PRIORITY_LOW ) || ((PRIORITY) == DMA_PRIORITY_MEDIUM) || ((PRIORITY) == DMA_PRIORITY_HIGH) || ((PRIORITY) == DMA_PRIORITY_VERY_HIGH))




/**
  * @}
  */

/* Private functions ---------------------------------------------------------*/

/**
  * @}
  */

/**
  * @}
  */







# 221 "Core/Inc/stm32g4xx_hal_conf.h" 2



# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_cortex.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_cortex.h
  * @author  MCD Application Team
  * @brief   Header file of CORTEX HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* Define to prevent recursive inclusion -------------------------------------*/

#define __STM32G4xx_HAL_CORTEX_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @defgroup CORTEX CORTEX
  * @brief CORTEX HAL module driver
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/** @defgroup CORTEX_Exported_Types CORTEX Exported Types
  * @{
  */


/** @defgroup CORTEX_MPU_Region_Initialization_Structure_definition MPU Region Initialization Structure Definition
  * @brief  MPU Region initialization structure 
  * @{
  */
typedef struct
{
  uint8_t                Enable;                /*!< Specifies the status of the region. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Enable                 */
  uint8_t                Number;                /*!< Specifies the number of the region to protect. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Number                 */
  uint32_t               BaseAddress;           /*!< Specifies the base address of the region to protect.                           */
  uint8_t                Size;                  /*!< Specifies the size of the region to protect. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Size                   */
  uint8_t                SubRegionDisable;      /*!< Specifies the number of the subregion protection to disable. 
                                                     This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF    */
  uint8_t                TypeExtField;          /*!< Specifies the TEX field level.
                                                     This parameter can be a value of @ref CORTEX_MPU_TEX_Levels                    */
  uint8_t                AccessPermission;      /*!< Specifies the region access permission type. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Permission_Attributes  */
  uint8_t                DisableExec;           /*!< Specifies the instruction access status. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Instruction_Access            */
  uint8_t                IsShareable;           /*!< Specifies the shareability status of the protected region. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Shareable              */
  uint8_t                IsCacheable;           /*!< Specifies the cacheable status of the region protected. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Cacheable              */
  uint8_t                IsBufferable;          /*!< Specifies the bufferable status of the protected region. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Bufferable             */
}MPU_Region_InitTypeDef;
/**
  * @}
  */


/**
  * @}
  */

/* Exported constants --------------------------------------------------------*/

/** @defgroup CORTEX_Exported_Constants CORTEX Exported Constants
  * @{
  */

/** @defgroup CORTEX_Preemption_Priority_Group CORTEX Preemption Priority Group
  * @{
  */
#define NVIC_PRIORITYGROUP_0 0x00000007U

#define NVIC_PRIORITYGROUP_1 0x00000006U

#define NVIC_PRIORITYGROUP_2 0x00000005U

#define NVIC_PRIORITYGROUP_3 0x00000004U

#define NVIC_PRIORITYGROUP_4 0x00000003U

/**
  * @}
  */

/** @defgroup CORTEX_SysTick_clock_source CORTEX SysTick clock source
  * @{
  */
#define SYSTICK_CLKSOURCE_HCLK_DIV8 0x00000000U
#define SYSTICK_CLKSOURCE_HCLK 0x00000004U

/**
  * @}
  */


/** @defgroup CORTEX_MPU_HFNMI_PRIVDEF_Control CORTEX MPU HFNMI and PRIVILEGED Access control
  * @{
  */
#define MPU_HFNMI_PRIVDEF_NONE 0x00000000U
#define MPU_HARDFAULT_NMI (MPU_CTRL_HFNMIENA_Msk)
#define MPU_PRIVILEGED_DEFAULT (MPU_CTRL_PRIVDEFENA_Msk)
#define MPU_HFNMI_PRIVDEF (MPU_CTRL_HFNMIENA_Msk | MPU_CTRL_PRIVDEFENA_Msk)
/**
  * @}
  */

/** @defgroup CORTEX_MPU_Region_Enable CORTEX MPU Region Enable
  * @{
  */
#define MPU_REGION_ENABLE ((uint8_t)0x01)
#define MPU_REGION_DISABLE ((uint8_t)0x00)
/**
  * @}
  */

/** @defgroup CORTEX_MPU_Instruction_Access CORTEX MPU Instruction Access
  * @{
  */
#define MPU_INSTRUCTION_ACCESS_ENABLE ((uint8_t)0x00)
#define MPU_INSTRUCTION_ACCESS_DISABLE ((uint8_t)0x01)
/**
  * @}
  */

/** @defgroup CORTEX_MPU_Access_Shareable CORTEX MPU Instruction Access Shareable
  * @{
  */
#define MPU_ACCESS_SHAREABLE ((uint8_t)0x01)
#define MPU_ACCESS_NOT_SHAREABLE ((uint8_t)0x00)
/**
  * @}
  */

/** @defgroup CORTEX_MPU_Access_Cacheable CORTEX MPU Instruction Access Cacheable
  * @{
  */
#define MPU_ACCESS_CACHEABLE ((uint8_t)0x01)
#define MPU_ACCESS_NOT_CACHEABLE ((uint8_t)0x00)
/**
  * @}
  */

/** @defgroup CORTEX_MPU_Access_Bufferable CORTEX MPU Instruction Access Bufferable
  * @{
  */
#define MPU_ACCESS_BUFFERABLE ((uint8_t)0x01)
#define MPU_ACCESS_NOT_BUFFERABLE ((uint8_t)0x00)
/**
  * @}
  */

/** @defgroup CORTEX_MPU_TEX_Levels CORTEX MPU TEX Levels
  * @{
  */
#define MPU_TEX_LEVEL0 ((uint8_t)0x00)
#define MPU_TEX_LEVEL1 ((uint8_t)0x01)
#define MPU_TEX_LEVEL2 ((uint8_t)0x02)
#define MPU_TEX_LEVEL4 ((uint8_t)0x04)
/**
  * @}
  */

/** @defgroup CORTEX_MPU_Region_Size CORTEX MPU Region Size
  * @{
  */
#define MPU_REGION_SIZE_32B ((uint8_t)0x04)
#define MPU_REGION_SIZE_64B ((uint8_t)0x05)
#define MPU_REGION_SIZE_128B ((uint8_t)0x06)
#define MPU_REGION_SIZE_256B ((uint8_t)0x07)
#define MPU_REGION_SIZE_512B ((uint8_t)0x08)
#define MPU_REGION_SIZE_1KB ((uint8_t)0x09)
#define MPU_REGION_SIZE_2KB ((uint8_t)0x0A)
#define MPU_REGION_SIZE_4KB ((uint8_t)0x0B)
#define MPU_REGION_SIZE_8KB ((uint8_t)0x0C)
#define MPU_REGION_SIZE_16KB ((uint8_t)0x0D)
#define MPU_REGION_SIZE_32KB ((uint8_t)0x0E)
#define MPU_REGION_SIZE_64KB ((uint8_t)0x0F)
#define MPU_REGION_SIZE_128KB ((uint8_t)0x10)
#define MPU_REGION_SIZE_256KB ((uint8_t)0x11)
#define MPU_REGION_SIZE_512KB ((uint8_t)0x12)
#define MPU_REGION_SIZE_1MB ((uint8_t)0x13)
#define MPU_REGION_SIZE_2MB ((uint8_t)0x14)
#define MPU_REGION_SIZE_4MB ((uint8_t)0x15)
#define MPU_REGION_SIZE_8MB ((uint8_t)0x16)
#define MPU_REGION_SIZE_16MB ((uint8_t)0x17)
#define MPU_REGION_SIZE_32MB ((uint8_t)0x18)
#define MPU_REGION_SIZE_64MB ((uint8_t)0x19)
#define MPU_REGION_SIZE_128MB ((uint8_t)0x1A)
#define MPU_REGION_SIZE_256MB ((uint8_t)0x1B)
#define MPU_REGION_SIZE_512MB ((uint8_t)0x1C)
#define MPU_REGION_SIZE_1GB ((uint8_t)0x1D)
#define MPU_REGION_SIZE_2GB ((uint8_t)0x1E)
#define MPU_REGION_SIZE_4GB ((uint8_t)0x1F)
/**
  * @}
  */

/** @defgroup CORTEX_MPU_Region_Permission_Attributes CORTEX MPU Region Permission Attributes 
  * @{
  */
#define MPU_REGION_NO_ACCESS ((uint8_t)0x00)
#define MPU_REGION_PRIV_RW ((uint8_t)0x01)
#define MPU_REGION_PRIV_RW_URO ((uint8_t)0x02)
#define MPU_REGION_FULL_ACCESS ((uint8_t)0x03)
#define MPU_REGION_PRIV_RO ((uint8_t)0x05)
#define MPU_REGION_PRIV_RO_URO ((uint8_t)0x06)
/**
  * @}
  */

/** @defgroup CORTEX_MPU_Region_Number CORTEX MPU Region Number
  * @{
  */
#define MPU_REGION_NUMBER0 ((uint8_t)0x00)
#define MPU_REGION_NUMBER1 ((uint8_t)0x01)
#define MPU_REGION_NUMBER2 ((uint8_t)0x02)
#define MPU_REGION_NUMBER3 ((uint8_t)0x03)
#define MPU_REGION_NUMBER4 ((uint8_t)0x04)
#define MPU_REGION_NUMBER5 ((uint8_t)0x05)
#define MPU_REGION_NUMBER6 ((uint8_t)0x06)
#define MPU_REGION_NUMBER7 ((uint8_t)0x07)
/**
  * @}
  */


/**
  * @}
  */

/* Exported macros -----------------------------------------------------------*/
/** @defgroup CORTEX_Exported_Macros CORTEX Exported Macros
  * @{
  */

/**
  * @}
  */

/* Exported functions --------------------------------------------------------*/
/** @defgroup CORTEX_Exported_Functions CORTEX Exported Functions
  * @{
  */

/** @defgroup CORTEX_Exported_Functions_Group1 Initialization and Configuration functions 
  * @brief    Initialization and Configuration functions
  * @{
  */
/* Initialization and Configuration functions *****************************/
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup);
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority);
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn);
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn);
void HAL_NVIC_SystemReset(void);
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb);

/**
  * @}
  */

/** @defgroup CORTEX_Exported_Functions_Group2 Peripheral Control functions 
  * @brief   Cortex control functions
  * @{
  */
/* Peripheral Control functions ***********************************************/
uint32_t HAL_NVIC_GetPriorityGrouping(void);
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority);
uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn);
void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn);
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn);
uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn);
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource);
void HAL_SYSTICK_IRQHandler(void);
void HAL_SYSTICK_Callback(void);


void HAL_MPU_Enable(uint32_t MPU_Control);
void HAL_MPU_Disable(void);
void HAL_MPU_EnableRegion(uint32_t RegionNumber);
void HAL_MPU_DisableRegion(uint32_t RegionNumber);
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init);

/**
  * @}
  */

/**
  * @}
  */

/* Private types -------------------------------------------------------------*/ 
/* Private variables ---------------------------------------------------------*/
/* Private constants ---------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/** @defgroup CORTEX_Private_Macros CORTEX Private Macros
  * @{
  */
#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PRIORITYGROUP_0) || ((GROUP) == NVIC_PRIORITYGROUP_1) || ((GROUP) == NVIC_PRIORITYGROUP_2) || ((GROUP) == NVIC_PRIORITYGROUP_3) || ((GROUP) == NVIC_PRIORITYGROUP_4))





#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY) ((PRIORITY) < 0x10U)

#define IS_NVIC_SUB_PRIORITY(PRIORITY) ((PRIORITY) < 0x10U)

#define IS_NVIC_DEVICE_IRQ(IRQ) ((IRQ) > SysTick_IRQn)

#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SYSTICK_CLKSOURCE_HCLK) || ((SOURCE) == SYSTICK_CLKSOURCE_HCLK_DIV8))



#define IS_MPU_REGION_ENABLE(STATE) (((STATE) == MPU_REGION_ENABLE) || ((STATE) == MPU_REGION_DISABLE))


#define IS_MPU_INSTRUCTION_ACCESS(STATE) (((STATE) == MPU_INSTRUCTION_ACCESS_ENABLE) || ((STATE) == MPU_INSTRUCTION_ACCESS_DISABLE))


#define IS_MPU_ACCESS_SHAREABLE(STATE) (((STATE) == MPU_ACCESS_SHAREABLE) || ((STATE) == MPU_ACCESS_NOT_SHAREABLE))


#define IS_MPU_ACCESS_CACHEABLE(STATE) (((STATE) == MPU_ACCESS_CACHEABLE) || ((STATE) == MPU_ACCESS_NOT_CACHEABLE))


#define IS_MPU_ACCESS_BUFFERABLE(STATE) (((STATE) == MPU_ACCESS_BUFFERABLE) || ((STATE) == MPU_ACCESS_NOT_BUFFERABLE))


#define IS_MPU_TEX_LEVEL(TYPE) (((TYPE) == MPU_TEX_LEVEL0) || ((TYPE) == MPU_TEX_LEVEL1) || ((TYPE) == MPU_TEX_LEVEL2) || ((TYPE) == MPU_TEX_LEVEL4))




#define IS_MPU_REGION_PERMISSION_ATTRIBUTE(TYPE) (((TYPE) == MPU_REGION_NO_ACCESS) || ((TYPE) == MPU_REGION_PRIV_RW) || ((TYPE) == MPU_REGION_PRIV_RW_URO) || ((TYPE) == MPU_REGION_FULL_ACCESS) || ((TYPE) == MPU_REGION_PRIV_RO) || ((TYPE) == MPU_REGION_PRIV_RO_URO))






#define IS_MPU_REGION_NUMBER(NUMBER) (((NUMBER) == MPU_REGION_NUMBER0) || ((NUMBER) == MPU_REGION_NUMBER1) || ((NUMBER) == MPU_REGION_NUMBER2) || ((NUMBER) == MPU_REGION_NUMBER3) || ((NUMBER) == MPU_REGION_NUMBER4) || ((NUMBER) == MPU_REGION_NUMBER5) || ((NUMBER) == MPU_REGION_NUMBER6) || ((NUMBER) == MPU_REGION_NUMBER7))








#define IS_MPU_REGION_SIZE(SIZE) (((SIZE) == MPU_REGION_SIZE_32B) || ((SIZE) == MPU_REGION_SIZE_64B) || ((SIZE) == MPU_REGION_SIZE_128B) || ((SIZE) == MPU_REGION_SIZE_256B) || ((SIZE) == MPU_REGION_SIZE_512B) || ((SIZE) == MPU_REGION_SIZE_1KB) || ((SIZE) == MPU_REGION_SIZE_2KB) || ((SIZE) == MPU_REGION_SIZE_4KB) || ((SIZE) == MPU_REGION_SIZE_8KB) || ((SIZE) == MPU_REGION_SIZE_16KB) || ((SIZE) == MPU_REGION_SIZE_32KB) || ((SIZE) == MPU_REGION_SIZE_64KB) || ((SIZE) == MPU_REGION_SIZE_128KB) || ((SIZE) == MPU_REGION_SIZE_256KB) || ((SIZE) == MPU_REGION_SIZE_512KB) || ((SIZE) == MPU_REGION_SIZE_1MB) || ((SIZE) == MPU_REGION_SIZE_2MB) || ((SIZE) == MPU_REGION_SIZE_4MB) || ((SIZE) == MPU_REGION_SIZE_8MB) || ((SIZE) == MPU_REGION_SIZE_16MB) || ((SIZE) == MPU_REGION_SIZE_32MB) || ((SIZE) == MPU_REGION_SIZE_64MB) || ((SIZE) == MPU_REGION_SIZE_128MB) || ((SIZE) == MPU_REGION_SIZE_256MB) || ((SIZE) == MPU_REGION_SIZE_512MB) || ((SIZE) == MPU_REGION_SIZE_1GB) || ((SIZE) == MPU_REGION_SIZE_2GB) || ((SIZE) == MPU_REGION_SIZE_4GB))
# 397 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_cortex.h"

#define IS_MPU_SUB_REGION_DISABLE(SUBREGION) ((SUBREGION) < (uint16_t)0x00FF)


/**
  * @}
  */

/* Private functions ---------------------------------------------------------*/

/**
  * @}
  */

/**
  * @}
  */








# 225 "Core/Inc/stm32g4xx_hal_conf.h" 2



# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_adc.h
  * @author  MCD Application Team
  * @brief   Header file of ADC HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_ADC_H 





/* Includes ------------------------------------------------------------------*/


/* Include low level driver */
# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_ll_adc.h
  * @author  MCD Application Team
  * @brief   Header file of ADC LL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_LL_ADC_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_LL_Driver
  * @{
  */



/** @defgroup ADC_LL ADC
  * @{
  */

/* Private types -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/

/* Private constants ---------------------------------------------------------*/
/** @defgroup ADC_LL_Private_Constants ADC Private Constants
  * @{
  */

/* Internal mask for ADC group regular sequencer:                             */
/* To select into literal LL_ADC_REG_RANK_x the relevant bits for:            */
/* - sequencer register offset                                                */
/* - sequencer rank bits position into the selected register                  */

/* Internal register offset for ADC group regular sequencer configuration */
/* (offset placed into a spare area of literal definition) */
#define ADC_SQR1_REGOFFSET (0x00000000UL)
#define ADC_SQR2_REGOFFSET (0x00000100UL)
#define ADC_SQR3_REGOFFSET (0x00000200UL)
#define ADC_SQR4_REGOFFSET (0x00000300UL)

#define ADC_REG_SQRX_REGOFFSET_MASK (ADC_SQR1_REGOFFSET | ADC_SQR2_REGOFFSET | ADC_SQR3_REGOFFSET | ADC_SQR4_REGOFFSET)

#define ADC_SQRX_REGOFFSET_POS (8UL)
#define ADC_REG_RANK_ID_SQRX_MASK (ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0)

/* Definition of ADC group regular sequencer bits information to be inserted  */
/* into ADC group regular sequencer ranks literals definition.                */
#define ADC_REG_RANK_1_SQRX_BITOFFSET_POS (ADC_SQR1_SQ1_Pos)
#define ADC_REG_RANK_2_SQRX_BITOFFSET_POS (ADC_SQR1_SQ2_Pos)
#define ADC_REG_RANK_3_SQRX_BITOFFSET_POS (ADC_SQR1_SQ3_Pos)
#define ADC_REG_RANK_4_SQRX_BITOFFSET_POS (ADC_SQR1_SQ4_Pos)
#define ADC_REG_RANK_5_SQRX_BITOFFSET_POS (ADC_SQR2_SQ5_Pos)
#define ADC_REG_RANK_6_SQRX_BITOFFSET_POS (ADC_SQR2_SQ6_Pos)
#define ADC_REG_RANK_7_SQRX_BITOFFSET_POS (ADC_SQR2_SQ7_Pos)
#define ADC_REG_RANK_8_SQRX_BITOFFSET_POS (ADC_SQR2_SQ8_Pos)
#define ADC_REG_RANK_9_SQRX_BITOFFSET_POS (ADC_SQR2_SQ9_Pos)
#define ADC_REG_RANK_10_SQRX_BITOFFSET_POS (ADC_SQR3_SQ10_Pos)
#define ADC_REG_RANK_11_SQRX_BITOFFSET_POS (ADC_SQR3_SQ11_Pos)
#define ADC_REG_RANK_12_SQRX_BITOFFSET_POS (ADC_SQR3_SQ12_Pos)
#define ADC_REG_RANK_13_SQRX_BITOFFSET_POS (ADC_SQR3_SQ13_Pos)
#define ADC_REG_RANK_14_SQRX_BITOFFSET_POS (ADC_SQR3_SQ14_Pos)
#define ADC_REG_RANK_15_SQRX_BITOFFSET_POS (ADC_SQR4_SQ15_Pos)
#define ADC_REG_RANK_16_SQRX_BITOFFSET_POS (ADC_SQR4_SQ16_Pos)



/* Internal mask for ADC group injected sequencer:                            */
/* To select into literal LL_ADC_INJ_RANK_x the relevant bits for:            */
/* - data register offset                                                     */
/* - sequencer rank bits position into the selected register                  */

/* Internal register offset for ADC group injected data register */
/* (offset placed into a spare area of literal definition) */
#define ADC_JDR1_REGOFFSET (0x00000000UL)
#define ADC_JDR2_REGOFFSET (0x00000100UL)
#define ADC_JDR3_REGOFFSET (0x00000200UL)
#define ADC_JDR4_REGOFFSET (0x00000300UL)

#define ADC_INJ_JDRX_REGOFFSET_MASK (ADC_JDR1_REGOFFSET | ADC_JDR2_REGOFFSET | ADC_JDR3_REGOFFSET | ADC_JDR4_REGOFFSET)

#define ADC_INJ_RANK_ID_JSQR_MASK (ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0)
#define ADC_JDRX_REGOFFSET_POS (8UL)

/* Definition of ADC group injected sequencer bits information to be inserted */
/* into ADC group injected sequencer ranks literals definition.               */
#define ADC_INJ_RANK_1_JSQR_BITOFFSET_POS (ADC_JSQR_JSQ1_Pos)
#define ADC_INJ_RANK_2_JSQR_BITOFFSET_POS (ADC_JSQR_JSQ2_Pos)
#define ADC_INJ_RANK_3_JSQR_BITOFFSET_POS (ADC_JSQR_JSQ3_Pos)
#define ADC_INJ_RANK_4_JSQR_BITOFFSET_POS (ADC_JSQR_JSQ4_Pos)



/* Internal mask for ADC group regular trigger:                               */
/* To select into literal LL_ADC_REG_TRIG_x the relevant bits for:            */
/* - regular trigger source                                                   */
/* - regular trigger edge                                                     */
#define ADC_REG_TRIG_EXT_EDGE_DEFAULT (ADC_CFGR_EXTEN_0)



/* Mask containing trigger source masks for each of possible                  */
/* trigger edge selection duplicated with shifts [0; 4; 8; 12]                */
/* corresponding to {SW start; ext trigger; ext trigger; ext trigger}.        */
#define ADC_REG_TRIG_SOURCE_MASK (((LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTSEL) << (4U * 0UL)) | ((ADC_CFGR_EXTSEL) << (4U * 1UL)) | ((ADC_CFGR_EXTSEL) << (4U * 2UL)) | ((ADC_CFGR_EXTSEL) << (4U * 3UL)) )




/* Mask containing trigger edge masks for each of possible                    */
/* trigger edge selection duplicated with shifts [0; 4; 8; 12]                */
/* corresponding to {SW start; ext trigger; ext trigger; ext trigger}.        */
#define ADC_REG_TRIG_EDGE_MASK (((LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN) << (4U * 0UL)) | ((ADC_REG_TRIG_EXT_EDGE_DEFAULT) << (4U * 1UL)) | ((ADC_REG_TRIG_EXT_EDGE_DEFAULT) << (4U * 2UL)) | ((ADC_REG_TRIG_EXT_EDGE_DEFAULT) << (4U * 3UL)) )




/* Definition of ADC group regular trigger bits information.                  */
#define ADC_REG_TRIG_EXTSEL_BITOFFSET_POS (ADC_CFGR_EXTSEL_Pos)
#define ADC_REG_TRIG_EXTEN_BITOFFSET_POS (ADC_CFGR_EXTEN_Pos)



/* Internal mask for ADC group injected trigger:                              */
/* To select into literal LL_ADC_INJ_TRIG_x the relevant bits for:            */
/* - injected trigger source                                                  */
/* - injected trigger edge                                                    */
#define ADC_INJ_TRIG_EXT_EDGE_DEFAULT (ADC_JSQR_JEXTEN_0)



/* Mask containing trigger source masks for each of possible                  */
/* trigger edge selection duplicated with shifts [0; 4; 8; 12]                */
/* corresponding to {SW start; ext trigger; ext trigger; ext trigger}.        */
#define ADC_INJ_TRIG_SOURCE_MASK (((LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTSEL) << (4U * 0UL)) | ((ADC_JSQR_JEXTSEL) << (4U * 1UL)) | ((ADC_JSQR_JEXTSEL) << (4U * 2UL)) | ((ADC_JSQR_JEXTSEL) << (4U * 3UL)) )




/* Mask containing trigger edge masks for each of possible                    */
/* trigger edge selection duplicated with shifts [0; 4; 8; 12]                */
/* corresponding to {SW start; ext trigger; ext trigger; ext trigger}.        */
#define ADC_INJ_TRIG_EDGE_MASK (((LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTEN) << (4U * 0UL)) | ((ADC_INJ_TRIG_EXT_EDGE_DEFAULT) << (4U * 1UL)) | ((ADC_INJ_TRIG_EXT_EDGE_DEFAULT) << (4U * 2UL)) | ((ADC_INJ_TRIG_EXT_EDGE_DEFAULT) << (4U * 3UL)) )




/* Definition of ADC group injected trigger bits information.                 */
#define ADC_INJ_TRIG_EXTSEL_BITOFFSET_POS (ADC_JSQR_JEXTSEL_Pos)
#define ADC_INJ_TRIG_EXTEN_BITOFFSET_POS (ADC_JSQR_JEXTEN_Pos)






/* Internal mask for ADC channel:                                             */
/* To select into literal LL_ADC_CHANNEL_x the relevant bits for:             */
/* - channel identifier defined by number                                     */
/* - channel identifier defined by bitfield                                   */
/* - channel differentiation between external channels (connected to          */
/*   GPIO pins) and internal channels (connected to internal paths)           */
/* - channel sampling time defined by SMPRx register offset                   */
/*   and SMPx bits positions into SMPRx register                              */
#define ADC_CHANNEL_ID_NUMBER_MASK (ADC_CFGR_AWD1CH)
#define ADC_CHANNEL_ID_BITFIELD_MASK (ADC_AWD2CR_AWD2CH)
#define ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS (ADC_CFGR_AWD1CH_Pos)
#define ADC_CHANNEL_ID_MASK (ADC_CHANNEL_ID_NUMBER_MASK | ADC_CHANNEL_ID_BITFIELD_MASK | ADC_CHANNEL_ID_INTERNAL_CH_MASK)

/* Equivalent mask of ADC_CHANNEL_NUMBER_MASK aligned on register LSB (bit 0) */
#define ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 (ADC_SQR2_SQ5)


/* Channel differentiation between external and internal channels */
#define ADC_CHANNEL_ID_INTERNAL_CH (0x80000000UL)
#define ADC_CHANNEL_ID_INTERNAL_CH_2 (0x00080000UL)


#define ADC_CHANNEL_ID_INTERNAL_CH_MASK (ADC_CHANNEL_ID_INTERNAL_CH | ADC_CHANNEL_ID_INTERNAL_CH_2)

/* Internal register offset for ADC channel sampling time configuration */
/* (offset placed into a spare area of literal definition) */
#define ADC_SMPR1_REGOFFSET (0x00000000UL)
#define ADC_SMPR2_REGOFFSET (0x02000000UL)
#define ADC_CHANNEL_SMPRX_REGOFFSET_MASK (ADC_SMPR1_REGOFFSET | ADC_SMPR2_REGOFFSET)
#define ADC_SMPRX_REGOFFSET_POS (25UL)


#define ADC_CHANNEL_SMPx_BITOFFSET_MASK (0x01F00000UL)
#define ADC_CHANNEL_SMPx_BITOFFSET_POS (20UL)


/* Definition of channels ID number information to be inserted into           */
/* channels literals definition.                                              */
#define ADC_CHANNEL_0_NUMBER (0x00000000UL)
#define ADC_CHANNEL_1_NUMBER (ADC_CFGR_AWD1CH_0)
#define ADC_CHANNEL_2_NUMBER (ADC_CFGR_AWD1CH_1)
#define ADC_CHANNEL_3_NUMBER (ADC_CFGR_AWD1CH_1 | ADC_CFGR_AWD1CH_0)
#define ADC_CHANNEL_4_NUMBER (ADC_CFGR_AWD1CH_2)
#define ADC_CHANNEL_5_NUMBER (ADC_CFGR_AWD1CH_2 | ADC_CFGR_AWD1CH_0)
#define ADC_CHANNEL_6_NUMBER (ADC_CFGR_AWD1CH_2 | ADC_CFGR_AWD1CH_1)
#define ADC_CHANNEL_7_NUMBER (ADC_CFGR_AWD1CH_2 | ADC_CFGR_AWD1CH_1 | ADC_CFGR_AWD1CH_0)
#define ADC_CHANNEL_8_NUMBER (ADC_CFGR_AWD1CH_3)
#define ADC_CHANNEL_9_NUMBER (ADC_CFGR_AWD1CH_3 | ADC_CFGR_AWD1CH_0)
#define ADC_CHANNEL_10_NUMBER (ADC_CFGR_AWD1CH_3 | ADC_CFGR_AWD1CH_1)
#define ADC_CHANNEL_11_NUMBER (ADC_CFGR_AWD1CH_3 | ADC_CFGR_AWD1CH_1 | ADC_CFGR_AWD1CH_0)
#define ADC_CHANNEL_12_NUMBER (ADC_CFGR_AWD1CH_3 | ADC_CFGR_AWD1CH_2)
#define ADC_CHANNEL_13_NUMBER (ADC_CFGR_AWD1CH_3 | ADC_CFGR_AWD1CH_2 | ADC_CFGR_AWD1CH_0)
#define ADC_CHANNEL_14_NUMBER (ADC_CFGR_AWD1CH_3 | ADC_CFGR_AWD1CH_2 | ADC_CFGR_AWD1CH_1)
#define ADC_CHANNEL_15_NUMBER (ADC_CFGR_AWD1CH_3 | ADC_CFGR_AWD1CH_2 | ADC_CFGR_AWD1CH_1 | ADC_CFGR_AWD1CH_0)

#define ADC_CHANNEL_16_NUMBER (ADC_CFGR_AWD1CH_4)
#define ADC_CHANNEL_17_NUMBER (ADC_CFGR_AWD1CH_4 | ADC_CFGR_AWD1CH_0)
#define ADC_CHANNEL_18_NUMBER (ADC_CFGR_AWD1CH_4 | ADC_CFGR_AWD1CH_1)

/* Definition of channels ID bitfield information to be inserted into         */
/* channels literals definition.                                              */
#define ADC_CHANNEL_0_BITFIELD (ADC_AWD2CR_AWD2CH_0)
#define ADC_CHANNEL_1_BITFIELD (ADC_AWD2CR_AWD2CH_1)
#define ADC_CHANNEL_2_BITFIELD (ADC_AWD2CR_AWD2CH_2)
#define ADC_CHANNEL_3_BITFIELD (ADC_AWD2CR_AWD2CH_3)
#define ADC_CHANNEL_4_BITFIELD (ADC_AWD2CR_AWD2CH_4)
#define ADC_CHANNEL_5_BITFIELD (ADC_AWD2CR_AWD2CH_5)
#define ADC_CHANNEL_6_BITFIELD (ADC_AWD2CR_AWD2CH_6)
#define ADC_CHANNEL_7_BITFIELD (ADC_AWD2CR_AWD2CH_7)
#define ADC_CHANNEL_8_BITFIELD (ADC_AWD2CR_AWD2CH_8)
#define ADC_CHANNEL_9_BITFIELD (ADC_AWD2CR_AWD2CH_9)
#define ADC_CHANNEL_10_BITFIELD (ADC_AWD2CR_AWD2CH_10)
#define ADC_CHANNEL_11_BITFIELD (ADC_AWD2CR_AWD2CH_11)
#define ADC_CHANNEL_12_BITFIELD (ADC_AWD2CR_AWD2CH_12)
#define ADC_CHANNEL_13_BITFIELD (ADC_AWD2CR_AWD2CH_13)
#define ADC_CHANNEL_14_BITFIELD (ADC_AWD2CR_AWD2CH_14)
#define ADC_CHANNEL_15_BITFIELD (ADC_AWD2CR_AWD2CH_15)
#define ADC_CHANNEL_16_BITFIELD (ADC_AWD2CR_AWD2CH_16)
#define ADC_CHANNEL_17_BITFIELD (ADC_AWD2CR_AWD2CH_17)
#define ADC_CHANNEL_18_BITFIELD (ADC_AWD2CR_AWD2CH_18)

/* Definition of channels sampling time information to be inserted into       */
/* channels literals definition.                                              */
/* Value shifted are equivalent to bitfield "ADC_SMPRx_SMPy" position         */
/* in register.                                                               */
#define ADC_CHANNEL_0_SMP (ADC_SMPR1_REGOFFSET | (( 0UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_1_SMP (ADC_SMPR1_REGOFFSET | (( 3UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_2_SMP (ADC_SMPR1_REGOFFSET | (( 6UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_3_SMP (ADC_SMPR1_REGOFFSET | (( 9UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_4_SMP (ADC_SMPR1_REGOFFSET | ((12UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_5_SMP (ADC_SMPR1_REGOFFSET | ((15UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_6_SMP (ADC_SMPR1_REGOFFSET | ((18UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_7_SMP (ADC_SMPR1_REGOFFSET | ((21UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_8_SMP (ADC_SMPR1_REGOFFSET | ((24UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_9_SMP (ADC_SMPR1_REGOFFSET | ((27UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_10_SMP (ADC_SMPR2_REGOFFSET | (( 0UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_11_SMP (ADC_SMPR2_REGOFFSET | (( 3UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_12_SMP (ADC_SMPR2_REGOFFSET | (( 6UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_13_SMP (ADC_SMPR2_REGOFFSET | (( 9UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_14_SMP (ADC_SMPR2_REGOFFSET | ((12UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_15_SMP (ADC_SMPR2_REGOFFSET | ((15UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_16_SMP (ADC_SMPR2_REGOFFSET | ((18UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_17_SMP (ADC_SMPR2_REGOFFSET | ((21UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))
#define ADC_CHANNEL_18_SMP (ADC_SMPR2_REGOFFSET | ((24UL) << ADC_CHANNEL_SMPx_BITOFFSET_POS))


/* Internal mask for ADC mode single or differential ended:                   */
/* To select into literals LL_ADC_SINGLE_ENDED or LL_ADC_SINGLE_DIFFERENTIAL  */
/* the relevant bits for:                                                     */
/* (concatenation of multiple bits used in different registers)               */
/* - ADC calibration: calibration start, calibration factor get or set        */
/* - ADC channels: set each ADC channel ending mode                           */
#define ADC_SINGLEDIFF_CALIB_START_MASK (ADC_CR_ADCALDIF)
#define ADC_SINGLEDIFF_CALIB_FACTOR_MASK (ADC_CALFACT_CALFACT_D | ADC_CALFACT_CALFACT_S)
#define ADC_SINGLEDIFF_CHANNEL_MASK (ADC_CHANNEL_ID_BITFIELD_MASK)
#define ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK (ADC_CALFACT_CALFACT_S_4 | ADC_CALFACT_CALFACT_S_3)


#define ADC_SINGLEDIFF_CALIB_F_BIT_D_MASK (0x00010000UL)

#define ADC_SINGLEDIFF_CALIB_F_BIT_D_POS (16UL)

#define ADC_SINGLEDIFF_CALIB_F_BIT_D_SHIFT4 (ADC_SINGLEDIFF_CALIB_F_BIT_D_POS - 4UL)


/* Internal mask for ADC analog watchdog:                                     */
/* To select into literals LL_ADC_AWD_CHANNELx_xxx the relevant bits for:     */
/* (concatenation of multiple bits used in different analog watchdogs,        */
/* (feature of several watchdogs not available on all STM32 series)).         */
/* - analog watchdog 1: monitored channel defined by number,                  */
/*   selection of ADC group (ADC groups regular and-or injected).             */
/* - analog watchdog 2 and 3: monitored channel defined by bitfield, no       */
/*   selection on groups.                                                     */

/* Internal register offset for ADC analog watchdog channel configuration */
#define ADC_AWD_CR1_REGOFFSET (0x00000000UL)
#define ADC_AWD_CR2_REGOFFSET (0x00100000UL)
#define ADC_AWD_CR3_REGOFFSET (0x00200000UL)

/* Register offset gap between AWD1 and AWD2-AWD3 configuration registers */
/* (Set separately as ADC_AWD_CRX_REGOFFSET to spare 32 bits space */
#define ADC_AWD_CR12_REGOFFSETGAP_MASK (ADC_AWD2CR_AWD2CH_0)
#define ADC_AWD_CR12_REGOFFSETGAP_VAL (0x00000024UL)

#define ADC_AWD_CRX_REGOFFSET_MASK (ADC_AWD_CR1_REGOFFSET | ADC_AWD_CR2_REGOFFSET | ADC_AWD_CR3_REGOFFSET)

#define ADC_AWD_CR1_CHANNEL_MASK (ADC_CFGR_AWD1CH | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)
#define ADC_AWD_CR23_CHANNEL_MASK (ADC_AWD2CR_AWD2CH)
#define ADC_AWD_CR_ALL_CHANNEL_MASK (ADC_AWD_CR1_CHANNEL_MASK | ADC_AWD_CR23_CHANNEL_MASK)

#define ADC_AWD_CRX_REGOFFSET_POS (20UL)


/* Internal register offset for ADC analog watchdog threshold configuration */
#define ADC_AWD_TR1_REGOFFSET (ADC_AWD_CR1_REGOFFSET)
#define ADC_AWD_TR2_REGOFFSET (ADC_AWD_CR2_REGOFFSET)
#define ADC_AWD_TR3_REGOFFSET (ADC_AWD_CR3_REGOFFSET)
#define ADC_AWD_TRX_REGOFFSET_MASK (ADC_AWD_TR1_REGOFFSET | ADC_AWD_TR2_REGOFFSET | ADC_AWD_TR3_REGOFFSET)
#define ADC_AWD_TRX_REGOFFSET_POS (ADC_AWD_CRX_REGOFFSET_POS)

#define ADC_AWD_TRX_BIT_HIGH_MASK (0x00010000UL)

#define ADC_AWD_TRX_BIT_HIGH_POS (16UL)

#define ADC_AWD_TRX_BIT_HIGH_SHIFT4 (ADC_AWD_TRX_BIT_HIGH_POS - 4UL)


/* Internal mask for ADC offset:                                              */
/* Internal register offset for ADC offset instance configuration */
#define ADC_OFR1_REGOFFSET (0x00000000UL)
#define ADC_OFR2_REGOFFSET (0x00000001UL)
#define ADC_OFR3_REGOFFSET (0x00000002UL)
#define ADC_OFR4_REGOFFSET (0x00000003UL)
#define ADC_OFRx_REGOFFSET_MASK (ADC_OFR1_REGOFFSET | ADC_OFR2_REGOFFSET | ADC_OFR3_REGOFFSET | ADC_OFR4_REGOFFSET)



/* ADC registers bits positions */
#define ADC_CFGR_RES_BITOFFSET_POS (ADC_CFGR_RES_Pos)
#define ADC_CFGR_AWD1SGL_BITOFFSET_POS (ADC_CFGR_AWD1SGL_Pos)
#define ADC_CFGR_AWD1EN_BITOFFSET_POS (ADC_CFGR_AWD1EN_Pos)
#define ADC_CFGR_JAWD1EN_BITOFFSET_POS (ADC_CFGR_JAWD1EN_Pos)
#define ADC_TR1_HT1_BITOFFSET_POS (ADC_TR1_HT1_Pos)


/* ADC registers bits groups */
#define ADC_CR_BITS_PROPERTY_RS (ADC_CR_ADCAL | ADC_CR_ADEN | ADC_CR_ADDIS | ADC_CR_JADSTART | ADC_CR_JADSTP | ADC_CR_ADSTART | ADC_CR_ADSTP)






/* ADC internal channels related definitions */
/* Internal voltage reference VrefInt */
#define VREFINT_CAL_ADDR ((uint16_t*) (0x1FFF75AAUL))


#define VREFINT_CAL_VREF (3000UL)


/* Temperature sensor */
#define TEMPSENSOR_CAL1_ADDR ((uint16_t*) (0x1FFF75A8UL))


#define TEMPSENSOR_CAL2_ADDR ((uint16_t*) (0x1FFF75CAUL))


#define TEMPSENSOR_CAL1_TEMP (30L)


#define TEMPSENSOR_CAL2_TEMP (110L)


#define TEMPSENSOR_CAL_VREFANALOG (3000UL)



/**
  * @}
  */


/* Private macros ------------------------------------------------------------*/
/** @defgroup ADC_LL_Private_Macros ADC Private Macros
  * @{
  */

/**
  * @brief  Driver macro reserved for internal use: set a pointer to
  *         a register from a register basis from which an offset
  *         is applied.
  * @param  __REG__ Register basis from which the offset is applied.
  * @param  __REG_OFFFSET__ Offset to be applied (unit: number of registers).
  * @retval Pointer to register address
  */
#define __ADC_PTR_REG_OFFSET(__REG__,__REG_OFFFSET__) ((__IO uint32_t *)((uint32_t) ((uint32_t)(&(__REG__)) + ((__REG_OFFFSET__) << 2UL))))


/**
  * @}
  */


/* Exported types ------------------------------------------------------------*/
# 634 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"

/* Exported constants --------------------------------------------------------*/
/** @defgroup ADC_LL_Exported_Constants ADC Exported Constants
  * @{
  */

/** @defgroup ADC_LL_EC_FLAG ADC flags
  * @brief    Flags defines which can be used with LL_ADC_ReadReg function
  * @{
  */
#define LL_ADC_FLAG_ADRDY ADC_ISR_ADRDY
#define LL_ADC_FLAG_EOC ADC_ISR_EOC

#define LL_ADC_FLAG_EOS ADC_ISR_EOS

#define LL_ADC_FLAG_OVR ADC_ISR_OVR
#define LL_ADC_FLAG_EOSMP ADC_ISR_EOSMP
#define LL_ADC_FLAG_JEOC ADC_ISR_JEOC

#define LL_ADC_FLAG_JEOS ADC_ISR_JEOS

#define LL_ADC_FLAG_JQOVF ADC_ISR_JQOVF

#define LL_ADC_FLAG_AWD1 ADC_ISR_AWD1
#define LL_ADC_FLAG_AWD2 ADC_ISR_AWD2
#define LL_ADC_FLAG_AWD3 ADC_ISR_AWD3

#define LL_ADC_FLAG_ADRDY_MST ADC_CSR_ADRDY_MST
#define LL_ADC_FLAG_ADRDY_SLV ADC_CSR_ADRDY_SLV
#define LL_ADC_FLAG_EOC_MST ADC_CSR_EOC_MST

#define LL_ADC_FLAG_EOC_SLV ADC_CSR_EOC_SLV

#define LL_ADC_FLAG_EOS_MST ADC_CSR_EOS_MST

#define LL_ADC_FLAG_EOS_SLV ADC_CSR_EOS_SLV

#define LL_ADC_FLAG_OVR_MST ADC_CSR_OVR_MST

#define LL_ADC_FLAG_OVR_SLV ADC_CSR_OVR_SLV

#define LL_ADC_FLAG_EOSMP_MST ADC_CSR_EOSMP_MST

#define LL_ADC_FLAG_EOSMP_SLV ADC_CSR_EOSMP_SLV

#define LL_ADC_FLAG_JEOC_MST ADC_CSR_JEOC_MST

#define LL_ADC_FLAG_JEOC_SLV ADC_CSR_JEOC_SLV

#define LL_ADC_FLAG_JEOS_MST ADC_CSR_JEOS_MST

#define LL_ADC_FLAG_JEOS_SLV ADC_CSR_JEOS_SLV

#define LL_ADC_FLAG_JQOVF_MST ADC_CSR_JQOVF_MST

#define LL_ADC_FLAG_JQOVF_SLV ADC_CSR_JQOVF_SLV

#define LL_ADC_FLAG_AWD1_MST ADC_CSR_AWD1_MST

#define LL_ADC_FLAG_AWD1_SLV ADC_CSR_AWD1_SLV

#define LL_ADC_FLAG_AWD2_MST ADC_CSR_AWD2_MST

#define LL_ADC_FLAG_AWD2_SLV ADC_CSR_AWD2_SLV

#define LL_ADC_FLAG_AWD3_MST ADC_CSR_AWD3_MST

#define LL_ADC_FLAG_AWD3_SLV ADC_CSR_AWD3_SLV


/**
  * @}
  */

/** @defgroup ADC_LL_EC_IT ADC interruptions for configuration (interruption enable or disable)
  * @brief    IT defines which can be used with LL_ADC_ReadReg and  LL_ADC_WriteReg functions
  * @{
  */
#define LL_ADC_IT_ADRDY ADC_IER_ADRDYIE
#define LL_ADC_IT_EOC ADC_IER_EOCIE

#define LL_ADC_IT_EOS ADC_IER_EOSIE

#define LL_ADC_IT_OVR ADC_IER_OVRIE
#define LL_ADC_IT_EOSMP ADC_IER_EOSMPIE

#define LL_ADC_IT_JEOC ADC_IER_JEOCIE

#define LL_ADC_IT_JEOS ADC_IER_JEOSIE

#define LL_ADC_IT_JQOVF ADC_IER_JQOVFIE

#define LL_ADC_IT_AWD1 ADC_IER_AWD1IE
#define LL_ADC_IT_AWD2 ADC_IER_AWD2IE
#define LL_ADC_IT_AWD3 ADC_IER_AWD3IE
/**
  * @}
  */

/** @defgroup ADC_LL_EC_REGISTERS  ADC registers compliant with specific purpose
  * @{
  */
/* List of ADC registers intended to be used (most commonly) with             */
/* DMA transfer.                                                              */
/* Refer to function @ref LL_ADC_DMA_GetRegAddr().                            */
#define LL_ADC_DMA_REG_REGULAR_DATA (0x00000000UL)





#define LL_ADC_DMA_REG_REGULAR_DATA_MULTI (0x00000001UL)





/**
  * @}
  */

/** @defgroup ADC_LL_EC_COMMON_CLOCK_SOURCE  ADC common - Clock source
  * @{
  */
#define LL_ADC_CLOCK_SYNC_PCLK_DIV1 (ADC_CCR_CKMODE_0)

#define LL_ADC_CLOCK_SYNC_PCLK_DIV2 (ADC_CCR_CKMODE_1)

#define LL_ADC_CLOCK_SYNC_PCLK_DIV4 (ADC_CCR_CKMODE_1 | ADC_CCR_CKMODE_0)

#define LL_ADC_CLOCK_ASYNC_DIV1 (0x00000000UL)

#define LL_ADC_CLOCK_ASYNC_DIV2 (ADC_CCR_PRESC_0)

#define LL_ADC_CLOCK_ASYNC_DIV4 (ADC_CCR_PRESC_1)

#define LL_ADC_CLOCK_ASYNC_DIV6 (ADC_CCR_PRESC_1 | ADC_CCR_PRESC_0)

#define LL_ADC_CLOCK_ASYNC_DIV8 (ADC_CCR_PRESC_2)

#define LL_ADC_CLOCK_ASYNC_DIV10 (ADC_CCR_PRESC_2 | ADC_CCR_PRESC_0)

#define LL_ADC_CLOCK_ASYNC_DIV12 (ADC_CCR_PRESC_2 | ADC_CCR_PRESC_1)

#define LL_ADC_CLOCK_ASYNC_DIV16 (ADC_CCR_PRESC_2 | ADC_CCR_PRESC_1 | ADC_CCR_PRESC_0)


#define LL_ADC_CLOCK_ASYNC_DIV32 (ADC_CCR_PRESC_3)

#define LL_ADC_CLOCK_ASYNC_DIV64 (ADC_CCR_PRESC_3 | ADC_CCR_PRESC_0)

#define LL_ADC_CLOCK_ASYNC_DIV128 (ADC_CCR_PRESC_3 | ADC_CCR_PRESC_1)

#define LL_ADC_CLOCK_ASYNC_DIV256 (ADC_CCR_PRESC_3 | ADC_CCR_PRESC_1 | ADC_CCR_PRESC_0)


/**
  * @}
  */

/** @defgroup ADC_LL_EC_COMMON_PATH_INTERNAL  ADC common - Measurement path to internal channels
  * @{
  */
/* Note: Other measurement paths to internal channels may be available        */
/*       (connections to other peripherals).                                  */
/*       If they are not listed below, they do not require any specific       */
/*       path enable. In this case, Access to measurement path is done        */
/*       only by selecting the corresponding ADC internal channel.            */
#define LL_ADC_PATH_INTERNAL_NONE (0x00000000UL)
#define LL_ADC_PATH_INTERNAL_VREFINT (ADC_CCR_VREFEN)
#define LL_ADC_PATH_INTERNAL_TEMPSENSOR (ADC_CCR_VSENSESEL)

#define LL_ADC_PATH_INTERNAL_VBAT (ADC_CCR_VBATSEL)
/**
  * @}
  */

/** @defgroup ADC_LL_EC_RESOLUTION  ADC instance - Resolution
  * @{
  */
#define LL_ADC_RESOLUTION_12B (0x00000000UL)
#define LL_ADC_RESOLUTION_10B ( ADC_CFGR_RES_0)
#define LL_ADC_RESOLUTION_8B (ADC_CFGR_RES_1 )
#define LL_ADC_RESOLUTION_6B (ADC_CFGR_RES_1 | ADC_CFGR_RES_0)
/**
  * @}
  */

/** @defgroup ADC_LL_EC_DATA_ALIGN  ADC instance - Data alignment
  * @{
  */
#define LL_ADC_DATA_ALIGN_RIGHT (0x00000000UL)

#define LL_ADC_DATA_ALIGN_LEFT (ADC_CFGR_ALIGN)

/**
  * @}
  */

/** @defgroup ADC_LL_EC_LP_MODE  ADC instance - Low power mode
  * @{
  */
#define LL_ADC_LP_MODE_NONE (0x00000000UL)
#define LL_ADC_LP_AUTOWAIT (ADC_CFGR_AUTDLY)



/**
  * @}
  */

/** @defgroup ADC_LL_EC_OFFSET_NB  ADC instance - Offset instance
  * @{
  */
#define LL_ADC_OFFSET_1 ADC_OFR1_REGOFFSET


#define LL_ADC_OFFSET_2 ADC_OFR2_REGOFFSET


#define LL_ADC_OFFSET_3 ADC_OFR3_REGOFFSET


#define LL_ADC_OFFSET_4 ADC_OFR4_REGOFFSET


/**
  * @}
  */

/** @defgroup ADC_LL_EC_OFFSET_STATE ADC instance - Offset state
  * @{
  */
#define LL_ADC_OFFSET_DISABLE (0x00000000UL)

#define LL_ADC_OFFSET_ENABLE (ADC_OFR1_OFFSET1_EN)

/**
  * @}
  */

/** @defgroup ADC_LL_EC_OFFSET_SIGN ADC instance - Offset sign
  * @{
  */
#define LL_ADC_OFFSET_SIGN_NEGATIVE (0x00000000UL)
#define LL_ADC_OFFSET_SIGN_POSITIVE (ADC_OFR1_OFFSETPOS)
/**
  * @}
  */

/** @defgroup ADC_LL_EC_OFFSET_SATURATION ADC instance - Offset saturation mode
  * @{
  */
#define LL_ADC_OFFSET_SATURATION_DISABLE (0x00000000UL)

#define LL_ADC_OFFSET_SATURATION_ENABLE (ADC_OFR1_SATEN)

/**
  * @}
  */
/** @defgroup ADC_LL_EC_GROUPS  ADC instance - Groups
  * @{
  */
#define LL_ADC_GROUP_REGULAR (0x00000001UL)
#define LL_ADC_GROUP_INJECTED (0x00000002UL)

#define LL_ADC_GROUP_REGULAR_INJECTED (0x00000003UL)
/**
  * @}
  */

/** @defgroup ADC_LL_EC_CHANNEL  ADC instance - Channel number
  * @{
  */
#define LL_ADC_CHANNEL_0 (ADC_CHANNEL_0_NUMBER | ADC_CHANNEL_0_SMP | ADC_CHANNEL_0_BITFIELD)

#define LL_ADC_CHANNEL_1 (ADC_CHANNEL_1_NUMBER | ADC_CHANNEL_1_SMP | ADC_CHANNEL_1_BITFIELD)

#define LL_ADC_CHANNEL_2 (ADC_CHANNEL_2_NUMBER | ADC_CHANNEL_2_SMP | ADC_CHANNEL_2_BITFIELD)

#define LL_ADC_CHANNEL_3 (ADC_CHANNEL_3_NUMBER | ADC_CHANNEL_3_SMP | ADC_CHANNEL_3_BITFIELD)

#define LL_ADC_CHANNEL_4 (ADC_CHANNEL_4_NUMBER | ADC_CHANNEL_4_SMP | ADC_CHANNEL_4_BITFIELD)

#define LL_ADC_CHANNEL_5 (ADC_CHANNEL_5_NUMBER | ADC_CHANNEL_5_SMP | ADC_CHANNEL_5_BITFIELD)

#define LL_ADC_CHANNEL_6 (ADC_CHANNEL_6_NUMBER | ADC_CHANNEL_6_SMP | ADC_CHANNEL_6_BITFIELD)

#define LL_ADC_CHANNEL_7 (ADC_CHANNEL_7_NUMBER | ADC_CHANNEL_7_SMP | ADC_CHANNEL_7_BITFIELD)

#define LL_ADC_CHANNEL_8 (ADC_CHANNEL_8_NUMBER | ADC_CHANNEL_8_SMP | ADC_CHANNEL_8_BITFIELD)

#define LL_ADC_CHANNEL_9 (ADC_CHANNEL_9_NUMBER | ADC_CHANNEL_9_SMP | ADC_CHANNEL_9_BITFIELD)

#define LL_ADC_CHANNEL_10 (ADC_CHANNEL_10_NUMBER | ADC_CHANNEL_10_SMP | ADC_CHANNEL_10_BITFIELD)

#define LL_ADC_CHANNEL_11 (ADC_CHANNEL_11_NUMBER | ADC_CHANNEL_11_SMP | ADC_CHANNEL_11_BITFIELD)

#define LL_ADC_CHANNEL_12 (ADC_CHANNEL_12_NUMBER | ADC_CHANNEL_12_SMP | ADC_CHANNEL_12_BITFIELD)

#define LL_ADC_CHANNEL_13 (ADC_CHANNEL_13_NUMBER | ADC_CHANNEL_13_SMP | ADC_CHANNEL_13_BITFIELD)

#define LL_ADC_CHANNEL_14 (ADC_CHANNEL_14_NUMBER | ADC_CHANNEL_14_SMP | ADC_CHANNEL_14_BITFIELD)

#define LL_ADC_CHANNEL_15 (ADC_CHANNEL_15_NUMBER | ADC_CHANNEL_15_SMP | ADC_CHANNEL_15_BITFIELD)

#define LL_ADC_CHANNEL_16 (ADC_CHANNEL_16_NUMBER | ADC_CHANNEL_16_SMP | ADC_CHANNEL_16_BITFIELD)

#define LL_ADC_CHANNEL_17 (ADC_CHANNEL_17_NUMBER | ADC_CHANNEL_17_SMP | ADC_CHANNEL_17_BITFIELD)

#define LL_ADC_CHANNEL_18 (ADC_CHANNEL_18_NUMBER | ADC_CHANNEL_18_SMP | ADC_CHANNEL_18_BITFIELD)

#define LL_ADC_CHANNEL_VREFINT (LL_ADC_CHANNEL_18 | ADC_CHANNEL_ID_INTERNAL_CH)


#define LL_ADC_CHANNEL_TEMPSENSOR_ADC1 (LL_ADC_CHANNEL_16 | ADC_CHANNEL_ID_INTERNAL_CH)


#define LL_ADC_CHANNEL_TEMPSENSOR_ADC5 (LL_ADC_CHANNEL_4 | ADC_CHANNEL_ID_INTERNAL_CH)



#define LL_ADC_CHANNEL_VBAT (LL_ADC_CHANNEL_17 | ADC_CHANNEL_ID_INTERNAL_CH)




#define LL_ADC_CHANNEL_VOPAMP1 (LL_ADC_CHANNEL_13 | ADC_CHANNEL_ID_INTERNAL_CH)


#define LL_ADC_CHANNEL_VOPAMP2 (LL_ADC_CHANNEL_16 | ADC_CHANNEL_ID_INTERNAL_CH | ADC_CHANNEL_ID_INTERNAL_CH_2)


#define LL_ADC_CHANNEL_VOPAMP3_ADC2 (LL_ADC_CHANNEL_18 | ADC_CHANNEL_ID_INTERNAL_CH | ADC_CHANNEL_ID_INTERNAL_CH_2)


#define LL_ADC_CHANNEL_VOPAMP3_ADC3 (LL_ADC_CHANNEL_13 | ADC_CHANNEL_ID_INTERNAL_CH | ADC_CHANNEL_ID_INTERNAL_CH_2)



#define LL_ADC_CHANNEL_VOPAMP4 (LL_ADC_CHANNEL_5 | ADC_CHANNEL_ID_INTERNAL_CH)


#define LL_ADC_CHANNEL_VOPAMP5 (LL_ADC_CHANNEL_3 | ADC_CHANNEL_ID_INTERNAL_CH)


#define LL_ADC_CHANNEL_VOPAMP6 (LL_ADC_CHANNEL_17 | ADC_CHANNEL_ID_INTERNAL_CH | ADC_CHANNEL_ID_INTERNAL_CH_2)




/**
  * @}
  */

/** @defgroup ADC_LL_EC_REG_TRIGGER_SOURCE  ADC group regular - Trigger source
  * @{
  */
#define LL_ADC_REG_TRIG_SOFTWARE (0x00000000UL)

#define LL_ADC_REG_TRIG_EXT_TIM1_TRGO (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_REG_TRIG_EXT_TIM1_TRGO2 (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_1 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_REG_TRIG_EXT_TIM1_CH1 (ADC_REG_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_REG_TRIG_EXT_TIM1_CH2 (ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_REG_TRIG_EXT_TIM1_CH3 (ADC_CFGR_EXTSEL_1 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_REG_TRIG_EXT_TIM2_TRGO (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_REG_TRIG_EXT_TIM2_CH1 (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)







#define LL_ADC_REG_TRIG_EXT_TIM2_CH2 (ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_REG_TRIG_EXT_TIM2_CH3 (ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_REG_TRIG_EXT_TIM3_TRGO (ADC_CFGR_EXTSEL_2 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)


#define LL_ADC_REG_TRIG_EXT_TIM3_CH1 (ADC_REG_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_REG_TRIG_EXT_TIM3_CH4 (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)







#define LL_ADC_REG_TRIG_EXT_TIM4_TRGO (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_2 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_REG_TRIG_EXT_TIM4_CH1 (ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_1 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_REG_TRIG_EXT_TIM4_CH4 (ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_REG_TRIG_EXT_TIM6_TRGO (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_REG_TRIG_EXT_TIM7_TRGO (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_1 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_REG_TRIG_EXT_TIM8_TRGO (ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_REG_TRIG_EXT_TIM8_TRGO2 (ADC_CFGR_EXTSEL_3 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)


#define LL_ADC_REG_TRIG_EXT_TIM8_CH1 (ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_REG_TRIG_EXT_TIM15_TRGO (ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_1 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_REG_TRIG_EXT_TIM20_TRGO (ADC_CFGR_EXTSEL_4 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)




#define LL_ADC_REG_TRIG_EXT_TIM20_TRGO2 (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_REG_TRIG_EXT_TIM20_CH1 (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_1 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_REG_TRIG_EXT_TIM20_CH2 (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)







#define LL_ADC_REG_TRIG_EXT_TIM20_CH3 (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_2 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)







#define LL_ADC_REG_TRIG_EXT_HRTIM_TRG1 (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_REG_TRIG_EXT_HRTIM_TRG2 (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_REG_TRIG_EXT_HRTIM_TRG3 (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_1 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_REG_TRIG_EXT_HRTIM_TRG4 (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_2 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_REG_TRIG_EXT_HRTIM_TRG5 (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_REG_TRIG_EXT_HRTIM_TRG6 (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_3 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_REG_TRIG_EXT_HRTIM_TRG7 (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_REG_TRIG_EXT_HRTIM_TRG8 (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_1 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_REG_TRIG_EXT_HRTIM_TRG9 (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_REG_TRIG_EXT_HRTIM_TRG10 (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_2 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_REG_TRIG_EXT_EXTI_LINE11 (ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_1 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_REG_TRIG_EXT_EXTI_LINE2 (ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_REG_TRIG_EXT_LPTIM_OUT (ADC_CFGR_EXTSEL_4 | ADC_CFGR_EXTSEL_3 | ADC_CFGR_EXTSEL_2 | ADC_CFGR_EXTSEL_0 | ADC_REG_TRIG_EXT_EDGE_DEFAULT)




/**
  * @}
  */

/** @defgroup ADC_LL_EC_REG_TRIGGER_EDGE  ADC group regular - Trigger edge
  * @{
  */
#define LL_ADC_REG_TRIG_EXT_RISING (ADC_CFGR_EXTEN_0)

#define LL_ADC_REG_TRIG_EXT_FALLING (ADC_CFGR_EXTEN_1)

#define LL_ADC_REG_TRIG_EXT_RISINGFALLING (ADC_CFGR_EXTEN_1 | ADC_CFGR_EXTEN_0)

/**
  * @}
  */

/** @defgroup ADC_LL_EC_REG_SAMPLING_MODE  ADC group regular - Sampling mode
  * @{
  */
#define LL_ADC_REG_SAMPLING_MODE_NORMAL (0x00000000UL)

#define LL_ADC_REG_SAMPLING_MODE_BULB (ADC_CFGR2_BULB)



#define LL_ADC_REG_SAMPLING_MODE_TRIGGER_CONTROLED (ADC_CFGR2_SMPTRIG)


/**
  * @}
  */

/** @defgroup ADC_LL_EC_REG_CONTINUOUS_MODE  ADC group regular - Continuous mode
  * @{
  */
#define LL_ADC_REG_CONV_SINGLE (0x00000000UL)

#define LL_ADC_REG_CONV_CONTINUOUS (ADC_CFGR_CONT)


/**
  * @}
  */

/** @defgroup ADC_LL_EC_REG_DMA_TRANSFER  ADC group regular - DMA transfer of ADC conversion data
  * @{
  */
#define LL_ADC_REG_DMA_TRANSFER_NONE (0x00000000UL)
#define LL_ADC_REG_DMA_TRANSFER_LIMITED (ADC_CFGR_DMAEN)



#define LL_ADC_REG_DMA_TRANSFER_UNLIMITED (ADC_CFGR_DMACFG | ADC_CFGR_DMAEN)



/**
  * @}
  */


/** @defgroup ADC_LL_EC_SAMPLINGTIME_COMMON_CONFIG ADC instance - ADC sampling time common configuration
  * @{
  */
#define LL_ADC_SAMPLINGTIME_COMMON_DEFAULT (0x00000000UL)
#define LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5 (ADC_SMPR1_SMPPLUS)



/**
  * @}
  */


/** @defgroup ADC_LL_EC_REG_OVR_DATA_BEHAVIOR  ADC group regular - Overrun behavior on conversion data
  * @{
  */
#define LL_ADC_REG_OVR_DATA_PRESERVED (0x00000000UL)

#define LL_ADC_REG_OVR_DATA_OVERWRITTEN (ADC_CFGR_OVRMOD)

/**
  * @}
  */

/** @defgroup ADC_LL_EC_REG_SEQ_SCAN_LENGTH  ADC group regular - Sequencer scan length
  * @{
  */
#define LL_ADC_REG_SEQ_SCAN_DISABLE (0x00000000UL)

#define LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS (ADC_SQR1_L_0)

#define LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS (ADC_SQR1_L_1)

#define LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS (ADC_SQR1_L_1 | ADC_SQR1_L_0)

#define LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS (ADC_SQR1_L_2)

#define LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS (ADC_SQR1_L_2 | ADC_SQR1_L_0)

#define LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS (ADC_SQR1_L_2 | ADC_SQR1_L_1)

#define LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS (ADC_SQR1_L_2 | ADC_SQR1_L_1 | ADC_SQR1_L_0)


#define LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS (ADC_SQR1_L_3)

#define LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS (ADC_SQR1_L_3 | ADC_SQR1_L_0)

#define LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS (ADC_SQR1_L_3 | ADC_SQR1_L_1)

#define LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS (ADC_SQR1_L_3 | ADC_SQR1_L_1 | ADC_SQR1_L_0)


#define LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS (ADC_SQR1_L_3 | ADC_SQR1_L_2)

#define LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS (ADC_SQR1_L_3 | ADC_SQR1_L_2 | ADC_SQR1_L_0)


#define LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS (ADC_SQR1_L_3 | ADC_SQR1_L_2 | ADC_SQR1_L_1)


#define LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS (ADC_SQR1_L_3 | ADC_SQR1_L_2 | ADC_SQR1_L_1 | ADC_SQR1_L_0)


/**
  * @}
  */

/** @defgroup ADC_LL_EC_REG_SEQ_DISCONT_MODE  ADC group regular - Sequencer discontinuous mode
  * @{
  */
#define LL_ADC_REG_SEQ_DISCONT_DISABLE (0x00000000UL)

#define LL_ADC_REG_SEQ_DISCONT_1RANK (ADC_CFGR_DISCEN)

#define LL_ADC_REG_SEQ_DISCONT_2RANKS (ADC_CFGR_DISCNUM_0 | ADC_CFGR_DISCEN)

#define LL_ADC_REG_SEQ_DISCONT_3RANKS (ADC_CFGR_DISCNUM_1 | ADC_CFGR_DISCEN)

#define LL_ADC_REG_SEQ_DISCONT_4RANKS (ADC_CFGR_DISCNUM_1 | ADC_CFGR_DISCNUM_0 | ADC_CFGR_DISCEN)


#define LL_ADC_REG_SEQ_DISCONT_5RANKS (ADC_CFGR_DISCNUM_2 | ADC_CFGR_DISCEN)

#define LL_ADC_REG_SEQ_DISCONT_6RANKS (ADC_CFGR_DISCNUM_2 | ADC_CFGR_DISCNUM_0 | ADC_CFGR_DISCEN)


#define LL_ADC_REG_SEQ_DISCONT_7RANKS (ADC_CFGR_DISCNUM_2 | ADC_CFGR_DISCNUM_1 | ADC_CFGR_DISCEN)


#define LL_ADC_REG_SEQ_DISCONT_8RANKS (ADC_CFGR_DISCNUM_2 | ADC_CFGR_DISCNUM_1 | ADC_CFGR_DISCNUM_0 | ADC_CFGR_DISCEN)


/**
  * @}
  */

/** @defgroup ADC_LL_EC_REG_SEQ_RANKS  ADC group regular - Sequencer ranks
  * @{
  */
#define LL_ADC_REG_RANK_1 (ADC_SQR1_REGOFFSET | ADC_REG_RANK_1_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_2 (ADC_SQR1_REGOFFSET | ADC_REG_RANK_2_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_3 (ADC_SQR1_REGOFFSET | ADC_REG_RANK_3_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_4 (ADC_SQR1_REGOFFSET | ADC_REG_RANK_4_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_5 (ADC_SQR2_REGOFFSET | ADC_REG_RANK_5_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_6 (ADC_SQR2_REGOFFSET | ADC_REG_RANK_6_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_7 (ADC_SQR2_REGOFFSET | ADC_REG_RANK_7_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_8 (ADC_SQR2_REGOFFSET | ADC_REG_RANK_8_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_9 (ADC_SQR2_REGOFFSET | ADC_REG_RANK_9_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_10 (ADC_SQR3_REGOFFSET | ADC_REG_RANK_10_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_11 (ADC_SQR3_REGOFFSET | ADC_REG_RANK_11_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_12 (ADC_SQR3_REGOFFSET | ADC_REG_RANK_12_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_13 (ADC_SQR3_REGOFFSET | ADC_REG_RANK_13_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_14 (ADC_SQR3_REGOFFSET | ADC_REG_RANK_14_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_15 (ADC_SQR4_REGOFFSET | ADC_REG_RANK_15_SQRX_BITOFFSET_POS)

#define LL_ADC_REG_RANK_16 (ADC_SQR4_REGOFFSET | ADC_REG_RANK_16_SQRX_BITOFFSET_POS)

/**
  * @}
  */

/** @defgroup ADC_LL_EC_INJ_TRIGGER_SOURCE  ADC group injected - Trigger source
  * @{
  */
#define LL_ADC_INJ_TRIG_SOFTWARE (0x00000000UL)

#define LL_ADC_INJ_TRIG_EXT_TIM1_TRGO (ADC_INJ_TRIG_EXT_EDGE_DEFAULT)


#define LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2 (ADC_JSQR_JEXTSEL_3 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)


#define LL_ADC_INJ_TRIG_EXT_TIM1_CH3 (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_1 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_INJ_TRIG_EXT_TIM1_CH4 (ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_INJ_TRIG_EXT_TIM2_TRGO (ADC_JSQR_JEXTSEL_1 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)


#define LL_ADC_INJ_TRIG_EXT_TIM2_CH1 (ADC_JSQR_JEXTSEL_1 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_INJ_TRIG_EXT_TIM3_TRGO (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_2 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_INJ_TRIG_EXT_TIM3_CH1 (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_INJ_TRIG_EXT_TIM3_CH3 (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_1 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_INJ_TRIG_EXT_TIM3_CH4 (ADC_JSQR_JEXTSEL_2 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_INJ_TRIG_EXT_TIM4_TRGO (ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_INJ_TRIG_EXT_TIM4_CH3 (ADC_JSQR_JEXTSEL_2 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_INJ_TRIG_EXT_TIM4_CH4 (ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_1 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_INJ_TRIG_EXT_TIM6_TRGO (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_1 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_INJ_TRIG_EXT_TIM7_TRGO (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_1 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_INJ_TRIG_EXT_TIM8_TRGO (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2 (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_1 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_INJ_TRIG_EXT_TIM8_CH2 (ADC_JSQR_JEXTSEL_1 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_INJ_TRIG_EXT_TIM8_CH4 (ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_1 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)




#define LL_ADC_INJ_TRIG_EXT_TIM15_TRGO (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_1 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)



#define LL_ADC_INJ_TRIG_EXT_TIM16_CH1 (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_1 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_INJ_TRIG_EXT_TIM20_TRGO (ADC_JSQR_JEXTSEL_4 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)




#define LL_ADC_INJ_TRIG_EXT_TIM20_TRGO2 (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_INJ_TRIG_EXT_TIM20_CH2 (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_1 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_INJ_TRIG_EXT_TIM20_CH4 (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_1 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_INJ_TRIG_EXT_HRTIM_TRG1 (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_1 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_INJ_TRIG_EXT_HRTIM_TRG2 (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_1 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_INJ_TRIG_EXT_HRTIM_TRG3 (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_2 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)






#define LL_ADC_INJ_TRIG_EXT_HRTIM_TRG4 (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_2 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_INJ_TRIG_EXT_HRTIM_TRG5 (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_INJ_TRIG_EXT_HRTIM_TRG6 (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_1 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_INJ_TRIG_EXT_HRTIM_TRG7 (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_1 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_INJ_TRIG_EXT_HRTIM_TRG8 (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_3 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_INJ_TRIG_EXT_HRTIM_TRG9 (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_INJ_TRIG_EXT_HRTIM_TRG10 (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_1 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_INJ_TRIG_EXT_EXTI_LINE3 (ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_INJ_TRIG_EXT_EXTI_LINE15 (ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_1 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)





#define LL_ADC_INJ_TRIG_EXT_LPTIM_OUT (ADC_JSQR_JEXTSEL_4 | ADC_JSQR_JEXTSEL_3 | ADC_JSQR_JEXTSEL_2 | ADC_JSQR_JEXTSEL_0 | ADC_INJ_TRIG_EXT_EDGE_DEFAULT)



/**
  * @}
  */

/** @defgroup ADC_LL_EC_INJ_TRIGGER_EDGE  ADC group injected - Trigger edge
  * @{
  */
#define LL_ADC_INJ_TRIG_EXT_RISING ( ADC_JSQR_JEXTEN_0)

#define LL_ADC_INJ_TRIG_EXT_FALLING (ADC_JSQR_JEXTEN_1 )

#define LL_ADC_INJ_TRIG_EXT_RISINGFALLING (ADC_JSQR_JEXTEN_1 | ADC_JSQR_JEXTEN_0)

/**
  * @}
  */

/** @defgroup ADC_LL_EC_INJ_TRIG_AUTO  ADC group injected - Automatic trigger mode
  * @{
  */
#define LL_ADC_INJ_TRIG_INDEPENDENT (0x00000000UL)


#define LL_ADC_INJ_TRIG_FROM_GRP_REGULAR (ADC_CFGR_JAUTO)




/**
  * @}
  */

/** @defgroup ADC_LL_EC_INJ_CONTEXT_QUEUE  ADC group injected - Context queue mode
  * @{
  */
#define LL_ADC_INJ_QUEUE_2CONTEXTS_LAST_ACTIVE (0x00000000UL)


#define LL_ADC_INJ_QUEUE_2CONTEXTS_END_EMPTY (ADC_CFGR_JQM)


#define LL_ADC_INJ_QUEUE_DISABLE (ADC_CFGR_JQDIS)

/**
  * @}
  */

/** @defgroup ADC_LL_EC_INJ_SEQ_SCAN_LENGTH  ADC group injected - Sequencer scan length
  * @{
  */
#define LL_ADC_INJ_SEQ_SCAN_DISABLE (0x00000000UL)

#define LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS ( ADC_JSQR_JL_0)

#define LL_ADC_INJ_SEQ_SCAN_ENABLE_3RANKS (ADC_JSQR_JL_1 )

#define LL_ADC_INJ_SEQ_SCAN_ENABLE_4RANKS (ADC_JSQR_JL_1 | ADC_JSQR_JL_0)

/**
  * @}
  */

/** @defgroup ADC_LL_EC_INJ_SEQ_DISCONT_MODE  ADC group injected - Sequencer discontinuous mode
  * @{
  */
#define LL_ADC_INJ_SEQ_DISCONT_DISABLE (0x00000000UL)

#define LL_ADC_INJ_SEQ_DISCONT_1RANK (ADC_CFGR_JDISCEN)

/**
  * @}
  */

/** @defgroup ADC_LL_EC_INJ_SEQ_RANKS  ADC group injected - Sequencer ranks
  * @{
  */
#define LL_ADC_INJ_RANK_1 (ADC_JDR1_REGOFFSET | ADC_INJ_RANK_1_JSQR_BITOFFSET_POS)

#define LL_ADC_INJ_RANK_2 (ADC_JDR2_REGOFFSET | ADC_INJ_RANK_2_JSQR_BITOFFSET_POS)

#define LL_ADC_INJ_RANK_3 (ADC_JDR3_REGOFFSET | ADC_INJ_RANK_3_JSQR_BITOFFSET_POS)

#define LL_ADC_INJ_RANK_4 (ADC_JDR4_REGOFFSET | ADC_INJ_RANK_4_JSQR_BITOFFSET_POS)

/**
  * @}
  */

/** @defgroup ADC_LL_EC_CHANNEL_SAMPLINGTIME  Channel - Sampling time
  * @{
  */
#define LL_ADC_SAMPLINGTIME_2CYCLES_5 (0x00000000UL)
#define LL_ADC_SAMPLINGTIME_6CYCLES_5 (ADC_SMPR2_SMP10_0)
#define LL_ADC_SAMPLINGTIME_12CYCLES_5 (ADC_SMPR2_SMP10_1)
#define LL_ADC_SAMPLINGTIME_24CYCLES_5 (ADC_SMPR2_SMP10_1 | ADC_SMPR2_SMP10_0)

#define LL_ADC_SAMPLINGTIME_47CYCLES_5 (ADC_SMPR2_SMP10_2)
#define LL_ADC_SAMPLINGTIME_92CYCLES_5 (ADC_SMPR2_SMP10_2 | ADC_SMPR2_SMP10_0)

#define LL_ADC_SAMPLINGTIME_247CYCLES_5 (ADC_SMPR2_SMP10_2 | ADC_SMPR2_SMP10_1)

#define LL_ADC_SAMPLINGTIME_640CYCLES_5 (ADC_SMPR2_SMP10_2 | ADC_SMPR2_SMP10_1 | ADC_SMPR2_SMP10_0)


/**
  * @}
  */

/** @defgroup ADC_LL_EC_CHANNEL_SINGLE_DIFF_ENDING  Channel - Single or differential ending
  * @{
  */
#define LL_ADC_SINGLE_ENDED ( ADC_CALFACT_CALFACT_S)

#define LL_ADC_DIFFERENTIAL_ENDED (ADC_CR_ADCALDIF | ADC_CALFACT_CALFACT_D)

#define LL_ADC_BOTH_SINGLE_DIFF_ENDED (LL_ADC_SINGLE_ENDED | LL_ADC_DIFFERENTIAL_ENDED)


/**
  * @}
  */

/** @defgroup ADC_LL_EC_AWD_NUMBER Analog watchdog - Analog watchdog number
  * @{
  */
#define LL_ADC_AWD1 (ADC_AWD_CR1_CHANNEL_MASK | ADC_AWD_CR1_REGOFFSET)

#define LL_ADC_AWD2 (ADC_AWD_CR23_CHANNEL_MASK | ADC_AWD_CR2_REGOFFSET)

#define LL_ADC_AWD3 (ADC_AWD_CR23_CHANNEL_MASK | ADC_AWD_CR3_REGOFFSET)

/**
  * @}
  */

/** @defgroup ADC_LL_EC_AWD_CHANNELS  Analog watchdog - Monitored channels
  * @{
  */
#define LL_ADC_AWD_DISABLE (0x00000000UL)

#define LL_ADC_AWD_ALL_CHANNELS_REG (ADC_AWD_CR23_CHANNEL_MASK | ADC_CFGR_AWD1EN)


#define LL_ADC_AWD_ALL_CHANNELS_INJ (ADC_AWD_CR23_CHANNEL_MASK | ADC_CFGR_JAWD1EN)


#define LL_ADC_AWD_ALL_CHANNELS_REG_INJ (ADC_AWD_CR23_CHANNEL_MASK | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN)


#define LL_ADC_AWD_CHANNEL_0_REG ((LL_ADC_CHANNEL_0 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_0_INJ ((LL_ADC_CHANNEL_0 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_0_REG_INJ ((LL_ADC_CHANNEL_0 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_1_REG ((LL_ADC_CHANNEL_1 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_1_INJ ((LL_ADC_CHANNEL_1 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_1_REG_INJ ((LL_ADC_CHANNEL_1 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_2_REG ((LL_ADC_CHANNEL_2 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_2_INJ ((LL_ADC_CHANNEL_2 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_2_REG_INJ ((LL_ADC_CHANNEL_2 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_3_REG ((LL_ADC_CHANNEL_3 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_3_INJ ((LL_ADC_CHANNEL_3 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_3_REG_INJ ((LL_ADC_CHANNEL_3 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_4_REG ((LL_ADC_CHANNEL_4 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_4_INJ ((LL_ADC_CHANNEL_4 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_4_REG_INJ ((LL_ADC_CHANNEL_4 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_5_REG ((LL_ADC_CHANNEL_5 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_5_INJ ((LL_ADC_CHANNEL_5 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_5_REG_INJ ((LL_ADC_CHANNEL_5 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_6_REG ((LL_ADC_CHANNEL_6 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_6_INJ ((LL_ADC_CHANNEL_6 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_6_REG_INJ ((LL_ADC_CHANNEL_6 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_7_REG ((LL_ADC_CHANNEL_7 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_7_INJ ((LL_ADC_CHANNEL_7 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_7_REG_INJ ((LL_ADC_CHANNEL_7 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_8_REG ((LL_ADC_CHANNEL_8 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_8_INJ ((LL_ADC_CHANNEL_8 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_8_REG_INJ ((LL_ADC_CHANNEL_8 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_9_REG ((LL_ADC_CHANNEL_9 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_9_INJ ((LL_ADC_CHANNEL_9 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_9_REG_INJ ((LL_ADC_CHANNEL_9 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_10_REG ((LL_ADC_CHANNEL_10 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_10_INJ ((LL_ADC_CHANNEL_10 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_10_REG_INJ ((LL_ADC_CHANNEL_10 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_11_REG ((LL_ADC_CHANNEL_11 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_11_INJ ((LL_ADC_CHANNEL_11 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_11_REG_INJ ((LL_ADC_CHANNEL_11 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_12_REG ((LL_ADC_CHANNEL_12 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_12_INJ ((LL_ADC_CHANNEL_12 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_12_REG_INJ ((LL_ADC_CHANNEL_12 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_13_REG ((LL_ADC_CHANNEL_13 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_13_INJ ((LL_ADC_CHANNEL_13 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_13_REG_INJ ((LL_ADC_CHANNEL_13 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_14_REG ((LL_ADC_CHANNEL_14 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_14_INJ ((LL_ADC_CHANNEL_14 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_14_REG_INJ ((LL_ADC_CHANNEL_14 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_15_REG ((LL_ADC_CHANNEL_15 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_15_INJ ((LL_ADC_CHANNEL_15 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_15_REG_INJ ((LL_ADC_CHANNEL_15 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)




#define LL_ADC_AWD_CHANNEL_16_REG ((LL_ADC_CHANNEL_16 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_16_INJ ((LL_ADC_CHANNEL_16 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_16_REG_INJ ((LL_ADC_CHANNEL_16 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_17_REG ((LL_ADC_CHANNEL_17 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_17_INJ ((LL_ADC_CHANNEL_17 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_17_REG_INJ ((LL_ADC_CHANNEL_17 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CHANNEL_18_REG ((LL_ADC_CHANNEL_18 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_18_INJ ((LL_ADC_CHANNEL_18 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CHANNEL_18_REG_INJ ((LL_ADC_CHANNEL_18 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VREFINT_REG ((LL_ADC_CHANNEL_VREFINT & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VREFINT_INJ ((LL_ADC_CHANNEL_VREFINT & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VREFINT_REG_INJ ((LL_ADC_CHANNEL_VREFINT & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)




#define LL_ADC_AWD_CH_TEMPSENSOR_ADC1_REG ((LL_ADC_CHANNEL_TEMPSENSOR_ADC1 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_TEMPSENSOR_ADC1_INJ ((LL_ADC_CHANNEL_TEMPSENSOR_ADC1 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_TEMPSENSOR_ADC1_REG_INJ ((LL_ADC_CHANNEL_TEMPSENSOR_ADC1 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)




#define LL_ADC_AWD_CH_TEMPSENSOR_ADC5_REG ((LL_ADC_CHANNEL_TEMPSENSOR_ADC5 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_TEMPSENSOR_ADC5_INJ ((LL_ADC_CHANNEL_TEMPSENSOR_ADC5 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_TEMPSENSOR_ADC5_REG_INJ ((LL_ADC_CHANNEL_TEMPSENSOR_ADC5 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)




#define LL_ADC_AWD_CH_VBAT_REG ((LL_ADC_CHANNEL_VBAT & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)




#define LL_ADC_AWD_CH_VBAT_INJ ((LL_ADC_CHANNEL_VBAT & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)




#define LL_ADC_AWD_CH_VBAT_REG_INJ ((LL_ADC_CHANNEL_VBAT & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)





#define LL_ADC_AWD_CH_VOPAMP1_REG ((LL_ADC_CHANNEL_VOPAMP1 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VOPAMP1_INJ ((LL_ADC_CHANNEL_VOPAMP1 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VOPAMP1_REG_INJ ((LL_ADC_CHANNEL_VOPAMP1 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)




#define LL_ADC_AWD_CH_VOPAMP2_REG ((LL_ADC_CHANNEL_VOPAMP2 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)


#define LL_ADC_AWD_CH_VOPAMP2_INJ ((LL_ADC_CHANNEL_VOPAMP2 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VOPAMP2_REG_INJ ((LL_ADC_CHANNEL_VOPAMP2 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)




#define LL_ADC_AWD_CH_VOPAMP3_ADC2_REG ((LL_ADC_CHANNEL_VOPAMP3_ADC2 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VOPAMP3_ADC2_INJ ((LL_ADC_CHANNEL_VOPAMP3_ADC2 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VOPAMP3_ADC2_REG_INJ ((LL_ADC_CHANNEL_VOPAMP3_ADC2 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)




#define LL_ADC_AWD_CH_VOPAMP3_ADC3_REG ((LL_ADC_CHANNEL_VOPAMP3_ADC3 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VOPAMP3_ADC3_INJ ((LL_ADC_CHANNEL_VOPAMP3_ADC3 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VOPAMP3_ADC3_REG_INJ ((LL_ADC_CHANNEL_VOPAMP3_ADC3 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)




#define LL_ADC_AWD_CH_VOPAMP4_REG ((LL_ADC_CHANNEL_VOPAMP4 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VOPAMP4_INJ ((LL_ADC_CHANNEL_VOPAMP4 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VOPAMP4_REG_INJ ((LL_ADC_CHANNEL_VOPAMP4 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)




#define LL_ADC_AWD_CH_VOPAMP5_REG ((LL_ADC_CHANNEL_VOPAMP5 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VOPAMP5_INJ ((LL_ADC_CHANNEL_VOPAMP5 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VOPAMP5_REG_INJ ((LL_ADC_CHANNEL_VOPAMP5 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)




#define LL_ADC_AWD_CH_VOPAMP6_REG ((LL_ADC_CHANNEL_VOPAMP6 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VOPAMP6_INJ ((LL_ADC_CHANNEL_VOPAMP6 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL)



#define LL_ADC_AWD_CH_VOPAMP6_REG_INJ ((LL_ADC_CHANNEL_VOPAMP6 & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)




/**
  * @}
  */

/** @defgroup ADC_LL_EC_AWD_THRESHOLDS  Analog watchdog - Thresholds
  * @{
  */
#define LL_ADC_AWD_THRESHOLD_HIGH (ADC_TR1_HT1)
#define LL_ADC_AWD_THRESHOLD_LOW (ADC_TR1_LT1)
#define LL_ADC_AWD_THRESHOLDS_HIGH_LOW (ADC_TR1_HT1 | ADC_TR1_LT1)


/**
  * @}
  */

/** @defgroup ADC_LL_EC_AWD_FILTERING_CONFIG  Analog watchdog - filtering config
  * @{
  */
#define LL_ADC_AWD_FILTERING_NONE (0x00000000UL)

#define LL_ADC_AWD_FILTERING_2SAMPLES (ADC_TR1_AWDFILT_0)

#define LL_ADC_AWD_FILTERING_3SAMPLES (ADC_TR1_AWDFILT_1)

#define LL_ADC_AWD_FILTERING_4SAMPLES (ADC_TR1_AWDFILT_1 | ADC_TR1_AWDFILT_0)

#define LL_ADC_AWD_FILTERING_5SAMPLES (ADC_TR1_AWDFILT_2)

#define LL_ADC_AWD_FILTERING_6SAMPLES (ADC_TR1_AWDFILT_2 | ADC_TR1_AWDFILT_0)

#define LL_ADC_AWD_FILTERING_7SAMPLES (ADC_TR1_AWDFILT_2 | ADC_TR1_AWDFILT_1)

#define LL_ADC_AWD_FILTERING_8SAMPLES (ADC_TR1_AWDFILT_2 | ADC_TR1_AWDFILT_1 | ADC_TR1_AWDFILT_0)


/**
  * @}
  */

/** @defgroup ADC_LL_EC_OVS_SCOPE  Oversampling - Oversampling scope
  * @{
  */
#define LL_ADC_OVS_DISABLE (0x00000000UL)
#define LL_ADC_OVS_GRP_REGULAR_CONTINUED (ADC_CFGR2_ROVSE)



#define LL_ADC_OVS_GRP_REGULAR_RESUMED (ADC_CFGR2_ROVSM | ADC_CFGR2_ROVSE)



#define LL_ADC_OVS_GRP_INJECTED (ADC_CFGR2_JOVSE)

#define LL_ADC_OVS_GRP_INJ_REG_RESUMED (ADC_CFGR2_JOVSE | ADC_CFGR2_ROVSE)



/**
  * @}
  */

/** @defgroup ADC_LL_EC_OVS_DISCONT_MODE  Oversampling - Discontinuous mode
  * @{
  */
#define LL_ADC_OVS_REG_CONT (0x00000000UL)

#define LL_ADC_OVS_REG_DISCONT (ADC_CFGR2_TROVS)

/**
  * @}
  */

/** @defgroup ADC_LL_EC_OVS_RATIO  Oversampling - Ratio
  * @{
  */
#define LL_ADC_OVS_RATIO_2 (0x00000000UL)


#define LL_ADC_OVS_RATIO_4 (ADC_CFGR2_OVSR_0)


#define LL_ADC_OVS_RATIO_8 (ADC_CFGR2_OVSR_1)


#define LL_ADC_OVS_RATIO_16 (ADC_CFGR2_OVSR_1 | ADC_CFGR2_OVSR_0)


#define LL_ADC_OVS_RATIO_32 (ADC_CFGR2_OVSR_2)


#define LL_ADC_OVS_RATIO_64 (ADC_CFGR2_OVSR_2 | ADC_CFGR2_OVSR_0)


#define LL_ADC_OVS_RATIO_128 (ADC_CFGR2_OVSR_2 | ADC_CFGR2_OVSR_1)


#define LL_ADC_OVS_RATIO_256 (ADC_CFGR2_OVSR_2 | ADC_CFGR2_OVSR_1 | ADC_CFGR2_OVSR_0)



/**
  * @}
  */

/** @defgroup ADC_LL_EC_OVS_SHIFT  Oversampling - Data right shift
  * @{
  */
#define LL_ADC_OVS_SHIFT_NONE (0x00000000UL)


#define LL_ADC_OVS_SHIFT_RIGHT_1 (ADC_CFGR2_OVSS_0)


#define LL_ADC_OVS_SHIFT_RIGHT_2 (ADC_CFGR2_OVSS_1)


#define LL_ADC_OVS_SHIFT_RIGHT_3 (ADC_CFGR2_OVSS_1 | ADC_CFGR2_OVSS_0)


#define LL_ADC_OVS_SHIFT_RIGHT_4 (ADC_CFGR2_OVSS_2)


#define LL_ADC_OVS_SHIFT_RIGHT_5 (ADC_CFGR2_OVSS_2 | ADC_CFGR2_OVSS_0)


#define LL_ADC_OVS_SHIFT_RIGHT_6 (ADC_CFGR2_OVSS_2 | ADC_CFGR2_OVSS_1)


#define LL_ADC_OVS_SHIFT_RIGHT_7 (ADC_CFGR2_OVSS_2 | ADC_CFGR2_OVSS_1 | ADC_CFGR2_OVSS_0)



#define LL_ADC_OVS_SHIFT_RIGHT_8 (ADC_CFGR2_OVSS_3)


/**
  * @}
  */


/** @defgroup ADC_LL_EC_MULTI_MODE  Multimode - Mode
  * @{
  */
#define LL_ADC_MULTI_INDEPENDENT (0x00000000UL)

#define LL_ADC_MULTI_DUAL_REG_SIMULT (ADC_CCR_DUAL_2 | ADC_CCR_DUAL_1)

#define LL_ADC_MULTI_DUAL_REG_INTERL (ADC_CCR_DUAL_2 | ADC_CCR_DUAL_1 | ADC_CCR_DUAL_0)


#define LL_ADC_MULTI_DUAL_INJ_SIMULT (ADC_CCR_DUAL_2 | ADC_CCR_DUAL_0)

#define LL_ADC_MULTI_DUAL_INJ_ALTERN (ADC_CCR_DUAL_3 | ADC_CCR_DUAL_0)

#define LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM (ADC_CCR_DUAL_0)

#define LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT (ADC_CCR_DUAL_1)

#define LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM (ADC_CCR_DUAL_1 | ADC_CCR_DUAL_0)

/**
  * @}
  */

/** @defgroup ADC_LL_EC_MULTI_DMA_TRANSFER  Multimode - DMA transfer
  * @{
  */
#define LL_ADC_MULTI_REG_DMA_EACH_ADC (0x00000000UL)


#define LL_ADC_MULTI_REG_DMA_LIMIT_RES12_10B (ADC_CCR_MDMA_1)





#define LL_ADC_MULTI_REG_DMA_LIMIT_RES8_6B (ADC_CCR_MDMA_1 | ADC_CCR_MDMA_0)





#define LL_ADC_MULTI_REG_DMA_UNLMT_RES12_10B (ADC_CCR_DMACFG | ADC_CCR_MDMA_1)





#define LL_ADC_MULTI_REG_DMA_UNLMT_RES8_6B (ADC_CCR_DMACFG | ADC_CCR_MDMA_1 | ADC_CCR_MDMA_0)






/**
  * @}
  */

/** @defgroup ADC_LL_EC_MULTI_TWOSMP_DELAY  Multimode - Delay between two sampling phases
  * @{
  */
#define LL_ADC_MULTI_TWOSMP_DELAY_1CYCLE (0x00000000UL)

#define LL_ADC_MULTI_TWOSMP_DELAY_2CYCLES (ADC_CCR_DELAY_0)

#define LL_ADC_MULTI_TWOSMP_DELAY_3CYCLES (ADC_CCR_DELAY_1)

#define LL_ADC_MULTI_TWOSMP_DELAY_4CYCLES (ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0)

#define LL_ADC_MULTI_TWOSMP_DELAY_5CYCLES (ADC_CCR_DELAY_2)

#define LL_ADC_MULTI_TWOSMP_DELAY_6CYCLES (ADC_CCR_DELAY_2 | ADC_CCR_DELAY_0)

#define LL_ADC_MULTI_TWOSMP_DELAY_7CYCLES (ADC_CCR_DELAY_2 | ADC_CCR_DELAY_1)

#define LL_ADC_MULTI_TWOSMP_DELAY_8CYCLES (ADC_CCR_DELAY_2 | ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0)


#define LL_ADC_MULTI_TWOSMP_DELAY_9CYCLES (ADC_CCR_DELAY_3)

#define LL_ADC_MULTI_TWOSMP_DELAY_10CYCLES (ADC_CCR_DELAY_3 | ADC_CCR_DELAY_0)

#define LL_ADC_MULTI_TWOSMP_DELAY_11CYCLES (ADC_CCR_DELAY_3 | ADC_CCR_DELAY_1)

#define LL_ADC_MULTI_TWOSMP_DELAY_12CYCLES (ADC_CCR_DELAY_3 | ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0)


/**
  * @}
  */

/** @defgroup ADC_LL_EC_MULTI_MASTER_SLAVE  Multimode - ADC master or slave
  * @{
  */
#define LL_ADC_MULTI_MASTER (ADC_CDR_RDATA_MST)

#define LL_ADC_MULTI_SLAVE (ADC_CDR_RDATA_SLV)

#define LL_ADC_MULTI_MASTER_SLAVE (ADC_CDR_RDATA_SLV | ADC_CDR_RDATA_MST)


/**
  * @}
  */



/** @defgroup ADC_LL_EC_HELPER_MACRO  Definitions of constants used by helper macro
  * @{
  */
#define LL_ADC_TEMPERATURE_CALC_ERROR ((int16_t)0x7FFF)




/**
  * @}
  */

/** @defgroup ADC_LL_EC_HW_DELAYS  Definitions of ADC hardware constraints delays
  * @note   Only ADC peripheral HW delays are defined in ADC LL driver driver,
  *         not timeout values.
  *         For details on delays values, refer to descriptions in source code
  *         above each literal definition.
  * @{
  */

/* Note: Only ADC peripheral HW delays are defined in ADC LL driver driver,   */
/*       not timeout values.                                                  */
/*       Timeout values for ADC operations are dependent to device clock      */
/*       configuration (system clock versus ADC clock),                       */
/*       and therefore must be defined in user application.                   */
/*       Indications for estimation of ADC timeout delays, for this           */
/*       STM32 series:                                                        */
/*       - ADC calibration time: maximum delay is 112/fADC.                   */
/*         (refer to device datasheet, parameter "tCAL")                      */
/*       - ADC enable time: maximum delay is 1 conversion cycle.              */
/*         (refer to device datasheet, parameter "tSTAB")                     */
/*       - ADC disable time: maximum delay should be a few ADC clock cycles   */
/*       - ADC stop conversion time: maximum delay should be a few ADC clock  */
/*         cycles                                                             */
/*       - ADC conversion time: duration depending on ADC clock and ADC       */
/*         configuration.                                                     */
/*         (refer to device reference manual, section "Timing")               */

/* Delay for ADC stabilization time (ADC voltage regulator start-up time)     */
/* Delay set to maximum value (refer to device datasheet,                     */
/* parameter "tADCVREG_STUP").                                                */
/* Unit: us                                                                   */
#define LL_ADC_DELAY_INTERNAL_REGUL_STAB_US ( 20UL)


/* Delay for internal voltage reference stabilization time.                   */
/* Delay set to maximum value (refer to device datasheet,                     */
/* parameter "tstart_vrefint").                                               */
/* Unit: us                                                                   */
#define LL_ADC_DELAY_VREFINT_STAB_US ( 12UL)


/* Delay for temperature sensor stabilization time.                           */
/* Literal set to maximum value (refer to device datasheet,                   */
/* parameter "tSTART").                                                       */
/* Unit: us                                                                   */
#define LL_ADC_DELAY_TEMPSENSOR_STAB_US (120UL)
#define LL_ADC_DELAY_TEMPSENSOR_BUFFER_STAB_US ( 15UL)



/* Delay required between ADC end of calibration and ADC enable.              */
/* Note: On this STM32 series, a minimum number of ADC clock cycles           */
/*       are required between ADC end of calibration and ADC enable.          */
/*       Wait time can be computed in user application by waiting for the     */
/*       equivalent number of CPU cycles, by taking into account              */
/*       ratio of CPU clock versus ADC clock prescalers.                      */
/* Unit: ADC clock cycles.                                                    */
#define LL_ADC_DELAY_CALIB_ENABLE_ADC_CYCLES ( 4UL)


/**
  * @}
  */

/**
  * @}
  */


/* Exported macro ------------------------------------------------------------*/
/** @defgroup ADC_LL_Exported_Macros ADC Exported Macros
  * @{
  */

/** @defgroup ADC_LL_EM_WRITE_READ Common write and read registers Macros
  * @{
  */

/**
  * @brief  Write a value in ADC register
  * @param  __INSTANCE__ ADC Instance
  * @param  __REG__ Register to be written
  * @param  __VALUE__ Value to be written in the register
  * @retval None
  */
#define LL_ADC_WriteReg(__INSTANCE__,__REG__,__VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))

/**
  * @brief  Read a value in ADC register
  * @param  __INSTANCE__ ADC Instance
  * @param  __REG__ Register to be read
  * @retval Register value
  */
#define LL_ADC_ReadReg(__INSTANCE__,__REG__) READ_REG(__INSTANCE__->__REG__)
/**
  * @}
  */

/** @defgroup ADC_LL_EM_HELPER_MACRO ADC helper macro
  * @{
  */

/**
  * @brief  Helper macro to get ADC channel number in decimal format
  *         from literals LL_ADC_CHANNEL_x.
  * @note   Example:
  *           __LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_CHANNEL_4)
  *           will return decimal number "4".
  * @note   The input can be a value from functions where a channel
  *         number is returned, either defined with number
  *         or with bitfield (only one bit must be set).
  * @param  __CHANNEL__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  * @retval Value between Min_Data=0 and Max_Data=18
  */
#define __LL_ADC_CHANNEL_TO_DECIMAL_NB(__CHANNEL__) ((((__CHANNEL__) & ADC_CHANNEL_ID_BITFIELD_MASK) == 0UL) ? ( ((__CHANNEL__) & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS ) : ( (uint32_t)POSITION_VAL((__CHANNEL__)) ) )
# 2545 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"

/**
  * @brief  Helper macro to get ADC channel in literal format LL_ADC_CHANNEL_x
  *         from number in decimal format.
  * @note   Example:
  *           __LL_ADC_DECIMAL_NB_TO_CHANNEL(4)
  *           will return a data equivalent to "LL_ADC_CHANNEL_4".
  * @param  __DECIMAL_NB__ Value between Min_Data=0 and Max_Data=18
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet for
  *             more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  *         (1, 2, 3, 4, 5, 7) For ADC channel read back from ADC register,
  *                      comparison with internal channel parameter to be done
  *                      using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
  */
#define __LL_ADC_DECIMAL_NB_TO_CHANNEL(__DECIMAL_NB__) (((__DECIMAL_NB__) <= 9UL) ? ( ((__DECIMAL_NB__) << ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) | (ADC_AWD2CR_AWD2CH_0 << (__DECIMAL_NB__)) | (ADC_SMPR1_REGOFFSET | (((3UL * (__DECIMAL_NB__))) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) ) : ( ((__DECIMAL_NB__) << ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) | (ADC_AWD2CR_AWD2CH_0 << (__DECIMAL_NB__)) | (ADC_SMPR2_REGOFFSET | (((3UL * ((__DECIMAL_NB__) - 10UL))) << ADC_CHANNEL_SMPx_BITOFFSET_POS)) ) )
# 2616 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"

/**
  * @brief  Helper macro to determine whether the selected channel
  *         corresponds to literal definitions of driver.
  * @note   The different literal definitions of ADC channels are:
  *         - ADC internal channel:
  *           LL_ADC_CHANNEL_VREFINT, LL_ADC_CHANNEL_TEMPSENSOR, ...
  *         - ADC external channel (channel connected to a GPIO pin):
  *           LL_ADC_CHANNEL_1, LL_ADC_CHANNEL_2, ...
  * @note   The channel parameter must be a value defined from literal
  *         definition of a ADC internal channel (LL_ADC_CHANNEL_VREFINT,
  *         LL_ADC_CHANNEL_TEMPSENSOR, ...),
  *         ADC external channel (LL_ADC_CHANNEL_1, LL_ADC_CHANNEL_2, ...),
  *         must not be a value from functions where a channel number is
  *         returned from ADC registers,
  *         because internal and external channels share the same channel
  *         number in ADC registers. The differentiation is made only with
  *         parameters definitions of driver.
  * @param  __CHANNEL__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  * @retval Value "0" if the channel corresponds to a parameter definition of a ADC external channel (channel
                      connected to a GPIO pin).
  *         Value "1" if the channel corresponds to a parameter definition of a ADC internal channel.
  */
#define __LL_ADC_IS_CHANNEL_INTERNAL(__CHANNEL__) (((__CHANNEL__) & ADC_CHANNEL_ID_INTERNAL_CH_MASK) != 0UL)


/**
  * @brief  Helper macro to convert a channel defined from parameter
  *         definition of a ADC internal channel (LL_ADC_CHANNEL_VREFINT,
  *         LL_ADC_CHANNEL_TEMPSENSOR, ...),
  *         to its equivalent parameter definition of a ADC external channel
  *         (LL_ADC_CHANNEL_1, LL_ADC_CHANNEL_2, ...).
  * @note   The channel parameter can be, additionally to a value
  *         defined from parameter definition of a ADC internal channel
  *         (LL_ADC_CHANNEL_VREFINT, LL_ADC_CHANNEL_TEMPSENSOR, ...),
  *         a value defined from parameter definition of
  *         ADC external channel (LL_ADC_CHANNEL_1, LL_ADC_CHANNEL_2, ...)
  *         or a value from functions where a channel number is returned
  *         from ADC registers.
  * @param  __CHANNEL__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1
  *         @arg @ref LL_ADC_CHANNEL_2
  *         @arg @ref LL_ADC_CHANNEL_3
  *         @arg @ref LL_ADC_CHANNEL_4
  *         @arg @ref LL_ADC_CHANNEL_5
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  */
#define __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL(__CHANNEL__) ((__CHANNEL__) & ~ADC_CHANNEL_ID_INTERNAL_CH_MASK)


/**
  * @brief  Helper macro to determine whether the internal channel
  *         selected is available on the ADC instance selected.
  * @note   The channel parameter must be a value defined from parameter
  *         definition of a ADC internal channel (LL_ADC_CHANNEL_VREFINT,
  *         LL_ADC_CHANNEL_TEMPSENSOR, ...),
  *         must not be a value defined from parameter definition of
  *         ADC external channel (LL_ADC_CHANNEL_1, LL_ADC_CHANNEL_2, ...)
  *         or a value from functions where a channel number is
  *         returned from ADC registers,
  *         because internal and external channels share the same channel
  *         number in ADC registers. The differentiation is made only with
  *         parameters definitions of driver.
  * @param  __ADC_INSTANCE__ ADC instance
  * @param  __CHANNEL__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  * @retval Value "0" if the internal channel selected is not available on the ADC instance selected.
  *         Value "1" if the internal channel selected is available on the ADC instance selected.
  */

#define __LL_ADC_IS_CHANNEL_INTERNAL_AVAILABLE(__ADC_INSTANCE__,__CHANNEL__) ((((__ADC_INSTANCE__) == ADC1) &&( ((__CHANNEL__) == LL_ADC_CHANNEL_VOPAMP1) || ((__CHANNEL__) == LL_ADC_CHANNEL_TEMPSENSOR_ADC1) || ((__CHANNEL__) == LL_ADC_CHANNEL_VBAT) || ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT) ) ) || (((__ADC_INSTANCE__) == ADC2) &&( ((__CHANNEL__) == LL_ADC_CHANNEL_VOPAMP2) || ((__CHANNEL__) == LL_ADC_CHANNEL_VOPAMP3_ADC2) ) ) || (((__ADC_INSTANCE__) == ADC3) &&( ((__CHANNEL__) == LL_ADC_CHANNEL_VOPAMP3_ADC3) || ((__CHANNEL__) == LL_ADC_CHANNEL_VBAT) || ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT) ) ) || (((__ADC_INSTANCE__) == ADC4) &&( ((__CHANNEL__) == LL_ADC_CHANNEL_VOPAMP6) || ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT) ) ) || (((__ADC_INSTANCE__) == ADC5) &&( ((__CHANNEL__) == LL_ADC_CHANNEL_VOPAMP5) || ((__CHANNEL__) == LL_ADC_CHANNEL_TEMPSENSOR_ADC5) || ((__CHANNEL__) == LL_ADC_CHANNEL_VOPAMP4) || ((__CHANNEL__) == LL_ADC_CHANNEL_VBAT) || ((__CHANNEL__) == LL_ADC_CHANNEL_VREFINT) ) ) )
# 2850 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"
# 2921 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"

/**
  * @brief  Helper macro to define ADC analog watchdog parameter:
  *         define a single channel to monitor with analog watchdog
  *         from sequencer channel and groups definition.
  * @note   To be used with function @ref LL_ADC_SetAnalogWDMonitChannels().
  *         Example:
  *           LL_ADC_SetAnalogWDMonitChannels(
  *             ADC1, LL_ADC_AWD1,
  *             __LL_ADC_ANALOGWD_CHANNEL_GROUP(LL_ADC_CHANNEL4, LL_ADC_GROUP_REGULAR))
  * @param  __CHANNEL__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet for
  *             more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  *         (1, 2, 3, 4, 5, 7) For ADC channel read back from ADC register,
  *                      comparison with internal channel parameter to be done
  *                      using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
  * @param  __GROUP__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_GROUP_REGULAR
  *         @arg @ref LL_ADC_GROUP_INJECTED
  *         @arg @ref LL_ADC_GROUP_REGULAR_INJECTED
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_AWD_DISABLE
  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_REG        (0)
  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_INJ        (0)
  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_0_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_0_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_0_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_1_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_1_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_1_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_2_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_2_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_2_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_3_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_3_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_3_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_4_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_4_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_4_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_5_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_5_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_5_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_6_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_6_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_6_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_7_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_7_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_7_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_8_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_8_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_8_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_9_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_9_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_9_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_10_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_10_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_10_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_11_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_11_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_11_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_12_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_12_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_12_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_13_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_13_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_13_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_14_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_14_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_14_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_15_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_15_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_15_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_16_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_16_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_16_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_17_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_17_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_17_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_18_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_18_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_18_REG_INJ
  *         @arg @ref LL_ADC_AWD_CH_VREFINT_REG          (0)
  *         @arg @ref LL_ADC_AWD_CH_VREFINT_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CH_VREFINT_REG_INJ
  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_ADC1_REG  (0)(1)
  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_ADC1_INJ  (0)(1)
  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_ADC1_REG_INJ (1)
  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_ADC5_REG  (0)(5)
  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_ADC5_INJ  (0)(5)
  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_ADC5_REG_INJ (5)
  *         @arg @ref LL_ADC_AWD_CH_VBAT_REG             (0)(6)
  *         @arg @ref LL_ADC_AWD_CH_VBAT_INJ             (0)(6)
  *         @arg @ref LL_ADC_AWD_CH_VBAT_REG_INJ            (6)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP1_REG          (0)(1)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP1_INJ          (0)(1)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP1_REG_INJ         (1)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP2_REG          (0)(2)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP2_INJ          (0)(2)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP2_REG_INJ         (2)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP3_ADC2_REG     (0)(2)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP3_ADC2_INJ     (0)(2)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP3_ADC2_REG_INJ    (2)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP3_ADC3_REG     (0)(3)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP3_ADC3_INJ     (0)(3)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP3_ADC3_REG_INJ    (3)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP4_REG          (0)(5)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP4_INJ          (0)(5)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP4_REG_INJ         (5)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP5_REG          (0)(5)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP5_INJ          (0)(5)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP5_REG_INJ         (5)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP6_REG          (0)(4)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP6_INJ          (0)(4)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP6_REG_INJ         (4)
  *
  *         (0) On STM32G4, parameter available only on analog watchdog number: AWD1.\n
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  */
#define __LL_ADC_ANALOGWD_CHANNEL_GROUP(__CHANNEL__,__GROUP__) (((__GROUP__) == LL_ADC_GROUP_REGULAR) ? (((__CHANNEL__) & ADC_CHANNEL_ID_MASK) | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) : ((__GROUP__) == LL_ADC_GROUP_INJECTED) ? (((__CHANNEL__) & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1SGL) : (((__CHANNEL__) & ADC_CHANNEL_ID_MASK) | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL) )
# 3099 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"

/**
  * @brief  Helper macro to set the value of ADC analog watchdog threshold high
  *         or low in function of ADC resolution, when ADC resolution is
  *         different of 12 bits.
  * @note   To be used with function @ref LL_ADC_ConfigAnalogWDThresholds()
  *         or @ref LL_ADC_SetAnalogWDThresholds().
  *         Example, with a ADC resolution of 8 bits, to set the value of
  *         analog watchdog threshold high (on 8 bits):
  *           LL_ADC_SetAnalogWDThresholds
  *            (< ADCx param >,
  *             __LL_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION(LL_ADC_RESOLUTION_8B, <threshold_value_8_bits>)
  *            );
  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_RESOLUTION_12B
  *         @arg @ref LL_ADC_RESOLUTION_10B
  *         @arg @ref LL_ADC_RESOLUTION_8B
  *         @arg @ref LL_ADC_RESOLUTION_6B
  * @param  __AWD_THRESHOLD__ Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
  */
#define __LL_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION(__ADC_RESOLUTION__,__AWD_THRESHOLD__) ((__AWD_THRESHOLD__) << ((__ADC_RESOLUTION__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1U )))


/**
  * @brief  Helper macro to get the value of ADC analog watchdog threshold high
  *         or low in function of ADC resolution, when ADC resolution is
  *         different of 12 bits.
  * @note   To be used with function @ref LL_ADC_GetAnalogWDThresholds().
  *         Example, with a ADC resolution of 8 bits, to get the value of
  *         analog watchdog threshold high (on 8 bits):
  *           < threshold_value_6_bits > = __LL_ADC_ANALOGWD_GET_THRESHOLD_RESOLUTION
  *            (LL_ADC_RESOLUTION_8B,
  *             LL_ADC_GetAnalogWDThresholds(<ADCx param>, LL_ADC_AWD_THRESHOLD_HIGH)
  *            );
  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_RESOLUTION_12B
  *         @arg @ref LL_ADC_RESOLUTION_10B
  *         @arg @ref LL_ADC_RESOLUTION_8B
  *         @arg @ref LL_ADC_RESOLUTION_6B
  * @param  __AWD_THRESHOLD_12_BITS__ Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
  */
#define __LL_ADC_ANALOGWD_GET_THRESHOLD_RESOLUTION(__ADC_RESOLUTION__,__AWD_THRESHOLD_12_BITS__) ((__AWD_THRESHOLD_12_BITS__) >> ((__ADC_RESOLUTION__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1U )))


/**
  * @brief  Helper macro to get the ADC analog watchdog threshold high
  *         or low from raw value containing both thresholds concatenated.
  * @note   To be used with function @ref LL_ADC_GetAnalogWDThresholds().
  *         Example, to get analog watchdog threshold high from the register raw value:
  *           __LL_ADC_ANALOGWD_THRESHOLDS_HIGH_LOW(LL_ADC_AWD_THRESHOLD_HIGH, <raw_value_with_both_thresholds>);
  * @param  __AWD_THRESHOLD_TYPE__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_AWD_THRESHOLD_HIGH
  *         @arg @ref LL_ADC_AWD_THRESHOLD_LOW
  * @param  __AWD_THRESHOLDS__ Value between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
  */
#define __LL_ADC_ANALOGWD_THRESHOLDS_HIGH_LOW(__AWD_THRESHOLD_TYPE__,__AWD_THRESHOLDS__) (((__AWD_THRESHOLDS__) >> (((__AWD_THRESHOLD_TYPE__) & ADC_AWD_TRX_BIT_HIGH_MASK) >> ADC_AWD_TRX_BIT_HIGH_SHIFT4)) & LL_ADC_AWD_THRESHOLD_LOW)



/**
  * @brief  Helper macro to set the ADC calibration value with both single ended
  *         and differential modes calibration factors concatenated.
  * @note   To be used with function @ref LL_ADC_SetCalibrationFactor().
  *         Example, to set calibration factors single ended to 0x55
  *         and differential ended to 0x2A:
  *           LL_ADC_SetCalibrationFactor(
  *             ADC1,
  *             __LL_ADC_CALIB_FACTOR_SINGLE_DIFF(0x55, 0x2A))
  * @param  __CALIB_FACTOR_SINGLE_ENDED__ Value between Min_Data=0x00 and Max_Data=0x7F
  * @param  __CALIB_FACTOR_DIFFERENTIAL__ Value between Min_Data=0x00 and Max_Data=0x7F
  * @retval Value between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
  */
#define __LL_ADC_CALIB_FACTOR_SINGLE_DIFF(__CALIB_FACTOR_SINGLE_ENDED__,__CALIB_FACTOR_DIFFERENTIAL__) (((__CALIB_FACTOR_DIFFERENTIAL__) << ADC_CALFACT_CALFACT_D_Pos) | (__CALIB_FACTOR_SINGLE_ENDED__))



/**
  * @brief  Helper macro to get the ADC multimode conversion data of ADC master
  *         or ADC slave from raw value with both ADC conversion data concatenated.
  * @note   This macro is intended to be used when multimode transfer by DMA
  *         is enabled: refer to function @ref LL_ADC_SetMultiDMATransfer().
  *         In this case the transferred data need to processed with this macro
  *         to separate the conversion data of ADC master and ADC slave.
  * @param  __ADC_MULTI_MASTER_SLAVE__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_MULTI_MASTER
  *         @arg @ref LL_ADC_MULTI_SLAVE
  * @param  __ADC_MULTI_CONV_DATA__ Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
  */
#define __LL_ADC_MULTI_CONV_DATA_MASTER_SLAVE(__ADC_MULTI_MASTER_SLAVE__,__ADC_MULTI_CONV_DATA__) (((__ADC_MULTI_CONV_DATA__) >> ((ADC_CDR_RDATA_SLV_Pos) & ~(__ADC_MULTI_MASTER_SLAVE__))) & ADC_CDR_RDATA_MST)




/**
  * @brief  Helper macro to select, from a ADC instance, to which ADC instance
  *         it has a dependence in multimode (ADC master of the corresponding
  *         ADC common instance).
  * @note   In case of device with multimode available and a mix of
  *         ADC instances compliant and not compliant with multimode feature,
  *         ADC instances not compliant with multimode feature are
  *         considered as master instances (do not depend to
  *         any other ADC instance).
  * @param  __ADCx__ ADC instance
  * @retval __ADCx__ ADC instance master of the corresponding ADC common instance
  */

#define __LL_ADC_MULTI_INSTANCE_MASTER(__ADCx__) ( ( ((__ADCx__) == ADC2) )? (ADC1) : ( ( ((__ADCx__) == ADC4) )? (ADC3) : (__ADCx__) ) )
# 3221 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"
# 3230 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"


/**
  * @brief  Helper macro to select the ADC common instance
  *         to which is belonging the selected ADC instance.
  * @note   ADC common register instance can be used for:
  *         - Set parameters common to several ADC instances
  *         - Multimode (for devices with several ADC instances)
  *         Refer to functions having argument "ADCxy_COMMON" as parameter.
  * @param  __ADCx__ ADC instance
  * @retval ADC common register instance
  */

#define __LL_ADC_COMMON_INSTANCE(__ADCx__) ((((__ADCx__) == ADC1) || ((__ADCx__) == ADC2)) ? ( (ADC12_COMMON) ) : ( (ADC345_COMMON) ) )
# 3253 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"



/**
  * @brief  Helper macro to check if all ADC instances sharing the same
  *         ADC common instance are disabled.
  * @note   This check is required by functions with setting conditioned to
  *         ADC state:
  *         All ADC instances of the ADC common group must be disabled.
  *         Refer to functions having argument "ADCxy_COMMON" as parameter.
  * @note   On devices with only 1 ADC common instance, parameter of this macro
  *         is useless and can be ignored (parameter kept for compatibility
  *         with devices featuring several ADC common instances).
  * @param  __ADCXY_COMMON__ ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval Value "0" if all ADC instances sharing the same ADC common instance
  *         are disabled.
  *         Value "1" if at least one ADC instance sharing the same ADC common instance
  *         is enabled.
  */


#define __LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__ADCXY_COMMON__) (((__ADCXY_COMMON__) == ADC12_COMMON) ? ( (LL_ADC_IsEnabled(ADC1) | LL_ADC_IsEnabled(ADC2) ) ) : ( (LL_ADC_IsEnabled(ADC3) | LL_ADC_IsEnabled(ADC4) | LL_ADC_IsEnabled(ADC5) ) ) )
# 3288 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"
# 3299 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"





/**
  * @brief  Helper macro to define the ADC conversion data full-scale digital
  *         value corresponding to the selected ADC resolution.
  * @note   ADC conversion data full-scale corresponds to voltage range
  *         determined by analog voltage references Vref+ and Vref-
  *         (refer to reference manual).
  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_RESOLUTION_12B
  *         @arg @ref LL_ADC_RESOLUTION_10B
  *         @arg @ref LL_ADC_RESOLUTION_8B
  *         @arg @ref LL_ADC_RESOLUTION_6B
  * @retval ADC conversion data full-scale digital value (unit: digital value of ADC conversion data)
  */
#define __LL_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__) (0xFFFUL >> ((__ADC_RESOLUTION__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1UL)))


/**
  * @brief  Helper macro to convert the ADC conversion data from
  *         a resolution to another resolution.
  * @param  __DATA__ ADC conversion data to be converted
  * @param  __ADC_RESOLUTION_CURRENT__ Resolution of the data to be converted
  *         This parameter can be one of the following values:
  *         @arg @ref LL_ADC_RESOLUTION_12B
  *         @arg @ref LL_ADC_RESOLUTION_10B
  *         @arg @ref LL_ADC_RESOLUTION_8B
  *         @arg @ref LL_ADC_RESOLUTION_6B
  * @param  __ADC_RESOLUTION_TARGET__ Resolution of the data after conversion
  *         This parameter can be one of the following values:
  *         @arg @ref LL_ADC_RESOLUTION_12B
  *         @arg @ref LL_ADC_RESOLUTION_10B
  *         @arg @ref LL_ADC_RESOLUTION_8B
  *         @arg @ref LL_ADC_RESOLUTION_6B
  * @retval ADC conversion data to the requested resolution
  */
#define __LL_ADC_CONVERT_DATA_RESOLUTION(__DATA__,__ADC_RESOLUTION_CURRENT__,__ADC_RESOLUTION_TARGET__) (((__DATA__) << ((__ADC_RESOLUTION_CURRENT__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1UL))) >> ((__ADC_RESOLUTION_TARGET__) >> (ADC_CFGR_RES_BITOFFSET_POS - 1UL)) )







/**
  * @brief  Helper macro to calculate the voltage (unit: mVolt)
  *         corresponding to a ADC conversion data (unit: digital value).
  * @note   Analog reference voltage (Vref+) must be either known from
  *         user board environment or can be calculated using ADC measurement
  *         and ADC helper macro @ref __LL_ADC_CALC_VREFANALOG_VOLTAGE().
  * @param  __VREFANALOG_VOLTAGE__ Analog reference voltage (unit: mV)
  * @param  __ADC_DATA__ ADC conversion data (resolution 12 bits)
  *                       (unit: digital value).
  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_RESOLUTION_12B
  *         @arg @ref LL_ADC_RESOLUTION_10B
  *         @arg @ref LL_ADC_RESOLUTION_8B
  *         @arg @ref LL_ADC_RESOLUTION_6B
  * @retval ADC conversion data equivalent voltage value (unit: mVolt)
  */
#define __LL_ADC_CALC_DATA_TO_VOLTAGE(__VREFANALOG_VOLTAGE__,__ADC_DATA__,__ADC_RESOLUTION__) ((__ADC_DATA__) * (__VREFANALOG_VOLTAGE__) / __LL_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__) )






/**
  * @brief  Helper macro to calculate the voltage (unit: mVolt)
  *         corresponding to a ADC conversion data (unit: digital value) in
  *         differential ended mode.
  * @note   ADC data from ADC data register is unsigned and centered around
  *         middle code in. Converted voltage can be positive or negative
  *         depending on differential input voltages.
  * @note   Analog reference voltage (Vref+) must be either known from
  *         user board environment or can be calculated using ADC measurement
  *         and ADC helper macro @ref __LL_ADC_CALC_VREFANALOG_VOLTAGE().
  * @param  __VREFANALOG_VOLTAGE__ Analog reference voltage (unit: mV)
  * @param  __ADC_DATA__ ADC conversion data (unit: digital value).
  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_RESOLUTION_12B
  *         @arg @ref LL_ADC_RESOLUTION_10B
  *         @arg @ref LL_ADC_RESOLUTION_8B
  *         @arg @ref LL_ADC_RESOLUTION_6B
  * @retval ADC conversion data equivalent voltage value (unit: mVolt)
  */
#define __LL_ADC_CALC_DIFF_DATA_TO_VOLTAGE(__VREFANALOG_VOLTAGE__,__ADC_DATA__,__ADC_RESOLUTION__) ((int32_t)((__ADC_DATA__) << 1U) * (int32_t)(__VREFANALOG_VOLTAGE__) / (int32_t)(__LL_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__)) - (int32_t)(__VREFANALOG_VOLTAGE__))






/**
  * @brief  Helper macro to calculate analog reference voltage (Vref+)
  *         (unit: mVolt) from ADC conversion data of internal voltage
  *         reference VrefInt.
  * @note   Computation is using VrefInt calibration value
  *         stored in system memory for each device during production.
  * @note   This voltage depends on user board environment: voltage level
  *         connected to pin Vref+.
  *         On devices with small package, the pin Vref+ is not present
  *         and internally bonded to pin Vdda.
  * @note   On this STM32 series, calibration data of internal voltage reference
  *         VrefInt corresponds to a resolution of 12 bits,
  *         this is the recommended ADC resolution to convert voltage of
  *         internal voltage reference VrefInt.
  *         Otherwise, this macro performs the processing to scale
  *         ADC conversion data to 12 bits.
  * @param  __VREFINT_ADC_DATA__ ADC conversion data (resolution 12 bits)
  *         of internal voltage reference VrefInt (unit: digital value).
  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_RESOLUTION_12B
  *         @arg @ref LL_ADC_RESOLUTION_10B
  *         @arg @ref LL_ADC_RESOLUTION_8B
  *         @arg @ref LL_ADC_RESOLUTION_6B
  * @retval Analog reference voltage (unit: mV)
  */
#define __LL_ADC_CALC_VREFANALOG_VOLTAGE(__VREFINT_ADC_DATA__,__ADC_RESOLUTION__) (((uint32_t)(*VREFINT_CAL_ADDR) * VREFINT_CAL_VREF) / __LL_ADC_CONVERT_DATA_RESOLUTION((__VREFINT_ADC_DATA__), (__ADC_RESOLUTION__), LL_ADC_RESOLUTION_12B) )







/**
  * @brief  Helper macro to calculate the temperature (unit: degree Celsius)
  *         from ADC conversion data of internal temperature sensor.
  * @note   Computation is using temperature sensor calibration values
  *         stored in system memory for each device during production.
  * @note   Calculation formula:
  *           Temperature = ((TS_ADC_DATA - TS_CAL1)
  *                           * (TS_CAL2_TEMP - TS_CAL1_TEMP))
  *                         / (TS_CAL2 - TS_CAL1) + TS_CAL1_TEMP
  *           with TS_ADC_DATA = temperature sensor raw data measured by ADC
  *                Avg_Slope = (TS_CAL2 - TS_CAL1)
  *                            / (TS_CAL2_TEMP - TS_CAL1_TEMP)
  *                TS_CAL1   = equivalent TS_ADC_DATA at temperature
  *                            TEMP_DEGC_CAL1 (calibrated in factory)
  *                TS_CAL2   = equivalent TS_ADC_DATA at temperature
  *                            TEMP_DEGC_CAL2 (calibrated in factory)
  *         Caution: Calculation relevancy under reserve that calibration
  *                  parameters are correct (address and data).
  *                  To calculate temperature using temperature sensor
  *                  datasheet typical values (generic values less, therefore
  *                  less accurate than calibrated values),
  *                  use helper macro @ref __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS().
  * @note   As calculation input, the analog reference voltage (Vref+) must be
  *         defined as it impacts the ADC LSB equivalent voltage.
  * @note   Analog reference voltage (Vref+) must be either known from
  *         user board environment or can be calculated using ADC measurement
  *         and ADC helper macro @ref __LL_ADC_CALC_VREFANALOG_VOLTAGE().
  * @note   On this STM32 series, calibration data of temperature sensor
  *         corresponds to a resolution of 12 bits,
  *         this is the recommended ADC resolution to convert voltage of
  *         temperature sensor.
  *         Otherwise, this macro performs the processing to scale
  *         ADC conversion data to 12 bits.
  * @param  __VREFANALOG_VOLTAGE__  Analog reference voltage (unit: mV)
  * @param  __TEMPSENSOR_ADC_DATA__ ADC conversion data of internal
  *                                 temperature sensor (unit: digital value).
  * @param  __ADC_RESOLUTION__      ADC resolution at which internal temperature
  *                                 sensor voltage has been measured.
  *         This parameter can be one of the following values:
  *         @arg @ref LL_ADC_RESOLUTION_12B
  *         @arg @ref LL_ADC_RESOLUTION_10B
  *         @arg @ref LL_ADC_RESOLUTION_8B
  *         @arg @ref LL_ADC_RESOLUTION_6B
  * @retval Temperature (unit: degree Celsius)
  *         In case or error, value LL_ADC_TEMPERATURE_CALC_ERROR is returned (inconsistent temperature value)
  */
#define __LL_ADC_CALC_TEMPERATURE(__VREFANALOG_VOLTAGE__,__TEMPSENSOR_ADC_DATA__,__ADC_RESOLUTION__) ((((int32_t)*TEMPSENSOR_CAL2_ADDR - (int32_t)*TEMPSENSOR_CAL1_ADDR) != 0) ? (((( ((int32_t)((__LL_ADC_CONVERT_DATA_RESOLUTION((__TEMPSENSOR_ADC_DATA__), (__ADC_RESOLUTION__), LL_ADC_RESOLUTION_12B) * (__VREFANALOG_VOLTAGE__)) / TEMPSENSOR_CAL_VREFANALOG) - (int32_t) *TEMPSENSOR_CAL1_ADDR) ) * (int32_t)(TEMPSENSOR_CAL2_TEMP - TEMPSENSOR_CAL1_TEMP) ) / (int32_t)((int32_t)*TEMPSENSOR_CAL2_ADDR - (int32_t)*TEMPSENSOR_CAL1_ADDR) ) + TEMPSENSOR_CAL1_TEMP ) : ((int32_t)LL_ADC_TEMPERATURE_CALC_ERROR) )
# 3491 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"

/**
  * @brief  Helper macro to calculate the temperature (unit: degree Celsius)
  *         from ADC conversion data of internal temperature sensor.
  * @note   Computation is using temperature sensor typical values
  *         (refer to device datasheet).
  * @note   Calculation formula:
  *           Temperature = (TS_TYP_CALx_VOLT(uV) - TS_ADC_DATA * Conversion_uV)
  *                         / Avg_Slope + CALx_TEMP
  *           with TS_ADC_DATA      = temperature sensor raw data measured by ADC
  *                                   (unit: digital value)
  *                Avg_Slope        = temperature sensor slope
  *                                   (unit: uV/Degree Celsius)
  *                TS_TYP_CALx_VOLT = temperature sensor digital value at
  *                                   temperature CALx_TEMP (unit: mV)
  *         Caution: Calculation relevancy under reserve the temperature sensor
  *                  of the current device has characteristics in line with
  *                  datasheet typical values.
  *                  If temperature sensor calibration values are available on
  *                  on this device (presence of macro __LL_ADC_CALC_TEMPERATURE()),
  *                  temperature calculation will be more accurate using
  *                  helper macro @ref __LL_ADC_CALC_TEMPERATURE().
  * @note   As calculation input, the analog reference voltage (Vref+) must be
  *         defined as it impacts the ADC LSB equivalent voltage.
  * @note   Analog reference voltage (Vref+) must be either known from
  *         user board environment or can be calculated using ADC measurement
  *         and ADC helper macro @ref __LL_ADC_CALC_VREFANALOG_VOLTAGE().
  * @note   ADC measurement data must correspond to a resolution of 12 bits
  *         (full scale digital value 4095). If not the case, the data must be
  *         preliminarily rescaled to an equivalent resolution of 12 bits.
  * @param  __TEMPSENSOR_TYP_AVGSLOPE__   Device datasheet data: Temperature sensor slope typical value
  *                                       (unit: uV/DegCelsius).
  *                                       On STM32G4, refer to device datasheet parameter "Avg_Slope".
  * @param  __TEMPSENSOR_TYP_CALX_V__     Device datasheet data: Temperature sensor voltage typical value
  *                                       (at temperature and Vref+ defined in parameters below) (unit: mV).
  *                                       On STM32G4, refer to datasheet parameter "V30" (corresponding to TS_CAL1).
  * @param  __TEMPSENSOR_CALX_TEMP__      Device datasheet data: Temperature at which temperature sensor voltage
  *                                       (see parameter above) is corresponding (unit: mV)
  * @param  __VREFANALOG_VOLTAGE__        Analog voltage reference (Vref+) value (unit: mV)
  * @param  __TEMPSENSOR_ADC_DATA__       ADC conversion data of internal temperature sensor (unit: digital value).
  * @param  __ADC_RESOLUTION__            ADC resolution at which internal temperature sensor voltage has been measured.
  *         This parameter can be one of the following values:
  *         @arg @ref LL_ADC_RESOLUTION_12B
  *         @arg @ref LL_ADC_RESOLUTION_10B
  *         @arg @ref LL_ADC_RESOLUTION_8B
  *         @arg @ref LL_ADC_RESOLUTION_6B
  * @retval Temperature (unit: degree Celsius)
  */
#define __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(__TEMPSENSOR_TYP_AVGSLOPE__,__TEMPSENSOR_TYP_CALX_V__,__TEMPSENSOR_CALX_TEMP__,__VREFANALOG_VOLTAGE__,__TEMPSENSOR_ADC_DATA__,__ADC_RESOLUTION__) (((((int32_t)((((__TEMPSENSOR_ADC_DATA__) * (__VREFANALOG_VOLTAGE__)) / __LL_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__)) * 1000UL) - (int32_t)(((__TEMPSENSOR_TYP_CALX_V__)) * 1000UL) ) ) / (int32_t)(__TEMPSENSOR_TYP_AVGSLOPE__) ) + (int32_t)(__TEMPSENSOR_CALX_TEMP__) )
# 3555 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"

/**
  * @}
  */

/**
  * @}
  */


/* Exported functions --------------------------------------------------------*/
/** @defgroup ADC_LL_Exported_Functions ADC Exported Functions
  * @{
  */

/** @defgroup ADC_LL_EF_DMA_Management ADC DMA management
  * @{
  */
/* Note: LL ADC functions to set DMA transfer are located into sections of    */
/*       configuration of ADC instance, groups and multimode (if available):  */
/*       @ref LL_ADC_REG_SetDMATransfer(), ...                                */

/**
  * @brief  Function to help to configure DMA transfer from ADC: retrieve the
  *         ADC register address from ADC instance and a list of ADC registers
  *         intended to be used (most commonly) with DMA transfer.
  * @note   These ADC registers are data registers:
  *         when ADC conversion data is available in ADC data registers,
  *         ADC generates a DMA transfer request.
  * @note   This macro is intended to be used with LL DMA driver, refer to
  *         function "LL_DMA_ConfigAddresses()".
  *         Example:
  *           LL_DMA_ConfigAddresses(DMA1,
  *                                  LL_DMA_CHANNEL_1,
  *                                  LL_ADC_DMA_GetRegAddr(ADC1, LL_ADC_DMA_REG_REGULAR_DATA),
  *                                  (uint32_t)&< array or variable >,
  *                                  LL_DMA_DIRECTION_PERIPH_TO_MEMORY);
  * @note   For devices with several ADC: in multimode, some devices
  *         use a different data register outside of ADC instance scope
  *         (common data register). This macro manages this register difference,
  *         only ADC instance has to be set as parameter.
  * @rmtoll DR       RDATA          LL_ADC_DMA_GetRegAddr\n
  *         CDR      RDATA_MST      LL_ADC_DMA_GetRegAddr\n
  *         CDR      RDATA_SLV      LL_ADC_DMA_GetRegAddr
  * @param  ADCx ADC instance
  * @param  Register This parameter can be one of the following values:
  *         @arg @ref LL_ADC_DMA_REG_REGULAR_DATA
  *         @arg @ref LL_ADC_DMA_REG_REGULAR_DATA_MULTI (1)
  *
  *         (1) Available on devices with several ADC instances.
  * @retval ADC register address
  */

__STATIC_INLINE uint32_t LL_ADC_DMA_GetRegAddr(const ADC_TypeDef *ADCx, uint32_t Register)
{
  uint32_t data_reg_addr;

  if (Register == LL_ADC_DMA_REG_REGULAR_DATA)
  {
    /* Retrieve address of register DR */
    data_reg_addr = (uint32_t) &(ADCx->DR);
  }
  else /* (Register == LL_ADC_DMA_REG_REGULAR_DATA_MULTI) */
  {
    /* Retrieve address of register CDR */
    data_reg_addr = (uint32_t) &((__LL_ADC_COMMON_INSTANCE(ADCx))->CDR);
  }

  return data_reg_addr;
}
# 3635 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"

/**
  * @}
  */

/** @defgroup ADC_LL_EF_Configuration_ADC_Common Configuration of ADC hierarchical scope: common to several
  *           ADC instances
  * @{
  */

/**
  * @brief  Set parameter common to several ADC: Clock source and prescaler.
  * @note   On this STM32 series, if ADC group injected is used, some
  *         clock ratio constraints between ADC clock and AHB clock
  *         must be respected.
  *         Refer to reference manual.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         All ADC instances of the ADC common group must be disabled.
  *         This check can be done with function @ref LL_ADC_IsEnabled() for each
  *         ADC instance or by using helper macro helper macro
  *         @ref __LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE().
  * @rmtoll CCR      CKMODE         LL_ADC_SetCommonClock\n
  *         CCR      PRESC          LL_ADC_SetCommonClock
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @param  CommonClock This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CLOCK_SYNC_PCLK_DIV1
  *         @arg @ref LL_ADC_CLOCK_SYNC_PCLK_DIV2
  *         @arg @ref LL_ADC_CLOCK_SYNC_PCLK_DIV4
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV1
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV2
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV4
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV6
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV8
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV10
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV12
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV16
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV32
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV64
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV128
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV256
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonClock(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t CommonClock)
{
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
}

/**
  * @brief  Get parameter common to several ADC: Clock source and prescaler.
  * @rmtoll CCR      CKMODE         LL_ADC_GetCommonClock\n
  *         CCR      PRESC          LL_ADC_GetCommonClock
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_CLOCK_SYNC_PCLK_DIV1
  *         @arg @ref LL_ADC_CLOCK_SYNC_PCLK_DIV2
  *         @arg @ref LL_ADC_CLOCK_SYNC_PCLK_DIV4
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV1
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV2
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV4
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV6
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV8
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV10
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV12
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV16
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV32
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV64
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV128
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV256
  */
__STATIC_INLINE uint32_t LL_ADC_GetCommonClock(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC));
}

/**
  * @brief  Set parameter common to several ADC: measurement path to
  *         internal channels (VrefInt, temperature sensor, ...).
  *         Configure all paths (overwrite current configuration).
  * @note   One or several values can be selected.
  *         Example: (LL_ADC_PATH_INTERNAL_VREFINT |
  *                   LL_ADC_PATH_INTERNAL_TEMPSENSOR)
  *         The values not selected are removed from configuration.
  * @note   Stabilization time of measurement path to internal channel:
  *         After enabling internal paths, before starting ADC conversion,
  *         a delay is required for internal voltage reference and
  *         temperature sensor stabilization time.
  *         Refer to device datasheet.
  *         Refer to literal @ref LL_ADC_DELAY_VREFINT_STAB_US.
  *         Refer to literals @ref LL_ADC_DELAY_TEMPSENSOR_STAB_US,
  *         @ref LL_ADC_DELAY_TEMPSENSOR_BUFFER_STAB_US.
  * @note   ADC internal channel sampling time constraint:
  *         For ADC conversion of internal channels,
  *         a sampling time minimum value is required.
  *         Refer to device datasheet.
  * @rmtoll CCR      VREFEN         LL_ADC_SetCommonPathInternalCh\n
  *         CCR      VSENSESEL      LL_ADC_SetCommonPathInternalCh\n
  *         CCR      VBATSEL        LL_ADC_SetCommonPathInternalCh
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @param  PathInternal This parameter can be a combination of the following values:
  *         @arg @ref LL_ADC_PATH_INTERNAL_NONE
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
{
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
}

/**
  * @brief  Set parameter common to several ADC: measurement path to
  *         internal channels (VrefInt, temperature sensor, ...).
  *         Add paths to the current configuration.
  * @note   One or several values can be selected.
  *         Example: (LL_ADC_PATH_INTERNAL_VREFINT |
  *                   LL_ADC_PATH_INTERNAL_TEMPSENSOR)
  * @note   Stabilization time of measurement path to internal channel:
  *         After enabling internal paths, before starting ADC conversion,
  *         a delay is required for internal voltage reference and
  *         temperature sensor stabilization time.
  *         Refer to device datasheet.
  *         Refer to literal @ref LL_ADC_DELAY_VREFINT_STAB_US.
  *         Refer to literals @ref LL_ADC_DELAY_TEMPSENSOR_STAB_US,
  *         @ref LL_ADC_DELAY_TEMPSENSOR_BUFFER_STAB_US.
  * @note   ADC internal channel sampling time constraint:
  *         For ADC conversion of internal channels,
  *         a sampling time minimum value is required.
  *         Refer to device datasheet.
  * @rmtoll CCR      VREFEN         LL_ADC_SetCommonPathInternalChAdd\n
  *         CCR      VSENSESEL      LL_ADC_SetCommonPathInternalChAdd\n
  *         CCR      VBATSEL        LL_ADC_SetCommonPathInternalChAdd
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @param  PathInternal This parameter can be a combination of the following values:
  *         @arg @ref LL_ADC_PATH_INTERNAL_NONE
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonPathInternalChAdd(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
{
  SET_BIT(ADCxy_COMMON->CCR, PathInternal);
}

/**
  * @brief  Set parameter common to several ADC: measurement path to
  *         internal channels (VrefInt, temperature sensor, ...).
  *         Remove paths to the current configuration.
  * @note   One or several values can be selected.
  *         Example: (LL_ADC_PATH_INTERNAL_VREFINT |
  *                   LL_ADC_PATH_INTERNAL_TEMPSENSOR)
  * @rmtoll CCR      VREFEN         LL_ADC_SetCommonPathInternalChRem\n
  *         CCR      VSENSESEL      LL_ADC_SetCommonPathInternalChRem\n
  *         CCR      VBATSEL        LL_ADC_SetCommonPathInternalChRem
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @param  PathInternal This parameter can be a combination of the following values:
  *         @arg @ref LL_ADC_PATH_INTERNAL_NONE
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonPathInternalChRem(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
{
  CLEAR_BIT(ADCxy_COMMON->CCR, PathInternal);
}

/**
  * @brief  Get parameter common to several ADC: measurement path to internal
  *         channels (VrefInt, temperature sensor, ...).
  * @note   One or several values can be selected.
  *         Example: (LL_ADC_PATH_INTERNAL_VREFINT |
  *                   LL_ADC_PATH_INTERNAL_TEMPSENSOR)
  * @rmtoll CCR      VREFEN         LL_ADC_GetCommonPathInternalCh\n
  *         CCR      VSENSESEL      LL_ADC_GetCommonPathInternalCh\n
  *         CCR      VBATSEL        LL_ADC_GetCommonPathInternalCh
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval Returned value can be a combination of the following values:
  *         @arg @ref LL_ADC_PATH_INTERNAL_NONE
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  */
__STATIC_INLINE uint32_t LL_ADC_GetCommonPathInternalCh(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL));
}

/**
  * @}
  */

/** @defgroup ADC_LL_EF_Configuration_ADC_Instance Configuration of ADC hierarchical scope: ADC instance
  * @{
  */

/**
  * @brief  Set ADC calibration factor in the mode single-ended
  *         or differential (for devices with differential mode available).
  * @note   This function is intended to set calibration parameters
  *         without having to perform a new calibration using
  *         @ref LL_ADC_StartCalibration().
  * @note   For devices with differential mode available:
  *         Calibration of offset is specific to each of
  *         single-ended and differential modes
  *         (calibration factor must be specified for each of these
  *         differential modes, if used afterwards and if the application
  *         requires their calibration).
  * @note   In case of setting calibration factors of both modes single ended
  *         and differential (parameter LL_ADC_BOTH_SINGLE_DIFF_ENDED):
  *         both calibration factors must be concatenated.
  *         To perform this processing, use helper macro
  *         @ref __LL_ADC_CALIB_FACTOR_SINGLE_DIFF().
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be enabled, without calibration on going, without conversion
  *         on going on group regular.
  * @rmtoll CALFACT  CALFACT_S      LL_ADC_SetCalibrationFactor\n
  *         CALFACT  CALFACT_D      LL_ADC_SetCalibrationFactor
  * @param  ADCx ADC instance
  * @param  SingleDiff This parameter can be one of the following values:
  *         @arg @ref LL_ADC_SINGLE_ENDED
  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
  *         @arg @ref LL_ADC_BOTH_SINGLE_DIFF_ENDED
  * @param  CalibrationFactor Value between Min_Data=0x00 and Max_Data=0x7F
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCalibrationFactor(ADC_TypeDef *ADCx, uint32_t SingleDiff, uint32_t CalibrationFactor)
{
  MODIFY_REG(ADCx->CALFACT,
             SingleDiff & ADC_SINGLEDIFF_CALIB_FACTOR_MASK,
             CalibrationFactor << (((SingleDiff & ADC_SINGLEDIFF_CALIB_F_BIT_D_MASK)
                                    >> ADC_SINGLEDIFF_CALIB_F_BIT_D_SHIFT4)
                                   & ~(SingleDiff & ADC_CALFACT_CALFACT_S)));
}

/**
  * @brief  Get ADC calibration factor in the mode single-ended
  *         or differential (for devices with differential mode available).
  * @note   Calibration factors are set by hardware after performing
  *         a calibration run using function @ref LL_ADC_StartCalibration().
  * @note   For devices with differential mode available:
  *         Calibration of offset is specific to each of
  *         single-ended and differential modes
  * @rmtoll CALFACT  CALFACT_S      LL_ADC_GetCalibrationFactor\n
  *         CALFACT  CALFACT_D      LL_ADC_GetCalibrationFactor
  * @param  ADCx ADC instance
  * @param  SingleDiff This parameter can be one of the following values:
  *         @arg @ref LL_ADC_SINGLE_ENDED
  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
  * @retval Value between Min_Data=0x00 and Max_Data=0x7F
  */
__STATIC_INLINE uint32_t LL_ADC_GetCalibrationFactor(const ADC_TypeDef *ADCx, uint32_t SingleDiff)
{
  /* Retrieve bits with position in register depending on parameter           */
  /* "SingleDiff".                                                            */
  /* Parameter used with mask "ADC_SINGLEDIFF_CALIB_FACTOR_MASK" because      */
  /* containing other bits reserved for other purpose.                        */
  return (uint32_t)(READ_BIT(ADCx->CALFACT,
                             (SingleDiff & ADC_SINGLEDIFF_CALIB_FACTOR_MASK))
                    >> ((SingleDiff & ADC_SINGLEDIFF_CALIB_F_BIT_D_MASK) >>
                        ADC_SINGLEDIFF_CALIB_F_BIT_D_SHIFT4));
}

/**
  * @brief  Set ADC resolution.
  *         Refer to reference manual for alignments formats
  *         dependencies to ADC resolutions.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll CFGR     RES            LL_ADC_SetResolution
  * @param  ADCx ADC instance
  * @param  Resolution This parameter can be one of the following values:
  *         @arg @ref LL_ADC_RESOLUTION_12B
  *         @arg @ref LL_ADC_RESOLUTION_10B
  *         @arg @ref LL_ADC_RESOLUTION_8B
  *         @arg @ref LL_ADC_RESOLUTION_6B
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetResolution(ADC_TypeDef *ADCx, uint32_t Resolution)
{
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_RES, Resolution);
}

/**
  * @brief  Get ADC resolution.
  *         Refer to reference manual for alignments formats
  *         dependencies to ADC resolutions.
  * @rmtoll CFGR     RES            LL_ADC_GetResolution
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_RESOLUTION_12B
  *         @arg @ref LL_ADC_RESOLUTION_10B
  *         @arg @ref LL_ADC_RESOLUTION_8B
  *         @arg @ref LL_ADC_RESOLUTION_6B
  */
__STATIC_INLINE uint32_t LL_ADC_GetResolution(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES));
}

/**
  * @brief  Set ADC conversion data alignment.
  * @note   Refer to reference manual for alignments formats
  *         dependencies to ADC resolutions.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll CFGR     ALIGN          LL_ADC_SetDataAlignment
  * @param  ADCx ADC instance
  * @param  DataAlignment This parameter can be one of the following values:
  *         @arg @ref LL_ADC_DATA_ALIGN_RIGHT
  *         @arg @ref LL_ADC_DATA_ALIGN_LEFT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetDataAlignment(ADC_TypeDef *ADCx, uint32_t DataAlignment)
{
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_ALIGN, DataAlignment);
}

/**
  * @brief  Get ADC conversion data alignment.
  * @note   Refer to reference manual for alignments formats
  *         dependencies to ADC resolutions.
  * @rmtoll CFGR     ALIGN          LL_ADC_GetDataAlignment
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_DATA_ALIGN_RIGHT
  *         @arg @ref LL_ADC_DATA_ALIGN_LEFT
  */
__STATIC_INLINE uint32_t LL_ADC_GetDataAlignment(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_ALIGN));
}

/**
  * @brief  Set ADC low power mode.
  * @note   Description of ADC low power modes:
  *         - ADC low power mode "auto wait": Dynamic low power mode,
  *           ADC conversions occurrences are limited to the minimum necessary
  *           in order to reduce power consumption.
  *           New ADC conversion starts only when the previous
  *           unitary conversion data (for ADC group regular)
  *           or previous sequence conversions data (for ADC group injected)
  *           has been retrieved by user software.
  *           In the meantime, ADC remains idle: does not performs any
  *           other conversion.
  *           This mode allows to automatically adapt the ADC conversions
  *           triggers to the speed of the software that reads the data.
  *           Moreover, this avoids risk of overrun for low frequency
  *           applications.
  *           How to use this low power mode:
  *           - It is not recommended to use with interruption or DMA
  *             since these modes have to clear immediately the EOC flag
  *             (by CPU to free the IRQ pending event or by DMA).
  *             Auto wait will work but fort a very short time, discarding
  *             its intended benefit (except specific case of high load of CPU
  *             or DMA transfers which can justify usage of auto wait).
  *           - Do use with polling: 1. Start conversion,
  *             2. Later on, when conversion data is needed: poll for end of
  *             conversion  to ensure that conversion is completed and
  *             retrieve ADC conversion data. This will trig another
  *             ADC conversion start.
  * @note   With ADC low power mode "auto wait", the ADC conversion data read
  *         is corresponding to previous ADC conversion start, independently
  *         of delay during which ADC was idle.
  *         Therefore, the ADC conversion data may be outdated: does not
  *         correspond to the current voltage level on the selected
  *         ADC channel.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll CFGR     AUTDLY         LL_ADC_SetLowPowerMode
  * @param  ADCx ADC instance
  * @param  LowPowerMode This parameter can be one of the following values:
  *         @arg @ref LL_ADC_LP_MODE_NONE
  *         @arg @ref LL_ADC_LP_AUTOWAIT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetLowPowerMode(ADC_TypeDef *ADCx, uint32_t LowPowerMode)
{
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_AUTDLY, LowPowerMode);
}

/**
  * @brief  Get ADC low power mode:
  * @note   Description of ADC low power modes:
  *         - ADC low power mode "auto wait": Dynamic low power mode,
  *           ADC conversions occurrences are limited to the minimum necessary
  *           in order to reduce power consumption.
  *           New ADC conversion starts only when the previous
  *           unitary conversion data (for ADC group regular)
  *           or previous sequence conversions data (for ADC group injected)
  *           has been retrieved by user software.
  *           In the meantime, ADC remains idle: does not performs any
  *           other conversion.
  *           This mode allows to automatically adapt the ADC conversions
  *           triggers to the speed of the software that reads the data.
  *           Moreover, this avoids risk of overrun for low frequency
  *           applications.
  *           How to use this low power mode:
  *           - It is not recommended to use with interruption or DMA
  *             since these modes have to clear immediately the EOC flag
  *             (by CPU to free the IRQ pending event or by DMA).
  *             Auto wait will work but fort a very short time, discarding
  *             its intended benefit (except specific case of high load of CPU
  *             or DMA transfers which can justify usage of auto wait).
  *           - Do use with polling: 1. Start conversion,
  *             2. Later on, when conversion data is needed: poll for end of
  *             conversion  to ensure that conversion is completed and
  *             retrieve ADC conversion data. This will trig another
  *             ADC conversion start.
  * @note   With ADC low power mode "auto wait", the ADC conversion data read
  *         is corresponding to previous ADC conversion start, independently
  *         of delay during which ADC was idle.
  *         Therefore, the ADC conversion data may be outdated: does not
  *         correspond to the current voltage level on the selected
  *         ADC channel.
  * @rmtoll CFGR     AUTDLY         LL_ADC_GetLowPowerMode
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_LP_MODE_NONE
  *         @arg @ref LL_ADC_LP_AUTOWAIT
  */
__STATIC_INLINE uint32_t LL_ADC_GetLowPowerMode(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_AUTDLY));
}

/**
  * @brief  Set ADC selected offset instance 1, 2, 3 or 4.
  * @note   This function set the 2 items of offset configuration:
  *         - ADC channel to which the offset programmed will be applied
  *           (independently of channel mapped on ADC group regular
  *           or group injected)
  *         - Offset level (offset to be subtracted from the raw
  *           converted data).
  * @note   Caution: Offset format is dependent to ADC resolution:
  *         offset has to be left-aligned on bit 11, the LSB (right bits)
  *         are set to 0.
  * @note   This function enables the offset, by default. It can be forced
  *         to disable state using function LL_ADC_SetOffsetState().
  * @note   If a channel is mapped on several offsets numbers, only the offset
  *         with the lowest value is considered for the subtraction.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @note   On STM32G4, some fast channels are available: fast analog inputs
  *         coming from GPIO pads (ADC_IN1..5).
  * @rmtoll OFR1     OFFSET1_CH     LL_ADC_SetOffset\n
  *         OFR1     OFFSET1        LL_ADC_SetOffset\n
  *         OFR1     OFFSET1_EN     LL_ADC_SetOffset\n
  *         OFR2     OFFSET2_CH     LL_ADC_SetOffset\n
  *         OFR2     OFFSET2        LL_ADC_SetOffset\n
  *         OFR2     OFFSET2_EN     LL_ADC_SetOffset\n
  *         OFR3     OFFSET3_CH     LL_ADC_SetOffset\n
  *         OFR3     OFFSET3        LL_ADC_SetOffset\n
  *         OFR3     OFFSET3_EN     LL_ADC_SetOffset\n
  *         OFR4     OFFSET4_CH     LL_ADC_SetOffset\n
  *         OFR4     OFFSET4        LL_ADC_SetOffset\n
  *         OFR4     OFFSET4_EN     LL_ADC_SetOffset
  * @param  ADCx ADC instance
  * @param  Offsety This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_1
  *         @arg @ref LL_ADC_OFFSET_2
  *         @arg @ref LL_ADC_OFFSET_3
  *         @arg @ref LL_ADC_OFFSET_4
  * @param  Channel This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  * @param  OffsetLevel Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffset(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t Channel, uint32_t OffsetLevel)
{
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);

  MODIFY_REG(*preg,
             ADC_OFR1_OFFSET1_EN | ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1,
             ADC_OFR1_OFFSET1_EN | (Channel & ADC_CHANNEL_ID_NUMBER_MASK) | OffsetLevel);
}

/**
  * @brief  Get for the ADC selected offset instance 1, 2, 3 or 4:
  *         Channel to which the offset programmed will be applied
  *         (independently of channel mapped on ADC group regular
  *         or group injected)
  * @note   Usage of the returned channel number:
  *         - To reinject this channel into another function LL_ADC_xxx:
  *           the returned channel number is only partly formatted on definition
  *           of literals LL_ADC_CHANNEL_x. Therefore, it has to be compared
  *           with parts of literals LL_ADC_CHANNEL_x or using
  *           helper macro @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
  *           Then the selected literal LL_ADC_CHANNEL_x can be used
  *           as parameter for another function.
  *         - To get the channel number in decimal format:
  *           process the returned value with the helper macro
  *           @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
  * @note   On STM32G4, some fast channels are available: fast analog inputs
  *         coming from GPIO pads (ADC_IN1..5).
  * @rmtoll OFR1     OFFSET1_CH     LL_ADC_GetOffsetChannel\n
  *         OFR2     OFFSET2_CH     LL_ADC_GetOffsetChannel\n
  *         OFR3     OFFSET3_CH     LL_ADC_GetOffsetChannel\n
  *         OFR4     OFFSET4_CH     LL_ADC_GetOffsetChannel
  * @param  ADCx ADC instance
  * @param  Offsety This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_1
  *         @arg @ref LL_ADC_OFFSET_2
  *         @arg @ref LL_ADC_OFFSET_3
  *         @arg @ref LL_ADC_OFFSET_4
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet for
  *             more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  *         (1, 2, 3, 4, 5, 7) For ADC channel read back from ADC register,
  *                      comparison with internal channel parameter to be done
  *                      using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
  */
__STATIC_INLINE uint32_t LL_ADC_GetOffsetChannel(const ADC_TypeDef *ADCx, uint32_t Offsety)
{
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);

  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
}

/**
  * @brief  Get for the ADC selected offset instance 1, 2, 3 or 4:
  *         Offset level (offset to be subtracted from the raw
  *         converted data).
  * @note   Caution: Offset format is dependent to ADC resolution:
  *         offset has to be left-aligned on bit 11, the LSB (right bits)
  *         are set to 0.
  * @rmtoll OFR1     OFFSET1        LL_ADC_GetOffsetLevel\n
  *         OFR2     OFFSET2        LL_ADC_GetOffsetLevel\n
  *         OFR3     OFFSET3        LL_ADC_GetOffsetLevel\n
  *         OFR4     OFFSET4        LL_ADC_GetOffsetLevel
  * @param  ADCx ADC instance
  * @param  Offsety This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_1
  *         @arg @ref LL_ADC_OFFSET_2
  *         @arg @ref LL_ADC_OFFSET_3
  *         @arg @ref LL_ADC_OFFSET_4
  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
  */
__STATIC_INLINE uint32_t LL_ADC_GetOffsetLevel(const ADC_TypeDef *ADCx, uint32_t Offsety)
{
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);

  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1);
}

/**
  * @brief  Set for the ADC selected offset instance 1, 2, 3 or 4:
  *         force offset state disable or enable
  *         without modifying offset channel or offset value.
  * @note   This function should be needed only in case of offset to be
  *         enabled-disabled dynamically, and should not be needed in other cases:
  *         function LL_ADC_SetOffset() automatically enables the offset.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll OFR1     OFFSET1_EN     LL_ADC_SetOffsetState\n
  *         OFR2     OFFSET2_EN     LL_ADC_SetOffsetState\n
  *         OFR3     OFFSET3_EN     LL_ADC_SetOffsetState\n
  *         OFR4     OFFSET4_EN     LL_ADC_SetOffsetState
  * @param  ADCx ADC instance
  * @param  Offsety This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_1
  *         @arg @ref LL_ADC_OFFSET_2
  *         @arg @ref LL_ADC_OFFSET_3
  *         @arg @ref LL_ADC_OFFSET_4
  * @param  OffsetState This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_DISABLE
  *         @arg @ref LL_ADC_OFFSET_ENABLE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetState(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetState)
{
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);

  MODIFY_REG(*preg,
             ADC_OFR1_OFFSET1_EN,
             OffsetState);
}

/**
  * @brief  Get for the ADC selected offset instance 1, 2, 3 or 4:
  *         offset state disabled or enabled.
  * @rmtoll OFR1     OFFSET1_EN     LL_ADC_GetOffsetState\n
  *         OFR2     OFFSET2_EN     LL_ADC_GetOffsetState\n
  *         OFR3     OFFSET3_EN     LL_ADC_GetOffsetState\n
  *         OFR4     OFFSET4_EN     LL_ADC_GetOffsetState
  * @param  ADCx ADC instance
  * @param  Offsety This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_1
  *         @arg @ref LL_ADC_OFFSET_2
  *         @arg @ref LL_ADC_OFFSET_3
  *         @arg @ref LL_ADC_OFFSET_4
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_DISABLE
  *         @arg @ref LL_ADC_OFFSET_ENABLE
  */
__STATIC_INLINE uint32_t LL_ADC_GetOffsetState(const ADC_TypeDef *ADCx, uint32_t Offsety)
{
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);

  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_EN);
}

/**
  * @brief  Set for the ADC selected offset instance 1, 2, 3 or 4:
  *         choose offset sign.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll OFR1     OFFSETPOS      LL_ADC_SetOffsetSign\n
  *         OFR2     OFFSETPOS      LL_ADC_SetOffsetSign\n
  *         OFR3     OFFSETPOS      LL_ADC_SetOffsetSign\n
  *         OFR4     OFFSETPOS      LL_ADC_SetOffsetSign
  * @param  ADCx ADC instance
  * @param  Offsety This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_1
  *         @arg @ref LL_ADC_OFFSET_2
  *         @arg @ref LL_ADC_OFFSET_3
  *         @arg @ref LL_ADC_OFFSET_4
  * @param  OffsetSign This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_SIGN_NEGATIVE
  *         @arg @ref LL_ADC_OFFSET_SIGN_POSITIVE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetSign(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetSign)
{
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);

  MODIFY_REG(*preg,
             ADC_OFR1_OFFSETPOS,
             OffsetSign);
}

/**
  * @brief  Get for the ADC selected offset instance 1, 2, 3 or 4:
  *         offset sign if positive or negative.
  * @rmtoll OFR1     OFFSETPOS      LL_ADC_GetOffsetSign\n
  *         OFR2     OFFSETPOS      LL_ADC_GetOffsetSign\n
  *         OFR3     OFFSETPOS      LL_ADC_GetOffsetSign\n
  *         OFR4     OFFSETPOS      LL_ADC_GetOffsetSign
  * @param  ADCx ADC instance
  * @param  Offsety This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_1
  *         @arg @ref LL_ADC_OFFSET_2
  *         @arg @ref LL_ADC_OFFSET_3
  *         @arg @ref LL_ADC_OFFSET_4
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_SIGN_NEGATIVE
  *         @arg @ref LL_ADC_OFFSET_SIGN_POSITIVE
  */
__STATIC_INLINE uint32_t LL_ADC_GetOffsetSign(const ADC_TypeDef *ADCx, uint32_t Offsety)
{
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);

  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSETPOS);
}

/**
  * @brief  Set for the ADC selected offset instance 1, 2, 3 or 4:
  *         choose offset saturation mode.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll OFR1     SATEN          LL_ADC_SetOffsetSaturation\n
  *         OFR2     SATEN          LL_ADC_SetOffsetSaturation\n
  *         OFR3     SATEN          LL_ADC_SetOffsetSaturation\n
  *         OFR4     SATEN          LL_ADC_SetOffsetSaturation
  * @param  ADCx ADC instance
  * @param  Offsety This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_1
  *         @arg @ref LL_ADC_OFFSET_2
  *         @arg @ref LL_ADC_OFFSET_3
  *         @arg @ref LL_ADC_OFFSET_4
  * @param  OffsetSaturation This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_SATURATION_ENABLE
  *         @arg @ref LL_ADC_OFFSET_SATURATION_DISABLE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetSaturation(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetSaturation)
{
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);

  MODIFY_REG(*preg,
             ADC_OFR1_SATEN,
             OffsetSaturation);
}

/**
  * @brief  Get for the ADC selected offset instance 1, 2, 3 or 4:
  *         offset saturation if enabled or disabled.
  * @rmtoll OFR1     SATEN          LL_ADC_GetOffsetSaturation\n
  *         OFR2     SATEN          LL_ADC_GetOffsetSaturation\n
  *         OFR3     SATEN          LL_ADC_GetOffsetSaturation\n
  *         OFR4     SATEN          LL_ADC_GetOffsetSaturation
  * @param  ADCx ADC instance
  * @param  Offsety This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_1
  *         @arg @ref LL_ADC_OFFSET_2
  *         @arg @ref LL_ADC_OFFSET_3
  *         @arg @ref LL_ADC_OFFSET_4
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_OFFSET_SATURATION_ENABLE
  *         @arg @ref LL_ADC_OFFSET_SATURATION_DISABLE
  */
__STATIC_INLINE uint32_t LL_ADC_GetOffsetSaturation(const ADC_TypeDef *ADCx, uint32_t Offsety)
{
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);

  return (uint32_t) READ_BIT(*preg, ADC_OFR1_SATEN);
}

/**
  * @brief  Set ADC gain compensation.
  * @note   This function set the gain compensation coefficient
  *         that is applied to raw converted data using the formula:
  *           DATA = DATA(raw) * (gain compensation coef) / 4096
  * @note   This function enables the gain compensation if given
  *         coefficient is above 0, otherwise it disables it.
  * @note   Gain compensation when enabled is applied to all channels.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll GCOMP    GCOMPCOEFF     LL_ADC_SetGainCompensation\n
  *         CFGR2    GCOMP          LL_ADC_SetGainCompensation
  * @param  ADCx ADC instance
  * @param  GainCompensation This parameter can be:
  *         0           Gain compensation will be disabled and value set to 0
  *         1 -> 16393  Gain compensation will be enabled with specified value
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetGainCompensation(ADC_TypeDef *ADCx, uint32_t GainCompensation)
{
  MODIFY_REG(ADCx->GCOMP, ADC_GCOMP_GCOMPCOEFF, GainCompensation);
  MODIFY_REG(ADCx->CFGR2, ADC_CFGR2_GCOMP, ((GainCompensation == 0UL) ? 0UL : 1UL) << ADC_CFGR2_GCOMP_Pos);
}

/**
  * @brief  Get the ADC gain compensation value
  * @rmtoll GCOMP    GCOMPCOEFF     LL_ADC_GetGainCompensation\n
  *         CFGR2    GCOMP          LL_ADC_GetGainCompensation
  * @param  ADCx ADC instance
  * @retval Returned value can be:
  *         0           Gain compensation is disabled
  *         1 -> 16393  Gain compensation is enabled with returned value
  */
__STATIC_INLINE uint32_t LL_ADC_GetGainCompensation(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CFGR2, ADC_CFGR2_GCOMP) == ADC_CFGR2_GCOMP) ?
          READ_BIT(ADCx->GCOMP, ADC_GCOMP_GCOMPCOEFF) : 0UL);
}


/**
  * @brief  Set ADC sampling time common configuration impacting
  *         settings of sampling time channel wise.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll SMPR1    SMPPLUS        LL_ADC_SetSamplingTimeCommonConfig
  * @param  ADCx ADC instance
  * @param  SamplingTimeCommonConfig This parameter can be one of the following values:
  *         @arg @ref LL_ADC_SAMPLINGTIME_COMMON_DEFAULT
  *         @arg @ref LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetSamplingTimeCommonConfig(ADC_TypeDef *ADCx, uint32_t SamplingTimeCommonConfig)
{
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
}

/**
  * @brief  Get ADC sampling time common configuration impacting
  *         settings of sampling time channel wise.
  * @rmtoll SMPR1    SMPPLUS        LL_ADC_GetSamplingTimeCommonConfig
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_SAMPLINGTIME_COMMON_DEFAULT
  *         @arg @ref LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5
  */
__STATIC_INLINE uint32_t LL_ADC_GetSamplingTimeCommonConfig(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->SMPR1, ADC_SMPR1_SMPPLUS));
}


/**
  * @}
  */

/** @defgroup ADC_LL_EF_Configuration_ADC_Group_Regular Configuration of ADC hierarchical scope: group regular
  * @{
  */

/**
  * @brief  Set ADC group regular conversion trigger source:
  *         internal (SW start) or from external peripheral (timer event,
  *         external interrupt line).
  * @note   On this STM32 series, setting trigger source to external trigger
  *         also set trigger polarity to rising edge
  *         (default setting for compatibility with some ADC on other
  *         STM32 series having this setting set by HW default value).
  *         In case of need to modify trigger edge, use
  *         function @ref LL_ADC_REG_SetTriggerEdge().
  * @note   Availability of parameters of trigger sources from timer
  *         depends on timers availability on the selected device.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on group regular.
  * @rmtoll CFGR     EXTSEL         LL_ADC_REG_SetTriggerSource\n
  *         CFGR     EXTEN          LL_ADC_REG_SetTriggerSource
  * @param  ADCx ADC instance
  * @param  TriggerSource This parameter can be one of the following values:
  *         @arg @ref LL_ADC_REG_TRIG_SOFTWARE
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_TRGO2
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_CH1        (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_CH2        (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_CH3
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM2_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM2_CH1        (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM2_CH2        (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM2_CH3        (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM3_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM3_CH1        (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM3_CH4        (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM4_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM4_CH1        (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM4_CH4        (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM6_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM7_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM8_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM8_TRGO2
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM8_CH1        (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM15_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM20_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM20_TRGO2
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM20_CH1
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM20_CH2       (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM20_CH3       (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG1
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG2      (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG3
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG4      (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG5
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG6
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG7
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG8
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG9
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG10
  *         @arg @ref LL_ADC_REG_TRIG_EXT_EXTI_LINE11     (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_EXTI_LINE2      (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_LPTIM_OUT
  *
  *         (1) On STM32G4 series, parameter not available on all ADC instances: ADC1, ADC2.\n
  *         (2) On STM32G4 series, parameter not available on all ADC instances: ADC3, ADC4, ADC5.
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet for
  *             more details.
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetTriggerSource(ADC_TypeDef *ADCx, uint32_t TriggerSource)
{
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_EXTEN | ADC_CFGR_EXTSEL, TriggerSource);
}

/**
  * @brief  Get ADC group regular conversion trigger source:
  *         internal (SW start) or from external peripheral (timer event,
  *         external interrupt line).
  * @note   To determine whether group regular trigger source is
  *         internal (SW start) or external, without detail
  *         of which peripheral is selected as external trigger,
  *         (equivalent to
  *         "if(LL_ADC_REG_GetTriggerSource(ADC1) == LL_ADC_REG_TRIG_SOFTWARE)")
  *         use function @ref LL_ADC_REG_IsTriggerSourceSWStart.
  * @note   Availability of parameters of trigger sources from timer
  *         depends on timers availability on the selected device.
  * @rmtoll CFGR     EXTSEL         LL_ADC_REG_GetTriggerSource\n
  *         CFGR     EXTEN          LL_ADC_REG_GetTriggerSource
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_REG_TRIG_SOFTWARE
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_TRGO2
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_CH1        (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_CH2        (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM1_CH3
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM2_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM2_CH1        (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM2_CH2        (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM2_CH3        (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM3_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM3_CH1        (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM3_CH4        (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM4_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM4_CH1        (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM4_CH4        (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM6_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM7_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM8_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM8_TRGO2
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM8_CH1        (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM15_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM20_TRGO
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM20_TRGO2
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM20_CH1
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM20_CH2       (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_TIM20_CH3       (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG1
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG2      (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG3
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG4      (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG5
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG6
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG7
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG8
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG9
  *         @arg @ref LL_ADC_REG_TRIG_EXT_HRTIM_TRG10
  *         @arg @ref LL_ADC_REG_TRIG_EXT_EXTI_LINE11     (1)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_EXTI_LINE2      (2)
  *         @arg @ref LL_ADC_REG_TRIG_EXT_LPTIM_OUT
  *
  *         (1) On STM32G4 series, parameter not available on all ADC instances: ADC1, ADC2.\n
  *         (2) On STM32G4 series, parameter not available on all ADC instances: ADC3, ADC4, ADC5.
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet for
  *             more details.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_GetTriggerSource(const ADC_TypeDef *ADCx)
{
  __IO uint32_t trigger_source = READ_BIT(ADCx->CFGR, ADC_CFGR_EXTSEL | ADC_CFGR_EXTEN);

  /* Value for shift of {0; 4; 8; 12} depending on value of bitfield          */
  /* corresponding to ADC_CFGR_EXTEN {0; 1; 2; 3}.                            */
  uint32_t shift_exten = ((trigger_source & ADC_CFGR_EXTEN) >> (ADC_REG_TRIG_EXTEN_BITOFFSET_POS - 2UL));

  /* Set bitfield corresponding to ADC_CFGR_EXTEN and ADC_CFGR_EXTSEL         */
  /* to match with triggers literals definition.                              */
  return ((trigger_source
           & (ADC_REG_TRIG_SOURCE_MASK >> shift_exten) & ADC_CFGR_EXTSEL)
          | ((ADC_REG_TRIG_EDGE_MASK >> shift_exten) & ADC_CFGR_EXTEN)
         );
}

/**
  * @brief  Get ADC group regular conversion trigger source internal (SW start)
  *         or external.
  * @note   In case of group regular trigger source set to external trigger,
  *         to determine which peripheral is selected as external trigger,
  *         use function @ref LL_ADC_REG_GetTriggerSource().
  * @rmtoll CFGR     EXTEN          LL_ADC_REG_IsTriggerSourceSWStart
  * @param  ADCx ADC instance
  * @retval Value "0" if trigger source external trigger
  *         Value "1" if trigger source SW start.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsTriggerSourceSWStart(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
}

/**
  * @brief  Set ADC group regular conversion trigger polarity.
  * @note   Applicable only for trigger source set to external trigger.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on group regular.
  * @rmtoll CFGR     EXTEN          LL_ADC_REG_SetTriggerEdge
  * @param  ADCx ADC instance
  * @param  ExternalTriggerEdge This parameter can be one of the following values:
  *         @arg @ref LL_ADC_REG_TRIG_EXT_RISING
  *         @arg @ref LL_ADC_REG_TRIG_EXT_FALLING
  *         @arg @ref LL_ADC_REG_TRIG_EXT_RISINGFALLING
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetTriggerEdge(ADC_TypeDef *ADCx, uint32_t ExternalTriggerEdge)
{
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_EXTEN, ExternalTriggerEdge);
}

/**
  * @brief  Get ADC group regular conversion trigger polarity.
  * @note   Applicable only for trigger source set to external trigger.
  * @rmtoll CFGR     EXTEN          LL_ADC_REG_GetTriggerEdge
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_REG_TRIG_EXT_RISING
  *         @arg @ref LL_ADC_REG_TRIG_EXT_FALLING
  *         @arg @ref LL_ADC_REG_TRIG_EXT_RISINGFALLING
  */
__STATIC_INLINE uint32_t LL_ADC_REG_GetTriggerEdge(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN));
}

/**
  * @brief  Set ADC sampling mode.
  * @note   This function set the ADC conversion sampling mode
  * @note   This mode applies to regular group only.
  * @note   Set sampling mode is applied to all conversion of regular group.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on group regular.
  * @rmtoll CFGR2    BULB           LL_ADC_REG_SetSamplingMode\n
  *         CFGR2    SMPTRIG        LL_ADC_REG_SetSamplingMode
  * @param  ADCx ADC instance
  * @param  SamplingMode This parameter can be one of the following values:
  *         @arg @ref LL_ADC_REG_SAMPLING_MODE_NORMAL
  *         @arg @ref LL_ADC_REG_SAMPLING_MODE_BULB
  *         @arg @ref LL_ADC_REG_SAMPLING_MODE_TRIGGER_CONTROLED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetSamplingMode(ADC_TypeDef *ADCx, uint32_t SamplingMode)
{
  MODIFY_REG(ADCx->CFGR2, ADC_CFGR2_BULB | ADC_CFGR2_SMPTRIG, SamplingMode);
}

/**
  * @brief  Get the ADC sampling mode
  * @rmtoll CFGR2    BULB           LL_ADC_REG_GetSamplingMode\n
  *         CFGR2    SMPTRIG        LL_ADC_REG_GetSamplingMode
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_REG_SAMPLING_MODE_NORMAL
  *         @arg @ref LL_ADC_REG_SAMPLING_MODE_BULB
  *         @arg @ref LL_ADC_REG_SAMPLING_MODE_TRIGGER_CONTROLED
  */
__STATIC_INLINE uint32_t LL_ADC_REG_GetSamplingMode(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR2, ADC_CFGR2_BULB | ADC_CFGR2_SMPTRIG));
}

/**
  * @brief  Set ADC group regular sequencer length and scan direction.
  * @note   Description of ADC group regular sequencer features:
  *         - For devices with sequencer fully configurable
  *           (function "LL_ADC_REG_SetSequencerRanks()" available):
  *           sequencer length and each rank affectation to a channel
  *           are configurable.
  *           This function performs configuration of:
  *           - Sequence length: Number of ranks in the scan sequence.
  *           - Sequence direction: Unless specified in parameters, sequencer
  *             scan direction is forward (from rank 1 to rank n).
  *           Sequencer ranks are selected using
  *           function "LL_ADC_REG_SetSequencerRanks()".
  *         - For devices with sequencer not fully configurable
  *           (function "LL_ADC_REG_SetSequencerChannels()" available):
  *           sequencer length and each rank affectation to a channel
  *           are defined by channel number.
  *           This function performs configuration of:
  *           - Sequence length: Number of ranks in the scan sequence is
  *             defined by number of channels set in the sequence,
  *             rank of each channel is fixed by channel HW number.
  *             (channel 0 fixed on rank 0, channel 1 fixed on rank1, ...).
  *           - Sequence direction: Unless specified in parameters, sequencer
  *             scan direction is forward (from lowest channel number to
  *             highest channel number).
  *           Sequencer ranks are selected using
  *           function "LL_ADC_REG_SetSequencerChannels()".
  * @note   Sequencer disabled is equivalent to sequencer of 1 rank:
  *         ADC conversion on only 1 channel.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on group regular.
  * @rmtoll SQR1     L              LL_ADC_REG_SetSequencerLength
  * @param  ADCx ADC instance
  * @param  SequencerNbRanks This parameter can be one of the following values:
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_DISABLE
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetSequencerLength(ADC_TypeDef *ADCx, uint32_t SequencerNbRanks)
{
  MODIFY_REG(ADCx->SQR1, ADC_SQR1_L, SequencerNbRanks);
}

/**
  * @brief  Get ADC group regular sequencer length and scan direction.
  * @note   Description of ADC group regular sequencer features:
  *         - For devices with sequencer fully configurable
  *           (function "LL_ADC_REG_SetSequencerRanks()" available):
  *           sequencer length and each rank affectation to a channel
  *           are configurable.
  *           This function retrieves:
  *           - Sequence length: Number of ranks in the scan sequence.
  *           - Sequence direction: Unless specified in parameters, sequencer
  *             scan direction is forward (from rank 1 to rank n).
  *           Sequencer ranks are selected using
  *           function "LL_ADC_REG_SetSequencerRanks()".
  *         - For devices with sequencer not fully configurable
  *           (function "LL_ADC_REG_SetSequencerChannels()" available):
  *           sequencer length and each rank affectation to a channel
  *           are defined by channel number.
  *           This function retrieves:
  *           - Sequence length: Number of ranks in the scan sequence is
  *             defined by number of channels set in the sequence,
  *             rank of each channel is fixed by channel HW number.
  *             (channel 0 fixed on rank 0, channel 1 fixed on rank1, ...).
  *           - Sequence direction: Unless specified in parameters, sequencer
  *             scan direction is forward (from lowest channel number to
  *             highest channel number).
  *           Sequencer ranks are selected using
  *           function "LL_ADC_REG_SetSequencerChannels()".
  * @note   Sequencer disabled is equivalent to sequencer of 1 rank:
  *         ADC conversion on only 1 channel.
  * @rmtoll SQR1     L              LL_ADC_REG_GetSequencerLength
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_DISABLE
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS
  *         @arg @ref LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS
  */
__STATIC_INLINE uint32_t LL_ADC_REG_GetSequencerLength(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->SQR1, ADC_SQR1_L));
}

/**
  * @brief  Set ADC group regular sequencer discontinuous mode:
  *         sequence subdivided and scan conversions interrupted every selected
  *         number of ranks.
  * @note   It is not possible to enable both ADC group regular
  *         continuous mode and sequencer discontinuous mode.
  * @note   It is not possible to enable both ADC auto-injected mode
  *         and ADC group regular sequencer discontinuous mode.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on group regular.
  * @rmtoll CFGR     DISCEN         LL_ADC_REG_SetSequencerDiscont\n
  *         CFGR     DISCNUM        LL_ADC_REG_SetSequencerDiscont
  * @param  ADCx ADC instance
  * @param  SeqDiscont This parameter can be one of the following values:
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_DISABLE
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_1RANK
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_2RANKS
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_3RANKS
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_4RANKS
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_5RANKS
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_6RANKS
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_7RANKS
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_8RANKS
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetSequencerDiscont(ADC_TypeDef *ADCx, uint32_t SeqDiscont)
{
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_DISCEN | ADC_CFGR_DISCNUM, SeqDiscont);
}

/**
  * @brief  Get ADC group regular sequencer discontinuous mode:
  *         sequence subdivided and scan conversions interrupted every selected
  *         number of ranks.
  * @rmtoll CFGR     DISCEN         LL_ADC_REG_GetSequencerDiscont\n
  *         CFGR     DISCNUM        LL_ADC_REG_GetSequencerDiscont
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_DISABLE
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_1RANK
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_2RANKS
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_3RANKS
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_4RANKS
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_5RANKS
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_6RANKS
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_7RANKS
  *         @arg @ref LL_ADC_REG_SEQ_DISCONT_8RANKS
  */
__STATIC_INLINE uint32_t LL_ADC_REG_GetSequencerDiscont(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_DISCEN | ADC_CFGR_DISCNUM));
}

/**
  * @brief  Set ADC group regular sequence: channel on the selected
  *         scan sequence rank.
  * @note   This function performs configuration of:
  *         - Channels ordering into each rank of scan sequence:
  *           whatever channel can be placed into whatever rank.
  * @note   On this STM32 series, ADC group regular sequencer is
  *         fully configurable: sequencer length and each rank
  *         affectation to a channel are configurable.
  *         Refer to description of function @ref LL_ADC_REG_SetSequencerLength().
  * @note   Depending on devices and packages, some channels may not be available.
  *         Refer to device datasheet for channels availability.
  * @note   On this STM32 series, to measure internal channels (VrefInt,
  *         TempSensor, ...), measurement paths to internal channels must be
  *         enabled separately.
  *         This can be done using function @ref LL_ADC_SetCommonPathInternalCh().
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on group regular.
  * @rmtoll SQR1     SQ1            LL_ADC_REG_SetSequencerRanks\n
  *         SQR1     SQ2            LL_ADC_REG_SetSequencerRanks\n
  *         SQR1     SQ3            LL_ADC_REG_SetSequencerRanks\n
  *         SQR1     SQ4            LL_ADC_REG_SetSequencerRanks\n
  *         SQR2     SQ5            LL_ADC_REG_SetSequencerRanks\n
  *         SQR2     SQ6            LL_ADC_REG_SetSequencerRanks\n
  *         SQR2     SQ7            LL_ADC_REG_SetSequencerRanks\n
  *         SQR2     SQ8            LL_ADC_REG_SetSequencerRanks\n
  *         SQR2     SQ9            LL_ADC_REG_SetSequencerRanks\n
  *         SQR3     SQ10           LL_ADC_REG_SetSequencerRanks\n
  *         SQR3     SQ11           LL_ADC_REG_SetSequencerRanks\n
  *         SQR3     SQ12           LL_ADC_REG_SetSequencerRanks\n
  *         SQR3     SQ13           LL_ADC_REG_SetSequencerRanks\n
  *         SQR3     SQ14           LL_ADC_REG_SetSequencerRanks\n
  *         SQR4     SQ15           LL_ADC_REG_SetSequencerRanks\n
  *         SQR4     SQ16           LL_ADC_REG_SetSequencerRanks
  * @param  ADCx ADC instance
  * @param  Rank This parameter can be one of the following values:
  *         @arg @ref LL_ADC_REG_RANK_1
  *         @arg @ref LL_ADC_REG_RANK_2
  *         @arg @ref LL_ADC_REG_RANK_3
  *         @arg @ref LL_ADC_REG_RANK_4
  *         @arg @ref LL_ADC_REG_RANK_5
  *         @arg @ref LL_ADC_REG_RANK_6
  *         @arg @ref LL_ADC_REG_RANK_7
  *         @arg @ref LL_ADC_REG_RANK_8
  *         @arg @ref LL_ADC_REG_RANK_9
  *         @arg @ref LL_ADC_REG_RANK_10
  *         @arg @ref LL_ADC_REG_RANK_11
  *         @arg @ref LL_ADC_REG_RANK_12
  *         @arg @ref LL_ADC_REG_RANK_13
  *         @arg @ref LL_ADC_REG_RANK_14
  *         @arg @ref LL_ADC_REG_RANK_15
  *         @arg @ref LL_ADC_REG_RANK_16
  * @param  Channel This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
{
  /* Set bits with content of parameter "Channel" with bits position          */
  /* in register and register position depending on parameter "Rank".         */
  /* Parameters "Rank" and "Channel" are used with masks because containing   */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1,
                                             ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));

  MODIFY_REG(*preg,
             ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 << (Rank & ADC_REG_RANK_ID_SQRX_MASK),
             ((Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS)
             << (Rank & ADC_REG_RANK_ID_SQRX_MASK));
}

/**
  * @brief  Get ADC group regular sequence: channel on the selected
  *         scan sequence rank.
  * @note   On this STM32 series, ADC group regular sequencer is
  *         fully configurable: sequencer length and each rank
  *         affectation to a channel are configurable.
  *         Refer to description of function @ref LL_ADC_REG_SetSequencerLength().
  * @note   Depending on devices and packages, some channels may not be available.
  *         Refer to device datasheet for channels availability.
  * @note   Usage of the returned channel number:
  *         - To reinject this channel into another function LL_ADC_xxx:
  *           the returned channel number is only partly formatted on definition
  *           of literals LL_ADC_CHANNEL_x. Therefore, it has to be compared
  *           with parts of literals LL_ADC_CHANNEL_x or using
  *           helper macro @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
  *           Then the selected literal LL_ADC_CHANNEL_x can be used
  *           as parameter for another function.
  *         - To get the channel number in decimal format:
  *           process the returned value with the helper macro
  *           @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
  * @rmtoll SQR1     SQ1            LL_ADC_REG_GetSequencerRanks\n
  *         SQR1     SQ2            LL_ADC_REG_GetSequencerRanks\n
  *         SQR1     SQ3            LL_ADC_REG_GetSequencerRanks\n
  *         SQR1     SQ4            LL_ADC_REG_GetSequencerRanks\n
  *         SQR2     SQ5            LL_ADC_REG_GetSequencerRanks\n
  *         SQR2     SQ6            LL_ADC_REG_GetSequencerRanks\n
  *         SQR2     SQ7            LL_ADC_REG_GetSequencerRanks\n
  *         SQR2     SQ8            LL_ADC_REG_GetSequencerRanks\n
  *         SQR2     SQ9            LL_ADC_REG_GetSequencerRanks\n
  *         SQR3     SQ10           LL_ADC_REG_GetSequencerRanks\n
  *         SQR3     SQ11           LL_ADC_REG_GetSequencerRanks\n
  *         SQR3     SQ12           LL_ADC_REG_GetSequencerRanks\n
  *         SQR3     SQ13           LL_ADC_REG_GetSequencerRanks\n
  *         SQR3     SQ14           LL_ADC_REG_GetSequencerRanks\n
  *         SQR4     SQ15           LL_ADC_REG_GetSequencerRanks\n
  *         SQR4     SQ16           LL_ADC_REG_GetSequencerRanks
  * @param  ADCx ADC instance
  * @param  Rank This parameter can be one of the following values:
  *         @arg @ref LL_ADC_REG_RANK_1
  *         @arg @ref LL_ADC_REG_RANK_2
  *         @arg @ref LL_ADC_REG_RANK_3
  *         @arg @ref LL_ADC_REG_RANK_4
  *         @arg @ref LL_ADC_REG_RANK_5
  *         @arg @ref LL_ADC_REG_RANK_6
  *         @arg @ref LL_ADC_REG_RANK_7
  *         @arg @ref LL_ADC_REG_RANK_8
  *         @arg @ref LL_ADC_REG_RANK_9
  *         @arg @ref LL_ADC_REG_RANK_10
  *         @arg @ref LL_ADC_REG_RANK_11
  *         @arg @ref LL_ADC_REG_RANK_12
  *         @arg @ref LL_ADC_REG_RANK_13
  *         @arg @ref LL_ADC_REG_RANK_14
  *         @arg @ref LL_ADC_REG_RANK_15
  *         @arg @ref LL_ADC_REG_RANK_16
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet for
  *             more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  *         (1, 2, 3, 4, 5, 7) For ADC channel read back from ADC register,
  *                      comparison with internal channel parameter to be done
  *                      using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
  */
__STATIC_INLINE uint32_t LL_ADC_REG_GetSequencerRanks(const ADC_TypeDef *ADCx, uint32_t Rank)
{
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1,
                                                   ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));

  return (uint32_t)((READ_BIT(*preg,
                              ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 << (Rank & ADC_REG_RANK_ID_SQRX_MASK))
                     >> (Rank & ADC_REG_RANK_ID_SQRX_MASK)) << ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS
                   );
}

/**
  * @brief  Set ADC continuous conversion mode on ADC group regular.
  * @note   Description of ADC continuous conversion mode:
  *         - single mode: one conversion per trigger
  *         - continuous mode: after the first trigger, following
  *           conversions launched successively automatically.
  * @note   It is not possible to enable both ADC group regular
  *         continuous mode and sequencer discontinuous mode.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on group regular.
  * @rmtoll CFGR     CONT           LL_ADC_REG_SetContinuousMode
  * @param  ADCx ADC instance
  * @param  Continuous This parameter can be one of the following values:
  *         @arg @ref LL_ADC_REG_CONV_SINGLE
  *         @arg @ref LL_ADC_REG_CONV_CONTINUOUS
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetContinuousMode(ADC_TypeDef *ADCx, uint32_t Continuous)
{
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_CONT, Continuous);
}

/**
  * @brief  Get ADC continuous conversion mode on ADC group regular.
  * @note   Description of ADC continuous conversion mode:
  *         - single mode: one conversion per trigger
  *         - continuous mode: after the first trigger, following
  *           conversions launched successively automatically.
  * @rmtoll CFGR     CONT           LL_ADC_REG_GetContinuousMode
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_REG_CONV_SINGLE
  *         @arg @ref LL_ADC_REG_CONV_CONTINUOUS
  */
__STATIC_INLINE uint32_t LL_ADC_REG_GetContinuousMode(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_CONT));
}

/**
  * @brief  Set ADC group regular conversion data transfer: no transfer or
  *         transfer by DMA, and DMA requests mode.
  * @note   If transfer by DMA selected, specifies the DMA requests
  *         mode:
  *         - Limited mode (One shot mode): DMA transfer requests are stopped
  *           when number of DMA data transfers (number of
  *           ADC conversions) is reached.
  *           This ADC mode is intended to be used with DMA mode non-circular.
  *         - Unlimited mode: DMA transfer requests are unlimited,
  *           whatever number of DMA data transfers (number of
  *           ADC conversions).
  *           This ADC mode is intended to be used with DMA mode circular.
  * @note   If ADC DMA requests mode is set to unlimited and DMA is set to
  *         mode non-circular:
  *         when DMA transfers size will be reached, DMA will stop transfers of
  *         ADC conversions data ADC will raise an overrun error
  *        (overrun flag and interruption if enabled).
  * @note   For devices with several ADC instances: ADC multimode DMA
  *         settings are available using function @ref LL_ADC_SetMultiDMATransfer().
  * @note   To configure DMA source address (peripheral address),
  *         use function @ref LL_ADC_DMA_GetRegAddr().
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll CFGR     DMAEN          LL_ADC_REG_SetDMATransfer\n
  *         CFGR     DMACFG         LL_ADC_REG_SetDMATransfer
  * @param  ADCx ADC instance
  * @param  DMATransfer This parameter can be one of the following values:
  *         @arg @ref LL_ADC_REG_DMA_TRANSFER_NONE
  *         @arg @ref LL_ADC_REG_DMA_TRANSFER_LIMITED
  *         @arg @ref LL_ADC_REG_DMA_TRANSFER_UNLIMITED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetDMATransfer(ADC_TypeDef *ADCx, uint32_t DMATransfer)
{
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_DMAEN | ADC_CFGR_DMACFG, DMATransfer);
}

/**
  * @brief  Get ADC group regular conversion data transfer: no transfer or
  *         transfer by DMA, and DMA requests mode.
  * @note   If transfer by DMA selected, specifies the DMA requests
  *         mode:
  *         - Limited mode (One shot mode): DMA transfer requests are stopped
  *           when number of DMA data transfers (number of
  *           ADC conversions) is reached.
  *           This ADC mode is intended to be used with DMA mode non-circular.
  *         - Unlimited mode: DMA transfer requests are unlimited,
  *           whatever number of DMA data transfers (number of
  *           ADC conversions).
  *           This ADC mode is intended to be used with DMA mode circular.
  * @note   If ADC DMA requests mode is set to unlimited and DMA is set to
  *         mode non-circular:
  *         when DMA transfers size will be reached, DMA will stop transfers of
  *         ADC conversions data ADC will raise an overrun error
  *         (overrun flag and interruption if enabled).
  * @note   For devices with several ADC instances: ADC multimode DMA
  *         settings are available using function @ref LL_ADC_GetMultiDMATransfer().
  * @note   To configure DMA source address (peripheral address),
  *         use function @ref LL_ADC_DMA_GetRegAddr().
  * @rmtoll CFGR     DMAEN          LL_ADC_REG_GetDMATransfer\n
  *         CFGR     DMACFG         LL_ADC_REG_GetDMATransfer
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_REG_DMA_TRANSFER_NONE
  *         @arg @ref LL_ADC_REG_DMA_TRANSFER_LIMITED
  *         @arg @ref LL_ADC_REG_DMA_TRANSFER_UNLIMITED
  */
__STATIC_INLINE uint32_t LL_ADC_REG_GetDMATransfer(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_DMAEN | ADC_CFGR_DMACFG));
}

/**
  * @brief  Set ADC group regular behavior in case of overrun:
  *         data preserved or overwritten.
  * @note   Compatibility with devices without feature overrun:
  *         other devices without this feature have a behavior
  *         equivalent to data overwritten.
  *         The default setting of overrun is data preserved.
  *         Therefore, for compatibility with all devices, parameter
  *         overrun should be set to data overwritten.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on group regular.
  * @rmtoll CFGR     OVRMOD         LL_ADC_REG_SetOverrun
  * @param  ADCx ADC instance
  * @param  Overrun This parameter can be one of the following values:
  *         @arg @ref LL_ADC_REG_OVR_DATA_PRESERVED
  *         @arg @ref LL_ADC_REG_OVR_DATA_OVERWRITTEN
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetOverrun(ADC_TypeDef *ADCx, uint32_t Overrun)
{
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_OVRMOD, Overrun);
}

/**
  * @brief  Get ADC group regular behavior in case of overrun:
  *         data preserved or overwritten.
  * @rmtoll CFGR     OVRMOD         LL_ADC_REG_GetOverrun
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_REG_OVR_DATA_PRESERVED
  *         @arg @ref LL_ADC_REG_OVR_DATA_OVERWRITTEN
  */
__STATIC_INLINE uint32_t LL_ADC_REG_GetOverrun(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_OVRMOD));
}

/**
  * @}
  */

/** @defgroup ADC_LL_EF_Configuration_ADC_Group_Injected Configuration of ADC hierarchical scope: group injected
  * @{
  */

/**
  * @brief  Set ADC group injected conversion trigger source:
  *         internal (SW start) or from external peripheral (timer event,
  *         external interrupt line).
  * @note   On this STM32 series, setting trigger source to external trigger
  *         also set trigger polarity to rising edge
  *         (default setting for compatibility with some ADC on other
  *         STM32 series having this setting set by HW default value).
  *         In case of need to modify trigger edge, use
  *         function @ref LL_ADC_INJ_SetTriggerEdge().
  * @note   Availability of parameters of trigger sources from timer
  *         depends on timers availability on the selected device.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must not be disabled. Can be enabled with or without conversion
  *         on going on either groups regular or injected.
  * @rmtoll JSQR     JEXTSEL        LL_ADC_INJ_SetTriggerSource\n
  *         JSQR     JEXTEN         LL_ADC_INJ_SetTriggerSource
  * @param  ADCx ADC instance
  * @param  TriggerSource This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_TRIG_SOFTWARE
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_CH3         (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_CH4
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM2_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM2_CH1         (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH1         (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH3         (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH4         (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM4_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM4_CH3         (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM4_CH4         (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM6_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM7_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_CH2         (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_CH4
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM15_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM16_CH1        (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM20_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM20_TRGO2
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM20_CH2        (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM20_CH4        (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG1       (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG2
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG3       (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG4
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG5
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG6
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG7
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG8
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG9
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG10
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_EXTI_LINE3       (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_EXTI_LINE15      (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_LPTIM_OUT
  *
  *         (1) On STM32G4 series, parameter not available on all ADC instances: ADC1, ADC2.\n
  *         (2) On STM32G4 series, parameter not available on all ADC instances: ADC3, ADC4, ADC5.
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet for
  *             more details.
  * @retval None
  */
__STATIC_INLINE void LL_ADC_INJ_SetTriggerSource(ADC_TypeDef *ADCx, uint32_t TriggerSource)
{
  MODIFY_REG(ADCx->JSQR, ADC_JSQR_JEXTSEL | ADC_JSQR_JEXTEN, TriggerSource);
}

/**
  * @brief  Get ADC group injected conversion trigger source:
  *         internal (SW start) or from external peripheral (timer event,
  *         external interrupt line).
  * @note   To determine whether group injected trigger source is
  *         internal (SW start) or external, without detail
  *         of which peripheral is selected as external trigger,
  *         (equivalent to
  *         "if(LL_ADC_INJ_GetTriggerSource(ADC1) == LL_ADC_INJ_TRIG_SOFTWARE)")
  *         use function @ref LL_ADC_INJ_IsTriggerSourceSWStart.
  * @note   Availability of parameters of trigger sources from timer
  *         depends on timers availability on the selected device.
  * @rmtoll JSQR     JEXTSEL        LL_ADC_INJ_GetTriggerSource\n
  *         JSQR     JEXTEN         LL_ADC_INJ_GetTriggerSource
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_INJ_TRIG_SOFTWARE
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_CH3         (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_CH4
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM2_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM2_CH1         (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH1         (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH3         (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH4         (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM4_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM4_CH3         (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM4_CH4         (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM6_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM7_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_CH2         (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_CH4
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM15_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM16_CH1        (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM20_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM20_TRGO2
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM20_CH2        (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM20_CH4        (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG1       (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG2
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG3       (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG4
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG5
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG6
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG7
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG8
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG9
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG10
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_EXTI_LINE3       (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_EXTI_LINE15      (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_LPTIM_OUT
  *
  *         (1) On STM32G4 series, parameter not available on all ADC instances: ADC1, ADC2.\n
  *         (2) On STM32G4 series, parameter not available on all ADC instances: ADC3, ADC4, ADC5.
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet for
  *             more details.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_GetTriggerSource(const ADC_TypeDef *ADCx)
{
  __IO uint32_t trigger_source = READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTSEL | ADC_JSQR_JEXTEN);

  /* Value for shift of {0; 4; 8; 12} depending on value of bitfield          */
  /* corresponding to ADC_JSQR_JEXTEN {0; 1; 2; 3}.                           */
  uint32_t shift_jexten = ((trigger_source & ADC_JSQR_JEXTEN) >> (ADC_INJ_TRIG_EXTEN_BITOFFSET_POS - 2UL));

  /* Set bitfield corresponding to ADC_JSQR_JEXTEN and ADC_JSQR_JEXTSEL       */
  /* to match with triggers literals definition.                              */
  return ((trigger_source
           & (ADC_INJ_TRIG_SOURCE_MASK >> shift_jexten) & ADC_JSQR_JEXTSEL)
          | ((ADC_INJ_TRIG_EDGE_MASK >> shift_jexten) & ADC_JSQR_JEXTEN)
         );
}

/**
  * @brief  Get ADC group injected conversion trigger source internal (SW start)
            or external
  * @note   In case of group injected trigger source set to external trigger,
  *         to determine which peripheral is selected as external trigger,
  *         use function @ref LL_ADC_INJ_GetTriggerSource.
  * @rmtoll JSQR     JEXTEN         LL_ADC_INJ_IsTriggerSourceSWStart
  * @param  ADCx ADC instance
  * @retval Value "0" if trigger source external trigger
  *         Value "1" if trigger source SW start.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsTriggerSourceSWStart(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTEN) == (LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTEN)) ? 1UL : 0UL);
}

/**
  * @brief  Set ADC group injected conversion trigger polarity.
  *         Applicable only for trigger source set to external trigger.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must not be disabled. Can be enabled with or without conversion
  *         on going on either groups regular or injected.
  * @rmtoll JSQR     JEXTEN         LL_ADC_INJ_SetTriggerEdge
  * @param  ADCx ADC instance
  * @param  ExternalTriggerEdge This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_RISING
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_FALLING
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_RISINGFALLING
  * @retval None
  */
__STATIC_INLINE void LL_ADC_INJ_SetTriggerEdge(ADC_TypeDef *ADCx, uint32_t ExternalTriggerEdge)
{
  MODIFY_REG(ADCx->JSQR, ADC_JSQR_JEXTEN, ExternalTriggerEdge);
}

/**
  * @brief  Get ADC group injected conversion trigger polarity.
  *         Applicable only for trigger source set to external trigger.
  * @rmtoll JSQR     JEXTEN         LL_ADC_INJ_GetTriggerEdge
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_RISING
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_FALLING
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_RISINGFALLING
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_GetTriggerEdge(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTEN));
}

/**
  * @brief  Set ADC group injected sequencer length and scan direction.
  * @note   This function performs configuration of:
  *         - Sequence length: Number of ranks in the scan sequence.
  *         - Sequence direction: Unless specified in parameters, sequencer
  *           scan direction is forward (from rank 1 to rank n).
  * @note   Sequencer disabled is equivalent to sequencer of 1 rank:
  *         ADC conversion on only 1 channel.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must not be disabled. Can be enabled with or without conversion
  *         on going on either groups regular or injected.
  * @rmtoll JSQR     JL             LL_ADC_INJ_SetSequencerLength
  * @param  ADCx ADC instance
  * @param  SequencerNbRanks This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_DISABLE
  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS
  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_3RANKS
  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_4RANKS
  * @retval None
  */
__STATIC_INLINE void LL_ADC_INJ_SetSequencerLength(ADC_TypeDef *ADCx, uint32_t SequencerNbRanks)
{
  MODIFY_REG(ADCx->JSQR, ADC_JSQR_JL, SequencerNbRanks);
}

/**
  * @brief  Get ADC group injected sequencer length and scan direction.
  * @note   This function retrieves:
  *         - Sequence length: Number of ranks in the scan sequence.
  *         - Sequence direction: Unless specified in parameters, sequencer
  *           scan direction is forward (from rank 1 to rank n).
  * @note   Sequencer disabled is equivalent to sequencer of 1 rank:
  *         ADC conversion on only 1 channel.
  * @rmtoll JSQR     JL             LL_ADC_INJ_GetSequencerLength
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_DISABLE
  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS
  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_3RANKS
  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_4RANKS
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_GetSequencerLength(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->JSQR, ADC_JSQR_JL));
}

/**
  * @brief  Set ADC group injected sequencer discontinuous mode:
  *         sequence subdivided and scan conversions interrupted every selected
  *         number of ranks.
  * @note   It is not possible to enable both ADC group injected
  *         auto-injected mode and sequencer discontinuous mode.
  * @rmtoll CFGR     JDISCEN        LL_ADC_INJ_SetSequencerDiscont
  * @param  ADCx ADC instance
  * @param  SeqDiscont This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_SEQ_DISCONT_DISABLE
  *         @arg @ref LL_ADC_INJ_SEQ_DISCONT_1RANK
  * @retval None
  */
__STATIC_INLINE void LL_ADC_INJ_SetSequencerDiscont(ADC_TypeDef *ADCx, uint32_t SeqDiscont)
{
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_JDISCEN, SeqDiscont);
}

/**
  * @brief  Get ADC group injected sequencer discontinuous mode:
  *         sequence subdivided and scan conversions interrupted every selected
  *         number of ranks.
  * @rmtoll CFGR     JDISCEN        LL_ADC_INJ_GetSequencerDiscont
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_INJ_SEQ_DISCONT_DISABLE
  *         @arg @ref LL_ADC_INJ_SEQ_DISCONT_1RANK
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_GetSequencerDiscont(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_JDISCEN));
}

/**
  * @brief  Set ADC group injected sequence: channel on the selected
  *         sequence rank.
  * @note   Depending on devices and packages, some channels may not be available.
  *         Refer to device datasheet for channels availability.
  * @note   On this STM32 series, to measure internal channels (VrefInt,
  *         TempSensor, ...), measurement paths to internal channels must be
  *         enabled separately.
  *         This can be done using function @ref LL_ADC_SetCommonPathInternalCh().
  * @note   On STM32G4, some fast channels are available: fast analog inputs
  *         coming from GPIO pads (ADC_IN1..5).
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must not be disabled. Can be enabled with or without conversion
  *         on going on either groups regular or injected.
  * @rmtoll JSQR     JSQ1           LL_ADC_INJ_SetSequencerRanks\n
  *         JSQR     JSQ2           LL_ADC_INJ_SetSequencerRanks\n
  *         JSQR     JSQ3           LL_ADC_INJ_SetSequencerRanks\n
  *         JSQR     JSQ4           LL_ADC_INJ_SetSequencerRanks
  * @param  ADCx ADC instance
  * @param  Rank This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_RANK_1
  *         @arg @ref LL_ADC_INJ_RANK_2
  *         @arg @ref LL_ADC_INJ_RANK_3
  *         @arg @ref LL_ADC_INJ_RANK_4
  * @param  Channel This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  * @retval None
  */
__STATIC_INLINE void LL_ADC_INJ_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
{
  /* Set bits with content of parameter "Channel" with bits position          */
  /* in register depending on parameter "Rank".                               */
  /* Parameters "Rank" and "Channel" are used with masks because containing   */
  /* other bits reserved for other purpose.                                   */
  MODIFY_REG(ADCx->JSQR,
             (ADC_CHANNEL_ID_NUMBER_MASK >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS)
             << (Rank & ADC_INJ_RANK_ID_JSQR_MASK),
             ((Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS)
             << (Rank & ADC_INJ_RANK_ID_JSQR_MASK));
}

/**
  * @brief  Get ADC group injected sequence: channel on the selected
  *         sequence rank.
  * @note   Depending on devices and packages, some channels may not be available.
  *         Refer to device datasheet for channels availability.
  * @note   Usage of the returned channel number:
  *         - To reinject this channel into another function LL_ADC_xxx:
  *           the returned channel number is only partly formatted on definition
  *           of literals LL_ADC_CHANNEL_x. Therefore, it has to be compared
  *           with parts of literals LL_ADC_CHANNEL_x or using
  *           helper macro @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
  *           Then the selected literal LL_ADC_CHANNEL_x can be used
  *           as parameter for another function.
  *         - To get the channel number in decimal format:
  *           process the returned value with the helper macro
  *           @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
  * @rmtoll JSQR     JSQ1           LL_ADC_INJ_GetSequencerRanks\n
  *         JSQR     JSQ2           LL_ADC_INJ_GetSequencerRanks\n
  *         JSQR     JSQ3           LL_ADC_INJ_GetSequencerRanks\n
  *         JSQR     JSQ4           LL_ADC_INJ_GetSequencerRanks
  * @param  ADCx ADC instance
  * @param  Rank This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_RANK_1
  *         @arg @ref LL_ADC_INJ_RANK_2
  *         @arg @ref LL_ADC_INJ_RANK_3
  *         @arg @ref LL_ADC_INJ_RANK_4
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet for
  *             more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  *         (1, 2, 3, 4, 5, 7) For ADC channel read back from ADC register,
  *                      comparison with internal channel parameter to be done
  *                      using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_GetSequencerRanks(const ADC_TypeDef *ADCx, uint32_t Rank)
{
  return (uint32_t)((READ_BIT(ADCx->JSQR,
                              (ADC_CHANNEL_ID_NUMBER_MASK >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS)
                              << (Rank & ADC_INJ_RANK_ID_JSQR_MASK))
                     >> (Rank & ADC_INJ_RANK_ID_JSQR_MASK)) << ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS
                   );
}

/**
  * @brief  Set ADC group injected conversion trigger:
  *         independent or from ADC group regular.
  * @note   This mode can be used to extend number of data registers
  *         updated after one ADC conversion trigger and with data
  *         permanently kept (not erased by successive conversions of scan of
  *         ADC sequencer ranks), up to 5 data registers:
  *         1 data register on ADC group regular, 4 data registers
  *         on ADC group injected.
  * @note   If ADC group injected injected trigger source is set to an
  *         external trigger, this feature must be must be set to
  *         independent trigger.
  *         ADC group injected automatic trigger is compliant only with
  *         group injected trigger source set to SW start, without any
  *         further action on  ADC group injected conversion start or stop:
  *         in this case, ADC group injected is controlled only
  *         from ADC group regular.
  * @note   It is not possible to enable both ADC group injected
  *         auto-injected mode and sequencer discontinuous mode.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll CFGR     JAUTO          LL_ADC_INJ_SetTrigAuto
  * @param  ADCx ADC instance
  * @param  TrigAuto This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_TRIG_INDEPENDENT
  *         @arg @ref LL_ADC_INJ_TRIG_FROM_GRP_REGULAR
  * @retval None
  */
__STATIC_INLINE void LL_ADC_INJ_SetTrigAuto(ADC_TypeDef *ADCx, uint32_t TrigAuto)
{
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_JAUTO, TrigAuto);
}

/**
  * @brief  Get ADC group injected conversion trigger:
  *         independent or from ADC group regular.
  * @rmtoll CFGR     JAUTO          LL_ADC_INJ_GetTrigAuto
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_INJ_TRIG_INDEPENDENT
  *         @arg @ref LL_ADC_INJ_TRIG_FROM_GRP_REGULAR
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_GetTrigAuto(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_JAUTO));
}

/**
  * @brief  Set ADC group injected contexts queue mode.
  * @note   A context is a setting of group injected sequencer:
  *         - group injected trigger
  *         - sequencer length
  *         - sequencer ranks
  *         If contexts queue is disabled:
  *         - only 1 sequence can be configured
  *           and is active perpetually.
  *         If contexts queue is enabled:
  *         - up to 2 contexts can be queued
  *           and are checked in and out as a FIFO stack (first-in, first-out).
  *         - If a new context is set when queues is full, error is triggered
  *           by interruption "Injected Queue Overflow".
  *         - Two behaviors are possible when all contexts have been processed:
  *           the contexts queue can maintain the last context active perpetually
  *           or can be empty and injected group triggers are disabled.
  *         - Triggers can be only external (not internal SW start)
  *         - Caution: The sequence must be fully configured in one time
  *           (one write of register JSQR makes a check-in of a new context
  *           into the queue).
  *           Therefore functions to set separately injected trigger and
  *           sequencer channels cannot be used, register JSQR must be set
  *           using function @ref LL_ADC_INJ_ConfigQueueContext().
  * @note   This parameter can be modified only when no conversion is on going
  *         on either groups regular or injected.
  * @note   A modification of the context mode (bit JQDIS) causes the contexts
  *         queue to be flushed and the register JSQR is cleared.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll CFGR     JQM            LL_ADC_INJ_SetQueueMode\n
  *         CFGR     JQDIS          LL_ADC_INJ_SetQueueMode
  * @param  ADCx ADC instance
  * @param  QueueMode This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_QUEUE_DISABLE
  *         @arg @ref LL_ADC_INJ_QUEUE_2CONTEXTS_LAST_ACTIVE
  *         @arg @ref LL_ADC_INJ_QUEUE_2CONTEXTS_END_EMPTY
  * @retval None
  */
__STATIC_INLINE void LL_ADC_INJ_SetQueueMode(ADC_TypeDef *ADCx, uint32_t QueueMode)
{
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_JQM | ADC_CFGR_JQDIS, QueueMode);
}

/**
  * @brief  Get ADC group injected context queue mode.
  * @rmtoll CFGR     JQM            LL_ADC_INJ_GetQueueMode\n
  *         CFGR     JQDIS          LL_ADC_INJ_GetQueueMode
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_INJ_QUEUE_DISABLE
  *         @arg @ref LL_ADC_INJ_QUEUE_2CONTEXTS_LAST_ACTIVE
  *         @arg @ref LL_ADC_INJ_QUEUE_2CONTEXTS_END_EMPTY
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_GetQueueMode(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_JQM | ADC_CFGR_JQDIS));
}

/**
  * @brief  Set one context on ADC group injected that will be checked in
  *         contexts queue.
  * @note   A context is a setting of group injected sequencer:
  *         - group injected trigger
  *         - sequencer length
  *         - sequencer ranks
  *         This function is intended to be used when contexts queue is enabled,
  *         because the sequence must be fully configured in one time
  *         (functions to set separately injected trigger and sequencer channels
  *         cannot be used):
  *         Refer to function @ref LL_ADC_INJ_SetQueueMode().
  * @note   In the contexts queue, only the active context can be read.
  *         The parameters of this function can be read using functions:
  *         @arg @ref LL_ADC_INJ_GetTriggerSource()
  *         @arg @ref LL_ADC_INJ_GetTriggerEdge()
  *         @arg @ref LL_ADC_INJ_GetSequencerRanks()
  * @note   On this STM32 series, to measure internal channels (VrefInt,
  *         TempSensor, ...), measurement paths to internal channels must be
  *         enabled separately.
  *         This can be done using function @ref LL_ADC_SetCommonPathInternalCh().
  * @note   On STM32G4, some fast channels are available: fast analog inputs
  *         coming from GPIO pads (ADC_IN1..5).
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must not be disabled. Can be enabled with or without conversion
  *         on going on either groups regular or injected.
  * @rmtoll JSQR     JEXTSEL        LL_ADC_INJ_ConfigQueueContext\n
  *         JSQR     JEXTEN         LL_ADC_INJ_ConfigQueueContext\n
  *         JSQR     JL             LL_ADC_INJ_ConfigQueueContext\n
  *         JSQR     JSQ1           LL_ADC_INJ_ConfigQueueContext\n
  *         JSQR     JSQ2           LL_ADC_INJ_ConfigQueueContext\n
  *         JSQR     JSQ3           LL_ADC_INJ_ConfigQueueContext\n
  *         JSQR     JSQ4           LL_ADC_INJ_ConfigQueueContext
  * @param  ADCx ADC instance
  * @param  TriggerSource This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_TRIG_SOFTWARE
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_CH3         (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM1_CH4
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM2_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM2_CH1         (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH1         (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH3         (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM3_CH4         (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM4_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM4_CH3         (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM4_CH4         (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM6_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM7_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_CH2         (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM8_CH4
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM15_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM16_CH1        (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM20_TRGO
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM20_TRGO2
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM20_CH2        (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_TIM20_CH4        (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG1       (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG2
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG3       (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG4
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG5
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG6
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG7
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG8
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG9
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_HRTIM_TRG10
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_EXTI_LINE3       (2)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_EXTI_LINE15      (1)
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_LPTIM_OUT
  *
  *         (1) On STM32G4 series, parameter not available on all ADC instances: ADC1, ADC2.\n
  *         (2) On STM32G4 series, parameter not available on all ADC instances: ADC3, ADC4, ADC5.
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet for
  *             more details.
  * @param  ExternalTriggerEdge This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_RISING
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_FALLING
  *         @arg @ref LL_ADC_INJ_TRIG_EXT_RISINGFALLING
  *
  *         Note: This parameter is discarded in case of SW start:
  *               parameter "TriggerSource" set to "LL_ADC_INJ_TRIG_SOFTWARE".
  * @param  SequencerNbRanks This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_DISABLE
  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS
  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_3RANKS
  *         @arg @ref LL_ADC_INJ_SEQ_SCAN_ENABLE_4RANKS
  * @param  Rank1_Channel This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  * @param  Rank2_Channel This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  * @param  Rank3_Channel This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  * @param  Rank4_Channel This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  * @retval None
  */
__STATIC_INLINE void LL_ADC_INJ_ConfigQueueContext(ADC_TypeDef *ADCx,
                                                   uint32_t TriggerSource,
                                                   uint32_t ExternalTriggerEdge,
                                                   uint32_t SequencerNbRanks,
                                                   uint32_t Rank1_Channel,
                                                   uint32_t Rank2_Channel,
                                                   uint32_t Rank3_Channel,
                                                   uint32_t Rank4_Channel)
{
  /* Set bits with content of parameter "Rankx_Channel" with bits position    */
  /* in register depending on literal "LL_ADC_INJ_RANK_x".                    */
  /* Parameters "Rankx_Channel" and "LL_ADC_INJ_RANK_x" are used with masks   */
  /* because containing other bits reserved for other purpose.                */
  /* If parameter "TriggerSource" is set to SW start, then parameter          */
  /* "ExternalTriggerEdge" is discarded.                                      */
  uint32_t is_trigger_not_sw = (uint32_t)((TriggerSource != LL_ADC_INJ_TRIG_SOFTWARE) ? 1UL : 0UL);
  MODIFY_REG(ADCx->JSQR,
             ADC_JSQR_JEXTSEL |
             ADC_JSQR_JEXTEN  |
             ADC_JSQR_JSQ4    |
             ADC_JSQR_JSQ3    |
             ADC_JSQR_JSQ2    |
             ADC_JSQR_JSQ1    |
             ADC_JSQR_JL,
             (TriggerSource & ADC_JSQR_JEXTSEL)          |
             (ExternalTriggerEdge * (is_trigger_not_sw)) |
             (((Rank4_Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS)
              << (LL_ADC_INJ_RANK_4 & ADC_INJ_RANK_ID_JSQR_MASK)) |
             (((Rank3_Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS)
              << (LL_ADC_INJ_RANK_3 & ADC_INJ_RANK_ID_JSQR_MASK)) |
             (((Rank2_Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS)
              << (LL_ADC_INJ_RANK_2 & ADC_INJ_RANK_ID_JSQR_MASK)) |
             (((Rank1_Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS)
              << (LL_ADC_INJ_RANK_1 & ADC_INJ_RANK_ID_JSQR_MASK)) |
             SequencerNbRanks
            );
}

/**
  * @}
  */

/** @defgroup ADC_LL_EF_Configuration_Channels Configuration of ADC hierarchical scope: channels
  * @{
  */

/**
  * @brief  Set sampling time of the selected ADC channel
  *         Unit: ADC clock cycles.
  * @note   On this device, sampling time is on channel scope: independently
  *         of channel mapped on ADC group regular or injected.
  * @note   In case of internal channel (VrefInt, TempSensor, ...) to be
  *         converted:
  *         sampling time constraints must be respected (sampling time can be
  *         adjusted in function of ADC clock frequency and sampling time
  *         setting).
  *         Refer to device datasheet for timings values (parameters TS_vrefint,
  *         TS_temp, ...).
  * @note   Conversion time is the addition of sampling time and processing time.
  *         On this STM32 series, ADC processing time is:
  *         - 12.5 ADC clock cycles at ADC resolution 12 bits
  *         - 10.5 ADC clock cycles at ADC resolution 10 bits
  *         - 8.5 ADC clock cycles at ADC resolution 8 bits
  *         - 6.5 ADC clock cycles at ADC resolution 6 bits
  * @note   In case of ADC conversion of internal channel (VrefInt,
  *         temperature sensor, ...), a sampling time minimum value
  *         is required.
  *         Refer to device datasheet.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll SMPR1    SMP0           LL_ADC_SetChannelSamplingTime\n
  *         SMPR1    SMP1           LL_ADC_SetChannelSamplingTime\n
  *         SMPR1    SMP2           LL_ADC_SetChannelSamplingTime\n
  *         SMPR1    SMP3           LL_ADC_SetChannelSamplingTime\n
  *         SMPR1    SMP4           LL_ADC_SetChannelSamplingTime\n
  *         SMPR1    SMP5           LL_ADC_SetChannelSamplingTime\n
  *         SMPR1    SMP6           LL_ADC_SetChannelSamplingTime\n
  *         SMPR1    SMP7           LL_ADC_SetChannelSamplingTime\n
  *         SMPR1    SMP8           LL_ADC_SetChannelSamplingTime\n
  *         SMPR1    SMP9           LL_ADC_SetChannelSamplingTime\n
  *         SMPR2    SMP10          LL_ADC_SetChannelSamplingTime\n
  *         SMPR2    SMP11          LL_ADC_SetChannelSamplingTime\n
  *         SMPR2    SMP12          LL_ADC_SetChannelSamplingTime\n
  *         SMPR2    SMP13          LL_ADC_SetChannelSamplingTime\n
  *         SMPR2    SMP14          LL_ADC_SetChannelSamplingTime\n
  *         SMPR2    SMP15          LL_ADC_SetChannelSamplingTime\n
  *         SMPR2    SMP16          LL_ADC_SetChannelSamplingTime\n
  *         SMPR2    SMP17          LL_ADC_SetChannelSamplingTime\n
  *         SMPR2    SMP18          LL_ADC_SetChannelSamplingTime
  * @param  ADCx ADC instance
  * @param  Channel This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  * @param  SamplingTime This parameter can be one of the following values:
  *         @arg @ref LL_ADC_SAMPLINGTIME_2CYCLES_5   (1)
  *         @arg @ref LL_ADC_SAMPLINGTIME_6CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_12CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_24CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_47CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_92CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_247CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_640CYCLES_5
  *
  *         (1) On some devices, ADC sampling time 2.5 ADC clock cycles
  *             can be replaced by 3.5 ADC clock cycles.
  *             Refer to function @ref LL_ADC_SetSamplingTimeCommonConfig().
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
{
  /* Set bits with content of parameter "SamplingTime" with bits position     */
  /* in register and register position depending on parameter "Channel".      */
  /* Parameter "Channel" is used with masks because containing                */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
                                             ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));

  MODIFY_REG(*preg,
             ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
             SamplingTime   << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
}

/**
  * @brief  Get sampling time of the selected ADC channel
  *         Unit: ADC clock cycles.
  * @note   On this device, sampling time is on channel scope: independently
  *         of channel mapped on ADC group regular or injected.
  * @note   Conversion time is the addition of sampling time and processing time.
  *         On this STM32 series, ADC processing time is:
  *         - 12.5 ADC clock cycles at ADC resolution 12 bits
  *         - 10.5 ADC clock cycles at ADC resolution 10 bits
  *         - 8.5 ADC clock cycles at ADC resolution 8 bits
  *         - 6.5 ADC clock cycles at ADC resolution 6 bits
  * @rmtoll SMPR1    SMP0           LL_ADC_GetChannelSamplingTime\n
  *         SMPR1    SMP1           LL_ADC_GetChannelSamplingTime\n
  *         SMPR1    SMP2           LL_ADC_GetChannelSamplingTime\n
  *         SMPR1    SMP3           LL_ADC_GetChannelSamplingTime\n
  *         SMPR1    SMP4           LL_ADC_GetChannelSamplingTime\n
  *         SMPR1    SMP5           LL_ADC_GetChannelSamplingTime\n
  *         SMPR1    SMP6           LL_ADC_GetChannelSamplingTime\n
  *         SMPR1    SMP7           LL_ADC_GetChannelSamplingTime\n
  *         SMPR1    SMP8           LL_ADC_GetChannelSamplingTime\n
  *         SMPR1    SMP9           LL_ADC_GetChannelSamplingTime\n
  *         SMPR2    SMP10          LL_ADC_GetChannelSamplingTime\n
  *         SMPR2    SMP11          LL_ADC_GetChannelSamplingTime\n
  *         SMPR2    SMP12          LL_ADC_GetChannelSamplingTime\n
  *         SMPR2    SMP13          LL_ADC_GetChannelSamplingTime\n
  *         SMPR2    SMP14          LL_ADC_GetChannelSamplingTime\n
  *         SMPR2    SMP15          LL_ADC_GetChannelSamplingTime\n
  *         SMPR2    SMP16          LL_ADC_GetChannelSamplingTime\n
  *         SMPR2    SMP17          LL_ADC_GetChannelSamplingTime\n
  *         SMPR2    SMP18          LL_ADC_GetChannelSamplingTime
  * @param  ADCx ADC instance
  * @param  Channel This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_0
  *         @arg @ref LL_ADC_CHANNEL_1                 (8)
  *         @arg @ref LL_ADC_CHANNEL_2                 (8)
  *         @arg @ref LL_ADC_CHANNEL_3                 (8)
  *         @arg @ref LL_ADC_CHANNEL_4                 (8)
  *         @arg @ref LL_ADC_CHANNEL_5                 (8)
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  *         @arg @ref LL_ADC_CHANNEL_16
  *         @arg @ref LL_ADC_CHANNEL_17
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref LL_ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref LL_ADC_CHANNEL_VBAT              (6)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref LL_ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_SAMPLINGTIME_2CYCLES_5   (1)
  *         @arg @ref LL_ADC_SAMPLINGTIME_6CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_12CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_24CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_47CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_92CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_247CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_640CYCLES_5
  *
  *         (1) On some devices, ADC sampling time 2.5 ADC clock cycles
  *             can be replaced by 3.5 ADC clock cycles.
  *             Refer to function @ref LL_ADC_SetSamplingTimeCommonConfig().
  */
__STATIC_INLINE uint32_t LL_ADC_GetChannelSamplingTime(const ADC_TypeDef *ADCx, uint32_t Channel)
{
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK)
                                                                 >> ADC_SMPRX_REGOFFSET_POS));

  return (uint32_t)(READ_BIT(*preg,
                             ADC_SMPR1_SMP0
                             << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS))
                    >> ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS)
                   );
}

/**
  * @brief  Set mode single-ended or differential input of the selected
  *         ADC channel.
  * @note   Channel ending is on channel scope: independently of channel mapped
  *         on ADC group regular or injected.
  *         In differential mode: Differential measurement is carried out
  *         between the selected channel 'i' (positive input) and
  *         channel 'i+1' (negative input). Only channel 'i' has to be
  *         configured, channel 'i+1' is configured automatically.
  * @note   Refer to Reference Manual to ensure the selected channel is
  *         available in differential mode.
  *         For example, internal channels (VrefInt, TempSensor, ...) are
  *         not available in differential mode.
  * @note   When configuring a channel 'i' in differential mode,
  *         the channel 'i+1' is not usable separately.
  * @note   On STM32G4, some channels are internally fixed to single-ended inputs
  *         configuration:
  *         - ADC1: Channels 12, 15, 16, 17 and 18
  *         - ADC2: Channels 15, 17 and 18
  *         - ADC3: Channels 12, 16, 17 and 18            (1)
  *         - ADC4: Channels 16, 17 and 18                (1)
  *         - ADC5: Channels 2, 3, 4, 16, 17 and 18       (1)
  *         (1) ADC3/4/5 are not available on all devices, refer to device datasheet
  *             for more details.
  * @note   For ADC channels configured in differential mode, both inputs
  *         should be biased at (Vref+)/2 +/-200mV.
  *         (Vref+ is the analog voltage reference)
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be ADC disabled.
  * @note   One or several values can be selected.
  *         Example: (LL_ADC_CHANNEL_4 | LL_ADC_CHANNEL_12 | ...)
  * @rmtoll DIFSEL   DIFSEL         LL_ADC_SetChannelSingleDiff
  * @param  ADCx ADC instance
  * @param  Channel This parameter can be one of the following values:
  *         @arg @ref LL_ADC_CHANNEL_1
  *         @arg @ref LL_ADC_CHANNEL_2
  *         @arg @ref LL_ADC_CHANNEL_3
  *         @arg @ref LL_ADC_CHANNEL_4
  *         @arg @ref LL_ADC_CHANNEL_5
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  * @param  SingleDiff This parameter can be a combination of the following values:
  *         @arg @ref LL_ADC_SINGLE_ENDED
  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SingleDiff)
{
  /* Bits of channels in single or differential mode are set only for         */
  /* differential mode (for single mode, mask of bits allowed to be set is    */
  /* shifted out of range of bits of channels in single or differential mode. */
  MODIFY_REG(ADCx->DIFSEL,
             Channel & ADC_SINGLEDIFF_CHANNEL_MASK,
             (Channel & ADC_SINGLEDIFF_CHANNEL_MASK)
             & (ADC_DIFSEL_DIFSEL >> (SingleDiff & ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK)));
}

/**
  * @brief  Get mode single-ended or differential input of the selected
  *         ADC channel.
  * @note   When configuring a channel 'i' in differential mode,
  *         the channel 'i+1' is not usable separately.
  *         Therefore, to ensure a channel is configured in single-ended mode,
  *         the configuration of channel itself and the channel 'i-1' must be
  *         read back (to ensure that the selected channel channel has not been
  *         configured in differential mode by the previous channel).
  * @note   Refer to Reference Manual to ensure the selected channel is
  *         available in differential mode.
  *         For example, internal channels (VrefInt, TempSensor, ...) are
  *         not available in differential mode.
  * @note   When configuring a channel 'i' in differential mode,
  *         the channel 'i+1' is not usable separately.
  * @note   On STM32G4, some channels are internally fixed to single-ended inputs
  *         configuration:
  *         - ADC1: Channels 12, 15, 16, 17 and 18
  *         - ADC2: Channels 15, 17 and 18
  *         - ADC3: Channels 12, 16, 17 and 18            (1)
  *         - ADC4: Channels 16, 17 and 18                (1)
  *         - ADC5: Channels 2, 3, 4, 16, 17 and 18       (1)
  *         (1) ADC3/4/5 are not available on all devices, refer to device datasheet
  *             for more details.
  * @note   One or several values can be selected. In this case, the value
  *         returned is null if all channels are in single ended-mode.
  *         Example: (LL_ADC_CHANNEL_4 | LL_ADC_CHANNEL_12 | ...)
  * @rmtoll DIFSEL   DIFSEL         LL_ADC_GetChannelSingleDiff
  * @param  ADCx ADC instance
  * @param  Channel This parameter can be a combination of the following values:
  *         @arg @ref LL_ADC_CHANNEL_1
  *         @arg @ref LL_ADC_CHANNEL_2
  *         @arg @ref LL_ADC_CHANNEL_3
  *         @arg @ref LL_ADC_CHANNEL_4
  *         @arg @ref LL_ADC_CHANNEL_5
  *         @arg @ref LL_ADC_CHANNEL_6
  *         @arg @ref LL_ADC_CHANNEL_7
  *         @arg @ref LL_ADC_CHANNEL_8
  *         @arg @ref LL_ADC_CHANNEL_9
  *         @arg @ref LL_ADC_CHANNEL_10
  *         @arg @ref LL_ADC_CHANNEL_11
  *         @arg @ref LL_ADC_CHANNEL_12
  *         @arg @ref LL_ADC_CHANNEL_13
  *         @arg @ref LL_ADC_CHANNEL_14
  *         @arg @ref LL_ADC_CHANNEL_15
  * @retval 0: channel in single-ended mode, else: channel in differential mode
  */
__STATIC_INLINE uint32_t LL_ADC_GetChannelSingleDiff(const ADC_TypeDef *ADCx, uint32_t Channel)
{
  return (uint32_t)(READ_BIT(ADCx->DIFSEL, (Channel & ADC_SINGLEDIFF_CHANNEL_MASK)));
}

/**
  * @}
  */

/** @defgroup ADC_LL_EF_Configuration_ADC_AnalogWatchdog Configuration of ADC transversal scope: analog watchdog
  * @{
  */

/**
  * @brief  Set ADC analog watchdog monitored channels:
  *         a single channel, multiple channels or all channels,
  *         on ADC groups regular and-or injected.
  * @note   Once monitored channels are selected, analog watchdog
  *         is enabled.
  * @note   In case of need to define a single channel to monitor
  *         with analog watchdog from sequencer channel definition,
  *         use helper macro @ref __LL_ADC_ANALOGWD_CHANNEL_GROUP().
  * @note   On this STM32 series, there are 2 kinds of analog watchdog
  *         instance:
  *         - AWD standard (instance AWD1):
  *           - channels monitored: can monitor 1 channel or all channels.
  *           - groups monitored: ADC groups regular and-or injected.
  *           - resolution: resolution is not limited (corresponds to
  *             ADC resolution configured).
  *         - AWD flexible (instances AWD2, AWD3):
  *           - channels monitored: flexible on channels monitored, selection is
  *             channel wise, from from 1 to all channels.
  *             Specificity of this analog watchdog: Multiple channels can
  *             be selected. For example:
  *             (LL_ADC_AWD_CHANNEL4_REG_INJ | LL_ADC_AWD_CHANNEL5_REG_INJ | ...)
  *           - groups monitored: not selection possible (monitoring on both
  *             groups regular and injected).
  *             Channels selected are monitored on groups regular and injected:
  *             LL_ADC_AWD_CHANNELxx_REG_INJ (do not use parameters
  *             LL_ADC_AWD_CHANNELxx_REG and LL_ADC_AWD_CHANNELxx_INJ)
  *           - resolution: resolution is limited to 8 bits: if ADC resolution is
  *             12 bits the 4 LSB are ignored, if ADC resolution is 10 bits
  *             the 2 LSB are ignored.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll CFGR     AWD1CH         LL_ADC_SetAnalogWDMonitChannels\n
  *         CFGR     AWD1SGL        LL_ADC_SetAnalogWDMonitChannels\n
  *         CFGR     AWD1EN         LL_ADC_SetAnalogWDMonitChannels\n
  *         CFGR     JAWD1EN        LL_ADC_SetAnalogWDMonitChannels\n
  *         AWD2CR   AWD2CH         LL_ADC_SetAnalogWDMonitChannels\n
  *         AWD3CR   AWD3CH         LL_ADC_SetAnalogWDMonitChannels
  * @param  ADCx ADC instance
  * @param  AWDy This parameter can be one of the following values:
  *         @arg @ref LL_ADC_AWD1
  *         @arg @ref LL_ADC_AWD2
  *         @arg @ref LL_ADC_AWD3
  * @param  AWDChannelGroup This parameter can be one of the following values:
  *         @arg @ref LL_ADC_AWD_DISABLE
  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_REG        (0)
  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_INJ        (0)
  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_0_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_0_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_0_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_1_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_1_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_1_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_2_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_2_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_2_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_3_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_3_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_3_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_4_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_4_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_4_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_5_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_5_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_5_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_6_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_6_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_6_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_7_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_7_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_7_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_8_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_8_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_8_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_9_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_9_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_9_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_10_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_10_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_10_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_11_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_11_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_11_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_12_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_12_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_12_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_13_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_13_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_13_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_14_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_14_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_14_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_15_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_15_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_15_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_16_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_16_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_16_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_17_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_17_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_17_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_18_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_18_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_18_REG_INJ
  *         @arg @ref LL_ADC_AWD_CH_VREFINT_REG          (0)
  *         @arg @ref LL_ADC_AWD_CH_VREFINT_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CH_VREFINT_REG_INJ
  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_ADC1_REG  (0)(1)
  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_ADC1_INJ  (0)(1)
  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_ADC1_REG_INJ (1)
  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_ADC5_REG  (0)(5)
  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_ADC5_INJ  (0)(5)
  *         @arg @ref LL_ADC_AWD_CH_TEMPSENSOR_ADC5_REG_INJ (5)
  *         @arg @ref LL_ADC_AWD_CH_VBAT_REG             (0)(6)
  *         @arg @ref LL_ADC_AWD_CH_VBAT_INJ             (0)(6)
  *         @arg @ref LL_ADC_AWD_CH_VBAT_REG_INJ            (6)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP1_REG          (0)(1)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP1_INJ          (0)(1)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP1_REG_INJ         (1)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP2_REG          (0)(2)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP2_INJ          (0)(2)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP2_REG_INJ         (2)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP3_ADC2_REG     (0)(2)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP3_ADC2_INJ     (0)(2)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP3_ADC2_REG_INJ    (2)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP3_ADC3_REG     (0)(3)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP3_ADC3_INJ     (0)(3)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP3_ADC3_REG_INJ    (3)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP4_REG          (0)(5)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP4_INJ          (0)(5)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP4_REG_INJ         (5)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP5_REG          (0)(5)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP5_INJ          (0)(5)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP5_REG_INJ         (5)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP6_REG          (0)(4)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP6_INJ          (0)(4)
  *         @arg @ref LL_ADC_AWD_CH_VOPAMP6_REG_INJ         (4)
  *
  *         (0) On STM32G4, parameter available only on analog watchdog number: AWD1.\n
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetAnalogWDMonitChannels(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDChannelGroup)
{
  /* Set bits with content of parameter "AWDChannelGroup" with bits position  */
  /* in register and register position depending on parameter "AWDy".         */
  /* Parameters "AWDChannelGroup" and "AWDy" are used with masks because      */
  /* containing other bits reserved for other purpose.                        */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->CFGR,
                                             ((AWDy & ADC_AWD_CRX_REGOFFSET_MASK) >> ADC_AWD_CRX_REGOFFSET_POS)
                                             + ((AWDy & ADC_AWD_CR12_REGOFFSETGAP_MASK)
                                                * ADC_AWD_CR12_REGOFFSETGAP_VAL));

  MODIFY_REG(*preg,
             (AWDy & ADC_AWD_CR_ALL_CHANNEL_MASK),
             AWDChannelGroup & AWDy);
}

/**
  * @brief  Get ADC analog watchdog monitored channel.
  * @note   Usage of the returned channel number:
  *         - To reinject this channel into another function LL_ADC_xxx:
  *           the returned channel number is only partly formatted on definition
  *           of literals LL_ADC_CHANNEL_x. Therefore, it has to be compared
  *           with parts of literals LL_ADC_CHANNEL_x or using
  *           helper macro @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
  *           Then the selected literal LL_ADC_CHANNEL_x can be used
  *           as parameter for another function.
  *         - To get the channel number in decimal format:
  *           process the returned value with the helper macro
  *           @ref __LL_ADC_CHANNEL_TO_DECIMAL_NB().
  *           Applicable only when the analog watchdog is set to monitor
  *           one channel.
  * @note   On this STM32 series, there are 2 kinds of analog watchdog
  *         instance:
  *         - AWD standard (instance AWD1):
  *           - channels monitored: can monitor 1 channel or all channels.
  *           - groups monitored: ADC groups regular and-or injected.
  *           - resolution: resolution is not limited (corresponds to
  *             ADC resolution configured).
  *         - AWD flexible (instances AWD2, AWD3):
  *           - channels monitored: flexible on channels monitored, selection is
  *             channel wise, from from 1 to all channels.
  *             Specificity of this analog watchdog: Multiple channels can
  *             be selected. For example:
  *             (LL_ADC_AWD_CHANNEL4_REG_INJ | LL_ADC_AWD_CHANNEL5_REG_INJ | ...)
  *           - groups monitored: not selection possible (monitoring on both
  *             groups regular and injected).
  *             Channels selected are monitored on groups regular and injected:
  *             LL_ADC_AWD_CHANNELxx_REG_INJ (do not use parameters
  *             LL_ADC_AWD_CHANNELxx_REG and LL_ADC_AWD_CHANNELxx_INJ)
  *           - resolution: resolution is limited to 8 bits: if ADC resolution is
  *             12 bits the 4 LSB are ignored, if ADC resolution is 10 bits
  *             the 2 LSB are ignored.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll CFGR     AWD1CH         LL_ADC_GetAnalogWDMonitChannels\n
  *         CFGR     AWD1SGL        LL_ADC_GetAnalogWDMonitChannels\n
  *         CFGR     AWD1EN         LL_ADC_GetAnalogWDMonitChannels\n
  *         CFGR     JAWD1EN        LL_ADC_GetAnalogWDMonitChannels\n
  *         AWD2CR   AWD2CH         LL_ADC_GetAnalogWDMonitChannels\n
  *         AWD3CR   AWD3CH         LL_ADC_GetAnalogWDMonitChannels
  * @param  ADCx ADC instance
  * @param  AWDy This parameter can be one of the following values:
  *         @arg @ref LL_ADC_AWD1
  *         @arg @ref LL_ADC_AWD2 (1)
  *         @arg @ref LL_ADC_AWD3 (1)
  *
  *         (1) On this AWD number, monitored channel can be retrieved
  *             if only 1 channel is programmed (or none or all channels).
  *             This function cannot retrieve monitored channel if
  *             multiple channels are programmed simultaneously
  *             by bitfield.
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_AWD_DISABLE
  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_REG        (0)
  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_INJ        (0)
  *         @arg @ref LL_ADC_AWD_ALL_CHANNELS_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_0_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_0_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_0_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_1_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_1_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_1_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_2_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_2_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_2_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_3_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_3_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_3_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_4_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_4_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_4_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_5_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_5_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_5_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_6_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_6_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_6_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_7_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_7_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_7_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_8_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_8_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_8_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_9_REG           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_9_INJ           (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_9_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_10_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_10_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_10_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_11_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_11_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_11_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_12_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_12_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_12_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_13_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_13_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_13_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_14_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_14_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_14_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_15_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_15_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_15_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_16_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_16_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_16_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_17_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_17_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_17_REG_INJ
  *         @arg @ref LL_ADC_AWD_CHANNEL_18_REG          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_18_INJ          (0)
  *         @arg @ref LL_ADC_AWD_CHANNEL_18_REG_INJ
  *
  *         (0) On STM32G4, parameter available only on analog watchdog number: AWD1.
  */
__STATIC_INLINE uint32_t LL_ADC_GetAnalogWDMonitChannels(const ADC_TypeDef *ADCx, uint32_t AWDy)
{
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->CFGR,
                                                   ((AWDy & ADC_AWD_CRX_REGOFFSET_MASK) >> ADC_AWD_CRX_REGOFFSET_POS)
                                                   + ((AWDy & ADC_AWD_CR12_REGOFFSETGAP_MASK)
                                                      * ADC_AWD_CR12_REGOFFSETGAP_VAL));

  uint32_t analog_wd_monit_channels = (READ_BIT(*preg, AWDy) & AWDy & ADC_AWD_CR_ALL_CHANNEL_MASK);

  /* If "analog_wd_monit_channels" == 0, then the selected AWD is disabled       */
  /* (parameter value LL_ADC_AWD_DISABLE).                                    */
  /* Else, the selected AWD is enabled and is monitoring a group of channels  */
  /* or a single channel.                                                     */
  if (analog_wd_monit_channels != 0UL)
  {
    if (AWDy == LL_ADC_AWD1)
    {
      if ((analog_wd_monit_channels & ADC_CFGR_AWD1SGL) == 0UL)
      {
        /* AWD monitoring a group of channels */
        analog_wd_monit_channels = ((analog_wd_monit_channels
                                     | (ADC_AWD_CR23_CHANNEL_MASK)
                                    )
                                    & (~(ADC_CFGR_AWD1CH))
                                   );
      }
      else
      {
        /* AWD monitoring a single channel */
        analog_wd_monit_channels = (analog_wd_monit_channels
                                    | (ADC_AWD2CR_AWD2CH_0 << (analog_wd_monit_channels >> ADC_CFGR_AWD1CH_Pos))
                                   );
      }
    }
    else
    {
      if ((analog_wd_monit_channels & ADC_AWD_CR23_CHANNEL_MASK) == ADC_AWD_CR23_CHANNEL_MASK)
      {
        /* AWD monitoring a group of channels */
        analog_wd_monit_channels = (ADC_AWD_CR23_CHANNEL_MASK
                                    | ((ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN))
                                   );
      }
      else
      {
        /* AWD monitoring a single channel */
        /* AWD monitoring a group of channels */
        analog_wd_monit_channels = (analog_wd_monit_channels
                                    | (ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL)
                                    | (__LL_ADC_CHANNEL_TO_DECIMAL_NB(analog_wd_monit_channels) << ADC_CFGR_AWD1CH_Pos)
                                   );
      }
    }
  }

  return analog_wd_monit_channels;
}

/**
  * @brief  Set ADC analog watchdog thresholds value of both thresholds
  *         high and low.
  * @note   If value of only one threshold high or low must be set,
  *         use function @ref LL_ADC_SetAnalogWDThresholds().
  * @note   In case of ADC resolution different of 12 bits,
  *         analog watchdog thresholds data require a specific shift.
  *         Use helper macro @ref __LL_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION().
  * @note   On this STM32 series, there are 2 kinds of analog watchdog
  *         instance:
  *         - AWD standard (instance AWD1):
  *           - channels monitored: can monitor 1 channel or all channels.
  *           - groups monitored: ADC groups regular and-or injected.
  *           - resolution: resolution is not limited (corresponds to
  *             ADC resolution configured).
  *         - AWD flexible (instances AWD2, AWD3):
  *           - channels monitored: flexible on channels monitored, selection is
  *             channel wise, from from 1 to all channels.
  *             Specificity of this analog watchdog: Multiple channels can
  *             be selected. For example:
  *             (LL_ADC_AWD_CHANNEL4_REG_INJ | LL_ADC_AWD_CHANNEL5_REG_INJ | ...)
  *           - groups monitored: not selection possible (monitoring on both
  *             groups regular and injected).
  *             Channels selected are monitored on groups regular and injected:
  *             LL_ADC_AWD_CHANNELxx_REG_INJ (do not use parameters
  *             LL_ADC_AWD_CHANNELxx_REG and LL_ADC_AWD_CHANNELxx_INJ)
  *           - resolution: resolution is limited to 8 bits: if ADC resolution is
  *             12 bits the 4 LSB are ignored, if ADC resolution is 10 bits
  *             the 2 LSB are ignored.
  * @note   If ADC oversampling is enabled, ADC analog watchdog thresholds are
  *         impacted: the comparison of analog watchdog thresholds is done on
  *         oversampling final computation (after ratio and shift application):
  *         ADC data register bitfield [15:4] (12 most significant bits).
  *         Examples:
  *         - Oversampling ratio and shift selected to have ADC conversion data
  *           on 12 bits (ratio 16 and shift 4, or ratio 32 and shift 5, ...):
  *           ADC analog watchdog thresholds must be divided by 16.
  *         - Oversampling ratio and shift selected to have ADC conversion data
  *           on 14 bits (ratio 16 and shift 2, or ratio 32 and shift 3, ...):
  *           ADC analog watchdog thresholds must be divided by 4.
  *         - Oversampling ratio and shift selected to have ADC conversion data
  *           on 16 bits (ratio 16 and shift none, or ratio 32 and shift 1, ...):
  *           ADC analog watchdog thresholds match directly to ADC data register.
  * @rmtoll TR1      HT1            LL_ADC_ConfigAnalogWDThresholds\n
  *         TR2      HT2            LL_ADC_ConfigAnalogWDThresholds\n
  *         TR3      HT3            LL_ADC_ConfigAnalogWDThresholds\n
  *         TR1      LT1            LL_ADC_ConfigAnalogWDThresholds\n
  *         TR2      LT2            LL_ADC_ConfigAnalogWDThresholds\n
  *         TR3      LT3            LL_ADC_ConfigAnalogWDThresholds
  * @param  ADCx ADC instance
  * @param  AWDy This parameter can be one of the following values:
  *         @arg @ref LL_ADC_AWD1
  *         @arg @ref LL_ADC_AWD2
  *         @arg @ref LL_ADC_AWD3
  * @param  AWDThresholdHighValue Value between Min_Data=0x000 and Max_Data=0xFFF
  * @param  AWDThresholdLowValue Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ConfigAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDThresholdHighValue,
                                                     uint32_t AWDThresholdLowValue)
{
  /* Set bits with content of parameter "AWDThresholdxxxValue" with bits      */
  /* position in register and register position depending on parameter        */
  /* "AWDy".                                                                  */
  /* Parameters "AWDy" and "AWDThresholdxxxValue" are used with masks because */
  /* containing other bits reserved for other purpose.                        */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->TR1,
                                             ((AWDy & ADC_AWD_TRX_REGOFFSET_MASK) >> ADC_AWD_TRX_REGOFFSET_POS));

  MODIFY_REG(*preg,
             ADC_TR1_HT1 | ADC_TR1_LT1,
             (AWDThresholdHighValue << ADC_TR1_HT1_BITOFFSET_POS) | AWDThresholdLowValue);
}

/**
  * @brief  Set ADC analog watchdog threshold value of threshold
  *         high or low.
  * @note   If values of both thresholds high or low must be set,
  *         use function @ref LL_ADC_ConfigAnalogWDThresholds().
  * @note   In case of ADC resolution different of 12 bits,
  *         analog watchdog thresholds data require a specific shift.
  *         Use helper macro @ref __LL_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION().
  * @note   On this STM32 series, there are 2 kinds of analog watchdog
  *         instance:
  *         - AWD standard (instance AWD1):
  *           - channels monitored: can monitor 1 channel or all channels.
  *           - groups monitored: ADC groups regular and-or injected.
  *           - resolution: resolution is not limited (corresponds to
  *             ADC resolution configured).
  *         - AWD flexible (instances AWD2, AWD3):
  *           - channels monitored: flexible on channels monitored, selection is
  *             channel wise, from from 1 to all channels.
  *             Specificity of this analog watchdog: Multiple channels can
  *             be selected. For example:
  *             (LL_ADC_AWD_CHANNEL4_REG_INJ | LL_ADC_AWD_CHANNEL5_REG_INJ | ...)
  *           - groups monitored: not selection possible (monitoring on both
  *             groups regular and injected).
  *             Channels selected are monitored on groups regular and injected:
  *             LL_ADC_AWD_CHANNELxx_REG_INJ (do not use parameters
  *             LL_ADC_AWD_CHANNELxx_REG and LL_ADC_AWD_CHANNELxx_INJ)
  *           - resolution: resolution is limited to 8 bits: if ADC resolution is
  *             12 bits the 4 LSB are ignored, if ADC resolution is 10 bits
  *             the 2 LSB are ignored.
  * @note   If ADC oversampling is enabled, ADC analog watchdog thresholds are
  *         impacted: the comparison of analog watchdog thresholds is done on
  *         oversampling final computation (after ratio and shift application):
  *         ADC data register bitfield [15:4] (12 most significant bits).
  *         Examples:
  *         - Oversampling ratio and shift selected to have ADC conversion data
  *           on 12 bits (ratio 16 and shift 4, or ratio 32 and shift 5, ...):
  *           ADC analog watchdog thresholds must be divided by 16.
  *         - Oversampling ratio and shift selected to have ADC conversion data
  *           on 14 bits (ratio 16 and shift 2, or ratio 32 and shift 3, ...):
  *           ADC analog watchdog thresholds must be divided by 4.
  *         - Oversampling ratio and shift selected to have ADC conversion data
  *           on 16 bits (ratio 16 and shift none, or ratio 32 and shift 1, ...):
  *           ADC analog watchdog thresholds match directly to ADC data register.
  * @note   On this STM32 series, setting of this feature is not conditioned to
  *         ADC state:
  *         ADC can be disabled, enabled with or without conversion on going
  *         on either ADC groups regular or injected.
  * @rmtoll TR1      HT1            LL_ADC_SetAnalogWDThresholds\n
  *         TR2      HT2            LL_ADC_SetAnalogWDThresholds\n
  *         TR3      HT3            LL_ADC_SetAnalogWDThresholds\n
  *         TR1      LT1            LL_ADC_SetAnalogWDThresholds\n
  *         TR2      LT2            LL_ADC_SetAnalogWDThresholds\n
  *         TR3      LT3            LL_ADC_SetAnalogWDThresholds
  * @param  ADCx ADC instance
  * @param  AWDy This parameter can be one of the following values:
  *         @arg @ref LL_ADC_AWD1
  *         @arg @ref LL_ADC_AWD2
  *         @arg @ref LL_ADC_AWD3
  * @param  AWDThresholdsHighLow This parameter can be one of the following values:
  *         @arg @ref LL_ADC_AWD_THRESHOLD_HIGH
  *         @arg @ref LL_ADC_AWD_THRESHOLD_LOW
  * @param  AWDThresholdValue Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDThresholdsHighLow,
                                                  uint32_t AWDThresholdValue)
{
  /* Set bits with content of parameter "AWDThresholdValue" with bits         */
  /* position in register and register position depending on parameters       */
  /* "AWDThresholdsHighLow" and "AWDy".                                       */
  /* Parameters "AWDy" and "AWDThresholdValue" are used with masks because    */
  /* containing other bits reserved for other purpose.                        */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->TR1,
                                             ((AWDy & ADC_AWD_TRX_REGOFFSET_MASK) >> ADC_AWD_TRX_REGOFFSET_POS));

  MODIFY_REG(*preg,
             AWDThresholdsHighLow,
             AWDThresholdValue << ((AWDThresholdsHighLow & ADC_AWD_TRX_BIT_HIGH_MASK) >> ADC_AWD_TRX_BIT_HIGH_SHIFT4));
}

/**
  * @brief  Get ADC analog watchdog threshold value of threshold high,
  *         threshold low or raw data with ADC thresholds high and low
  *         concatenated.
  * @note   If raw data with ADC thresholds high and low is retrieved,
  *         the data of each threshold high or low can be isolated
  *         using helper macro:
  *         @ref __LL_ADC_ANALOGWD_THRESHOLDS_HIGH_LOW().
  * @note   In case of ADC resolution different of 12 bits,
  *         analog watchdog thresholds data require a specific shift.
  *         Use helper macro @ref __LL_ADC_ANALOGWD_GET_THRESHOLD_RESOLUTION().
  * @rmtoll TR1      HT1            LL_ADC_GetAnalogWDThresholds\n
  *         TR2      HT2            LL_ADC_GetAnalogWDThresholds\n
  *         TR3      HT3            LL_ADC_GetAnalogWDThresholds\n
  *         TR1      LT1            LL_ADC_GetAnalogWDThresholds\n
  *         TR2      LT2            LL_ADC_GetAnalogWDThresholds\n
  *         TR3      LT3            LL_ADC_GetAnalogWDThresholds
  * @param  ADCx ADC instance
  * @param  AWDy This parameter can be one of the following values:
  *         @arg @ref LL_ADC_AWD1
  *         @arg @ref LL_ADC_AWD2
  *         @arg @ref LL_ADC_AWD3
  * @param  AWDThresholdsHighLow This parameter can be one of the following values:
  *         @arg @ref LL_ADC_AWD_THRESHOLD_HIGH
  *         @arg @ref LL_ADC_AWD_THRESHOLD_LOW
  *         @arg @ref LL_ADC_AWD_THRESHOLDS_HIGH_LOW
  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
  */
__STATIC_INLINE uint32_t LL_ADC_GetAnalogWDThresholds(const ADC_TypeDef *ADCx,
                                                      uint32_t AWDy, uint32_t AWDThresholdsHighLow)
{
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->TR1,
                                                   ((AWDy & ADC_AWD_TRX_REGOFFSET_MASK) >> ADC_AWD_TRX_REGOFFSET_POS));

  return (uint32_t)(READ_BIT(*preg,
                             (AWDThresholdsHighLow | ADC_TR1_LT1))
                    >> (((AWDThresholdsHighLow & ADC_AWD_TRX_BIT_HIGH_MASK) >> ADC_AWD_TRX_BIT_HIGH_SHIFT4)
                        & ~(AWDThresholdsHighLow & ADC_TR1_LT1)));
}

/**
  * @brief  Set ADC analog watchdog filtering configuration
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @note   On this STM32 series, this feature is only available on first
  *         analog watchdog (AWD1)
  * @rmtoll TR1      AWDFILT        LL_ADC_SetAWDFilteringConfiguration
  * @param  ADCx ADC instance
  * @param  AWDy This parameter can be one of the following values:
  *         @arg @ref LL_ADC_AWD1
  * @param  FilteringConfig This parameter can be one of the following values:
  *         @arg @ref LL_ADC_AWD_FILTERING_NONE
  *         @arg @ref LL_ADC_AWD_FILTERING_2SAMPLES
  *         @arg @ref LL_ADC_AWD_FILTERING_3SAMPLES
  *         @arg @ref LL_ADC_AWD_FILTERING_4SAMPLES
  *         @arg @ref LL_ADC_AWD_FILTERING_5SAMPLES
  *         @arg @ref LL_ADC_AWD_FILTERING_6SAMPLES
  *         @arg @ref LL_ADC_AWD_FILTERING_7SAMPLES
  *         @arg @ref LL_ADC_AWD_FILTERING_8SAMPLES
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetAWDFilteringConfiguration(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t FilteringConfig)
{
  /* Prevent unused argument(s) compilation warning */
  (void)(AWDy);
  MODIFY_REG(ADCx->TR1, ADC_TR1_AWDFILT, FilteringConfig);
}

/**
  * @brief  Get ADC analog watchdog filtering configuration
  * @note   On this STM32 series, this feature is only available on first
  *         analog watchdog (AWD1)
  * @rmtoll TR1      AWDFILT        LL_ADC_GetAWDFilteringConfiguration
  * @param  ADCx ADC instance
  * @param  AWDy This parameter can be one of the following values:
  *         @arg @ref LL_ADC_AWD1
  * @retval Returned value can be:
  *         @arg @ref LL_ADC_AWD_FILTERING_NONE
  *         @arg @ref LL_ADC_AWD_FILTERING_2SAMPLES
  *         @arg @ref LL_ADC_AWD_FILTERING_3SAMPLES
  *         @arg @ref LL_ADC_AWD_FILTERING_4SAMPLES
  *         @arg @ref LL_ADC_AWD_FILTERING_5SAMPLES
  *         @arg @ref LL_ADC_AWD_FILTERING_6SAMPLES
  *         @arg @ref LL_ADC_AWD_FILTERING_7SAMPLES
  *         @arg @ref LL_ADC_AWD_FILTERING_8SAMPLES
  */
__STATIC_INLINE uint32_t LL_ADC_GetAWDFilteringConfiguration(const ADC_TypeDef *ADCx, uint32_t AWDy)
{
  /* Prevent unused argument(s) compilation warning */
  (void)(AWDy);
  return (uint32_t)(READ_BIT(ADCx->TR1, ADC_TR1_AWDFILT));
}

/**
  * @}
  */

/** @defgroup ADC_LL_EF_Configuration_ADC_oversampling Configuration of ADC transversal scope: oversampling
  * @{
  */

/**
  * @brief  Set ADC oversampling scope: ADC groups regular and-or injected
  *         (availability of ADC group injected depends on STM32 series).
  * @note   If both groups regular and injected are selected,
  *         specify behavior of ADC group injected interrupting
  *         group regular: when ADC group injected is triggered,
  *         the oversampling on ADC group regular is either
  *         temporary stopped and continued, or resumed from start
  *         (oversampler buffer reset).
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll CFGR2    ROVSE          LL_ADC_SetOverSamplingScope\n
  *         CFGR2    JOVSE          LL_ADC_SetOverSamplingScope\n
  *         CFGR2    ROVSM          LL_ADC_SetOverSamplingScope
  * @param  ADCx ADC instance
  * @param  OvsScope This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OVS_DISABLE
  *         @arg @ref LL_ADC_OVS_GRP_REGULAR_CONTINUED
  *         @arg @ref LL_ADC_OVS_GRP_REGULAR_RESUMED
  *         @arg @ref LL_ADC_OVS_GRP_INJECTED
  *         @arg @ref LL_ADC_OVS_GRP_INJ_REG_RESUMED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOverSamplingScope(ADC_TypeDef *ADCx, uint32_t OvsScope)
{
  MODIFY_REG(ADCx->CFGR2, ADC_CFGR2_ROVSE | ADC_CFGR2_JOVSE | ADC_CFGR2_ROVSM, OvsScope);
}

/**
  * @brief  Get ADC oversampling scope: ADC groups regular and-or injected
  *         (availability of ADC group injected depends on STM32 series).
  * @note   If both groups regular and injected are selected,
  *         specify behavior of ADC group injected interrupting
  *         group regular: when ADC group injected is triggered,
  *         the oversampling on ADC group regular is either
  *         temporary stopped and continued, or resumed from start
  *         (oversampler buffer reset).
  * @rmtoll CFGR2    ROVSE          LL_ADC_GetOverSamplingScope\n
  *         CFGR2    JOVSE          LL_ADC_GetOverSamplingScope\n
  *         CFGR2    ROVSM          LL_ADC_GetOverSamplingScope
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_OVS_DISABLE
  *         @arg @ref LL_ADC_OVS_GRP_REGULAR_CONTINUED
  *         @arg @ref LL_ADC_OVS_GRP_REGULAR_RESUMED
  *         @arg @ref LL_ADC_OVS_GRP_INJECTED
  *         @arg @ref LL_ADC_OVS_GRP_INJ_REG_RESUMED
  */
__STATIC_INLINE uint32_t LL_ADC_GetOverSamplingScope(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR2, ADC_CFGR2_ROVSE | ADC_CFGR2_JOVSE | ADC_CFGR2_ROVSM));
}

/**
  * @brief  Set ADC oversampling discontinuous mode (triggered mode)
  *         on the selected ADC group.
  * @note   Number of oversampled conversions are done either in:
  *         - continuous mode (all conversions of oversampling ratio
  *           are done from 1 trigger)
  *         - discontinuous mode (each conversion of oversampling ratio
  *           needs a trigger)
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on group regular.
  * @note   On this STM32 series, oversampling discontinuous mode
  *         (triggered mode) can be used only when oversampling is
  *         set on group regular only and in resumed mode.
  * @rmtoll CFGR2    TROVS          LL_ADC_SetOverSamplingDiscont
  * @param  ADCx ADC instance
  * @param  OverSamplingDiscont This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OVS_REG_CONT
  *         @arg @ref LL_ADC_OVS_REG_DISCONT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOverSamplingDiscont(ADC_TypeDef *ADCx, uint32_t OverSamplingDiscont)
{
  MODIFY_REG(ADCx->CFGR2, ADC_CFGR2_TROVS, OverSamplingDiscont);
}

/**
  * @brief  Get ADC oversampling discontinuous mode (triggered mode)
  *         on the selected ADC group.
  * @note   Number of oversampled conversions are done either in:
  *         - continuous mode (all conversions of oversampling ratio
  *           are done from 1 trigger)
  *         - discontinuous mode (each conversion of oversampling ratio
  *           needs a trigger)
  * @rmtoll CFGR2    TROVS          LL_ADC_GetOverSamplingDiscont
  * @param  ADCx ADC instance
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_OVS_REG_CONT
  *         @arg @ref LL_ADC_OVS_REG_DISCONT
  */
__STATIC_INLINE uint32_t LL_ADC_GetOverSamplingDiscont(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR2, ADC_CFGR2_TROVS));
}

/**
  * @brief  Set ADC oversampling
  *         (impacting both ADC groups regular and injected)
  * @note   This function set the 2 items of oversampling configuration:
  *         - ratio
  *         - shift
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be disabled or enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll CFGR2    OVSS           LL_ADC_ConfigOverSamplingRatioShift\n
  *         CFGR2    OVSR           LL_ADC_ConfigOverSamplingRatioShift
  * @param  ADCx ADC instance
  * @param  Ratio This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OVS_RATIO_2
  *         @arg @ref LL_ADC_OVS_RATIO_4
  *         @arg @ref LL_ADC_OVS_RATIO_8
  *         @arg @ref LL_ADC_OVS_RATIO_16
  *         @arg @ref LL_ADC_OVS_RATIO_32
  *         @arg @ref LL_ADC_OVS_RATIO_64
  *         @arg @ref LL_ADC_OVS_RATIO_128
  *         @arg @ref LL_ADC_OVS_RATIO_256
  * @param  Shift This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OVS_SHIFT_NONE
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_1
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_2
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_3
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_4
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_5
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_6
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_7
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_8
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ConfigOverSamplingRatioShift(ADC_TypeDef *ADCx, uint32_t Ratio, uint32_t Shift)
{
  MODIFY_REG(ADCx->CFGR2, (ADC_CFGR2_OVSS | ADC_CFGR2_OVSR), (Shift | Ratio));
}

/**
  * @brief  Get ADC oversampling ratio
  *        (impacting both ADC groups regular and injected)
  * @rmtoll CFGR2    OVSR           LL_ADC_GetOverSamplingRatio
  * @param  ADCx ADC instance
  * @retval Ratio This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OVS_RATIO_2
  *         @arg @ref LL_ADC_OVS_RATIO_4
  *         @arg @ref LL_ADC_OVS_RATIO_8
  *         @arg @ref LL_ADC_OVS_RATIO_16
  *         @arg @ref LL_ADC_OVS_RATIO_32
  *         @arg @ref LL_ADC_OVS_RATIO_64
  *         @arg @ref LL_ADC_OVS_RATIO_128
  *         @arg @ref LL_ADC_OVS_RATIO_256
  */
__STATIC_INLINE uint32_t LL_ADC_GetOverSamplingRatio(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR2, ADC_CFGR2_OVSR));
}

/**
  * @brief  Get ADC oversampling shift
  *        (impacting both ADC groups regular and injected)
  * @rmtoll CFGR2    OVSS           LL_ADC_GetOverSamplingShift
  * @param  ADCx ADC instance
  * @retval Shift This parameter can be one of the following values:
  *         @arg @ref LL_ADC_OVS_SHIFT_NONE
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_1
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_2
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_3
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_4
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_5
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_6
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_7
  *         @arg @ref LL_ADC_OVS_SHIFT_RIGHT_8
  */
__STATIC_INLINE uint32_t LL_ADC_GetOverSamplingShift(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CFGR2, ADC_CFGR2_OVSS));
}

/**
  * @}
  */

/** @defgroup ADC_LL_EF_Configuration_ADC_Multimode Configuration of ADC hierarchical scope: multimode
  * @{
  */


/**
  * @brief  Set ADC multimode configuration to operate in independent mode
  *         or multimode (for devices with several ADC instances).
  * @note   If multimode configuration: the selected ADC instance is
  *         either master or slave depending on hardware.
  *         Refer to reference manual.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         All ADC instances of the ADC common group must be disabled.
  *         This check can be done with function @ref LL_ADC_IsEnabled() for each
  *         ADC instance or by using helper macro
  *         @ref __LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE().
  * @rmtoll CCR      DUAL           LL_ADC_SetMultimode
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @param  Multimode This parameter can be one of the following values:
  *         @arg @ref LL_ADC_MULTI_INDEPENDENT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIMULT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INTERL
  *         @arg @ref LL_ADC_MULTI_DUAL_INJ_SIMULT
  *         @arg @ref LL_ADC_MULTI_DUAL_INJ_ALTERN
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetMultimode(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t Multimode)
{
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_DUAL, Multimode);
}

/**
  * @brief  Get ADC multimode configuration to operate in independent mode
  *         or multimode (for devices with several ADC instances).
  * @note   If multimode configuration: the selected ADC instance is
  *         either master or slave depending on hardware.
  *         Refer to reference manual.
  * @rmtoll CCR      DUAL           LL_ADC_GetMultimode
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_MULTI_INDEPENDENT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIMULT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INTERL
  *         @arg @ref LL_ADC_MULTI_DUAL_INJ_SIMULT
  *         @arg @ref LL_ADC_MULTI_DUAL_INJ_ALTERN
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultimode(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
}

/**
  * @brief  Set ADC multimode conversion data transfer: no transfer
  *         or transfer by DMA.
  * @note   If ADC multimode transfer by DMA is not selected:
  *         each ADC uses its own DMA channel, with its individual
  *         DMA transfer settings.
  *         If ADC multimode transfer by DMA is selected:
  *         One DMA channel is used for both ADC (DMA of ADC master)
  *         Specifies the DMA requests mode:
  *         - Limited mode (One shot mode): DMA transfer requests are stopped
  *           when number of DMA data transfers (number of
  *           ADC conversions) is reached.
  *           This ADC mode is intended to be used with DMA mode non-circular.
  *         - Unlimited mode: DMA transfer requests are unlimited,
  *           whatever number of DMA data transfers (number of
  *           ADC conversions).
  *           This ADC mode is intended to be used with DMA mode circular.
  * @note   If ADC DMA requests mode is set to unlimited and DMA is set to
  *         mode non-circular:
  *         when DMA transfers size will be reached, DMA will stop transfers of
  *         ADC conversions data ADC will raise an overrun error
  *         (overrun flag and interruption if enabled).
  * @note   How to retrieve multimode conversion data:
  *         Whatever multimode transfer by DMA setting: using function
  *         @ref LL_ADC_REG_ReadMultiConversionData32().
  *         If ADC multimode transfer by DMA is selected: conversion data
  *         is a raw data with ADC master and slave concatenated.
  *         A macro is available to get the conversion data of
  *         ADC master or ADC slave: see helper macro
  *         @ref __LL_ADC_MULTI_CONV_DATA_MASTER_SLAVE().
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         All ADC instances of the ADC common group must be disabled
  *         or enabled without conversion on going on group regular.
  * @rmtoll CCR      MDMA           LL_ADC_SetMultiDMATransfer\n
  *         CCR      DMACFG         LL_ADC_SetMultiDMATransfer
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @param  MultiDMATransfer This parameter can be one of the following values:
  *         @arg @ref LL_ADC_MULTI_REG_DMA_EACH_ADC
  *         @arg @ref LL_ADC_MULTI_REG_DMA_LIMIT_RES12_10B
  *         @arg @ref LL_ADC_MULTI_REG_DMA_LIMIT_RES8_6B
  *         @arg @ref LL_ADC_MULTI_REG_DMA_UNLMT_RES12_10B
  *         @arg @ref LL_ADC_MULTI_REG_DMA_UNLMT_RES8_6B
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetMultiDMATransfer(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t MultiDMATransfer)
{
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG, MultiDMATransfer);
}

/**
  * @brief  Get ADC multimode conversion data transfer: no transfer
  *         or transfer by DMA.
  * @note   If ADC multimode transfer by DMA is not selected:
  *         each ADC uses its own DMA channel, with its individual
  *         DMA transfer settings.
  *         If ADC multimode transfer by DMA is selected:
  *         One DMA channel is used for both ADC (DMA of ADC master)
  *         Specifies the DMA requests mode:
  *         - Limited mode (One shot mode): DMA transfer requests are stopped
  *           when number of DMA data transfers (number of
  *           ADC conversions) is reached.
  *           This ADC mode is intended to be used with DMA mode non-circular.
  *         - Unlimited mode: DMA transfer requests are unlimited,
  *           whatever number of DMA data transfers (number of
  *           ADC conversions).
  *           This ADC mode is intended to be used with DMA mode circular.
  * @note   If ADC DMA requests mode is set to unlimited and DMA is set to
  *         mode non-circular:
  *         when DMA transfers size will be reached, DMA will stop transfers of
  *         ADC conversions data ADC will raise an overrun error
  *         (overrun flag and interruption if enabled).
  * @note   How to retrieve multimode conversion data:
  *         Whatever multimode transfer by DMA setting: using function
  *         @ref LL_ADC_REG_ReadMultiConversionData32().
  *         If ADC multimode transfer by DMA is selected: conversion data
  *         is a raw data with ADC master and slave concatenated.
  *         A macro is available to get the conversion data of
  *         ADC master or ADC slave: see helper macro
  *         @ref __LL_ADC_MULTI_CONV_DATA_MASTER_SLAVE().
  * @rmtoll CCR      MDMA           LL_ADC_GetMultiDMATransfer\n
  *         CCR      DMACFG         LL_ADC_GetMultiDMATransfer
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_MULTI_REG_DMA_EACH_ADC
  *         @arg @ref LL_ADC_MULTI_REG_DMA_LIMIT_RES12_10B
  *         @arg @ref LL_ADC_MULTI_REG_DMA_LIMIT_RES8_6B
  *         @arg @ref LL_ADC_MULTI_REG_DMA_UNLMT_RES12_10B
  *         @arg @ref LL_ADC_MULTI_REG_DMA_UNLMT_RES8_6B
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultiDMATransfer(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG));
}

/**
  * @brief  Set ADC multimode delay between 2 sampling phases.
  * @note   The sampling delay range depends on ADC resolution:
  *         - ADC resolution 12 bits can have maximum delay of 12 cycles.
  *         - ADC resolution 10 bits can have maximum delay of 10 cycles.
  *         - ADC resolution  8 bits can have maximum delay of  8 cycles.
  *         - ADC resolution  6 bits can have maximum delay of  6 cycles.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         All ADC instances of the ADC common group must be disabled.
  *         This check can be done with function @ref LL_ADC_IsEnabled() for each
  *         ADC instance or by using helper macro helper macro
  *         @ref __LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE().
  * @rmtoll CCR      DELAY          LL_ADC_SetMultiTwoSamplingDelay
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @param  MultiTwoSamplingDelay This parameter can be one of the following values:
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_1CYCLE
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_2CYCLES
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_3CYCLES
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_4CYCLES
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_5CYCLES
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_6CYCLES  (1)
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_7CYCLES  (1)
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_8CYCLES  (2)
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_9CYCLES  (2)
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_10CYCLES (2)
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_11CYCLES (3)
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_12CYCLES (3)
  *
  *         (1) Parameter available only if ADC resolution is 12, 10 or 8 bits.\n
  *         (2) Parameter available only if ADC resolution is 12 or 10 bits.\n
  *         (3) Parameter available only if ADC resolution is 12 bits.
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetMultiTwoSamplingDelay(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t MultiTwoSamplingDelay)
{
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_DELAY, MultiTwoSamplingDelay);
}

/**
  * @brief  Get ADC multimode delay between 2 sampling phases.
  * @rmtoll CCR      DELAY          LL_ADC_GetMultiTwoSamplingDelay
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_1CYCLE
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_2CYCLES
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_3CYCLES
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_4CYCLES
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_5CYCLES
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_6CYCLES  (1)
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_7CYCLES  (1)
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_8CYCLES  (2)
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_9CYCLES  (2)
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_10CYCLES (2)
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_11CYCLES (3)
  *         @arg @ref LL_ADC_MULTI_TWOSMP_DELAY_12CYCLES (3)
  *
  *         (1) Parameter available only if ADC resolution is 12, 10 or 8 bits.\n
  *         (2) Parameter available only if ADC resolution is 12 or 10 bits.\n
  *         (3) Parameter available only if ADC resolution is 12 bits.
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultiTwoSamplingDelay(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DELAY));
}


/**
  * @}
  */
/** @defgroup ADC_LL_EF_Operation_ADC_Instance Operation on ADC hierarchical scope: ADC instance
  * @{
  */

/**
  * @brief  Put ADC instance in deep power down state.
  * @note   In case of ADC calibration necessary: When ADC is in deep-power-down
  *         state, the internal analog calibration is lost. After exiting from
  *         deep power down, calibration must be relaunched or calibration factor
  *         (preliminarily saved) must be set back into calibration register.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be ADC disabled.
  * @rmtoll CR       DEEPPWD        LL_ADC_EnableDeepPowerDown
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableDeepPowerDown(ADC_TypeDef *ADCx)
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_DEEPPWD);
}

/**
  * @brief  Disable ADC deep power down mode.
  * @note   In case of ADC calibration necessary: When ADC is in deep-power-down
  *         state, the internal analog calibration is lost. After exiting from
  *         deep power down, calibration must be relaunched or calibration factor
  *         (preliminarily saved) must be set back into calibration register.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be ADC disabled.
  * @rmtoll CR       DEEPPWD        LL_ADC_DisableDeepPowerDown
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableDeepPowerDown(ADC_TypeDef *ADCx)
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
}

/**
  * @brief  Get the selected ADC instance deep power down state.
  * @rmtoll CR       DEEPPWD        LL_ADC_IsDeepPowerDownEnabled
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
}

/**
  * @brief  Enable ADC instance internal voltage regulator.
  * @note   On this STM32 series, after ADC internal voltage regulator enable,
  *         a delay for ADC internal voltage regulator stabilization
  *         is required before performing a ADC calibration or ADC enable.
  *         Refer to device datasheet, parameter tADCVREG_STUP.
  *         Refer to literal @ref LL_ADC_DELAY_INTERNAL_REGUL_STAB_US.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be ADC disabled.
  * @rmtoll CR       ADVREGEN       LL_ADC_EnableInternalRegulator
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableInternalRegulator(ADC_TypeDef *ADCx)
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADVREGEN);
}

/**
  * @brief  Disable ADC internal voltage regulator.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be ADC disabled.
  * @rmtoll CR       ADVREGEN       LL_ADC_DisableInternalRegulator
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableInternalRegulator(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->CR, (ADC_CR_ADVREGEN | ADC_CR_BITS_PROPERTY_RS));
}

/**
  * @brief  Get the selected ADC instance internal voltage regulator state.
  * @rmtoll CR       ADVREGEN       LL_ADC_IsInternalRegulatorEnabled
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
}

/**
  * @brief  Enable the selected ADC instance.
  * @note   On this STM32 series, after ADC enable, a delay for
  *         ADC internal analog stabilization is required before performing a
  *         ADC conversion start.
  *         Refer to device datasheet, parameter tSTAB.
  * @note   On this STM32 series, flag LL_ADC_FLAG_ADRDY is raised when the ADC
  *         is enabled and when conversion clock is active.
  *         (not only core clock: this ADC has a dual clock domain)
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be ADC disabled and ADC internal voltage regulator enabled.
  * @rmtoll CR       ADEN           LL_ADC_Enable
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_Enable(ADC_TypeDef *ADCx)
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADEN);
}

/**
  * @brief  Disable the selected ADC instance.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be not disabled. Must be enabled without conversion on going
  *         on either groups regular or injected.
  * @rmtoll CR       ADDIS          LL_ADC_Disable
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_Disable(ADC_TypeDef *ADCx)
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADDIS);
}

/**
  * @brief  Get the selected ADC instance enable state.
  * @note   On this STM32 series, flag LL_ADC_FLAG_ADRDY is raised when the ADC
  *         is enabled and when conversion clock is active.
  *         (not only core clock: this ADC has a dual clock domain)
  * @rmtoll CR       ADEN           LL_ADC_IsEnabled
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
}

/**
  * @brief  Get the selected ADC instance disable state.
  * @rmtoll CR       ADDIS          LL_ADC_IsDisableOngoing
  * @param  ADCx ADC instance
  * @retval 0: no ADC disable command on going.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDisableOngoing(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
}

/**
  * @brief  Start ADC calibration in the mode single-ended
  *         or differential (for devices with differential mode available).
  * @note   On this STM32 series, a minimum number of ADC clock cycles
  *         are required between ADC end of calibration and ADC enable.
  *         Refer to literal @ref LL_ADC_DELAY_CALIB_ENABLE_ADC_CYCLES.
  * @note   For devices with differential mode available:
  *         Calibration of offset is specific to each of
  *         single-ended and differential modes
  *         (calibration run must be performed for each of these
  *         differential modes, if used afterwards and if the application
  *         requires their calibration).
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be ADC disabled.
  * @rmtoll CR       ADCAL          LL_ADC_StartCalibration\n
  *         CR       ADCALDIF       LL_ADC_StartCalibration
  * @param  ADCx ADC instance
  * @param  SingleDiff This parameter can be one of the following values:
  *         @arg @ref LL_ADC_SINGLE_ENDED
  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_StartCalibration(ADC_TypeDef *ADCx, uint32_t SingleDiff)
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
             ADC_CR_ADCALDIF | ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADCAL | (SingleDiff & ADC_SINGLEDIFF_CALIB_START_MASK));
}

/**
  * @brief  Get ADC calibration state.
  * @rmtoll CR       ADCAL          LL_ADC_IsCalibrationOnGoing
  * @param  ADCx ADC instance
  * @retval 0: calibration complete, 1: calibration in progress.
  */
__STATIC_INLINE uint32_t LL_ADC_IsCalibrationOnGoing(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
}

/**
  * @}
  */

/** @defgroup ADC_LL_EF_Operation_ADC_Group_Regular Operation on ADC hierarchical scope: group regular
  * @{
  */

/**
  * @brief  Start ADC group regular conversion.
  * @note   On this STM32 series, this function is relevant for both
  *         internal trigger (SW start) and external trigger:
  *         - If ADC trigger has been set to software start, ADC conversion
  *           starts immediately.
  *         - If ADC trigger has been set to external trigger, ADC conversion
  *           will start at next trigger event (on the selected trigger edge)
  *           following the ADC start conversion command.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be enabled without conversion on going on group regular,
  *         without conversion stop command on going on group regular,
  *         without ADC disable command on going.
  * @rmtoll CR       ADSTART        LL_ADC_REG_StartConversion
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_StartConversion(ADC_TypeDef *ADCx)
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADSTART);
}

/**
  * @brief  Stop ADC group regular conversion.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be enabled with conversion on going on group regular,
  *         without ADC disable command on going.
  * @rmtoll CR       ADSTP          LL_ADC_REG_StopConversion
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_StopConversion(ADC_TypeDef *ADCx)
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADSTP);
}

/**
  * @brief  Get ADC group regular conversion state.
  * @rmtoll CR       ADSTART        LL_ADC_REG_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
}

/**
  * @brief  Get ADC group regular command of conversion stop state
  * @rmtoll CR       ADSTP          LL_ADC_REG_IsStopConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no command of conversion stop is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsStopConversionOngoing(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTP) == (ADC_CR_ADSTP)) ? 1UL : 0UL);
}

/**
  * @brief  Start ADC sampling phase for sampling time trigger mode
  * @note   This function is relevant only when
  *         - @ref LL_ADC_REG_SAMPLING_MODE_TRIGGER_CONTROLED has been set
  *           using @ref LL_ADC_REG_SetSamplingMode
  *         - @ref LL_ADC_REG_TRIG_SOFTWARE is used as trigger source
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be enabled without conversion on going on group regular,
  *         without conversion stop command on going on group regular,
  *         without ADC disable command on going.
  * @rmtoll CFGR2    SWTRIG         LL_ADC_REG_StartSamplingPhase
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_StartSamplingPhase(ADC_TypeDef *ADCx)
{
  SET_BIT(ADCx->CFGR2, ADC_CFGR2_SWTRIG);
}

/**
  * @brief  Stop ADC sampling phase for sampling time trigger mode and start conversion
  * @note   This function is relevant only when
  *         - @ref LL_ADC_REG_SAMPLING_MODE_TRIGGER_CONTROLED has been set
  *           using @ref LL_ADC_REG_SetSamplingMode
  *         - @ref LL_ADC_REG_TRIG_SOFTWARE is used as trigger source
  *         - @ref LL_ADC_REG_StartSamplingPhase has been called to start
  *           the sampling phase
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be enabled without conversion on going on group regular,
  *         without conversion stop command on going on group regular,
  *         without ADC disable command on going.
  * @rmtoll CFGR2    SWTRIG         LL_ADC_REG_StopSamplingPhase
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_StopSamplingPhase(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->CFGR2, ADC_CFGR2_SWTRIG);
}

/**
  * @brief  Get ADC group regular conversion data, range fit for
  *         all ADC configurations: all ADC resolutions and
  *         all oversampling increased data width (for devices
  *         with feature oversampling).
  * @rmtoll DR       RDATA          LL_ADC_REG_ReadConversionData32
  * @param  ADCx ADC instance
  * @retval Value between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_ADC_REG_ReadConversionData32(const ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
}

/**
  * @brief  Get ADC group regular conversion data, range fit for
  *         ADC resolution 12 bits.
  * @note   For devices with feature oversampling: Oversampling
  *         can increase data width, function for extended range
  *         may be needed: @ref LL_ADC_REG_ReadConversionData32.
  * @rmtoll DR       RDATA          LL_ADC_REG_ReadConversionData12
  * @param  ADCx ADC instance
  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
  */
__STATIC_INLINE uint16_t LL_ADC_REG_ReadConversionData12(const ADC_TypeDef *ADCx)
{
  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
}

/**
  * @brief  Get ADC group regular conversion data, range fit for
  *         ADC resolution 10 bits.
  * @note   For devices with feature oversampling: Oversampling
  *         can increase data width, function for extended range
  *         may be needed: @ref LL_ADC_REG_ReadConversionData32.
  * @rmtoll DR       RDATA          LL_ADC_REG_ReadConversionData10
  * @param  ADCx ADC instance
  * @retval Value between Min_Data=0x000 and Max_Data=0x3FF
  */
__STATIC_INLINE uint16_t LL_ADC_REG_ReadConversionData10(const ADC_TypeDef *ADCx)
{
  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
}

/**
  * @brief  Get ADC group regular conversion data, range fit for
  *         ADC resolution 8 bits.
  * @note   For devices with feature oversampling: Oversampling
  *         can increase data width, function for extended range
  *         may be needed: @ref LL_ADC_REG_ReadConversionData32.
  * @rmtoll DR       RDATA          LL_ADC_REG_ReadConversionData8
  * @param  ADCx ADC instance
  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
  */
__STATIC_INLINE uint8_t LL_ADC_REG_ReadConversionData8(const ADC_TypeDef *ADCx)
{
  return (uint8_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
}

/**
  * @brief  Get ADC group regular conversion data, range fit for
  *         ADC resolution 6 bits.
  * @note   For devices with feature oversampling: Oversampling
  *         can increase data width, function for extended range
  *         may be needed: @ref LL_ADC_REG_ReadConversionData32.
  * @rmtoll DR       RDATA          LL_ADC_REG_ReadConversionData6
  * @param  ADCx ADC instance
  * @retval Value between Min_Data=0x00 and Max_Data=0x3F
  */
__STATIC_INLINE uint8_t LL_ADC_REG_ReadConversionData6(const ADC_TypeDef *ADCx)
{
  return (uint8_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
}


/**
  * @brief  Get ADC multimode conversion data of ADC master, ADC slave
  *         or raw data with ADC master and slave concatenated.
  * @note   If raw data with ADC master and slave concatenated is retrieved,
  *         a macro is available to get the conversion data of
  *         ADC master or ADC slave: see helper macro
  *         @ref __LL_ADC_MULTI_CONV_DATA_MASTER_SLAVE().
  *         (however this macro is mainly intended for multimode
  *         transfer by DMA, because this function can do the same
  *         by getting multimode conversion data of ADC master or ADC slave
  *         separately).
  * @rmtoll CDR      RDATA_MST      LL_ADC_REG_ReadMultiConversionData32\n
  *         CDR      RDATA_SLV      LL_ADC_REG_ReadMultiConversionData32
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @param  ConversionData This parameter can be one of the following values:
  *         @arg @ref LL_ADC_MULTI_MASTER
  *         @arg @ref LL_ADC_MULTI_SLAVE
  *         @arg @ref LL_ADC_MULTI_MASTER_SLAVE
  * @retval Value between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_ADC_REG_ReadMultiConversionData32(const ADC_Common_TypeDef *ADCxy_COMMON,
                                                              uint32_t ConversionData)
{
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CDR,
                             ConversionData)
                    >> (POSITION_VAL(ConversionData) & 0x1FUL)
                   );
}


/**
  * @}
  */

/** @defgroup ADC_LL_EF_Operation_ADC_Group_Injected Operation on ADC hierarchical scope: group injected
  * @{
  */

/**
  * @brief  Start ADC group injected conversion.
  * @note   On this STM32 series, this function is relevant for both
  *         internal trigger (SW start) and external trigger:
  *         - If ADC trigger has been set to software start, ADC conversion
  *           starts immediately.
  *         - If ADC trigger has been set to external trigger, ADC conversion
  *           will start at next trigger event (on the selected trigger edge)
  *           following the ADC start conversion command.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be enabled without conversion on going on group injected,
  *         without conversion stop command on going on group injected,
  *         without ADC disable command on going.
  * @rmtoll CR       JADSTART       LL_ADC_INJ_StartConversion
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_INJ_StartConversion(ADC_TypeDef *ADCx)
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_JADSTART);
}

/**
  * @brief  Stop ADC group injected conversion.
  * @note   On this STM32 series, setting of this feature is conditioned to
  *         ADC state:
  *         ADC must be enabled with conversion on going on group injected,
  *         without ADC disable command on going.
  * @rmtoll CR       JADSTP         LL_ADC_INJ_StopConversion
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_INJ_StopConversion(ADC_TypeDef *ADCx)
{
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_JADSTP);
}

/**
  * @brief  Get ADC group injected conversion state.
  * @rmtoll CR       JADSTART       LL_ADC_INJ_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
}

/**
  * @brief  Get ADC group injected command of conversion stop state
  * @rmtoll CR       JADSTP         LL_ADC_INJ_IsStopConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no command of conversion stop is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsStopConversionOngoing(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTP) == (ADC_CR_JADSTP)) ? 1UL : 0UL);
}

/**
  * @brief  Get ADC group injected conversion data, range fit for
  *         all ADC configurations: all ADC resolutions and
  *         all oversampling increased data width (for devices
  *         with feature oversampling).
  * @rmtoll JDR1     JDATA          LL_ADC_INJ_ReadConversionData32\n
  *         JDR2     JDATA          LL_ADC_INJ_ReadConversionData32\n
  *         JDR3     JDATA          LL_ADC_INJ_ReadConversionData32\n
  *         JDR4     JDATA          LL_ADC_INJ_ReadConversionData32
  * @param  ADCx ADC instance
  * @param  Rank This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_RANK_1
  *         @arg @ref LL_ADC_INJ_RANK_2
  *         @arg @ref LL_ADC_INJ_RANK_3
  *         @arg @ref LL_ADC_INJ_RANK_4
  * @retval Value between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_ReadConversionData32(const ADC_TypeDef *ADCx, uint32_t Rank)
{
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1,
                                                   ((Rank & ADC_INJ_JDRX_REGOFFSET_MASK) >> ADC_JDRX_REGOFFSET_POS));

  return (uint32_t)(READ_BIT(*preg,
                             ADC_JDR1_JDATA)
                   );
}

/**
  * @brief  Get ADC group injected conversion data, range fit for
  *         ADC resolution 12 bits.
  * @note   For devices with feature oversampling: Oversampling
  *         can increase data width, function for extended range
  *         may be needed: @ref LL_ADC_INJ_ReadConversionData32.
  * @rmtoll JDR1     JDATA          LL_ADC_INJ_ReadConversionData12\n
  *         JDR2     JDATA          LL_ADC_INJ_ReadConversionData12\n
  *         JDR3     JDATA          LL_ADC_INJ_ReadConversionData12\n
  *         JDR4     JDATA          LL_ADC_INJ_ReadConversionData12
  * @param  ADCx ADC instance
  * @param  Rank This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_RANK_1
  *         @arg @ref LL_ADC_INJ_RANK_2
  *         @arg @ref LL_ADC_INJ_RANK_3
  *         @arg @ref LL_ADC_INJ_RANK_4
  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
  */
__STATIC_INLINE uint16_t LL_ADC_INJ_ReadConversionData12(const ADC_TypeDef *ADCx, uint32_t Rank)
{
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1,
                                                   ((Rank & ADC_INJ_JDRX_REGOFFSET_MASK) >> ADC_JDRX_REGOFFSET_POS));

  return (uint16_t)(READ_BIT(*preg,
                             ADC_JDR1_JDATA)
                   );
}

/**
  * @brief  Get ADC group injected conversion data, range fit for
  *         ADC resolution 10 bits.
  * @note   For devices with feature oversampling: Oversampling
  *         can increase data width, function for extended range
  *         may be needed: @ref LL_ADC_INJ_ReadConversionData32.
  * @rmtoll JDR1     JDATA          LL_ADC_INJ_ReadConversionData10\n
  *         JDR2     JDATA          LL_ADC_INJ_ReadConversionData10\n
  *         JDR3     JDATA          LL_ADC_INJ_ReadConversionData10\n
  *         JDR4     JDATA          LL_ADC_INJ_ReadConversionData10
  * @param  ADCx ADC instance
  * @param  Rank This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_RANK_1
  *         @arg @ref LL_ADC_INJ_RANK_2
  *         @arg @ref LL_ADC_INJ_RANK_3
  *         @arg @ref LL_ADC_INJ_RANK_4
  * @retval Value between Min_Data=0x000 and Max_Data=0x3FF
  */
__STATIC_INLINE uint16_t LL_ADC_INJ_ReadConversionData10(const ADC_TypeDef *ADCx, uint32_t Rank)
{
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1,
                                                   ((Rank & ADC_INJ_JDRX_REGOFFSET_MASK) >> ADC_JDRX_REGOFFSET_POS));

  return (uint16_t)(READ_BIT(*preg,
                             ADC_JDR1_JDATA)
                   );
}

/**
  * @brief  Get ADC group injected conversion data, range fit for
  *         ADC resolution 8 bits.
  * @note   For devices with feature oversampling: Oversampling
  *         can increase data width, function for extended range
  *         may be needed: @ref LL_ADC_INJ_ReadConversionData32.
  * @rmtoll JDR1     JDATA          LL_ADC_INJ_ReadConversionData8\n
  *         JDR2     JDATA          LL_ADC_INJ_ReadConversionData8\n
  *         JDR3     JDATA          LL_ADC_INJ_ReadConversionData8\n
  *         JDR4     JDATA          LL_ADC_INJ_ReadConversionData8
  * @param  ADCx ADC instance
  * @param  Rank This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_RANK_1
  *         @arg @ref LL_ADC_INJ_RANK_2
  *         @arg @ref LL_ADC_INJ_RANK_3
  *         @arg @ref LL_ADC_INJ_RANK_4
  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
  */
__STATIC_INLINE uint8_t LL_ADC_INJ_ReadConversionData8(const ADC_TypeDef *ADCx, uint32_t Rank)
{
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1,
                                                   ((Rank & ADC_INJ_JDRX_REGOFFSET_MASK) >> ADC_JDRX_REGOFFSET_POS));

  return (uint8_t)(READ_BIT(*preg,
                            ADC_JDR1_JDATA)
                  );
}

/**
  * @brief  Get ADC group injected conversion data, range fit for
  *         ADC resolution 6 bits.
  * @note   For devices with feature oversampling: Oversampling
  *         can increase data width, function for extended range
  *         may be needed: @ref LL_ADC_INJ_ReadConversionData32.
  * @rmtoll JDR1     JDATA          LL_ADC_INJ_ReadConversionData6\n
  *         JDR2     JDATA          LL_ADC_INJ_ReadConversionData6\n
  *         JDR3     JDATA          LL_ADC_INJ_ReadConversionData6\n
  *         JDR4     JDATA          LL_ADC_INJ_ReadConversionData6
  * @param  ADCx ADC instance
  * @param  Rank This parameter can be one of the following values:
  *         @arg @ref LL_ADC_INJ_RANK_1
  *         @arg @ref LL_ADC_INJ_RANK_2
  *         @arg @ref LL_ADC_INJ_RANK_3
  *         @arg @ref LL_ADC_INJ_RANK_4
  * @retval Value between Min_Data=0x00 and Max_Data=0x3F
  */
__STATIC_INLINE uint8_t LL_ADC_INJ_ReadConversionData6(const ADC_TypeDef *ADCx, uint32_t Rank)
{
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->JDR1,
                                                   ((Rank & ADC_INJ_JDRX_REGOFFSET_MASK) >> ADC_JDRX_REGOFFSET_POS));

  return (uint8_t)(READ_BIT(*preg,
                            ADC_JDR1_JDATA)
                  );
}

/**
  * @}
  */

/** @defgroup ADC_LL_EF_FLAG_Management ADC flag management
  * @{
  */

/**
  * @brief  Get flag ADC ready.
  * @note   On this STM32 series, flag LL_ADC_FLAG_ADRDY is raised when the ADC
  *         is enabled and when conversion clock is active.
  *         (not only core clock: this ADC has a dual clock domain)
  * @rmtoll ISR      ADRDY          LL_ADC_IsActiveFlag_ADRDY
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_ADRDY(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag ADC group regular end of unitary conversion.
  * @rmtoll ISR      EOC            LL_ADC_IsActiveFlag_EOC
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_EOC(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->ISR, ADC_ISR_EOC) == (ADC_ISR_EOC)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag ADC group regular end of sequence conversions.
  * @rmtoll ISR      EOS            LL_ADC_IsActiveFlag_EOS
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_EOS(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_EOS) == (LL_ADC_FLAG_EOS)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag ADC group regular overrun.
  * @rmtoll ISR      OVR            LL_ADC_IsActiveFlag_OVR
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_OVR(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_OVR) == (LL_ADC_FLAG_OVR)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag ADC group regular end of sampling phase.
  * @rmtoll ISR      EOSMP          LL_ADC_IsActiveFlag_EOSMP
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_EOSMP(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_EOSMP) == (LL_ADC_FLAG_EOSMP)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag ADC group injected end of unitary conversion.
  * @rmtoll ISR      JEOC           LL_ADC_IsActiveFlag_JEOC
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_JEOC(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_JEOC) == (LL_ADC_FLAG_JEOC)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag ADC group injected end of sequence conversions.
  * @rmtoll ISR      JEOS           LL_ADC_IsActiveFlag_JEOS
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_JEOS(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_JEOS) == (LL_ADC_FLAG_JEOS)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag ADC group injected contexts queue overflow.
  * @rmtoll ISR      JQOVF          LL_ADC_IsActiveFlag_JQOVF
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_JQOVF(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_JQOVF) == (LL_ADC_FLAG_JQOVF)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag ADC analog watchdog 1 flag
  * @rmtoll ISR      AWD1           LL_ADC_IsActiveFlag_AWD1
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_AWD1(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_AWD1) == (LL_ADC_FLAG_AWD1)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag ADC analog watchdog 2.
  * @rmtoll ISR      AWD2           LL_ADC_IsActiveFlag_AWD2
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_AWD2(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_AWD2) == (LL_ADC_FLAG_AWD2)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag ADC analog watchdog 3.
  * @rmtoll ISR      AWD3           LL_ADC_IsActiveFlag_AWD3
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_AWD3(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_AWD3) == (LL_ADC_FLAG_AWD3)) ? 1UL : 0UL);
}

/**
  * @brief  Clear flag ADC ready.
  * @note   On this STM32 series, flag LL_ADC_FLAG_ADRDY is raised when the ADC
  *         is enabled and when conversion clock is active.
  *         (not only core clock: this ADC has a dual clock domain)
  * @rmtoll ISR      ADRDY          LL_ADC_ClearFlag_ADRDY
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_ADRDY(ADC_TypeDef *ADCx)
{
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_ADRDY);
}

/**
  * @brief  Clear flag ADC group regular end of unitary conversion.
  * @rmtoll ISR      EOC            LL_ADC_ClearFlag_EOC
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_EOC(ADC_TypeDef *ADCx)
{
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
}

/**
  * @brief  Clear flag ADC group regular end of sequence conversions.
  * @rmtoll ISR      EOS            LL_ADC_ClearFlag_EOS
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_EOS(ADC_TypeDef *ADCx)
{
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOS);
}

/**
  * @brief  Clear flag ADC group regular overrun.
  * @rmtoll ISR      OVR            LL_ADC_ClearFlag_OVR
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_OVR(ADC_TypeDef *ADCx)
{
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_OVR);
}

/**
  * @brief  Clear flag ADC group regular end of sampling phase.
  * @rmtoll ISR      EOSMP          LL_ADC_ClearFlag_EOSMP
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_EOSMP(ADC_TypeDef *ADCx)
{
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOSMP);
}

/**
  * @brief  Clear flag ADC group injected end of unitary conversion.
  * @rmtoll ISR      JEOC           LL_ADC_ClearFlag_JEOC
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_JEOC(ADC_TypeDef *ADCx)
{
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOC);
}

/**
  * @brief  Clear flag ADC group injected end of sequence conversions.
  * @rmtoll ISR      JEOS           LL_ADC_ClearFlag_JEOS
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_JEOS(ADC_TypeDef *ADCx)
{
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOS);
}

/**
  * @brief  Clear flag ADC group injected contexts queue overflow.
  * @rmtoll ISR      JQOVF          LL_ADC_ClearFlag_JQOVF
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_JQOVF(ADC_TypeDef *ADCx)
{
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JQOVF);
}

/**
  * @brief  Clear flag ADC analog watchdog 1.
  * @rmtoll ISR      AWD1           LL_ADC_ClearFlag_AWD1
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_AWD1(ADC_TypeDef *ADCx)
{
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD1);
}

/**
  * @brief  Clear flag ADC analog watchdog 2.
  * @rmtoll ISR      AWD2           LL_ADC_ClearFlag_AWD2
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_AWD2(ADC_TypeDef *ADCx)
{
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD2);
}

/**
  * @brief  Clear flag ADC analog watchdog 3.
  * @rmtoll ISR      AWD3           LL_ADC_ClearFlag_AWD3
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_AWD3(ADC_TypeDef *ADCx)
{
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD3);
}


/**
  * @brief  Get flag multimode ADC ready of the ADC master.
  * @rmtoll CSR      ADRDY_MST      LL_ADC_IsActiveFlag_MST_ADRDY
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_ADRDY(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_ADRDY_MST) == (LL_ADC_FLAG_ADRDY_MST)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC ready of the ADC slave.
  * @rmtoll CSR      ADRDY_SLV      LL_ADC_IsActiveFlag_SLV_ADRDY
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_ADRDY(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_ADRDY_SLV) == (LL_ADC_FLAG_ADRDY_SLV)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC group regular end of unitary conversion of the ADC master.
  * @rmtoll CSR      EOC_MST        LL_ADC_IsActiveFlag_MST_EOC
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_EOC(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_EOC_SLV) == (LL_ADC_FLAG_EOC_SLV)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC group regular end of unitary conversion of the ADC slave.
  * @rmtoll CSR      EOC_SLV        LL_ADC_IsActiveFlag_SLV_EOC
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_EOC(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_EOC_SLV) == (LL_ADC_FLAG_EOC_SLV)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC group regular end of sequence conversions of the ADC master.
  * @rmtoll CSR      EOS_MST        LL_ADC_IsActiveFlag_MST_EOS
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_EOS(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_EOS_MST) == (LL_ADC_FLAG_EOS_MST)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC group regular end of sequence conversions of the ADC slave.
  * @rmtoll CSR      EOS_SLV        LL_ADC_IsActiveFlag_SLV_EOS
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_EOS(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_EOS_SLV) == (LL_ADC_FLAG_EOS_SLV)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC group regular overrun of the ADC master.
  * @rmtoll CSR      OVR_MST        LL_ADC_IsActiveFlag_MST_OVR
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_OVR(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_OVR_MST) == (LL_ADC_FLAG_OVR_MST)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC group regular overrun of the ADC slave.
  * @rmtoll CSR      OVR_SLV        LL_ADC_IsActiveFlag_SLV_OVR
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_OVR(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_OVR_SLV) == (LL_ADC_FLAG_OVR_SLV)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC group regular end of sampling of the ADC master.
  * @rmtoll CSR      EOSMP_MST      LL_ADC_IsActiveFlag_MST_EOSMP
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_EOSMP(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_EOSMP_MST) == (LL_ADC_FLAG_EOSMP_MST)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC group regular end of sampling of the ADC slave.
  * @rmtoll CSR      EOSMP_SLV      LL_ADC_IsActiveFlag_SLV_EOSMP
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_EOSMP(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_EOSMP_SLV) == (LL_ADC_FLAG_EOSMP_SLV)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC group injected end of unitary conversion of the ADC master.
  * @rmtoll CSR      JEOC_MST       LL_ADC_IsActiveFlag_MST_JEOC
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_JEOC(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_JEOC_MST) == (LL_ADC_FLAG_JEOC_MST)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC group injected end of unitary conversion of the ADC slave.
  * @rmtoll CSR      JEOC_SLV       LL_ADC_IsActiveFlag_SLV_JEOC
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_JEOC(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_JEOC_SLV) == (LL_ADC_FLAG_JEOC_SLV)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC group injected end of sequence conversions of the ADC master.
  * @rmtoll CSR      JEOS_MST       LL_ADC_IsActiveFlag_MST_JEOS
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_JEOS(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_JEOS_MST) == (LL_ADC_FLAG_JEOS_MST)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC group injected end of sequence conversions of the ADC slave.
  * @rmtoll CSR      JEOS_SLV       LL_ADC_IsActiveFlag_SLV_JEOS
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_JEOS(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_JEOS_SLV) == (LL_ADC_FLAG_JEOS_SLV)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC group injected context queue overflow of the ADC master.
  * @rmtoll CSR      JQOVF_MST      LL_ADC_IsActiveFlag_MST_JQOVF
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_JQOVF(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_JQOVF_MST) == (LL_ADC_FLAG_JQOVF_MST)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC group injected context queue overflow of the ADC slave.
  * @rmtoll CSR      JQOVF_SLV      LL_ADC_IsActiveFlag_SLV_JQOVF
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_JQOVF(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_JQOVF_SLV) == (LL_ADC_FLAG_JQOVF_SLV)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC analog watchdog 1 of the ADC master.
  * @rmtoll CSR      AWD1_MST       LL_ADC_IsActiveFlag_MST_AWD1
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_AWD1(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_AWD1_MST) == (LL_ADC_FLAG_AWD1_MST)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode analog watchdog 1 of the ADC slave.
  * @rmtoll CSR      AWD1_SLV       LL_ADC_IsActiveFlag_SLV_AWD1
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_AWD1(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_AWD1_SLV) == (LL_ADC_FLAG_AWD1_SLV)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC analog watchdog 2 of the ADC master.
  * @rmtoll CSR      AWD2_MST       LL_ADC_IsActiveFlag_MST_AWD2
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_AWD2(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_AWD2_MST) == (LL_ADC_FLAG_AWD2_MST)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC analog watchdog 2 of the ADC slave.
  * @rmtoll CSR      AWD2_SLV       LL_ADC_IsActiveFlag_SLV_AWD2
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_AWD2(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_AWD2_SLV) == (LL_ADC_FLAG_AWD2_SLV)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC analog watchdog 3 of the ADC master.
  * @rmtoll CSR      AWD3_MST       LL_ADC_IsActiveFlag_MST_AWD3
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_MST_AWD3(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_AWD3_MST) == (LL_ADC_FLAG_AWD3_MST)) ? 1UL : 0UL);
}

/**
  * @brief  Get flag multimode ADC analog watchdog 3 of the ADC slave.
  * @rmtoll CSR      AWD3_SLV       LL_ADC_IsActiveFlag_SLV_AWD3
  * @param  ADCxy_COMMON ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsActiveFlag_SLV_AWD3(const ADC_Common_TypeDef *ADCxy_COMMON)
{
  return ((READ_BIT(ADCxy_COMMON->CSR, LL_ADC_FLAG_AWD3_SLV) == (LL_ADC_FLAG_AWD3_SLV)) ? 1UL : 0UL);
}


/**
  * @}
  */

/** @defgroup ADC_LL_EF_IT_Management ADC IT management
  * @{
  */

/**
  * @brief  Enable ADC ready.
  * @rmtoll IER      ADRDYIE        LL_ADC_EnableIT_ADRDY
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_ADRDY(ADC_TypeDef *ADCx)
{
  SET_BIT(ADCx->IER, LL_ADC_IT_ADRDY);
}

/**
  * @brief  Enable interruption ADC group regular end of unitary conversion.
  * @rmtoll IER      EOCIE          LL_ADC_EnableIT_EOC
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_EOC(ADC_TypeDef *ADCx)
{
  SET_BIT(ADCx->IER, LL_ADC_IT_EOC);
}

/**
  * @brief  Enable interruption ADC group regular end of sequence conversions.
  * @rmtoll IER      EOSIE          LL_ADC_EnableIT_EOS
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_EOS(ADC_TypeDef *ADCx)
{
  SET_BIT(ADCx->IER, LL_ADC_IT_EOS);
}

/**
  * @brief  Enable ADC group regular interruption overrun.
  * @rmtoll IER      OVRIE          LL_ADC_EnableIT_OVR
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_OVR(ADC_TypeDef *ADCx)
{
  SET_BIT(ADCx->IER, LL_ADC_IT_OVR);
}

/**
  * @brief  Enable interruption ADC group regular end of sampling.
  * @rmtoll IER      EOSMPIE        LL_ADC_EnableIT_EOSMP
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_EOSMP(ADC_TypeDef *ADCx)
{
  SET_BIT(ADCx->IER, LL_ADC_IT_EOSMP);
}

/**
  * @brief  Enable interruption ADC group injected end of unitary conversion.
  * @rmtoll IER      JEOCIE         LL_ADC_EnableIT_JEOC
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_JEOC(ADC_TypeDef *ADCx)
{
  SET_BIT(ADCx->IER, LL_ADC_IT_JEOC);
}

/**
  * @brief  Enable interruption ADC group injected end of sequence conversions.
  * @rmtoll IER      JEOSIE         LL_ADC_EnableIT_JEOS
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_JEOS(ADC_TypeDef *ADCx)
{
  SET_BIT(ADCx->IER, LL_ADC_IT_JEOS);
}

/**
  * @brief  Enable interruption ADC group injected context queue overflow.
  * @rmtoll IER      JQOVFIE        LL_ADC_EnableIT_JQOVF
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_JQOVF(ADC_TypeDef *ADCx)
{
  SET_BIT(ADCx->IER, LL_ADC_IT_JQOVF);
}

/**
  * @brief  Enable interruption ADC analog watchdog 1.
  * @rmtoll IER      AWD1IE         LL_ADC_EnableIT_AWD1
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_AWD1(ADC_TypeDef *ADCx)
{
  SET_BIT(ADCx->IER, LL_ADC_IT_AWD1);
}

/**
  * @brief  Enable interruption ADC analog watchdog 2.
  * @rmtoll IER      AWD2IE         LL_ADC_EnableIT_AWD2
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_AWD2(ADC_TypeDef *ADCx)
{
  SET_BIT(ADCx->IER, LL_ADC_IT_AWD2);
}

/**
  * @brief  Enable interruption ADC analog watchdog 3.
  * @rmtoll IER      AWD3IE         LL_ADC_EnableIT_AWD3
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_AWD3(ADC_TypeDef *ADCx)
{
  SET_BIT(ADCx->IER, LL_ADC_IT_AWD3);
}

/**
  * @brief  Disable interruption ADC ready.
  * @rmtoll IER      ADRDYIE        LL_ADC_DisableIT_ADRDY
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_ADRDY(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_ADRDY);
}

/**
  * @brief  Disable interruption ADC group regular end of unitary conversion.
  * @rmtoll IER      EOCIE          LL_ADC_DisableIT_EOC
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_EOC(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOC);
}

/**
  * @brief  Disable interruption ADC group regular end of sequence conversions.
  * @rmtoll IER      EOSIE          LL_ADC_DisableIT_EOS
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_EOS(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOS);
}

/**
  * @brief  Disable interruption ADC group regular overrun.
  * @rmtoll IER      OVRIE          LL_ADC_DisableIT_OVR
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_OVR(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_OVR);
}

/**
  * @brief  Disable interruption ADC group regular end of sampling.
  * @rmtoll IER      EOSMPIE        LL_ADC_DisableIT_EOSMP
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_EOSMP(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOSMP);
}

/**
  * @brief  Disable interruption ADC group regular end of unitary conversion.
  * @rmtoll IER      JEOCIE         LL_ADC_DisableIT_JEOC
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_JEOC(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOC);
}

/**
  * @brief  Disable interruption ADC group injected end of sequence conversions.
  * @rmtoll IER      JEOSIE         LL_ADC_DisableIT_JEOS
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_JEOS(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOS);
}

/**
  * @brief  Disable interruption ADC group injected context queue overflow.
  * @rmtoll IER      JQOVFIE        LL_ADC_DisableIT_JQOVF
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_JQOVF(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JQOVF);
}

/**
  * @brief  Disable interruption ADC analog watchdog 1.
  * @rmtoll IER      AWD1IE         LL_ADC_DisableIT_AWD1
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_AWD1(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD1);
}

/**
  * @brief  Disable interruption ADC analog watchdog 2.
  * @rmtoll IER      AWD2IE         LL_ADC_DisableIT_AWD2
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_AWD2(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD2);
}

/**
  * @brief  Disable interruption ADC analog watchdog 3.
  * @rmtoll IER      AWD3IE         LL_ADC_DisableIT_AWD3
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_AWD3(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD3);
}

/**
  * @brief  Get state of interruption ADC ready
  *         (0: interrupt disabled, 1: interrupt enabled).
  * @rmtoll IER      ADRDYIE        LL_ADC_IsEnabledIT_ADRDY
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_ADRDY(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->IER, LL_ADC_IT_ADRDY) == (LL_ADC_IT_ADRDY)) ? 1UL : 0UL);
}

/**
  * @brief  Get state of interruption ADC group regular end of unitary conversion
  *         (0: interrupt disabled, 1: interrupt enabled).
  * @rmtoll IER      EOCIE          LL_ADC_IsEnabledIT_EOC
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_EOC(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->IER, LL_ADC_IT_EOC) == (LL_ADC_IT_EOC)) ? 1UL : 0UL);
}

/**
  * @brief  Get state of interruption ADC group regular end of sequence conversions
  *         (0: interrupt disabled, 1: interrupt enabled).
  * @rmtoll IER      EOSIE          LL_ADC_IsEnabledIT_EOS
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_EOS(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->IER, LL_ADC_IT_EOS) == (LL_ADC_IT_EOS)) ? 1UL : 0UL);
}

/**
  * @brief  Get state of interruption ADC group regular overrun
  *         (0: interrupt disabled, 1: interrupt enabled).
  * @rmtoll IER      OVRIE          LL_ADC_IsEnabledIT_OVR
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_OVR(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->IER, LL_ADC_IT_OVR) == (LL_ADC_IT_OVR)) ? 1UL : 0UL);
}

/**
  * @brief  Get state of interruption ADC group regular end of sampling
  *         (0: interrupt disabled, 1: interrupt enabled).
  * @rmtoll IER      EOSMPIE        LL_ADC_IsEnabledIT_EOSMP
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_EOSMP(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->IER, LL_ADC_IT_EOSMP) == (LL_ADC_IT_EOSMP)) ? 1UL : 0UL);
}

/**
  * @brief  Get state of interruption ADC group injected end of unitary conversion
  *         (0: interrupt disabled, 1: interrupt enabled).
  * @rmtoll IER      JEOCIE         LL_ADC_IsEnabledIT_JEOC
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_JEOC(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->IER, LL_ADC_IT_JEOC) == (LL_ADC_IT_JEOC)) ? 1UL : 0UL);
}

/**
  * @brief  Get state of interruption ADC group injected end of sequence conversions
  *         (0: interrupt disabled, 1: interrupt enabled).
  * @rmtoll IER      JEOSIE         LL_ADC_IsEnabledIT_JEOS
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_JEOS(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->IER, LL_ADC_IT_JEOS) == (LL_ADC_IT_JEOS)) ? 1UL : 0UL);
}

/**
  * @brief  Get state of interruption ADC group injected context queue overflow interrupt state
  *         (0: interrupt disabled, 1: interrupt enabled).
  * @rmtoll IER      JQOVFIE        LL_ADC_IsEnabledIT_JQOVF
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_JQOVF(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->IER, LL_ADC_IT_JQOVF) == (LL_ADC_IT_JQOVF)) ? 1UL : 0UL);
}

/**
  * @brief  Get state of interruption ADC analog watchdog 1
  *         (0: interrupt disabled, 1: interrupt enabled).
  * @rmtoll IER      AWD1IE         LL_ADC_IsEnabledIT_AWD1
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_AWD1(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->IER, LL_ADC_IT_AWD1) == (LL_ADC_IT_AWD1)) ? 1UL : 0UL);
}

/**
  * @brief  Get state of interruption Get ADC analog watchdog 2
  *         (0: interrupt disabled, 1: interrupt enabled).
  * @rmtoll IER      AWD2IE         LL_ADC_IsEnabledIT_AWD2
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_AWD2(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->IER, LL_ADC_IT_AWD2) == (LL_ADC_IT_AWD2)) ? 1UL : 0UL);
}

/**
  * @brief  Get state of interruption Get ADC analog watchdog 3
  *         (0: interrupt disabled, 1: interrupt enabled).
  * @rmtoll IER      AWD3IE         LL_ADC_IsEnabledIT_AWD3
  * @param  ADCx ADC instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabledIT_AWD3(const ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->IER, LL_ADC_IT_AWD3) == (LL_ADC_IT_AWD3)) ? 1UL : 0UL);
}

/**
  * @}
  */

# 9185 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_ll_adc.h"

/**
  * @}
  */

/**
  * @}
  */



/**
  * @}
  */





# 32 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc.h" 2

/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup ADC
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/** @defgroup ADC_Exported_Types ADC Exported Types
  * @{
  */

/**
  * @brief  ADC group regular oversampling structure definition
  */
typedef struct
{
  uint32_t Ratio;                         /*!< Configures the oversampling ratio.
                                               This parameter can be a value of @ref ADC_HAL_EC_OVS_RATIO */

  uint32_t RightBitShift;                 /*!< Configures the division coefficient for the Oversampler.
                                               This parameter can be a value of @ref ADC_HAL_EC_OVS_SHIFT */

  uint32_t TriggeredMode;                 /*!< Selects the regular triggered oversampling mode.
                                               This parameter can be a value of @ref ADC_HAL_EC_OVS_DISCONT_MODE */

  uint32_t OversamplingStopReset;         /*!< Selects the regular oversampling mode.
                                               The oversampling is either temporary stopped or reset upon an injected
                                               sequence interruption.
                                               If oversampling is enabled on both regular and injected groups, this
                                               parameter is discarded and forced to setting
                                               "ADC_REGOVERSAMPLING_RESUMED_MODE" (the oversampling buffer is zeroed
                                               during injection sequence).
                                               This parameter can be a value of @ref ADC_HAL_EC_OVS_SCOPE_REG */

} ADC_OversamplingTypeDef;

/**
  * @brief  Structure definition of ADC instance and ADC group regular.
  * @note   Parameters of this structure are shared within 2 scopes:
  *          - Scope entire ADC (affects ADC groups regular and injected): ClockPrescaler, Resolution, DataAlign,
  *            GainCompensation, ScanConvMode, EOCSelection, LowPowerAutoWait.
  *          - Scope ADC group regular: ContinuousConvMode, NbrOfConversion, DiscontinuousConvMode, NbrOfDiscConversion,
  *            ExternalTrigConv, ExternalTrigConvEdge, DMAContinuousRequests, Overrun, OversamplingMode, Oversampling,
  *            SamplingMode.
  * @note   The setting of these parameters by function HAL_ADC_Init() is conditioned to ADC state.
  *         ADC state can be either:
  *          - For all parameters: ADC disabled
  *          - For all parameters except 'LowPowerAutoWait', 'DMAContinuousRequests' and 'Oversampling': ADC enabled
  *            without conversion on going on group regular.
  *          - For parameters 'LowPowerAutoWait' and 'DMAContinuousRequests': ADC enabled without conversion on going
  *            on groups regular and injected.
  *         If ADC is not in the appropriate state to modify some parameters, these parameters setting is bypassed
  *         without error reporting (as it can be the expected behavior in case of intended action to update another
  *         parameter (which fulfills the ADC state condition) on the fly).
  */
typedef struct
{
  uint32_t ClockPrescaler;        /*!< Select ADC clock source (synchronous clock derived from APB clock or asynchronous
                                       clock derived from system clock or PLL (Refer to reference manual for list of
                                       clocks available)) and clock prescaler.
                                       This parameter can be a value of @ref ADC_HAL_EC_COMMON_CLOCK_SOURCE.
                                       Note: The ADC clock configuration is common to all ADC instances.
                                       Note: In case of usage of channels on injected group, ADC frequency should be
                                             lower than AHB clock frequency /4 for resolution 12 or 10 bits,
                                                        AHB clock frequency /3 for resolution 8 bits,
                                                        AHB clock frequency /2 for resolution 6 bits.
                                       Note: In case of synchronous clock mode based on HCLK/1, the configuration must
                                             be enabled only if the system clock has a 50% duty clock cycle (APB
                                             prescaler configured inside RCC  must be bypassed and PCLK clock must have
                                             50% duty cycle). Refer to reference manual for details.
                                       Note: In case of usage of asynchronous clock, the selected clock must be
                                             preliminarily enabled at RCC top level.
                                       Note: This parameter can be modified only if all ADC instances are disabled. */

  uint32_t Resolution;            /*!< Configure the ADC resolution.
                                       This parameter can be a value of @ref ADC_HAL_EC_RESOLUTION */

  uint32_t DataAlign;             /*!< Specify ADC data alignment in conversion data register (right or left).
                                       Refer to reference manual for alignments formats versus resolutions.
                                       This parameter can be a value of @ref ADC_HAL_EC_DATA_ALIGN */

  uint32_t GainCompensation;      /*!< Specify the ADC gain compensation coefficient to be applied to ADC raw conversion
                                       data, based on following formula:
                                         DATA = DATA(raw) * (gain compensation coef) / 4096
                                       "2.12" bit format, unsigned: 2 bits exponents / 12 bits mantissa
                                       Gain step is 1/4096 = 0.000244
                                       Gain range is 0.0000 to 3.999756
                                       This parameter value can be
                                        0           Gain compensation will be disabled and coefficient set to 0
                                        1 -> 0x3FFF Gain compensation will be enabled and coefficient set to specified
                                                    value
                                       Note: Gain compensation when enabled is applied to all channels. */

  uint32_t ScanConvMode;          /*!< Configure the sequencer of ADC groups regular and injected.
                                       This parameter can be associated to parameter 'DiscontinuousConvMode' to have
                                       main sequence subdivided in successive parts.
                                       If disabled: Conversion is performed in single mode (one channel converted, the
                                                    one defined in rank 1). Parameters 'NbrOfConversion' and
                                                    'InjectedNbrOfConversion' are discarded (equivalent to set to 1).
                                       If enabled:  Conversions are performed in sequence mode (multiple ranks defined
                                                    by 'NbrOfConversion' or 'InjectedNbrOfConversion' and rank of each
                                                    channel in sequencer). Scan direction is upward: from rank 1 to
                                                    rank 'n'.
                                       This parameter can be a value of @ref ADC_Scan_mode */

  uint32_t EOCSelection;          /*!< Specify which EOC (End Of Conversion) flag is used for conversion by polling and
                                       interruption: end of unitary conversion or end of sequence conversions.
                                       This parameter can be a value of @ref ADC_EOCSelection. */

  FunctionalState LowPowerAutoWait; /*!< Select the dynamic low power Auto Delay: new conversion start only when the
                                       previous conversion (for ADC group regular) or previous sequence (for ADC group
                                       injected) has been retrieved by user software, using function HAL_ADC_GetValue()
                                       or HAL_ADCEx_InjectedGetValue().
                                       This feature automatically adapts the frequency of ADC conversions triggers to
                                       the speed of the system that reads the data. Moreover, this avoids risk of
                                       overrun for low frequency applications.
                                       This parameter can be set to ENABLE or DISABLE.
                                       Note: It is not recommended to use with interruption or DMA (HAL_ADC_Start_IT(),
                                             HAL_ADC_Start_DMA()) since these modes have to clear immediately the EOC
                                             flag (by CPU to free the IRQ pending event or by DMA).
                                             Auto wait will work but fort a very short time, discarding its intended
                                             benefit (except specific case of high load of CPU or DMA transfers which
                                             can justify usage of auto wait).
                                             Do use with polling: 1. Start conversion with HAL_ADC_Start(), 2. Later on,
                                             when ADC conversion data is needed:
                                             use HAL_ADC_PollForConversion() to ensure that conversion is completed and
                                             HAL_ADC_GetValue() to retrieve conversion result and trig another
                                             conversion start. (in case of usage of ADC group injected, use the
                                             equivalent functions HAL_ADCExInjected_Start(),
                                             HAL_ADCEx_InjectedGetValue(), ...). */

  FunctionalState ContinuousConvMode; /*!< Specify whether the conversion is performed in single mode (one conversion)
                                           or continuous mode for ADC group regular, after the first ADC conversion
                                           start trigger occurred (software start or external trigger). This parameter
                                           can be set to ENABLE or DISABLE. */

  uint32_t NbrOfConversion;       /*!< Specify the number of ranks that will be converted within the regular group
                                       sequencer.
                                       This parameter is dependent on ScanConvMode:
                                        - sequencer configured to fully configurable:
                                          Number of ranks in the scan sequence is configurable using this parameter.
                                          Note: After the first call of 'HAL_ADC_Init()', each rank corresponding to
                                                parameter "NbrOfConversion" must be set using 'HAL_ADC_ConfigChannel()'.
                                                Afterwards, when all needed sequencer ranks are set, parameter
                                                'NbrOfConversion' can be updated without modifying configuration of
                                                sequencer ranks (sequencer ranks above 'NbrOfConversion' are discarded).
                                        - sequencer configured to not fully configurable:
                                          Number of ranks in the scan sequence is defined by number of channels set in
                                          the sequence. This parameter is discarded.
                                       This parameter must be a number between Min_Data = 1 and Max_Data = 8.
                                       Note: This parameter must be modified when no conversion is on going on regular
                                             group (ADC disabled, or ADC enabled without continuous mode or external
                                             trigger that could launch a conversion). */

  FunctionalState DiscontinuousConvMode; /*!< Specify whether the conversions sequence of ADC group regular is performed
                                              in Complete-sequence/Discontinuous-sequence (main sequence subdivided in
                                              successive parts).
                                              Discontinuous mode is used only if sequencer is enabled (parameter
                                              'ScanConvMode'). If sequencer is disabled, this parameter is discarded.
                                              Discontinuous mode can be enabled only if continuous mode is disabled.
                                              If continuous mode is enabled, this parameter setting is discarded.
                                              This parameter can be set to ENABLE or DISABLE.
                                              Note: On this STM32 series, ADC group regular number of discontinuous
                                                    ranks increment is fixed to one-by-one. */

  uint32_t NbrOfDiscConversion;   /*!< Specifies the number of discontinuous conversions in which the main sequence
                                       of ADC group regular (parameter NbrOfConversion) will be subdivided.
                                       If parameter 'DiscontinuousConvMode' is disabled, this parameter is discarded.
                                       This parameter must be a number between Min_Data = 1 and Max_Data = 8. */

  uint32_t ExternalTrigConv;      /*!< Select the external event source used to trigger ADC group regular conversion
                                       start.
                                       If set to ADC_SOFTWARE_START, external triggers are disabled and software trigger
                                       is used instead.
                                       This parameter can be a value of @ref ADC_regular_external_trigger_source.
                                       Caution: external trigger source is common to all ADC instances. */

  uint32_t ExternalTrigConvEdge;  /*!< Select the external event edge used to trigger ADC group regular conversion start
                                       If trigger source is set to ADC_SOFTWARE_START, this parameter is discarded.
                                       This parameter can be a value of @ref ADC_regular_external_trigger_edge */

  uint32_t SamplingMode;          /*!< Select the sampling mode to be used for ADC group regular conversion.
                                       This parameter can be a value of @ref ADC_regular_sampling_mode */

  FunctionalState DMAContinuousRequests; /*!< Specify whether the DMA requests are performed in one shot mode (DMA
                                              transfer stops when number of conversions is reached) or in continuous
                                              mode (DMA transfer unlimited, whatever number of conversions).
                                              This parameter can be set to ENABLE or DISABLE.
                                              Note: In continuous mode, DMA must be configured in circular mode.
                                                    Otherwise an overrun will be triggered when DMA buffer maximum
                                                    pointer is reached. */

  uint32_t Overrun;               /*!< Select the behavior in case of overrun: data overwritten or preserved (default).
                                       This parameter applies to ADC group regular only.
                                       This parameter can be a value of @ref ADC_HAL_EC_REG_OVR_DATA_BEHAVIOR.
                                       Note: In case of overrun set to data preserved and usage with programming model
                                             with interruption (HAL_Start_IT()): ADC IRQ handler has to clear end of
                                             conversion flags, this induces the release of the preserved data. If
                                             needed, this data can be saved in function HAL_ADC_ConvCpltCallback(),
                                             placed in user program code (called before end of conversion flags clear)
                                       Note: Error reporting with respect to the conversion mode:
                                             - Usage with ADC conversion by polling for event or interruption: Error is
                                               reported only if overrun is set to data preserved. If overrun is set to
                                               data overwritten, user can willingly not read all the converted data,
                                               this is not considered as an erroneous case.
                                             - Usage with ADC conversion by DMA: Error is reported whatever overrun
                                               setting (DMA is expected to process all data from data register). */

  FunctionalState OversamplingMode;       /*!< Specify whether the oversampling feature is enabled or disabled.
                                               This parameter can be set to ENABLE or DISABLE.
                                               Note: This parameter can be modified only if there is no conversion is
                                                     ongoing on ADC groups regular and injected */

  ADC_OversamplingTypeDef Oversampling;   /*!< Specify the Oversampling parameters.
                                               Caution: this setting overwrites the previous oversampling configuration
                                                        if oversampling is already enabled. */

} ADC_InitTypeDef;

/**
  * @brief  Structure definition of ADC channel for regular group
  * @note   The setting of these parameters by function HAL_ADC_ConfigChannel() is conditioned to ADC state.
  *         ADC state can be either:
  *          - For all parameters: ADC disabled (this is the only possible ADC state to modify parameter 'SingleDiff')
  *          - For all except parameters 'SamplingTime', 'Offset', 'OffsetNumber': ADC enabled without conversion
  *            on going on regular group.
  *          - For parameters 'SamplingTime', 'Offset', 'OffsetNumber': ADC enabled without conversion on going on
  *            regular and injected groups.
  *         If ADC is not in the appropriate state to modify some parameters, these parameters setting is bypassed
  *         without error reporting (as it can be the expected behavior in case of intended action to update another
  *         parameter (which fulfills the ADC state condition) on the fly).
  */
typedef struct
{
  uint32_t Channel;                /*!< Specify the channel to configure into ADC regular group.
                                        This parameter can be a value of @ref ADC_HAL_EC_CHANNEL
                                        Note: Depending on devices and ADC instances, some channels may not be available
                                              on device package pins. Refer to device datasheet for channels
                                              availability. */

  uint32_t Rank;                   /*!< Specify the rank in the regular group sequencer.
                                        This parameter can be a value of @ref ADC_HAL_EC_REG_SEQ_RANKS
                                        Note: to disable a channel or change order of conversion sequencer, rank
                                        containing a previous channel setting can be overwritten by the new channel
                                        setting (or parameter number of conversions adjusted) */

  uint32_t SamplingTime;           /*!< Sampling time value to be set for the selected channel.
                                        Unit: ADC clock cycles
                                        Conversion time is the addition of sampling time and processing time
                                        (12.5 ADC clock cycles at ADC resolution 12 bits, 10.5 cycles at 10 bits,
                                        8.5 cycles at 8 bits, 6.5 cycles at 6 bits).
                                        This parameter can be a value of @ref ADC_HAL_EC_CHANNEL_SAMPLINGTIME
                                        Caution: This parameter applies to a channel that can be used into regular
                                                 and/or injected group. It overwrites the last setting.
                                        Note: In case of usage of internal measurement channels (VrefInt, Vbat, ...),
                                              sampling time constraints must be respected (sampling time can be adjusted
                                              in function of ADC clock frequency and sampling time setting).
                                              Refer to device datasheet for timings values. */

  uint32_t SingleDiff;             /*!< Select single-ended or differential input.
                                        In differential mode: Differential measurement is carried out between the
                                        selected channel 'i' (positive input) and channel 'i+1' (negative input).
                                        Only channel 'i' has to be configured, channel 'i+1' is configured automatically
                                        This parameter must be a value of @ref ADC_HAL_EC_CHANNEL_SINGLE_DIFF_ENDING
                                        Caution: This parameter applies to a channel that can be used in a regular
                                                 and/or injected group.
                                                 It overwrites the last setting.
                                        Note: Refer to Reference Manual to ensure the selected channel is available in
                                              differential mode.
                                        Note: When configuring a channel 'i' in differential mode, the channel 'i+1' is
                                              not usable separately.
                                        Note: This parameter must be modified when ADC is disabled (before ADC start
                                              conversion or after ADC stop conversion).
                                              If ADC is enabled, this parameter setting is bypassed without error
                                              reporting (as it can be the expected behavior in case of another parameter
                                              update on the fly) */

  uint32_t OffsetNumber;           /*!< Select the offset number
                                        This parameter can be a value of @ref ADC_HAL_EC_OFFSET_NB
                                        Caution: Only one offset is allowed per channel. This parameter overwrites the
                                                 last setting. */

  uint32_t Offset;                 /*!< Define the offset to be applied on the raw converted data.
                                        Offset value must be a positive number.
                                        Depending of ADC resolution selected (12, 10, 8 or 6 bits), this parameter
                                        must be a number between Min_Data = 0x000 and Max_Data = 0xFFF,
                                        0x3FF, 0xFF or 0x3F respectively.
                                        Note: This parameter must be modified when no conversion is on going on both
                                              regular and injected groups (ADC disabled, or ADC enabled without
                                              continuous mode or external trigger that could launch a conversion). */

  uint32_t OffsetSign;                /*!< Define if the offset should be subtracted (negative sign) or added (positive
                                            sign) from or to the raw converted data.
                                            This parameter can be a value of @ref ADCEx_OffsetSign.
                                            Note: This parameter must be modified when no conversion is on going on both
                                                  regular and injected groups (ADC disabled, or ADC enabled without
                                                  continuous mode or external trigger that could launch a conversion).*/
  FunctionalState OffsetSaturation;   /*!< Define if the offset should be saturated upon under or over flow.
                                        This parameter value can be ENABLE or DISABLE.
                                        Note: This parameter must be modified when no conversion is on going on both
                                              regular and injected groups (ADC disabled, or ADC enabled without
                                              continuous mode or external trigger that could launch a conversion). */

} ADC_ChannelConfTypeDef;

/**
  * @brief  Structure definition of ADC analog watchdog
  * @note   The setting of these parameters by function HAL_ADC_AnalogWDGConfig() is conditioned to ADC state.
  *         ADC state can be either:
  *          - For all parameters except 'HighThreshold', 'LowThreshold': ADC disabled or ADC enabled without conversion
               on going on ADC groups regular and injected.
  *          - For parameters 'HighThreshold', 'LowThreshold': ADC enabled with conversion on going on regular and
               injected groups.
  */
typedef struct
{
  uint32_t WatchdogNumber;    /*!< Select which ADC analog watchdog is monitoring the selected channel.
                                   For Analog Watchdog 1: Only 1 channel can be monitored (or overall group of channels
                                                          by setting parameter 'WatchdogMode')
                                   For Analog Watchdog 2 and 3: Several channels can be monitored (by successive calls
                                                                of 'HAL_ADC_AnalogWDGConfig()' for each channel)
                                   This parameter can be a value of @ref ADC_HAL_EC_AWD_NUMBER. */

  uint32_t WatchdogMode;      /*!< Configure the ADC analog watchdog mode: single/all/none channels.
                                   For Analog Watchdog 1: Configure the ADC analog watchdog mode: single channel or all
                                                          channels, ADC groups regular and-or injected.
                                   For Analog Watchdog 2 and 3: Several channels can be monitored by applying
                                                                successively the AWD init structure. Channels on ADC
                                                                group regular and injected are not differentiated: Set
                                                                value 'ADC_ANALOGWATCHDOG_SINGLE_xxx' to monitor 1
                                                                channel, value 'ADC_ANALOGWATCHDOG_ALL_xxx' to monitor
                                                                all channels, 'ADC_ANALOGWATCHDOG_NONE' to monitor no
                                                                channel.
                                   This parameter can be a value of @ref ADC_analog_watchdog_mode. */

  uint32_t Channel;           /*!< Select which ADC channel to monitor by analog watchdog.
                                   For Analog Watchdog 1: this parameter has an effect only if parameter 'WatchdogMode'
                                                          is configured on single channel (only 1 channel can be
                                                          monitored).
                                   For Analog Watchdog 2 and 3: Several channels can be monitored. To use this feature,
                                                                call successively the function HAL_ADC_AnalogWDGConfig()
                                                                for each channel to be added (or removed with value
                                                                'ADC_ANALOGWATCHDOG_NONE').
                                   This parameter can be a value of @ref ADC_HAL_EC_CHANNEL. */

  FunctionalState ITMode;     /*!< Specify whether the analog watchdog is configured in interrupt or polling mode.
                                   This parameter can be set to ENABLE or DISABLE */

  uint32_t HighThreshold;     /*!< Configure the ADC analog watchdog High threshold value.
                                   Depending of ADC resolution selected (12, 10, 8 or 6 bits), this parameter must be a
                                   number between Min_Data = 0x000 and Max_Data = 0xFFF, 0x3FF, 0xFF or 0x3F
                                   respectively.
                                   Note: Analog watchdog 2 and 3 are limited to a resolution of 8 bits: if ADC
                                         resolution is 12 bits the 4 LSB are ignored, if ADC resolution is 10 bits the 2
                                         LSB are ignored.
                                   Note: If ADC oversampling is enabled, ADC analog watchdog thresholds are
                                         impacted: the comparison of analog watchdog thresholds is done on
                                         oversampling final computation (after ratio and shift application):
                                         ADC data register bitfield [15:4] (12 most significant bits). */

  uint32_t LowThreshold;      /*!< Configures the ADC analog watchdog Low threshold value.
                                   Depending of ADC resolution selected (12, 10, 8 or 6 bits), this parameter must be a
                                   number between Min_Data = 0x000 and Max_Data = 0xFFF, 0x3FF, 0xFF or 0x3F
                                   respectively.
                                   Note: Analog watchdog 2 and 3 are limited to a resolution of 8 bits: if ADC
                                         resolution is 12 bits the 4 LSB are ignored, if ADC resolution is 10 bits the 2
                                         LSB are ignored.
                                   Note: If ADC oversampling is enabled, ADC analog watchdog thresholds are
                                         impacted: the comparison of analog watchdog thresholds is done on
                                         oversampling final computation (after ratio and shift application):
                                         ADC data register bitfield [15:4] (12 most significant bits).*/

  uint32_t FilteringConfig;   /*!< Specify whether filtering should be use and the number of samples to consider.
                                   Before setting flag or raising interrupt, analog watchdog can wait to have several
                                   consecutive out-of-window samples. This parameter allows to configure this number.
                                   This parameter only applies to Analog watchdog 1. For others, use value
                                   ADC_AWD_FILTERING_NONE.
                                   This parameter can be a value of @ref ADC_analog_watchdog_filtering_config. */
} ADC_AnalogWDGConfTypeDef;

/**
  * @brief  ADC group injected contexts queue configuration
  * @note   Structure intended to be used only through structure "ADC_HandleTypeDef"
  */
typedef struct
{
  uint32_t ContextQueue;                 /*!< Injected channel configuration context: build-up over each
                                              HAL_ADCEx_InjectedConfigChannel() call to finally initialize
                                              JSQR register at HAL_ADCEx_InjectedConfigChannel() last call */

  uint32_t ChannelCount;                 /*!< Number of channels in the injected sequence */
} ADC_InjectionConfigTypeDef;

/** @defgroup ADC_States ADC States
  * @{
  */

/**
  * @brief  HAL ADC state machine: ADC states definition (bitfields)
  * @note   ADC state machine is managed by bitfields, state must be compared
  *         with bit by bit.
  *         For example:
  *           " if ((HAL_ADC_GetState(hadc1) & HAL_ADC_STATE_REG_BUSY) != 0UL) "
  *           " if ((HAL_ADC_GetState(hadc1) & HAL_ADC_STATE_AWD1) != 0UL) "
  */
/* States of ADC global scope */
#define HAL_ADC_STATE_RESET (0x00000000UL)
#define HAL_ADC_STATE_READY (0x00000001UL)
#define HAL_ADC_STATE_BUSY_INTERNAL (0x00000002UL)

#define HAL_ADC_STATE_TIMEOUT (0x00000004UL)

/* States of ADC errors */
#define HAL_ADC_STATE_ERROR_INTERNAL (0x00000010UL)
#define HAL_ADC_STATE_ERROR_CONFIG (0x00000020UL)
#define HAL_ADC_STATE_ERROR_DMA (0x00000040UL)

/* States of ADC group regular */
#define HAL_ADC_STATE_REG_BUSY (0x00000100UL)



#define HAL_ADC_STATE_REG_EOC (0x00000200UL)
#define HAL_ADC_STATE_REG_OVR (0x00000400UL)
#define HAL_ADC_STATE_REG_EOSMP (0x00000800UL)


/* States of ADC group injected */
#define HAL_ADC_STATE_INJ_BUSY (0x00001000UL)



#define HAL_ADC_STATE_INJ_EOC (0x00002000UL)
#define HAL_ADC_STATE_INJ_JQOVF (0x00004000UL)

/* States of ADC analog watchdogs */
#define HAL_ADC_STATE_AWD1 (0x00010000UL)
#define HAL_ADC_STATE_AWD2 (0x00020000UL)
#define HAL_ADC_STATE_AWD3 (0x00040000UL)

/* States of ADC multi-mode */
#define HAL_ADC_STATE_MULTIMODE_SLAVE (0x00100000UL)


/**
  * @}
  */

/**
  * @brief  ADC handle Structure definition
  */



typedef struct

{
  ADC_TypeDef                   *Instance;                     /*!< Register base address */
  ADC_InitTypeDef               Init;                          /*!< ADC initialization parameters and regular
                                                                    conversions setting */
  DMA_HandleTypeDef             *DMA_Handle;                   /*!< Pointer DMA Handler */
  HAL_LockTypeDef               Lock;                          /*!< ADC locking object */
  __IO uint32_t                 State;                         /*!< ADC communication state (bitmap of ADC states) */
  __IO uint32_t                 ErrorCode;                     /*!< ADC Error code */
  ADC_InjectionConfigTypeDef    InjectionConfig ;              /*!< ADC injected channel configuration build-up
                                                                  structure */
# 517 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc.h"
} ADC_HandleTypeDef;

# 544 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc.h"

/**
  * @}
  */


/* Exported constants --------------------------------------------------------*/

/** @defgroup ADC_Exported_Constants ADC Exported Constants
  * @{
  */

/** @defgroup ADC_Error_Code ADC Error Code
  * @{
  */
#define HAL_ADC_ERROR_NONE (0x00U)
#define HAL_ADC_ERROR_INTERNAL (0x01U)

#define HAL_ADC_ERROR_OVR (0x02U)
#define HAL_ADC_ERROR_DMA (0x04U)
#define HAL_ADC_ERROR_JQOVF (0x08U)



/**
  * @}
  */

/** @defgroup ADC_HAL_EC_COMMON_CLOCK_SOURCE  ADC common - Clock source
  * @{
  */

#define ADC_CLOCK_SYNC_PCLK_DIV1 (LL_ADC_CLOCK_SYNC_PCLK_DIV1)

#define ADC_CLOCK_SYNC_PCLK_DIV2 (LL_ADC_CLOCK_SYNC_PCLK_DIV2)

#define ADC_CLOCK_SYNC_PCLK_DIV4 (LL_ADC_CLOCK_SYNC_PCLK_DIV4)

#define ADC_CLOCK_ASYNC_DIV1 (LL_ADC_CLOCK_ASYNC_DIV1)

#define ADC_CLOCK_ASYNC_DIV2 (LL_ADC_CLOCK_ASYNC_DIV2)

#define ADC_CLOCK_ASYNC_DIV4 (LL_ADC_CLOCK_ASYNC_DIV4)

#define ADC_CLOCK_ASYNC_DIV6 (LL_ADC_CLOCK_ASYNC_DIV6)

#define ADC_CLOCK_ASYNC_DIV8 (LL_ADC_CLOCK_ASYNC_DIV8)

#define ADC_CLOCK_ASYNC_DIV10 (LL_ADC_CLOCK_ASYNC_DIV10)

#define ADC_CLOCK_ASYNC_DIV12 (LL_ADC_CLOCK_ASYNC_DIV12)

#define ADC_CLOCK_ASYNC_DIV16 (LL_ADC_CLOCK_ASYNC_DIV16)

#define ADC_CLOCK_ASYNC_DIV32 (LL_ADC_CLOCK_ASYNC_DIV32)

#define ADC_CLOCK_ASYNC_DIV64 (LL_ADC_CLOCK_ASYNC_DIV64)

#define ADC_CLOCK_ASYNC_DIV128 (LL_ADC_CLOCK_ASYNC_DIV128)

#define ADC_CLOCK_ASYNC_DIV256 (LL_ADC_CLOCK_ASYNC_DIV256)

/**
  * @}
  */

/** @defgroup ADC_HAL_EC_RESOLUTION  ADC instance - Resolution
  * @{
  */
#define ADC_RESOLUTION_12B (LL_ADC_RESOLUTION_12B)
#define ADC_RESOLUTION_10B (LL_ADC_RESOLUTION_10B)
#define ADC_RESOLUTION_8B (LL_ADC_RESOLUTION_8B)
#define ADC_RESOLUTION_6B (LL_ADC_RESOLUTION_6B)
/**
  * @}
  */

/** @defgroup ADC_HAL_EC_DATA_ALIGN ADC conversion data alignment
  * @{
  */
#define ADC_DATAALIGN_RIGHT (LL_ADC_DATA_ALIGN_RIGHT)

#define ADC_DATAALIGN_LEFT (LL_ADC_DATA_ALIGN_LEFT)

/**
  * @}
  */

/** @defgroup ADC_Scan_mode ADC sequencer scan mode
  * @{
  */
#define ADC_SCAN_DISABLE (0x00000000UL)
#define ADC_SCAN_ENABLE (0x00000001UL)
/**
  * @}
  */

/** @defgroup ADC_regular_external_trigger_source ADC group regular trigger source
  * @{
  */
/* ADC group regular trigger sources for all ADC instances */
#define ADC_SOFTWARE_START (LL_ADC_REG_TRIG_SOFTWARE)

#define ADC_EXTERNALTRIG_T1_TRGO (LL_ADC_REG_TRIG_EXT_TIM1_TRGO)

#define ADC_EXTERNALTRIG_T1_TRGO2 (LL_ADC_REG_TRIG_EXT_TIM1_TRGO2)

#define ADC_EXTERNALTRIG_T1_CC1 (LL_ADC_REG_TRIG_EXT_TIM1_CH1)

#define ADC_EXTERNALTRIG_T1_CC2 (LL_ADC_REG_TRIG_EXT_TIM1_CH2)

#define ADC_EXTERNALTRIG_T1_CC3 (LL_ADC_REG_TRIG_EXT_TIM1_CH3)

#define ADC_EXTERNALTRIG_T2_TRGO (LL_ADC_REG_TRIG_EXT_TIM2_TRGO)

#define ADC_EXTERNALTRIG_T2_CC1 (LL_ADC_REG_TRIG_EXT_TIM2_CH1)

#define ADC_EXTERNALTRIG_T2_CC2 (LL_ADC_REG_TRIG_EXT_TIM2_CH2)

#define ADC_EXTERNALTRIG_T2_CC3 (LL_ADC_REG_TRIG_EXT_TIM2_CH3)

#define ADC_EXTERNALTRIG_T3_TRGO (LL_ADC_REG_TRIG_EXT_TIM3_TRGO)

#define ADC_EXTERNALTRIG_T3_CC1 (LL_ADC_REG_TRIG_EXT_TIM3_CH1)

#define ADC_EXTERNALTRIG_T3_CC4 (LL_ADC_REG_TRIG_EXT_TIM3_CH4)

#define ADC_EXTERNALTRIG_T4_TRGO (LL_ADC_REG_TRIG_EXT_TIM4_TRGO)

#define ADC_EXTERNALTRIG_T4_CC1 (LL_ADC_REG_TRIG_EXT_TIM4_CH1)

#define ADC_EXTERNALTRIG_T4_CC4 (LL_ADC_REG_TRIG_EXT_TIM4_CH4)

#define ADC_EXTERNALTRIG_T6_TRGO (LL_ADC_REG_TRIG_EXT_TIM6_TRGO)

#define ADC_EXTERNALTRIG_T7_TRGO (LL_ADC_REG_TRIG_EXT_TIM7_TRGO)

#define ADC_EXTERNALTRIG_T8_TRGO (LL_ADC_REG_TRIG_EXT_TIM8_TRGO)

#define ADC_EXTERNALTRIG_T8_TRGO2 (LL_ADC_REG_TRIG_EXT_TIM8_TRGO2)

#define ADC_EXTERNALTRIG_T8_CC1 (LL_ADC_REG_TRIG_EXT_TIM8_CH1)

#define ADC_EXTERNALTRIG_T15_TRGO (LL_ADC_REG_TRIG_EXT_TIM15_TRGO)

#define ADC_EXTERNALTRIG_T20_TRGO (LL_ADC_REG_TRIG_EXT_TIM20_TRGO)

#define ADC_EXTERNALTRIG_T20_TRGO2 (LL_ADC_REG_TRIG_EXT_TIM20_TRGO2)

#define ADC_EXTERNALTRIG_T20_CC1 (LL_ADC_REG_TRIG_EXT_TIM20_CH1)

#define ADC_EXTERNALTRIG_T20_CC2 (LL_ADC_REG_TRIG_EXT_TIM20_CH2)

#define ADC_EXTERNALTRIG_T20_CC3 (LL_ADC_REG_TRIG_EXT_TIM20_CH3)

#define ADC_EXTERNALTRIG_HRTIM_TRG1 (LL_ADC_REG_TRIG_EXT_HRTIM_TRG1)

#define ADC_EXTERNALTRIG_HRTIM_TRG2 (LL_ADC_REG_TRIG_EXT_HRTIM_TRG2)

#define ADC_EXTERNALTRIG_HRTIM_TRG3 (LL_ADC_REG_TRIG_EXT_HRTIM_TRG3)

#define ADC_EXTERNALTRIG_HRTIM_TRG4 (LL_ADC_REG_TRIG_EXT_HRTIM_TRG4)

#define ADC_EXTERNALTRIG_HRTIM_TRG5 (LL_ADC_REG_TRIG_EXT_HRTIM_TRG5)

#define ADC_EXTERNALTRIG_HRTIM_TRG6 (LL_ADC_REG_TRIG_EXT_HRTIM_TRG6)

#define ADC_EXTERNALTRIG_HRTIM_TRG7 (LL_ADC_REG_TRIG_EXT_HRTIM_TRG7)

#define ADC_EXTERNALTRIG_HRTIM_TRG8 (LL_ADC_REG_TRIG_EXT_HRTIM_TRG8)

#define ADC_EXTERNALTRIG_HRTIM_TRG9 (LL_ADC_REG_TRIG_EXT_HRTIM_TRG9)

#define ADC_EXTERNALTRIG_HRTIM_TRG10 (LL_ADC_REG_TRIG_EXT_HRTIM_TRG10)

#define ADC_EXTERNALTRIG_EXT_IT2 (LL_ADC_REG_TRIG_EXT_EXTI_LINE2)

#define ADC_EXTERNALTRIG_EXT_IT11 (LL_ADC_REG_TRIG_EXT_EXTI_LINE11)

#define ADC_EXTERNALTRIG_LPTIM_OUT (LL_ADC_REG_TRIG_EXT_LPTIM_OUT)

/**
  * @}
  */

/** @defgroup ADC_regular_external_trigger_edge ADC group regular trigger edge (when external trigger is selected)
  * @{
  */
#define ADC_EXTERNALTRIGCONVEDGE_NONE (0x00000000UL)

#define ADC_EXTERNALTRIGCONVEDGE_RISING (LL_ADC_REG_TRIG_EXT_RISING)

#define ADC_EXTERNALTRIGCONVEDGE_FALLING (LL_ADC_REG_TRIG_EXT_FALLING)

#define ADC_EXTERNALTRIGCONVEDGE_RISINGFALLING (LL_ADC_REG_TRIG_EXT_RISINGFALLING)

/**
  * @}
  */

/** @defgroup ADC_regular_sampling_mode ADC group regular sampling mode
  * @{
  */
#define ADC_SAMPLING_MODE_NORMAL (0x00000000UL)

#define ADC_SAMPLING_MODE_BULB (ADC_CFGR2_BULB)



#define ADC_SAMPLING_MODE_TRIGGER_CONTROLED (ADC_CFGR2_SMPTRIG)



/**
  * @}
  */

/** @defgroup ADC_EOCSelection ADC sequencer end of unitary conversion or sequence conversions
  * @{
  */
#define ADC_EOC_SINGLE_CONV (ADC_ISR_EOC)
#define ADC_EOC_SEQ_CONV (ADC_ISR_EOS)
/**
  * @}
  */

/** @defgroup ADC_HAL_EC_REG_OVR_DATA_BEHAVIOR  ADC group regular - Overrun behavior on conversion data
  * @{
  */
#define ADC_OVR_DATA_PRESERVED (LL_ADC_REG_OVR_DATA_PRESERVED)

#define ADC_OVR_DATA_OVERWRITTEN (LL_ADC_REG_OVR_DATA_OVERWRITTEN)

/**
  * @}
  */

/** @defgroup ADC_HAL_EC_REG_SEQ_RANKS  ADC group regular - Sequencer ranks
  * @{
  */
#define ADC_REGULAR_RANK_1 (LL_ADC_REG_RANK_1)
#define ADC_REGULAR_RANK_2 (LL_ADC_REG_RANK_2)
#define ADC_REGULAR_RANK_3 (LL_ADC_REG_RANK_3)
#define ADC_REGULAR_RANK_4 (LL_ADC_REG_RANK_4)
#define ADC_REGULAR_RANK_5 (LL_ADC_REG_RANK_5)
#define ADC_REGULAR_RANK_6 (LL_ADC_REG_RANK_6)
#define ADC_REGULAR_RANK_7 (LL_ADC_REG_RANK_7)
#define ADC_REGULAR_RANK_8 (LL_ADC_REG_RANK_8)
#define ADC_REGULAR_RANK_9 (LL_ADC_REG_RANK_9)
#define ADC_REGULAR_RANK_10 (LL_ADC_REG_RANK_10)
#define ADC_REGULAR_RANK_11 (LL_ADC_REG_RANK_11)
#define ADC_REGULAR_RANK_12 (LL_ADC_REG_RANK_12)
#define ADC_REGULAR_RANK_13 (LL_ADC_REG_RANK_13)
#define ADC_REGULAR_RANK_14 (LL_ADC_REG_RANK_14)
#define ADC_REGULAR_RANK_15 (LL_ADC_REG_RANK_15)
#define ADC_REGULAR_RANK_16 (LL_ADC_REG_RANK_16)
/**
  * @}
  */

/** @defgroup ADC_HAL_EC_CHANNEL_SAMPLINGTIME  Channel - Sampling time
  * @{
  */
#define ADC_SAMPLETIME_2CYCLES_5 (LL_ADC_SAMPLINGTIME_2CYCLES_5)
#define ADC_SAMPLETIME_6CYCLES_5 (LL_ADC_SAMPLINGTIME_6CYCLES_5)
#define ADC_SAMPLETIME_12CYCLES_5 (LL_ADC_SAMPLINGTIME_12CYCLES_5)
#define ADC_SAMPLETIME_24CYCLES_5 (LL_ADC_SAMPLINGTIME_24CYCLES_5)
#define ADC_SAMPLETIME_47CYCLES_5 (LL_ADC_SAMPLINGTIME_47CYCLES_5)
#define ADC_SAMPLETIME_92CYCLES_5 (LL_ADC_SAMPLINGTIME_92CYCLES_5)
#define ADC_SAMPLETIME_247CYCLES_5 (LL_ADC_SAMPLINGTIME_247CYCLES_5)
#define ADC_SAMPLETIME_640CYCLES_5 (LL_ADC_SAMPLINGTIME_640CYCLES_5)
#define ADC_SAMPLETIME_3CYCLES_5 (ADC_SMPR1_SMPPLUS | LL_ADC_SAMPLINGTIME_2CYCLES_5)


/**
  * @}
  */

/** @defgroup ADC_HAL_EC_CHANNEL  ADC instance - Channel number
  * @{
  */
/* Note: VrefInt, TempSensor and Vbat internal channels are not available on  */
/*        all ADC instances (refer to Reference Manual).                      */
#define ADC_CHANNEL_0 (LL_ADC_CHANNEL_0)
#define ADC_CHANNEL_1 (LL_ADC_CHANNEL_1)
#define ADC_CHANNEL_2 (LL_ADC_CHANNEL_2)
#define ADC_CHANNEL_3 (LL_ADC_CHANNEL_3)
#define ADC_CHANNEL_4 (LL_ADC_CHANNEL_4)
#define ADC_CHANNEL_5 (LL_ADC_CHANNEL_5)
#define ADC_CHANNEL_6 (LL_ADC_CHANNEL_6)
#define ADC_CHANNEL_7 (LL_ADC_CHANNEL_7)
#define ADC_CHANNEL_8 (LL_ADC_CHANNEL_8)
#define ADC_CHANNEL_9 (LL_ADC_CHANNEL_9)
#define ADC_CHANNEL_10 (LL_ADC_CHANNEL_10)
#define ADC_CHANNEL_11 (LL_ADC_CHANNEL_11)
#define ADC_CHANNEL_12 (LL_ADC_CHANNEL_12)
#define ADC_CHANNEL_13 (LL_ADC_CHANNEL_13)
#define ADC_CHANNEL_14 (LL_ADC_CHANNEL_14)
#define ADC_CHANNEL_15 (LL_ADC_CHANNEL_15)
#define ADC_CHANNEL_16 (LL_ADC_CHANNEL_16)
#define ADC_CHANNEL_17 (LL_ADC_CHANNEL_17)
#define ADC_CHANNEL_18 (LL_ADC_CHANNEL_18)
#define ADC_CHANNEL_VREFINT (LL_ADC_CHANNEL_VREFINT)


#define ADC_CHANNEL_TEMPSENSOR_ADC1 (LL_ADC_CHANNEL_TEMPSENSOR_ADC1)

#define ADC_CHANNEL_TEMPSENSOR_ADC5 (LL_ADC_CHANNEL_TEMPSENSOR_ADC5)


#define ADC_CHANNEL_VBAT (LL_ADC_CHANNEL_VBAT)




#define ADC_CHANNEL_VOPAMP1 (LL_ADC_CHANNEL_VOPAMP1)

#define ADC_CHANNEL_VOPAMP2 (LL_ADC_CHANNEL_VOPAMP2)

#define ADC_CHANNEL_VOPAMP3_ADC2 (LL_ADC_CHANNEL_VOPAMP3_ADC2)

#define ADC_CHANNEL_VOPAMP3_ADC3 (LL_ADC_CHANNEL_VOPAMP3_ADC3)


#define ADC_CHANNEL_VOPAMP4 (LL_ADC_CHANNEL_VOPAMP4)


#define ADC_CHANNEL_VOPAMP5 (LL_ADC_CHANNEL_VOPAMP5)


#define ADC_CHANNEL_VOPAMP6 (LL_ADC_CHANNEL_VOPAMP6)


/**
  * @}
  */

/** @defgroup ADC_HAL_EC_AWD_NUMBER Analog watchdog - ADC analog watchdog (AWD) number
  * @{
  */
#define ADC_ANALOGWATCHDOG_1 (LL_ADC_AWD1)
#define ADC_ANALOGWATCHDOG_2 (LL_ADC_AWD2)
#define ADC_ANALOGWATCHDOG_3 (LL_ADC_AWD3)
/**
  * @}
  */

/** @defgroup ADC_analog_watchdog_filtering_config ADC analog watchdog (AWD) filtering configuration
  * @{
  */
#define ADC_AWD_FILTERING_NONE (0x00000000UL)

#define ADC_AWD_FILTERING_2SAMPLES ((ADC_TR1_AWDFILT_0))

#define ADC_AWD_FILTERING_3SAMPLES ((ADC_TR1_AWDFILT_1))

#define ADC_AWD_FILTERING_4SAMPLES ((ADC_TR1_AWDFILT_1 | ADC_TR1_AWDFILT_0))

#define ADC_AWD_FILTERING_5SAMPLES ((ADC_TR1_AWDFILT_2))

#define ADC_AWD_FILTERING_6SAMPLES ((ADC_TR1_AWDFILT_2 | ADC_TR1_AWDFILT_0))

#define ADC_AWD_FILTERING_7SAMPLES ((ADC_TR1_AWDFILT_2 | ADC_TR1_AWDFILT_1))

#define ADC_AWD_FILTERING_8SAMPLES ((ADC_TR1_AWDFILT_2 | ADC_TR1_AWDFILT_1 | ADC_TR1_AWDFILT_0))


/**
  * @}
  */

/** @defgroup ADC_analog_watchdog_mode ADC analog watchdog (AWD) mode
  * @{
  */
#define ADC_ANALOGWATCHDOG_NONE (0x00000000UL)
#define ADC_ANALOGWATCHDOG_SINGLE_REG (ADC_CFGR_AWD1SGL | ADC_CFGR_AWD1EN)

#define ADC_ANALOGWATCHDOG_SINGLE_INJEC (ADC_CFGR_AWD1SGL | ADC_CFGR_JAWD1EN)

#define ADC_ANALOGWATCHDOG_SINGLE_REGINJEC (ADC_CFGR_AWD1SGL | ADC_CFGR_AWD1EN | ADC_CFGR_JAWD1EN)


#define ADC_ANALOGWATCHDOG_ALL_REG (ADC_CFGR_AWD1EN)

#define ADC_ANALOGWATCHDOG_ALL_INJEC (ADC_CFGR_JAWD1EN)

#define ADC_ANALOGWATCHDOG_ALL_REGINJEC (ADC_CFGR_AWD1EN | ADC_CFGR_JAWD1EN)

/**
  * @}
  */

/** @defgroup ADC_HAL_EC_OVS_RATIO  Oversampling - Ratio
  * @{
  */
/**
  * @note The oversampling ratio is the number of ADC conversions performed, sum of these conversions data is computed
  *       to result as the ADC oversampling conversion data (before potential shift)
  */
#define ADC_OVERSAMPLING_RATIO_2 (LL_ADC_OVS_RATIO_2)
#define ADC_OVERSAMPLING_RATIO_4 (LL_ADC_OVS_RATIO_4)
#define ADC_OVERSAMPLING_RATIO_8 (LL_ADC_OVS_RATIO_8)
#define ADC_OVERSAMPLING_RATIO_16 (LL_ADC_OVS_RATIO_16)
#define ADC_OVERSAMPLING_RATIO_32 (LL_ADC_OVS_RATIO_32)
#define ADC_OVERSAMPLING_RATIO_64 (LL_ADC_OVS_RATIO_64)
#define ADC_OVERSAMPLING_RATIO_128 (LL_ADC_OVS_RATIO_128)
#define ADC_OVERSAMPLING_RATIO_256 (LL_ADC_OVS_RATIO_256)
/**
  * @}
  */

/** @defgroup ADC_HAL_EC_OVS_SHIFT  Oversampling - Data shift
  * @{
  */
/**
  * @note The sum of the ADC conversions data is divided by "Rightbitshift" number to result as the ADC oversampling
  *       conversion data)
  */
#define ADC_RIGHTBITSHIFT_NONE (LL_ADC_OVS_SHIFT_NONE)
#define ADC_RIGHTBITSHIFT_1 (LL_ADC_OVS_SHIFT_RIGHT_1)
#define ADC_RIGHTBITSHIFT_2 (LL_ADC_OVS_SHIFT_RIGHT_2)
#define ADC_RIGHTBITSHIFT_3 (LL_ADC_OVS_SHIFT_RIGHT_3)
#define ADC_RIGHTBITSHIFT_4 (LL_ADC_OVS_SHIFT_RIGHT_4)
#define ADC_RIGHTBITSHIFT_5 (LL_ADC_OVS_SHIFT_RIGHT_5)
#define ADC_RIGHTBITSHIFT_6 (LL_ADC_OVS_SHIFT_RIGHT_6)
#define ADC_RIGHTBITSHIFT_7 (LL_ADC_OVS_SHIFT_RIGHT_7)
#define ADC_RIGHTBITSHIFT_8 (LL_ADC_OVS_SHIFT_RIGHT_8)
/**
  * @}
  */

/** @defgroup ADC_HAL_EC_OVS_DISCONT_MODE  Oversampling - Discontinuous mode
  * @{
  */
#define ADC_TRIGGEREDMODE_SINGLE_TRIGGER (LL_ADC_OVS_REG_CONT)

#define ADC_TRIGGEREDMODE_MULTI_TRIGGER (LL_ADC_OVS_REG_DISCONT)

/**
  * @}
  */

/** @defgroup ADC_HAL_EC_OVS_SCOPE_REG  Oversampling - Oversampling scope for ADC group regular
  * @{
  */
#define ADC_REGOVERSAMPLING_CONTINUED_MODE (LL_ADC_OVS_GRP_REGULAR_CONTINUED)

#define ADC_REGOVERSAMPLING_RESUMED_MODE (LL_ADC_OVS_GRP_REGULAR_RESUMED)

/**
  * @}
  */

/** @defgroup ADC_Event_type ADC Event type
  * @{
  */
/**
  * @note Analog watchdog 1 is available on all stm32 series
  *       Analog watchdog 2 and 3 are not available on all series
  */
#define ADC_EOSMP_EVENT (ADC_FLAG_EOSMP)
#define ADC_AWD1_EVENT (ADC_FLAG_AWD1)
#define ADC_AWD2_EVENT (ADC_FLAG_AWD2)
#define ADC_AWD3_EVENT (ADC_FLAG_AWD3)
#define ADC_OVR_EVENT (ADC_FLAG_OVR)
#define ADC_JQOVF_EVENT (ADC_FLAG_JQOVF)
/**
  * @}
  */
#define ADC_AWD_EVENT ADC_AWD1_EVENT


/** @defgroup ADC_interrupts_definition ADC interrupts definition
  * @{
  */
#define ADC_IT_RDY ADC_IER_ADRDYIE
#define ADC_IT_EOSMP ADC_IER_EOSMPIE
#define ADC_IT_EOC ADC_IER_EOCIE
#define ADC_IT_EOS ADC_IER_EOSIE
#define ADC_IT_OVR ADC_IER_OVRIE
#define ADC_IT_JEOC ADC_IER_JEOCIE
#define ADC_IT_JEOS ADC_IER_JEOSIE
#define ADC_IT_AWD1 ADC_IER_AWD1IE
#define ADC_IT_AWD2 ADC_IER_AWD2IE

#define ADC_IT_AWD3 ADC_IER_AWD3IE

#define ADC_IT_JQOVF ADC_IER_JQOVFIE

/**
  * @}
  */

/** @defgroup ADC_flags_definition ADC flags definition
  * @{
  */
#define ADC_FLAG_RDY ADC_ISR_ADRDY
#define ADC_FLAG_EOSMP ADC_ISR_EOSMP
#define ADC_FLAG_EOC ADC_ISR_EOC
#define ADC_FLAG_EOS ADC_ISR_EOS
#define ADC_FLAG_OVR ADC_ISR_OVR
#define ADC_FLAG_JEOC ADC_ISR_JEOC
#define ADC_FLAG_JEOS ADC_ISR_JEOS
#define ADC_FLAG_AWD1 ADC_ISR_AWD1
#define ADC_FLAG_AWD2 ADC_ISR_AWD2
#define ADC_FLAG_AWD3 ADC_ISR_AWD3
#define ADC_FLAG_JQOVF ADC_ISR_JQOVF

/**
  * @}
  */

/**
  * @}
  */

/* Private macro -------------------------------------------------------------*/

/** @defgroup ADC_Private_Macros ADC Private Macros
  * @{
  */
/* Macro reserved for internal HAL driver usage, not intended to be used in   */
/* code of final user.                                                        */

/**
  * @brief Return resolution bits in CFGR register RES[1:0] field.
  * @param __HANDLE__ ADC handle
  * @retval Value of bitfield RES in CFGR register.
  */
#define ADC_GET_RESOLUTION(__HANDLE__) (LL_ADC_GetResolution((__HANDLE__)->Instance))


/**
  * @brief Clear ADC error code (set it to no error code "HAL_ADC_ERROR_NONE").
  * @param __HANDLE__ ADC handle
  * @retval None
  */
#define ADC_CLEAR_ERRORCODE(__HANDLE__) ((__HANDLE__)->ErrorCode = HAL_ADC_ERROR_NONE)

/**
  * @brief Simultaneously clear and set specific bits of the handle State.
  * @note  ADC_STATE_CLR_SET() macro is merely aliased to generic macro MODIFY_REG(),
  *        the first parameter is the ADC handle State, the second parameter is the
  *        bit field to clear, the third and last parameter is the bit field to set.
  * @retval None
  */
#define ADC_STATE_CLR_SET MODIFY_REG

/**
  * @brief Verify that a given value is aligned with the ADC resolution range.
  * @param __RESOLUTION__ ADC resolution (12, 10, 8 or 6 bits).
  * @param __ADC_VALUE__ value checked against the resolution.
  * @retval SET (__ADC_VALUE__ in line with __RESOLUTION__) or RESET (__ADC_VALUE__ not in line with __RESOLUTION__)
  */
#define IS_ADC_RANGE(__RESOLUTION__,__ADC_VALUE__) ((__ADC_VALUE__) <= __LL_ADC_DIGITAL_SCALE(__RESOLUTION__))


/**
  * @brief Verify the length of the scheduled regular conversions group.
  * @param __LENGTH__ number of programmed conversions.
  * @retval SET (__LENGTH__ is within the maximum number of possible programmable regular conversions)
  *         or RESET (__LENGTH__ is null or too large)
  */
#define IS_ADC_REGULAR_NB_CONV(__LENGTH__) (((__LENGTH__) >= (1UL)) && ((__LENGTH__) <= (16UL)))


/**
  * @brief Verify the number of scheduled regular conversions in discontinuous mode.
  * @param NUMBER number of scheduled regular conversions in discontinuous mode.
  * @retval SET (NUMBER is within the maximum number of regular conversions in discontinuous mode)
  *         or RESET (NUMBER is null or too large)
  */
#define IS_ADC_REGULAR_DISCONT_NUMBER(NUMBER) (((NUMBER) >= (1UL)) && ((NUMBER) <= (8UL)))


/**
  * @brief Verify the ADC clock setting.
  * @param __ADC_CLOCK__ programmed ADC clock.
  * @retval SET (__ADC_CLOCK__ is a valid value) or RESET (__ADC_CLOCK__ is invalid)
  */
#define IS_ADC_CLOCKPRESCALER(__ADC_CLOCK__) (((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV1) || ((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV2) || ((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV4) || ((__ADC_CLOCK__) == ADC_CLOCK_ASYNC_DIV1) || ((__ADC_CLOCK__) == ADC_CLOCK_ASYNC_DIV2) || ((__ADC_CLOCK__) == ADC_CLOCK_ASYNC_DIV4) || ((__ADC_CLOCK__) == ADC_CLOCK_ASYNC_DIV6) || ((__ADC_CLOCK__) == ADC_CLOCK_ASYNC_DIV8) || ((__ADC_CLOCK__) == ADC_CLOCK_ASYNC_DIV10) || ((__ADC_CLOCK__) == ADC_CLOCK_ASYNC_DIV12) || ((__ADC_CLOCK__) == ADC_CLOCK_ASYNC_DIV16) || ((__ADC_CLOCK__) == ADC_CLOCK_ASYNC_DIV32) || ((__ADC_CLOCK__) == ADC_CLOCK_ASYNC_DIV64) || ((__ADC_CLOCK__) == ADC_CLOCK_ASYNC_DIV128) || ((__ADC_CLOCK__) == ADC_CLOCK_ASYNC_DIV256) )
# 1139 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc.h"

/**
  * @brief Verify the ADC resolution setting.
  * @param __RESOLUTION__ programmed ADC resolution.
  * @retval SET (__RESOLUTION__ is a valid value) or RESET (__RESOLUTION__ is invalid)
  */
#define IS_ADC_RESOLUTION(__RESOLUTION__) (((__RESOLUTION__) == ADC_RESOLUTION_12B) || ((__RESOLUTION__) == ADC_RESOLUTION_10B) || ((__RESOLUTION__) == ADC_RESOLUTION_8B) || ((__RESOLUTION__) == ADC_RESOLUTION_6B) )




/**
  * @brief Verify the ADC resolution setting when limited to 6 or 8 bits.
  * @param __RESOLUTION__ programmed ADC resolution when limited to 6 or 8 bits.
  * @retval SET (__RESOLUTION__ is a valid value) or RESET (__RESOLUTION__ is invalid)
  */
#define IS_ADC_RESOLUTION_8_6_BITS(__RESOLUTION__) (((__RESOLUTION__) == ADC_RESOLUTION_8B) || ((__RESOLUTION__) == ADC_RESOLUTION_6B) )


/**
  * @brief Verify the ADC converted data alignment.
  * @param __ALIGN__ programmed ADC converted data alignment.
  * @retval SET (__ALIGN__ is a valid value) or RESET (__ALIGN__ is invalid)
  */
#define IS_ADC_DATA_ALIGN(__ALIGN__) (((__ALIGN__) == ADC_DATAALIGN_RIGHT) || ((__ALIGN__) == ADC_DATAALIGN_LEFT) )


/**
  * @brief Verify the ADC gain compensation.
  * @param __GAIN_COMPENSATION__ programmed ADC gain compensation coefficient.
  * @retval SET (__GAIN_COMPENSATION__ is a valid value) or RESET (__GAIN_COMPENSATION__ is invalid)
  */
#define IS_ADC_GAIN_COMPENSATION(__GAIN_COMPENSATION__) ((__GAIN_COMPENSATION__) <= 16393UL)

/**
  * @brief Verify the ADC scan mode.
  * @param __SCAN_MODE__ programmed ADC scan mode.
  * @retval SET (__SCAN_MODE__ is valid) or RESET (__SCAN_MODE__ is invalid)
  */
#define IS_ADC_SCAN_MODE(__SCAN_MODE__) (((__SCAN_MODE__) == ADC_SCAN_DISABLE) || ((__SCAN_MODE__) == ADC_SCAN_ENABLE) )


/**
  * @brief Verify the ADC edge trigger setting for regular group.
  * @param __EDGE__ programmed ADC edge trigger setting.
  * @retval SET (__EDGE__ is a valid value) or RESET (__EDGE__ is invalid)
  */
#define IS_ADC_EXTTRIG_EDGE(__EDGE__) (((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_NONE) || ((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_RISING) || ((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_FALLING) || ((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_RISINGFALLING) )




/**
  * @brief Verify the ADC regular conversions external trigger.
  * @param __HANDLE__ ADC handle
  * @param __REGTRIG__ programmed ADC regular conversions external trigger.
  * @retval SET (__REGTRIG__ is a valid value) or RESET (__REGTRIG__ is invalid)
  */
# 1244 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc.h"
#define IS_ADC_EXTTRIG(__HANDLE__,__REGTRIG__) (((__REGTRIG__) == ADC_EXTERNALTRIG_T1_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T1_TRGO2) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T1_CC3) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T2_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T3_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T4_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T6_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T7_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T8_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T8_TRGO2) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T15_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T20_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T20_TRGO2) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T20_CC1) || ((__REGTRIG__) == ADC_EXTERNALTRIG_LPTIM_OUT) || ((((__HANDLE__)->Instance == ADC1) || ((__HANDLE__)->Instance == ADC2)) && (((__REGTRIG__) == ADC_EXTERNALTRIG_T1_CC1) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T1_CC2) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T2_CC2) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T3_CC4) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T4_CC4) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T20_CC2) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T20_CC3) || ((__REGTRIG__) == ADC_EXTERNALTRIG_EXT_IT11))) || ((((__HANDLE__)->Instance == ADC3) || ((__HANDLE__)->Instance == ADC4) || ((__HANDLE__)->Instance == ADC5)) && (((__REGTRIG__) == ADC_EXTERNALTRIG_T2_CC1) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T2_CC3) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T3_CC1) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T4_CC1) || ((__REGTRIG__) == ADC_EXTERNALTRIG_T8_CC1) || ((__REGTRIG__) == ADC_EXTERNALTRIG_EXT_IT2))) || ((__REGTRIG__) == ADC_SOFTWARE_START) )
# 1279 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc.h"
# 1363 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc.h"

/**
  * @brief Verify the ADC regular conversions external trigger.
  * @param __SAMPLINGMODE__ programmed ADC regular conversions external trigger.
  * @retval SET (__SAMPLINGMODE__ is a valid value) or RESET (__SAMPLINGMODE__ is invalid)
  */
#define IS_ADC_SAMPLINGMODE(__SAMPLINGMODE__) (((__SAMPLINGMODE__) == ADC_SAMPLING_MODE_NORMAL) || ((__SAMPLINGMODE__) == ADC_SAMPLING_MODE_BULB) || ((__SAMPLINGMODE__) == ADC_SAMPLING_MODE_TRIGGER_CONTROLED) )



/**
  * @brief Verify the ADC regular conversions check for converted data availability.
  * @param __EOC_SELECTION__ converted data availability check.
  * @retval SET (__EOC_SELECTION__ is a valid value) or RESET (__EOC_SELECTION__ is invalid)
  */
#define IS_ADC_EOC_SELECTION(__EOC_SELECTION__) (((__EOC_SELECTION__) == ADC_EOC_SINGLE_CONV) || ((__EOC_SELECTION__) == ADC_EOC_SEQ_CONV) )


/**
  * @brief Verify the ADC regular conversions overrun handling.
  * @param __OVR__ ADC regular conversions overrun handling.
  * @retval SET (__OVR__ is a valid value) or RESET (__OVR__ is invalid)
  */
#define IS_ADC_OVERRUN(__OVR__) (((__OVR__) == ADC_OVR_DATA_PRESERVED) || ((__OVR__) == ADC_OVR_DATA_OVERWRITTEN) )


/**
  * @brief Verify the ADC conversions sampling time.
  * @param __TIME__ ADC conversions sampling time.
  * @retval SET (__TIME__ is a valid value) or RESET (__TIME__ is invalid)
  */
#define IS_ADC_SAMPLE_TIME(__TIME__) (((__TIME__) == ADC_SAMPLETIME_2CYCLES_5) || ((__TIME__) == ADC_SAMPLETIME_3CYCLES_5) || ((__TIME__) == ADC_SAMPLETIME_6CYCLES_5) || ((__TIME__) == ADC_SAMPLETIME_12CYCLES_5) || ((__TIME__) == ADC_SAMPLETIME_24CYCLES_5) || ((__TIME__) == ADC_SAMPLETIME_47CYCLES_5) || ((__TIME__) == ADC_SAMPLETIME_92CYCLES_5) || ((__TIME__) == ADC_SAMPLETIME_247CYCLES_5) || ((__TIME__) == ADC_SAMPLETIME_640CYCLES_5) )
# 1403 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc.h"

/**
  * @brief Verify the ADC regular channel setting.
  * @param  __CHANNEL__ programmed ADC regular channel.
  * @retval SET (__CHANNEL__ is valid) or RESET (__CHANNEL__ is invalid)
  */
#define IS_ADC_REGULAR_RANK(__CHANNEL__) (((__CHANNEL__) == ADC_REGULAR_RANK_1 ) || ((__CHANNEL__) == ADC_REGULAR_RANK_2 ) || ((__CHANNEL__) == ADC_REGULAR_RANK_3 ) || ((__CHANNEL__) == ADC_REGULAR_RANK_4 ) || ((__CHANNEL__) == ADC_REGULAR_RANK_5 ) || ((__CHANNEL__) == ADC_REGULAR_RANK_6 ) || ((__CHANNEL__) == ADC_REGULAR_RANK_7 ) || ((__CHANNEL__) == ADC_REGULAR_RANK_8 ) || ((__CHANNEL__) == ADC_REGULAR_RANK_9 ) || ((__CHANNEL__) == ADC_REGULAR_RANK_10) || ((__CHANNEL__) == ADC_REGULAR_RANK_11) || ((__CHANNEL__) == ADC_REGULAR_RANK_12) || ((__CHANNEL__) == ADC_REGULAR_RANK_13) || ((__CHANNEL__) == ADC_REGULAR_RANK_14) || ((__CHANNEL__) == ADC_REGULAR_RANK_15) || ((__CHANNEL__) == ADC_REGULAR_RANK_16) )
# 1425 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc.h"

/**
  * @}
  */


/* Private constants ---------------------------------------------------------*/

/** @defgroup ADC_Private_Constants ADC Private Constants
  * @{
  */

/* Fixed timeout values for ADC conversion (including sampling time)        */
/* Maximum sampling time is 640.5 ADC clock cycle (SMPx[2:0] = 0b111        */
/* Maximum conversion time is 12.5 + Maximum sampling time                  */
/*                       or 12.5  + 640.5 = 653 ADC clock cycles            */
/* Minimum ADC Clock frequency is 0.14 MHz                                  */
/* Maximum conversion time is                                               */
/*              653 / 0.14 MHz = 4.66 ms                                    */
#define ADC_STOP_CONVERSION_TIMEOUT ( 5UL)

/* Delay for temperature sensor stabilization time.                         */
/* Maximum delay is 120us (refer device datasheet, parameter tSTART).       */
/* Unit: us                                                                 */
#define ADC_TEMPSENSOR_DELAY_US (LL_ADC_DELAY_TEMPSENSOR_STAB_US)

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/

/** @defgroup ADC_Exported_Macros ADC Exported Macros
  * @{
  */
/* Macro for internal HAL driver usage, and possibly can be used into code of */
/* final user.                                                                */

/** @defgroup ADC_HAL_EM_HANDLE_IT_FLAG HAL ADC macro to manage HAL ADC handle, IT and flags.
  * @{
  */

/** @brief  Reset ADC handle state.
  * @param __HANDLE__ ADC handle
  * @retval None
  */
# 1479 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc.h"
#define __HAL_ADC_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_ADC_STATE_RESET)



/**
  * @brief Enable ADC interrupt.
  * @param __HANDLE__ ADC handle
  * @param __INTERRUPT__ ADC Interrupt
  *        This parameter can be one of the following values:
  *            @arg @ref ADC_IT_RDY    ADC Ready interrupt source
  *            @arg @ref ADC_IT_EOSMP  ADC End of Sampling interrupt source
  *            @arg @ref ADC_IT_EOC    ADC End of Regular Conversion interrupt source
  *            @arg @ref ADC_IT_EOS    ADC End of Regular sequence of Conversions interrupt source
  *            @arg @ref ADC_IT_OVR    ADC overrun interrupt source
  *            @arg @ref ADC_IT_JEOC   ADC End of Injected Conversion interrupt source
  *            @arg @ref ADC_IT_JEOS   ADC End of Injected sequence of Conversions interrupt source
  *            @arg @ref ADC_IT_AWD1   ADC Analog watchdog 1 interrupt source (main analog watchdog)
  *            @arg @ref ADC_IT_AWD2   ADC Analog watchdog 2 interrupt source (additional analog watchdog)
  *            @arg @ref ADC_IT_AWD3   ADC Analog watchdog 3 interrupt source (additional analog watchdog)
  *            @arg @ref ADC_IT_JQOVF  ADC Injected Context Queue Overflow interrupt source.
  * @retval None
  */
#define __HAL_ADC_ENABLE_IT(__HANDLE__,__INTERRUPT__) (((__HANDLE__)->Instance->IER) |= (__INTERRUPT__))


/**
  * @brief Disable ADC interrupt.
  * @param __HANDLE__ ADC handle
  * @param __INTERRUPT__ ADC Interrupt
  *        This parameter can be one of the following values:
  *            @arg @ref ADC_IT_RDY    ADC Ready interrupt source
  *            @arg @ref ADC_IT_EOSMP  ADC End of Sampling interrupt source
  *            @arg @ref ADC_IT_EOC    ADC End of Regular Conversion interrupt source
  *            @arg @ref ADC_IT_EOS    ADC End of Regular sequence of Conversions interrupt source
  *            @arg @ref ADC_IT_OVR    ADC overrun interrupt source
  *            @arg @ref ADC_IT_JEOC   ADC End of Injected Conversion interrupt source
  *            @arg @ref ADC_IT_JEOS   ADC End of Injected sequence of Conversions interrupt source
  *            @arg @ref ADC_IT_AWD1   ADC Analog watchdog 1 interrupt source (main analog watchdog)
  *            @arg @ref ADC_IT_AWD2   ADC Analog watchdog 2 interrupt source (additional analog watchdog)
  *            @arg @ref ADC_IT_AWD3   ADC Analog watchdog 3 interrupt source (additional analog watchdog)
  *            @arg @ref ADC_IT_JQOVF  ADC Injected Context Queue Overflow interrupt source.
  * @retval None
  */
#define __HAL_ADC_DISABLE_IT(__HANDLE__,__INTERRUPT__) (((__HANDLE__)->Instance->IER) &= ~(__INTERRUPT__))


/** @brief  Checks if the specified ADC interrupt source is enabled or disabled.
  * @param __HANDLE__ ADC handle
  * @param __INTERRUPT__ ADC interrupt source to check
  *          This parameter can be one of the following values:
  *            @arg @ref ADC_IT_RDY    ADC Ready interrupt source
  *            @arg @ref ADC_IT_EOSMP  ADC End of Sampling interrupt source
  *            @arg @ref ADC_IT_EOC    ADC End of Regular Conversion interrupt source
  *            @arg @ref ADC_IT_EOS    ADC End of Regular sequence of Conversions interrupt source
  *            @arg @ref ADC_IT_OVR    ADC overrun interrupt source
  *            @arg @ref ADC_IT_JEOC   ADC End of Injected Conversion interrupt source
  *            @arg @ref ADC_IT_JEOS   ADC End of Injected sequence of Conversions interrupt source
  *            @arg @ref ADC_IT_AWD1   ADC Analog watchdog 1 interrupt source (main analog watchdog)
  *            @arg @ref ADC_IT_AWD2   ADC Analog watchdog 2 interrupt source (additional analog watchdog)
  *            @arg @ref ADC_IT_AWD3   ADC Analog watchdog 3 interrupt source (additional analog watchdog)
  *            @arg @ref ADC_IT_JQOVF  ADC Injected Context Queue Overflow interrupt source.
  * @retval State of interruption (SET or RESET)
  */
#define __HAL_ADC_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__) (((__HANDLE__)->Instance->IER & (__INTERRUPT__)) == (__INTERRUPT__))


/**
  * @brief Check whether the specified ADC flag is set or not.
  * @param __HANDLE__ ADC handle
  * @param __FLAG__ ADC flag
  *        This parameter can be one of the following values:
  *            @arg @ref ADC_FLAG_RDY     ADC Ready flag
  *            @arg @ref ADC_FLAG_EOSMP   ADC End of Sampling flag
  *            @arg @ref ADC_FLAG_EOC     ADC End of Regular Conversion flag
  *            @arg @ref ADC_FLAG_EOS     ADC End of Regular sequence of Conversions flag
  *            @arg @ref ADC_FLAG_OVR     ADC overrun flag
  *            @arg @ref ADC_FLAG_JEOC    ADC End of Injected Conversion flag
  *            @arg @ref ADC_FLAG_JEOS    ADC End of Injected sequence of Conversions flag
  *            @arg @ref ADC_FLAG_AWD1    ADC Analog watchdog 1 flag (main analog watchdog)
  *            @arg @ref ADC_FLAG_AWD2    ADC Analog watchdog 2 flag (additional analog watchdog)
  *            @arg @ref ADC_FLAG_AWD3    ADC Analog watchdog 3 flag (additional analog watchdog)
  *            @arg @ref ADC_FLAG_JQOVF   ADC Injected Context Queue Overflow flag.
  * @retval State of flag (TRUE or FALSE).
  */
#define __HAL_ADC_GET_FLAG(__HANDLE__,__FLAG__) ((((__HANDLE__)->Instance->ISR) & (__FLAG__)) == (__FLAG__))


/**
  * @brief Clear the specified ADC flag.
  * @param __HANDLE__ ADC handle
  * @param __FLAG__ ADC flag
  *        This parameter can be one of the following values:
  *            @arg @ref ADC_FLAG_RDY     ADC Ready flag
  *            @arg @ref ADC_FLAG_EOSMP   ADC End of Sampling flag
  *            @arg @ref ADC_FLAG_EOC     ADC End of Regular Conversion flag
  *            @arg @ref ADC_FLAG_EOS     ADC End of Regular sequence of Conversions flag
  *            @arg @ref ADC_FLAG_OVR     ADC overrun flag
  *            @arg @ref ADC_FLAG_JEOC    ADC End of Injected Conversion flag
  *            @arg @ref ADC_FLAG_JEOS    ADC End of Injected sequence of Conversions flag
  *            @arg @ref ADC_FLAG_AWD1    ADC Analog watchdog 1 flag (main analog watchdog)
  *            @arg @ref ADC_FLAG_AWD2    ADC Analog watchdog 2 flag (additional analog watchdog)
  *            @arg @ref ADC_FLAG_AWD3    ADC Analog watchdog 3 flag (additional analog watchdog)
  *            @arg @ref ADC_FLAG_JQOVF   ADC Injected Context Queue Overflow flag.
  * @retval None
  */
/* Note: bit cleared bit by writing 1 (writing 0 has no effect on any bit of register ISR) */
#define __HAL_ADC_CLEAR_FLAG(__HANDLE__,__FLAG__) (((__HANDLE__)->Instance->ISR) = (__FLAG__))


/**
  * @}
  */

/** @defgroup ADC_HAL_EM_HELPER_MACRO HAL ADC helper macro
  * @{
  */

/**
  * @brief  Helper macro to get ADC channel number in decimal format
  *         from literals ADC_CHANNEL_x.
  * @note   Example:
  *           __HAL_ADC_CHANNEL_TO_DECIMAL_NB(ADC_CHANNEL_4)
  *           will return decimal number "4".
  * @note   The input can be a value from functions where a channel
  *         number is returned, either defined with number
  *         or with bitfield (only one bit must be set).
  * @param  __CHANNEL__ This parameter can be one of the following values:
  *         @arg @ref ADC_CHANNEL_0
  *         @arg @ref ADC_CHANNEL_1                 (8)
  *         @arg @ref ADC_CHANNEL_2                 (8)
  *         @arg @ref ADC_CHANNEL_3                 (8)
  *         @arg @ref ADC_CHANNEL_4                 (8)
  *         @arg @ref ADC_CHANNEL_5                 (8)
  *         @arg @ref ADC_CHANNEL_6
  *         @arg @ref ADC_CHANNEL_7
  *         @arg @ref ADC_CHANNEL_8
  *         @arg @ref ADC_CHANNEL_9
  *         @arg @ref ADC_CHANNEL_10
  *         @arg @ref ADC_CHANNEL_11
  *         @arg @ref ADC_CHANNEL_12
  *         @arg @ref ADC_CHANNEL_13
  *         @arg @ref ADC_CHANNEL_14
  *         @arg @ref ADC_CHANNEL_15
  *         @arg @ref ADC_CHANNEL_16
  *         @arg @ref ADC_CHANNEL_17
  *         @arg @ref ADC_CHANNEL_18
  *         @arg @ref ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref ADC_CHANNEL_VBAT              (6)
  *         @arg @ref ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *            (fADC) to convert in 12-bit resolution.\n
  * @retval Value between Min_Data=0 and Max_Data=18
  */
#define __HAL_ADC_CHANNEL_TO_DECIMAL_NB(__CHANNEL__) __LL_ADC_CHANNEL_TO_DECIMAL_NB((__CHANNEL__))


/**
  * @brief  Helper macro to get ADC channel in literal format ADC_CHANNEL_x
  *         from number in decimal format.
  * @note   Example:
  *           __HAL_ADC_DECIMAL_NB_TO_CHANNEL(4)
  *           will return a data equivalent to "ADC_CHANNEL_4".
  * @param  __DECIMAL_NB__ Value between Min_Data=0 and Max_Data=18
  * @retval Returned value can be one of the following values:
  *         @arg @ref ADC_CHANNEL_0
  *         @arg @ref ADC_CHANNEL_1                 (8)
  *         @arg @ref ADC_CHANNEL_2                 (8)
  *         @arg @ref ADC_CHANNEL_3                 (8)
  *         @arg @ref ADC_CHANNEL_4                 (8)
  *         @arg @ref ADC_CHANNEL_5                 (8)
  *         @arg @ref ADC_CHANNEL_6
  *         @arg @ref ADC_CHANNEL_7
  *         @arg @ref ADC_CHANNEL_8
  *         @arg @ref ADC_CHANNEL_9
  *         @arg @ref ADC_CHANNEL_10
  *         @arg @ref ADC_CHANNEL_11
  *         @arg @ref ADC_CHANNEL_12
  *         @arg @ref ADC_CHANNEL_13
  *         @arg @ref ADC_CHANNEL_14
  *         @arg @ref ADC_CHANNEL_15
  *         @arg @ref ADC_CHANNEL_16
  *         @arg @ref ADC_CHANNEL_17
  *         @arg @ref ADC_CHANNEL_18
  *         @arg @ref ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref ADC_CHANNEL_VBAT              (6)
  *         @arg @ref ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *          -  On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet for
  *             more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC)
  *             to convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *             (fADC) to convert in 12-bit resolution.\n
  *         (1, 2, 3, 4, 5, 7) For ADC channel read back from ADC register,
  *                      comparison with internal channel parameter to be done
  *                      using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
  */
#define __HAL_ADC_DECIMAL_NB_TO_CHANNEL(__DECIMAL_NB__) __LL_ADC_DECIMAL_NB_TO_CHANNEL((__DECIMAL_NB__))


/**
  * @brief  Helper macro to determine whether the selected channel
  *         corresponds to literal definitions of driver.
  * @note   The different literal definitions of ADC channels are:
  *         - ADC internal channel:
  *           ADC_CHANNEL_VREFINT, ADC_CHANNEL_TEMPSENSOR, ...
  *         - ADC external channel (channel connected to a GPIO pin):
  *           ADC_CHANNEL_1, ADC_CHANNEL_2, ...
  * @note   The channel parameter must be a value defined from literal
  *         definition of a ADC internal channel (ADC_CHANNEL_VREFINT,
  *         ADC_CHANNEL_TEMPSENSOR, ...),
  *         ADC external channel (ADC_CHANNEL_1, ADC_CHANNEL_2, ...),
  *         must not be a value from functions where a channel number is
  *         returned from ADC registers,
  *         because internal and external channels share the same channel
  *         number in ADC registers. The differentiation is made only with
  *         parameters definitions of driver.
  * @param  __CHANNEL__ This parameter can be one of the following values:
  *         @arg @ref ADC_CHANNEL_0
  *         @arg @ref ADC_CHANNEL_1                 (8)
  *         @arg @ref ADC_CHANNEL_2                 (8)
  *         @arg @ref ADC_CHANNEL_3                 (8)
  *         @arg @ref ADC_CHANNEL_4                 (8)
  *         @arg @ref ADC_CHANNEL_5                 (8)
  *         @arg @ref ADC_CHANNEL_6
  *         @arg @ref ADC_CHANNEL_7
  *         @arg @ref ADC_CHANNEL_8
  *         @arg @ref ADC_CHANNEL_9
  *         @arg @ref ADC_CHANNEL_10
  *         @arg @ref ADC_CHANNEL_11
  *         @arg @ref ADC_CHANNEL_12
  *         @arg @ref ADC_CHANNEL_13
  *         @arg @ref ADC_CHANNEL_14
  *         @arg @ref ADC_CHANNEL_15
  *         @arg @ref ADC_CHANNEL_16
  *         @arg @ref ADC_CHANNEL_17
  *         @arg @ref ADC_CHANNEL_18
  *         @arg @ref ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref ADC_CHANNEL_VBAT              (6)
  *         @arg @ref ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *            (fADC) to convert in 12-bit resolution.\n
  * @retval Value "0" if the channel corresponds to a parameter definition of a ADC external channel (channel
  *         connected to a GPIO pin).
  *         Value "1" if the channel corresponds to a parameter definition of a ADC internal channel.
  */
#define __HAL_ADC_IS_CHANNEL_INTERNAL(__CHANNEL__) __LL_ADC_IS_CHANNEL_INTERNAL((__CHANNEL__))


/**
  * @brief  Helper macro to convert a channel defined from parameter
  *         definition of a ADC internal channel (ADC_CHANNEL_VREFINT,
  *         ADC_CHANNEL_TEMPSENSOR, ...),
  *         to its equivalent parameter definition of a ADC external channel
  *         (ADC_CHANNEL_1, ADC_CHANNEL_2, ...).
  * @note   The channel parameter can be, additionally to a value
  *         defined from parameter definition of a ADC internal channel
  *         (ADC_CHANNEL_VREFINT, ADC_CHANNEL_TEMPSENSOR, ...),
  *         a value defined from parameter definition of
  *         ADC external channel (ADC_CHANNEL_1, ADC_CHANNEL_2, ...)
  *         or a value from functions where a channel number is returned
  *         from ADC registers.
  * @param  __CHANNEL__ This parameter can be one of the following values:
  *         @arg @ref ADC_CHANNEL_0
  *         @arg @ref ADC_CHANNEL_1                 (8)
  *         @arg @ref ADC_CHANNEL_2                 (8)
  *         @arg @ref ADC_CHANNEL_3                 (8)
  *         @arg @ref ADC_CHANNEL_4                 (8)
  *         @arg @ref ADC_CHANNEL_5                 (8)
  *         @arg @ref ADC_CHANNEL_6
  *         @arg @ref ADC_CHANNEL_7
  *         @arg @ref ADC_CHANNEL_8
  *         @arg @ref ADC_CHANNEL_9
  *         @arg @ref ADC_CHANNEL_10
  *         @arg @ref ADC_CHANNEL_11
  *         @arg @ref ADC_CHANNEL_12
  *         @arg @ref ADC_CHANNEL_13
  *         @arg @ref ADC_CHANNEL_14
  *         @arg @ref ADC_CHANNEL_15
  *         @arg @ref ADC_CHANNEL_16
  *         @arg @ref ADC_CHANNEL_17
  *         @arg @ref ADC_CHANNEL_18
  *         @arg @ref ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref ADC_CHANNEL_VBAT              (6)
  *         @arg @ref ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  *         (8) On STM32G4, fast channel allows: 2.5 (sampling) + 12.5 (conversion) = 15 ADC clock cycles (fADC) to
  *             convert in 12-bit resolution.
  *             Other channels are slow channels  allows: 6.5 (sampling) + 12.5 (conversion) = 19 ADC clock cycles
  *            (fADC) to convert in 12-bit resolution.\n
  * @retval Returned value can be one of the following values:
  *         @arg @ref ADC_CHANNEL_0
  *         @arg @ref ADC_CHANNEL_1
  *         @arg @ref ADC_CHANNEL_2
  *         @arg @ref ADC_CHANNEL_3
  *         @arg @ref ADC_CHANNEL_4
  *         @arg @ref ADC_CHANNEL_5
  *         @arg @ref ADC_CHANNEL_6
  *         @arg @ref ADC_CHANNEL_7
  *         @arg @ref ADC_CHANNEL_8
  *         @arg @ref ADC_CHANNEL_9
  *         @arg @ref ADC_CHANNEL_10
  *         @arg @ref ADC_CHANNEL_11
  *         @arg @ref ADC_CHANNEL_12
  *         @arg @ref ADC_CHANNEL_13
  *         @arg @ref ADC_CHANNEL_14
  *         @arg @ref ADC_CHANNEL_15
  *         @arg @ref ADC_CHANNEL_16
  *         @arg @ref ADC_CHANNEL_17
  *         @arg @ref ADC_CHANNEL_18
  */
#define __HAL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL(__CHANNEL__) __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL((__CHANNEL__))


/**
  * @brief  Helper macro to determine whether the internal channel
  *         selected is available on the ADC instance selected.
  * @note   The channel parameter must be a value defined from parameter
  *         definition of a ADC internal channel (ADC_CHANNEL_VREFINT,
  *         ADC_CHANNEL_TEMPSENSOR, ...),
  *         must not be a value defined from parameter definition of
  *         ADC external channel (ADC_CHANNEL_1, ADC_CHANNEL_2, ...)
  *         or a value from functions where a channel number is
  *         returned from ADC registers,
  *         because internal and external channels share the same channel
  *         number in ADC registers. The differentiation is made only with
  *         parameters definitions of driver.
  * @param  __ADC_INSTANCE__ ADC instance
  * @param  __CHANNEL__ This parameter can be one of the following values:
  *         @arg @ref ADC_CHANNEL_VREFINT           (7)
  *         @arg @ref ADC_CHANNEL_TEMPSENSOR_ADC1   (1)
  *         @arg @ref ADC_CHANNEL_TEMPSENSOR_ADC5   (5)
  *         @arg @ref ADC_CHANNEL_VBAT              (6)
  *         @arg @ref ADC_CHANNEL_VOPAMP1           (1)
  *         @arg @ref ADC_CHANNEL_VOPAMP2           (2)
  *         @arg @ref ADC_CHANNEL_VOPAMP3_ADC2      (2)
  *         @arg @ref ADC_CHANNEL_VOPAMP3_ADC3      (3)
  *         @arg @ref ADC_CHANNEL_VOPAMP4           (5)
  *         @arg @ref ADC_CHANNEL_VOPAMP5           (5)
  *         @arg @ref ADC_CHANNEL_VOPAMP6           (4)
  *
  *         (1) On STM32G4, parameter available only on ADC instance: ADC1.\n
  *         (2) On STM32G4, parameter available only on ADC instance: ADC2.\n
  *         (3) On STM32G4, parameter available only on ADC instance: ADC3.\n
  *         (4) On STM32G4, parameter available only on ADC instance: ADC4.\n
  *         (5) On STM32G4, parameter available only on ADC instance: ADC5.\n
  *         (6) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC5.\n
  *         (7) On STM32G4, parameter available only on ADC instances: ADC1, ADC3, ADC4, ADC5.\n
  *             On this STM32 series, all ADCx are not available on all devices. Refer to device datasheet
  *             for more details.
  * @retval Value "0" if the internal channel selected is not available on the ADC instance selected.
  *         Value "1" if the internal channel selected is available on the ADC instance selected.
  */
#define __HAL_ADC_IS_CHANNEL_INTERNAL_AVAILABLE(__ADC_INSTANCE__,__CHANNEL__) __LL_ADC_IS_CHANNEL_INTERNAL_AVAILABLE((__ADC_INSTANCE__), (__CHANNEL__))



/**
  * @brief  Helper macro to get the ADC multimode conversion data of ADC master
  *         or ADC slave from raw value with both ADC conversion data concatenated.
  * @note   This macro is intended to be used when multimode transfer by DMA
  *         is enabled: refer to function @ref LL_ADC_SetMultiDMATransfer().
  *         In this case the transferred data need to processed with this macro
  *         to separate the conversion data of ADC master and ADC slave.
  * @param  __ADC_MULTI_MASTER_SLAVE__ This parameter can be one of the following values:
  *         @arg @ref LL_ADC_MULTI_MASTER
  *         @arg @ref LL_ADC_MULTI_SLAVE
  * @param  __ADC_MULTI_CONV_DATA__ Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
  */
#define __HAL_ADC_MULTI_CONV_DATA_MASTER_SLAVE(__ADC_MULTI_MASTER_SLAVE__,__ADC_MULTI_CONV_DATA__) __LL_ADC_MULTI_CONV_DATA_MASTER_SLAVE((__ADC_MULTI_MASTER_SLAVE__), (__ADC_MULTI_CONV_DATA__))



/**
  * @brief  Helper macro to select the ADC common instance
  *         to which is belonging the selected ADC instance.
  * @note   ADC common register instance can be used for:
  *         - Set parameters common to several ADC instances
  *         - Multimode (for devices with several ADC instances)
  *         Refer to functions having argument "ADCxy_COMMON" as parameter.
  * @param  __ADCx__ ADC instance
  * @retval ADC common register instance
  */
#define __HAL_ADC_COMMON_INSTANCE(__ADCx__) __LL_ADC_COMMON_INSTANCE((__ADCx__))


/**
  * @brief  Helper macro to check if all ADC instances sharing the same
  *         ADC common instance are disabled.
  * @note   This check is required by functions with setting conditioned to
  *         ADC state:
  *         All ADC instances of the ADC common group must be disabled.
  *         Refer to functions having argument "ADCxy_COMMON" as parameter.
  * @note   On devices with only 1 ADC common instance, parameter of this macro
  *         is useless and can be ignored (parameter kept for compatibility
  *         with devices featuring several ADC common instances).
  * @param  __ADCXY_COMMON__ ADC common instance
  *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
  * @retval Value "0" if all ADC instances sharing the same ADC common instance
  *         are disabled.
  *         Value "1" if at least one ADC instance sharing the same ADC common instance
  *         is enabled.
  */
#define __HAL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__ADCXY_COMMON__) __LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE((__ADCXY_COMMON__))


/**
  * @brief  Helper macro to define the ADC conversion data full-scale digital
  *         value corresponding to the selected ADC resolution.
  * @note   ADC conversion data full-scale corresponds to voltage range
  *         determined by analog voltage references Vref+ and Vref-
  *         (refer to reference manual).
  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
  *         @arg @ref ADC_RESOLUTION_12B
  *         @arg @ref ADC_RESOLUTION_10B
  *         @arg @ref ADC_RESOLUTION_8B
  *         @arg @ref ADC_RESOLUTION_6B
  * @retval ADC conversion data full-scale digital value
  */
#define __HAL_ADC_DIGITAL_SCALE(__ADC_RESOLUTION__) __LL_ADC_DIGITAL_SCALE((__ADC_RESOLUTION__))


/**
  * @brief  Helper macro to convert the ADC conversion data from
  *         a resolution to another resolution.
  * @param  __DATA__ ADC conversion data to be converted
  * @param  __ADC_RESOLUTION_CURRENT__ Resolution of to the data to be converted
  *         This parameter can be one of the following values:
  *         @arg @ref ADC_RESOLUTION_12B
  *         @arg @ref ADC_RESOLUTION_10B
  *         @arg @ref ADC_RESOLUTION_8B
  *         @arg @ref ADC_RESOLUTION_6B
  * @param  __ADC_RESOLUTION_TARGET__ Resolution of the data after conversion
  *         This parameter can be one of the following values:
  *         @arg @ref ADC_RESOLUTION_12B
  *         @arg @ref ADC_RESOLUTION_10B
  *         @arg @ref ADC_RESOLUTION_8B
  *         @arg @ref ADC_RESOLUTION_6B
  * @retval ADC conversion data to the requested resolution
  */
#define __HAL_ADC_CONVERT_DATA_RESOLUTION(__DATA__,__ADC_RESOLUTION_CURRENT__,__ADC_RESOLUTION_TARGET__) __LL_ADC_CONVERT_DATA_RESOLUTION((__DATA__), (__ADC_RESOLUTION_CURRENT__), (__ADC_RESOLUTION_TARGET__))






/**
  * @brief  Helper macro to calculate the voltage (unit: mVolt)
  *         corresponding to a ADC conversion data (unit: digital value).
  * @note   Analog reference voltage (Vref+) must be either known from
  *         user board environment or can be calculated using ADC measurement
  *         and ADC helper macro @ref __LL_ADC_CALC_VREFANALOG_VOLTAGE().
  * @param  __VREFANALOG_VOLTAGE__ Analog reference voltage (unit: mV)
  * @param  __ADC_DATA__ ADC conversion data (resolution 12 bits)
  *                       (unit: digital value).
  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
  *         @arg @ref ADC_RESOLUTION_12B
  *         @arg @ref ADC_RESOLUTION_10B
  *         @arg @ref ADC_RESOLUTION_8B
  *         @arg @ref ADC_RESOLUTION_6B
  * @retval ADC conversion data equivalent voltage value (unit: mVolt)
  */
#define __HAL_ADC_CALC_DATA_TO_VOLTAGE(__VREFANALOG_VOLTAGE__,__ADC_DATA__,__ADC_RESOLUTION__) __LL_ADC_CALC_DATA_TO_VOLTAGE((__VREFANALOG_VOLTAGE__), (__ADC_DATA__), (__ADC_RESOLUTION__))






/**
  * @brief  Helper macro to calculate the voltage (unit: mVolt)
  *         corresponding to a ADC conversion data (unit: digital value)
  *         in differential ended mode.
  * @note   Analog reference voltage (Vref+) must be either known from
  *         user board environment or can be calculated using ADC measurement
  *         and ADC helper macro @ref __LL_ADC_CALC_VREFANALOG_VOLTAGE().
  * @param  __VREFANALOG_VOLTAGE__ Analog reference voltage (unit: mV)
  * @param  __ADC_DATA__ ADC conversion data (resolution 12 bits)
  *                       (unit: digital value).
  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
  *         @arg @ref ADC_RESOLUTION_12B
  *         @arg @ref ADC_RESOLUTION_10B
  *         @arg @ref ADC_RESOLUTION_8B
  *         @arg @ref ADC_RESOLUTION_6B
  * @retval ADC conversion data equivalent voltage value (unit: mVolt)
  */
#define __HAL_ADC_CALC_DIFF_DATA_TO_VOLTAGE(__VREFANALOG_VOLTAGE__,__ADC_DATA__,__ADC_RESOLUTION__) __LL_ADC_CALC_DIFF_DATA_TO_VOLTAGE((__VREFANALOG_VOLTAGE__), (__ADC_DATA__), (__ADC_RESOLUTION__))






/**
  * @brief  Helper macro to calculate analog reference voltage (Vref+)
  *         (unit: mVolt) from ADC conversion data of internal voltage
  *         reference VrefInt.
  * @note   Computation is using VrefInt calibration value
  *         stored in system memory for each device during production.
  * @note   This voltage depends on user board environment: voltage level
  *         connected to pin Vref+.
  *         On devices with small package, the pin Vref+ is not present
  *         and internally bonded to pin Vdda.
  * @note   On this STM32 series, calibration data of internal voltage reference
  *         VrefInt corresponds to a resolution of 12 bits,
  *         this is the recommended ADC resolution to convert voltage of
  *         internal voltage reference VrefInt.
  *         Otherwise, this macro performs the processing to scale
  *         ADC conversion data to 12 bits.
  * @param  __VREFINT_ADC_DATA__ ADC conversion data (resolution 12 bits)
  *         of internal voltage reference VrefInt (unit: digital value).
  * @param  __ADC_RESOLUTION__ This parameter can be one of the following values:
  *         @arg @ref ADC_RESOLUTION_12B
  *         @arg @ref ADC_RESOLUTION_10B
  *         @arg @ref ADC_RESOLUTION_8B
  *         @arg @ref ADC_RESOLUTION_6B
  * @retval Analog reference voltage (unit: mV)
  */
#define __HAL_ADC_CALC_VREFANALOG_VOLTAGE(__VREFINT_ADC_DATA__,__ADC_RESOLUTION__) __LL_ADC_CALC_VREFANALOG_VOLTAGE((__VREFINT_ADC_DATA__), (__ADC_RESOLUTION__))




/**
  * @brief  Helper macro to calculate the temperature (unit: degree Celsius)
  *         from ADC conversion data of internal temperature sensor.
  * @note   Computation is using temperature sensor calibration values
  *         stored in system memory for each device during production.
  * @note   Calculation formula:
  *           Temperature = ((TS_ADC_DATA - TS_CAL1)
  *                           * (TS_CAL2_TEMP - TS_CAL1_TEMP))
  *                         / (TS_CAL2 - TS_CAL1) + TS_CAL1_TEMP
  *           with TS_ADC_DATA = temperature sensor raw data measured by ADC
  *                Avg_Slope = (TS_CAL2 - TS_CAL1)
  *                            / (TS_CAL2_TEMP - TS_CAL1_TEMP)
  *                TS_CAL1   = equivalent TS_ADC_DATA at temperature
  *                            TEMP_DEGC_CAL1 (calibrated in factory)
  *                TS_CAL2   = equivalent TS_ADC_DATA at temperature
  *                            TEMP_DEGC_CAL2 (calibrated in factory)
  *         Caution: Calculation relevancy under reserve that calibration
  *                  parameters are correct (address and data).
  *                  To calculate temperature using temperature sensor
  *                  datasheet typical values (generic values less, therefore
  *                  less accurate than calibrated values),
  *                  use helper macro @ref __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS().
  * @note   As calculation input, the analog reference voltage (Vref+) must be
  *         defined as it impacts the ADC LSB equivalent voltage.
  * @note   Analog reference voltage (Vref+) must be either known from
  *         user board environment or can be calculated using ADC measurement
  *         and ADC helper macro @ref __LL_ADC_CALC_VREFANALOG_VOLTAGE().
  * @note   On this STM32 series, calibration data of temperature sensor
  *         corresponds to a resolution of 12 bits,
  *         this is the recommended ADC resolution to convert voltage of
  *         temperature sensor.
  *         Otherwise, this macro performs the processing to scale
  *         ADC conversion data to 12 bits.
  * @param  __VREFANALOG_VOLTAGE__  Analog reference voltage (unit: mV)
  * @param  __TEMPSENSOR_ADC_DATA__ ADC conversion data of internal
  *                                 temperature sensor (unit: digital value).
  * @param  __ADC_RESOLUTION__      ADC resolution at which internal temperature
  *                                 sensor voltage has been measured.
  *         This parameter can be one of the following values:
  *         @arg @ref ADC_RESOLUTION_12B
  *         @arg @ref ADC_RESOLUTION_10B
  *         @arg @ref ADC_RESOLUTION_8B
  *         @arg @ref ADC_RESOLUTION_6B
  * @retval Temperature (unit: degree Celsius)
  */
#define __HAL_ADC_CALC_TEMPERATURE(__VREFANALOG_VOLTAGE__,__TEMPSENSOR_ADC_DATA__,__ADC_RESOLUTION__) __LL_ADC_CALC_TEMPERATURE((__VREFANALOG_VOLTAGE__), (__TEMPSENSOR_ADC_DATA__), (__ADC_RESOLUTION__))






/**
  * @brief  Helper macro to calculate the temperature (unit: degree Celsius)
  *         from ADC conversion data of internal temperature sensor.
  * @note   Computation is using temperature sensor typical values
  *         (refer to device datasheet).
  * @note   Calculation formula:
  *           Temperature = (TS_TYP_CALx_VOLT(uV) - TS_ADC_DATA * Conversion_uV)
  *                         / Avg_Slope + CALx_TEMP
  *           with TS_ADC_DATA      = temperature sensor raw data measured by ADC
  *                                   (unit: digital value)
  *                Avg_Slope        = temperature sensor slope
  *                                   (unit: uV/Degree Celsius)
  *                TS_TYP_CALx_VOLT = temperature sensor digital value at
  *                                   temperature CALx_TEMP (unit: mV)
  *         Caution: Calculation relevancy under reserve the temperature sensor
  *                  of the current device has characteristics in line with
  *                  datasheet typical values.
  *                  If temperature sensor calibration values are available on
  *                  on this device (presence of macro __LL_ADC_CALC_TEMPERATURE()),
  *                  temperature calculation will be more accurate using
  *                  helper macro @ref __LL_ADC_CALC_TEMPERATURE().
  * @note   As calculation input, the analog reference voltage (Vref+) must be
  *         defined as it impacts the ADC LSB equivalent voltage.
  * @note   Analog reference voltage (Vref+) must be either known from
  *         user board environment or can be calculated using ADC measurement
  *         and ADC helper macro @ref __LL_ADC_CALC_VREFANALOG_VOLTAGE().
  * @note   ADC measurement data must correspond to a resolution of 12bits
  *         (full scale digital value 4095). If not the case, the data must be
  *         preliminarily rescaled to an equivalent resolution of 12 bits.
  * @param  __TEMPSENSOR_TYP_AVGSLOPE__    Device datasheet data: Temperature sensor slope typical value
                                           (unit: uV/DegCelsius).
  *                                        On STM32G4, refer to device datasheet parameter "Avg_Slope".
  * @param  __TEMPSENSOR_TYP_CALX_V__      Device datasheet data: Temperature sensor voltage typical value (at
                                           temperature and Vref+ defined in parameters below) (unit: mV).
  *                                        On STM32G4, refer to device datasheet parameter "V30"
                                           (corresponding to TS_CAL1).
  * @param  __TEMPSENSOR_CALX_TEMP__      Device datasheet data: Temperature at which temperature sensor voltage (see
                                                                 parameter above) is corresponding (unit: mV)
  * @param  __VREFANALOG_VOLTAGE__        Analog voltage reference (Vref+) voltage (unit: mV)
  * @param  __TEMPSENSOR_ADC_DATA__       ADC conversion data of internal temperature sensor (unit: digital value).
  * @param  __ADC_RESOLUTION__            ADC resolution at which internal temperature sensor voltage has been measured.
  *         This parameter can be one of the following values:
  *         @arg @ref ADC_RESOLUTION_12B
  *         @arg @ref ADC_RESOLUTION_10B
  *         @arg @ref ADC_RESOLUTION_8B
  *         @arg @ref ADC_RESOLUTION_6B
  * @retval Temperature (unit: degree Celsius)
  */
#define __HAL_ADC_CALC_TEMPERATURE_TYP_PARAMS(__TEMPSENSOR_TYP_AVGSLOPE__,__TEMPSENSOR_TYP_CALX_V__,__TEMPSENSOR_CALX_TEMP__,__VREFANALOG_VOLTAGE__,__TEMPSENSOR_ADC_DATA__,__ADC_RESOLUTION__) __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS((__TEMPSENSOR_TYP_AVGSLOPE__), (__TEMPSENSOR_TYP_CALX_V__), (__TEMPSENSOR_CALX_TEMP__), (__VREFANALOG_VOLTAGE__), (__TEMPSENSOR_ADC_DATA__), (__ADC_RESOLUTION__))
# 2188 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc.h"

/**
  * @}
  */

/**
  * @}
  */

/* Include ADC HAL Extended module */
# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_adc_ex.h
  * @author  MCD Application Team
  * @brief   Header file of ADC HAL extended module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_ADC_EX_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup ADCEx
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/** @defgroup ADCEx_Exported_Types ADC Extended Exported Types
  * @{
  */

/**
  * @brief  ADC Injected Conversion Oversampling structure definition
  */
typedef struct
{
  uint32_t Ratio;                         /*!< Configures the oversampling ratio.
                                               This parameter can be a value of @ref ADC_HAL_EC_OVS_RATIO */

  uint32_t RightBitShift;                 /*!< Configures the division coefficient for the Oversampler.
                                               This parameter can be a value of @ref ADC_HAL_EC_OVS_SHIFT */
} ADC_InjOversamplingTypeDef;

/**
  * @brief  Structure definition of ADC group injected and ADC channel affected to ADC group injected
  * @note   Parameters of this structure are shared within 2 scopes:
  *          - Scope channel: InjectedChannel, InjectedRank, InjectedSamplingTime , InjectedSingleDiff,
  *            InjectedOffsetNumber, InjectedOffset, InjectedOffsetSign, InjectedOffsetSaturation
  *          - Scope ADC group injected (affects all channels of injected group): InjectedNbrOfConversion,
  *            InjectedDiscontinuousConvMode,
  *            AutoInjectedConv, QueueInjectedContext, ExternalTrigInjecConv, ExternalTrigInjecConvEdge,
  *            InjecOversamplingMode, InjecOversampling.
  * @note   The setting of these parameters by function HAL_ADCEx_InjectedConfigChannel() is conditioned to ADC state.
  *         ADC state can be either:
  *          - For all parameters: ADC disabled (this is the only possible ADC state to modify parameter
  *            'InjectedSingleDiff')
  *          - For parameters 'InjectedDiscontinuousConvMode', 'QueueInjectedContext', 'InjecOversampling': ADC enabled
  *            without conversion on going on injected group.
  *          - For parameters 'InjectedSamplingTime', 'InjectedOffset', 'InjectedOffsetNumber', 'InjectedOffsetSign',
  *            'InjectedOffsetSaturation', 'AutoInjectedConv': ADC enabled without conversion on going on regular and
  *            injected groups.
  *          - For parameters 'InjectedChannel', 'InjectedRank', 'InjectedNbrOfConversion', 'ExternalTrigInjecConv',
  *            'ExternalTrigInjecConvEdge': ADC enabled and while conversion on going
  *            on ADC groups regular and injected.
  *         If ADC is not in the appropriate state to modify some parameters, these parameters setting is bypassed
  *         without error reporting (as it can be the expected behavior in case of intended action to update another
  *         parameter (which fulfills the ADC state condition) on the fly).
  */
typedef struct
{
  uint32_t InjectedChannel;               /*!< Specifies the channel to configure into ADC group injected.
                                               This parameter can be a value of @ref ADC_HAL_EC_CHANNEL
                                               Note: Depending on devices and ADC instances, some channels may not be
                                                     available on device package pins. Refer to device datasheet for
                                                     channels availability. */

  uint32_t InjectedRank;                  /*!< Specifies the rank in the ADC group injected sequencer.
                                               This parameter must be a value of @ref ADC_INJ_SEQ_RANKS.
                                               Note: to disable a channel or change order of conversion sequencer,
                                                     rank containing a previous channel setting can be overwritten by
                                                     the new channel setting (or parameter number of conversions
                                                     adjusted) */

  uint32_t InjectedSamplingTime;          /*!< Sampling time value to be set for the selected channel.
                                               Unit: ADC clock cycles.
                                               Conversion time is the addition of sampling time and processing time
                                               (12.5 ADC clock cycles at ADC resolution 12 bits, 10.5 cycles at 10 bits,
                                               8.5 cycles at 8 bits, 6.5 cycles at 6 bits).
                                               This parameter can be a value of @ref ADC_HAL_EC_CHANNEL_SAMPLINGTIME.
                                               Caution: This parameter applies to a channel that can be used in a
                                                        regular and/or injected group. It overwrites the last setting.
                                               Note: In case of usage of internal measurement channels (VrefInt, ...),
                                                     sampling time constraints must be respected (sampling time can be
                                                     adjusted in function of ADC clock frequency and sampling time
                                                     setting). Refer to device datasheet for timings values. */

  uint32_t InjectedSingleDiff;            /*!< Selection of single-ended or differential input.
                                               In differential mode: Differential measurement is between the selected
                                               channel 'i' (positive input) and channel 'i+1' (negative input).
                                               Only channel 'i' has to be configured, channel 'i+1' is configured
                                               automatically.
                                               This parameter must be a value of
                                               @ref ADC_HAL_EC_CHANNEL_SINGLE_DIFF_ENDING.
                                               Caution: This parameter applies to a channel that can be used in a
                                               regular and/or injected group. It overwrites the last setting.
                                               Note: Refer to Reference Manual to ensure the selected channel is
                                                     available in differential mode.
                                               Note: When configuring a channel 'i' in differential mode, the channel
                                                     'i+1' is not usable separately.
                                               Note: This parameter must be modified when ADC is disabled (before ADC
                                                     start conversion or after ADC stop conversion).
                                               If ADC is enabled, this parameter setting is bypassed without error
                                               reporting (as it can be the expected behavior in case of another
                                               parameter update on the fly) */

  uint32_t InjectedOffsetNumber;          /*!< Selects the offset number.
                                               This parameter can be a value of @ref ADC_HAL_EC_OFFSET_NB.
                                               Caution: Only one offset is allowed per channel. This parameter
                                                        overwrites the last setting. */

  uint32_t InjectedOffset;                /*!< Defines the offset to be applied on the raw converted data.
                                               Offset value must be a positive number.
                                               Depending of ADC resolution selected (12, 10, 8 or 6 bits), this
                                               parameter must be a number between Min_Data = 0x000 and Max_Data = 0xFFF,
                                               0x3FF, 0xFF or 0x3F respectively.
                                               Note: This parameter must be modified when no conversion is on going
                                                     on both regular and injected groups (ADC disabled, or ADC enabled
                                                     without continuous mode or external trigger that could launch a
                                                     conversion). */

  uint32_t InjectedOffsetSign;                /*!< Define if the offset should be subtracted (negative sign) or added
                                                  (positive sign) from or to the raw converted data.
                                                  This parameter can be a value of @ref ADCEx_OffsetSign.
                                                  Note: This parameter must be modified when no conversion is on going
                                                        on both regular and injected groups (ADC disabled, or ADC
                                                        enabled without continuous mode or external trigger that could
                                                        launch a conversion). */
  FunctionalState InjectedOffsetSaturation;   /*!< Define if the offset should be saturated upon under or over flow.
                                               This parameter value can be ENABLE or DISABLE.
                                               Note: This parameter must be modified when no conversion is on going
                                                     on both regular and injected groups (ADC disabled, or ADC enabled
                                                     without continuous mode or external trigger that could launch a
                                                     conversion). */

  uint32_t InjectedNbrOfConversion;       /*!< Specifies the number of ranks that will be converted within the ADC group
                                               injected sequencer.
                                               To use the injected group sequencer and convert several ranks, parameter
                                               'ScanConvMode' must be enabled.
                                               This parameter must be a number between Min_Data = 1 and Max_Data = 4.
                                               Caution: this setting impacts the entire injected group. Therefore,
                                               call of HAL_ADCEx_InjectedConfigChannel() to configure a channel on
                                               injected group can impact the configuration of other channels previously
                                               set. */

  FunctionalState InjectedDiscontinuousConvMode; /*!< Specifies whether the conversions sequence of ADC group injected
                                               is performed in Complete-sequence/Discontinuous-sequence
                                               (main sequence subdivided in successive parts).
                                               Discontinuous mode is used only if sequencer is enabled (parameter
                                               'ScanConvMode'). If sequencer is disabled, this parameter is discarded.
                                               Discontinuous mode can be enabled only if continuous mode is disabled.
                                               This parameter can be set to ENABLE or DISABLE.
                                               Note: This parameter must be modified when ADC is disabled (before ADC
                                               start conversion or after ADC stop conversion).
                                               Note: For injected group, discontinuous mode converts the sequence
                                               channel by channel (discontinuous length fixed to 1 rank).
                                               Caution: this setting impacts the entire injected group. Therefore,
                                                        call of HAL_ADCEx_InjectedConfigChannel() to
                                                        configure a channel on injected group can impact the
                                                        configuration of other channels previously set. */

  FunctionalState AutoInjectedConv;       /*!< Enables or disables the selected ADC group injected automatic conversion
                                               after regular one
                                               This parameter can be set to ENABLE or DISABLE.
                                               Note: To use Automatic injected conversion, discontinuous mode must
                                                     be disabled ('DiscontinuousConvMode' and
                                                     'InjectedDiscontinuousConvMode' set to DISABLE)
                                               Note: To use Automatic injected conversion, injected group external
                                                     triggers must be disabled ('ExternalTrigInjecConv' set to
                                                     ADC_INJECTED_SOFTWARE_START)
                                               Note: In case of DMA used with regular group: if DMA configured in
                                                     normal mode (single shot) JAUTO will be stopped upon DMA transfer
                                                     complete.
                                                     To maintain JAUTO always enabled, DMA must be configured in
                                                     circular mode.
                                               Caution: this setting impacts the entire injected group. Therefore,
                                                        call of HAL_ADCEx_InjectedConfigChannel() to configure a channel
                                                        on injected group can impact the configuration of other channels
                                                        previously set. */

  FunctionalState QueueInjectedContext;   /*!< Specifies whether the context queue feature is enabled.
                                               This parameter can be set to ENABLE or DISABLE.
                                               If context queue is enabled, injected sequencer&channels configurations
                                               are queued on up to 2 contexts. If a
                                               new injected context is set when queue is full, error is triggered by
                                               interruption and through function
                                               'HAL_ADCEx_InjectedQueueOverflowCallback'.
                                               Caution: This feature request that the sequence is fully configured
                                                        before injected conversion start.
                                                        Therefore, configure channels with as many calls to
                                                        HAL_ADCEx_InjectedConfigChannel() as the
                                                        'InjectedNbrOfConversion' parameter.
                                               Caution: this setting impacts the entire injected group. Therefore,
                                                        call of HAL_ADCEx_InjectedConfigChannel() to
                                                        configure a channel on injected group can impact the
                                                        configuration of other channels previously set.
                                               Note: This parameter must be modified when ADC is disabled (before ADC
                                                     start conversion or after ADC stop conversion). */

  uint32_t ExternalTrigInjecConv;         /*!< Selects the external event used to trigger the conversion start of
                                               injected group.
                                               If set to ADC_INJECTED_SOFTWARE_START, external triggers are disabled
                                               and software trigger is used instead.
                                               This parameter can be a value of
                                               @ref ADC_injected_external_trigger_source.
                                               Caution: this setting impacts the entire injected group. Therefore,
                                                        call of HAL_ADCEx_InjectedConfigChannel() to configure a channel
                                                        on injected group can impact the configuration of other channels
                                                        previously set. */

  uint32_t ExternalTrigInjecConvEdge;     /*!< Selects the external trigger edge of injected group.
                                               This parameter can be a value of @ref ADC_injected_external_trigger_edge.
                                               If trigger source is set to ADC_INJECTED_SOFTWARE_START, this parameter
                                               is discarded.
                                               Caution: this setting impacts the entire injected group. Therefore,
                                                        call of HAL_ADCEx_InjectedConfigChannel() to
                                                        configure a channel on injected group can impact the
                                                        configuration of other channels previously set. */

  FunctionalState InjecOversamplingMode;         /*!< Specifies whether the oversampling feature is enabled or disabled.
                                                      This parameter can be set to ENABLE or DISABLE.
                                                      Note: This parameter can be modified only if there is no
                                                      conversion is ongoing (both ADSTART and JADSTART cleared). */

  ADC_InjOversamplingTypeDef  InjecOversampling; /*!< Specifies the Oversampling parameters.
                                                      Caution: this setting overwrites the previous oversampling
                                                               configuration if oversampling already enabled.
                                                      Note: This parameter can be modified only if there is no
                                                            conversion is ongoing (both ADSTART and JADSTART cleared).*/
} ADC_InjectionConfTypeDef;


/**
  * @brief  Structure definition of ADC multimode
  * @note   The setting of these parameters by function HAL_ADCEx_MultiModeConfigChannel() is conditioned by ADCs state
  *         (both Master and Slave ADCs).
  *         Both Master and Slave ADCs must be disabled.
  */
typedef struct
{
  uint32_t Mode;              /*!< Configures the ADC to operate in independent or multimode.
                                   This parameter can be a value of @ref ADC_HAL_EC_MULTI_MODE. */

  uint32_t DMAAccessMode;     /*!< Configures the DMA mode for multimode ADC:
                                   selection whether 2 DMA channels (each ADC uses its own DMA channel) or 1 DMA channel
                                   (one DMA channel for both ADC, DMA of ADC master).
                                   This parameter can be a value of @ref ADC_HAL_EC_MULTI_DMA_TRANSFER_RESOLUTION. */

  uint32_t TwoSamplingDelay;  /*!< Configures the Delay between 2 sampling phases.
                                   This parameter can be a value of @ref ADC_HAL_EC_MULTI_TWOSMP_DELAY.
                                   Delay range depends on selected resolution:
                                    from 1 to 12 clock cycles for 12 bits, from 1 to 10 clock cycles for 10 bits,
                                    from 1 to 8 clock cycles for 8 bits, from 1 to 6 clock cycles for 6 bits.     */
} ADC_MultiModeTypeDef;


/**
  * @}
  */

/* Exported constants --------------------------------------------------------*/

/** @defgroup ADCEx_Exported_Constants ADC Extended Exported Constants
  * @{
  */

/** @defgroup ADC_injected_external_trigger_source ADC group injected trigger source
  * @{
  */
/* ADC group regular trigger sources for all ADC instances */
#define ADC_INJECTED_SOFTWARE_START (LL_ADC_INJ_TRIG_SOFTWARE)

#define ADC_EXTERNALTRIGINJEC_T1_TRGO (LL_ADC_INJ_TRIG_EXT_TIM1_TRGO)

#define ADC_EXTERNALTRIGINJEC_T1_TRGO2 (LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2)

#define ADC_EXTERNALTRIGINJEC_T1_CC3 (LL_ADC_INJ_TRIG_EXT_TIM1_CH3)

#define ADC_EXTERNALTRIGINJEC_T1_CC4 (LL_ADC_INJ_TRIG_EXT_TIM1_CH4)

#define ADC_EXTERNALTRIGINJEC_T2_TRGO (LL_ADC_INJ_TRIG_EXT_TIM2_TRGO)

#define ADC_EXTERNALTRIGINJEC_T2_CC1 (LL_ADC_INJ_TRIG_EXT_TIM2_CH1)

#define ADC_EXTERNALTRIGINJEC_T3_TRGO (LL_ADC_INJ_TRIG_EXT_TIM3_TRGO)

#define ADC_EXTERNALTRIGINJEC_T3_CC1 (LL_ADC_INJ_TRIG_EXT_TIM3_CH1)

#define ADC_EXTERNALTRIGINJEC_T3_CC3 (LL_ADC_INJ_TRIG_EXT_TIM3_CH3)

#define ADC_EXTERNALTRIGINJEC_T3_CC4 (LL_ADC_INJ_TRIG_EXT_TIM3_CH4)

#define ADC_EXTERNALTRIGINJEC_T4_TRGO (LL_ADC_INJ_TRIG_EXT_TIM4_TRGO)

#define ADC_EXTERNALTRIGINJEC_T4_CC3 (LL_ADC_INJ_TRIG_EXT_TIM4_CH3)

#define ADC_EXTERNALTRIGINJEC_T4_CC4 (LL_ADC_INJ_TRIG_EXT_TIM4_CH4)

#define ADC_EXTERNALTRIGINJEC_T6_TRGO (LL_ADC_INJ_TRIG_EXT_TIM6_TRGO)

#define ADC_EXTERNALTRIGINJEC_T7_TRGO (LL_ADC_INJ_TRIG_EXT_TIM7_TRGO)

#define ADC_EXTERNALTRIGINJEC_T8_TRGO (LL_ADC_INJ_TRIG_EXT_TIM8_TRGO)

#define ADC_EXTERNALTRIGINJEC_T8_TRGO2 (LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2)

#define ADC_EXTERNALTRIGINJEC_T8_CC2 (LL_ADC_INJ_TRIG_EXT_TIM8_CH2)

#define ADC_EXTERNALTRIGINJEC_T8_CC4 (LL_ADC_INJ_TRIG_EXT_TIM8_CH4)

#define ADC_EXTERNALTRIGINJEC_T15_TRGO (LL_ADC_INJ_TRIG_EXT_TIM15_TRGO)

#define ADC_EXTERNALTRIGINJEC_T16_CC1 (LL_ADC_INJ_TRIG_EXT_TIM16_CH1)

#define ADC_EXTERNALTRIGINJEC_T20_TRGO (LL_ADC_INJ_TRIG_EXT_TIM20_TRGO)

#define ADC_EXTERNALTRIGINJEC_T20_TRGO2 (LL_ADC_INJ_TRIG_EXT_TIM20_TRGO2)

#define ADC_EXTERNALTRIGINJEC_T20_CC2 (LL_ADC_INJ_TRIG_EXT_TIM20_CH2)

#define ADC_EXTERNALTRIGINJEC_T20_CC4 (LL_ADC_INJ_TRIG_EXT_TIM20_CH4)

#define ADC_EXTERNALTRIGINJEC_HRTIM_TRG1 (LL_ADC_INJ_TRIG_EXT_HRTIM_TRG1)

#define ADC_EXTERNALTRIGINJEC_HRTIM_TRG2 (LL_ADC_INJ_TRIG_EXT_HRTIM_TRG2)

#define ADC_EXTERNALTRIGINJEC_HRTIM_TRG3 (LL_ADC_INJ_TRIG_EXT_HRTIM_TRG3)

#define ADC_EXTERNALTRIGINJEC_HRTIM_TRG4 (LL_ADC_INJ_TRIG_EXT_HRTIM_TRG4)

#define ADC_EXTERNALTRIGINJEC_HRTIM_TRG5 (LL_ADC_INJ_TRIG_EXT_HRTIM_TRG5)

#define ADC_EXTERNALTRIGINJEC_HRTIM_TRG6 (LL_ADC_INJ_TRIG_EXT_HRTIM_TRG6)

#define ADC_EXTERNALTRIGINJEC_HRTIM_TRG7 (LL_ADC_INJ_TRIG_EXT_HRTIM_TRG7)

#define ADC_EXTERNALTRIGINJEC_HRTIM_TRG8 (LL_ADC_INJ_TRIG_EXT_HRTIM_TRG8)

#define ADC_EXTERNALTRIGINJEC_HRTIM_TRG9 (LL_ADC_INJ_TRIG_EXT_HRTIM_TRG9)

#define ADC_EXTERNALTRIGINJEC_HRTIM_TRG10 (LL_ADC_INJ_TRIG_EXT_HRTIM_TRG10)

#define ADC_EXTERNALTRIGINJEC_EXT_IT3 (LL_ADC_INJ_TRIG_EXT_EXTI_LINE3)

#define ADC_EXTERNALTRIGINJEC_EXT_IT15 (LL_ADC_INJ_TRIG_EXT_EXTI_LINE15)

#define ADC_EXTERNALTRIGINJEC_LPTIM_OUT (LL_ADC_INJ_TRIG_EXT_LPTIM_OUT)

/**
  * @}
  */

/** @defgroup ADC_injected_external_trigger_edge ADC group injected trigger edge (when external trigger is selected)
  * @{
  */
#define ADC_EXTERNALTRIGINJECCONV_EDGE_NONE (0x00000000UL)

#define ADC_EXTERNALTRIGINJECCONV_EDGE_RISING (ADC_JSQR_JEXTEN_0)

#define ADC_EXTERNALTRIGINJECCONV_EDGE_FALLING (ADC_JSQR_JEXTEN_1)

#define ADC_EXTERNALTRIGINJECCONV_EDGE_RISINGFALLING (ADC_JSQR_JEXTEN)

/**
  * @}
  */

/** @defgroup ADC_HAL_EC_CHANNEL_SINGLE_DIFF_ENDING  Channel - Single or differential ending
  * @{
  */
#define ADC_SINGLE_ENDED (LL_ADC_SINGLE_ENDED)
#define ADC_DIFFERENTIAL_ENDED (LL_ADC_DIFFERENTIAL_ENDED)
/**
  * @}
  */

/** @defgroup ADC_HAL_EC_OFFSET_NB  ADC instance - Offset number
  * @{
  */
#define ADC_OFFSET_NONE (ADC_OFFSET_4 + 1U)

#define ADC_OFFSET_1 (LL_ADC_OFFSET_1)


#define ADC_OFFSET_2 (LL_ADC_OFFSET_2)


#define ADC_OFFSET_3 (LL_ADC_OFFSET_3)


#define ADC_OFFSET_4 (LL_ADC_OFFSET_4)


/**
  * @}
  */

/** @defgroup ADCEx_OffsetSign ADC Extended Offset Sign
  * @{
  */
#define ADC_OFFSET_SIGN_NEGATIVE (0x00000000UL)
#define ADC_OFFSET_SIGN_POSITIVE (ADC_OFR1_OFFSETPOS)
/**
  * @}
  */

/** @defgroup ADC_INJ_SEQ_RANKS  ADC group injected - Sequencer ranks
  * @{
  */
#define ADC_INJECTED_RANK_1 (LL_ADC_INJ_RANK_1)
#define ADC_INJECTED_RANK_2 (LL_ADC_INJ_RANK_2)
#define ADC_INJECTED_RANK_3 (LL_ADC_INJ_RANK_3)
#define ADC_INJECTED_RANK_4 (LL_ADC_INJ_RANK_4)
/**
  * @}
  */


/** @defgroup ADC_HAL_EC_MULTI_MODE  Multimode - Mode
  * @{
  */
#define ADC_MODE_INDEPENDENT (LL_ADC_MULTI_INDEPENDENT)

#define ADC_DUALMODE_REGSIMULT (LL_ADC_MULTI_DUAL_REG_SIMULT)

#define ADC_DUALMODE_INTERL (LL_ADC_MULTI_DUAL_REG_INTERL)

#define ADC_DUALMODE_INJECSIMULT (LL_ADC_MULTI_DUAL_INJ_SIMULT)

#define ADC_DUALMODE_ALTERTRIG (LL_ADC_MULTI_DUAL_INJ_ALTERN)


#define ADC_DUALMODE_REGSIMULT_INJECSIMULT (LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM)

#define ADC_DUALMODE_REGSIMULT_ALTERTRIG (LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT)

#define ADC_DUALMODE_REGINTERL_INJECSIMULT (LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM)


/** @defgroup ADC_HAL_EC_MULTI_DMA_TRANSFER_RESOLUTION  Multimode - DMA transfer mode depending on ADC resolution
  * @{
  */
#define ADC_DMAACCESSMODE_DISABLED (0x00000000UL)

#define ADC_DMAACCESSMODE_12_10_BITS (ADC_CCR_MDMA_1)

#define ADC_DMAACCESSMODE_8_6_BITS (ADC_CCR_MDMA)

/**
  * @}
  */

/** @defgroup ADC_HAL_EC_MULTI_TWOSMP_DELAY  Multimode - Delay between two sampling phases
  * @{
  */
#define ADC_TWOSAMPLINGDELAY_1CYCLE (LL_ADC_MULTI_TWOSMP_DELAY_1CYCLE)

#define ADC_TWOSAMPLINGDELAY_2CYCLES (LL_ADC_MULTI_TWOSMP_DELAY_2CYCLES)

#define ADC_TWOSAMPLINGDELAY_3CYCLES (LL_ADC_MULTI_TWOSMP_DELAY_3CYCLES)

#define ADC_TWOSAMPLINGDELAY_4CYCLES (LL_ADC_MULTI_TWOSMP_DELAY_4CYCLES)

#define ADC_TWOSAMPLINGDELAY_5CYCLES (LL_ADC_MULTI_TWOSMP_DELAY_5CYCLES)

#define ADC_TWOSAMPLINGDELAY_6CYCLES (LL_ADC_MULTI_TWOSMP_DELAY_6CYCLES)

#define ADC_TWOSAMPLINGDELAY_7CYCLES (LL_ADC_MULTI_TWOSMP_DELAY_7CYCLES)

#define ADC_TWOSAMPLINGDELAY_8CYCLES (LL_ADC_MULTI_TWOSMP_DELAY_8CYCLES)

#define ADC_TWOSAMPLINGDELAY_9CYCLES (LL_ADC_MULTI_TWOSMP_DELAY_9CYCLES)

#define ADC_TWOSAMPLINGDELAY_10CYCLES (LL_ADC_MULTI_TWOSMP_DELAY_10CYCLES)

#define ADC_TWOSAMPLINGDELAY_11CYCLES (LL_ADC_MULTI_TWOSMP_DELAY_11CYCLES)

#define ADC_TWOSAMPLINGDELAY_12CYCLES (LL_ADC_MULTI_TWOSMP_DELAY_12CYCLES)

/**
  * @}
  */

/**
  * @}
  */


/** @defgroup ADC_HAL_EC_GROUPS  ADC instance - Groups
  * @{
  */
#define ADC_REGULAR_GROUP (LL_ADC_GROUP_REGULAR)

#define ADC_INJECTED_GROUP (LL_ADC_GROUP_INJECTED)

#define ADC_REGULAR_INJECTED_GROUP (LL_ADC_GROUP_REGULAR_INJECTED)
/**
  * @}
  */

/** @defgroup ADC_CFGR_fields ADCx CFGR fields
  * @{
  */
#define ADC_CFGR_FIELDS (ADC_CFGR_AWD1CH | ADC_CFGR_JAUTO | ADC_CFGR_JAWD1EN | ADC_CFGR_AWD1EN | ADC_CFGR_AWD1SGL | ADC_CFGR_JQM | ADC_CFGR_JDISCEN | ADC_CFGR_DISCNUM | ADC_CFGR_DISCEN | ADC_CFGR_AUTDLY | ADC_CFGR_CONT | ADC_CFGR_OVRMOD | ADC_CFGR_EXTEN | ADC_CFGR_EXTSEL | ADC_CFGR_ALIGN | ADC_CFGR_RES | ADC_CFGR_DMACFG | ADC_CFGR_DMAEN )





/**
  * @}
  */

/** @defgroup ADC_SMPR1_fields ADCx SMPR1 fields
  * @{
  */

#define ADC_SMPR1_FIELDS (ADC_SMPR1_SMP9 | ADC_SMPR1_SMP8 | ADC_SMPR1_SMP7 | ADC_SMPR1_SMP6 | ADC_SMPR1_SMP5 | ADC_SMPR1_SMP4 | ADC_SMPR1_SMP3 | ADC_SMPR1_SMP2 | ADC_SMPR1_SMP1 | ADC_SMPR1_SMP0 | ADC_SMPR1_SMPPLUS)









/**
  * @}
  */

/** @defgroup ADC_CFGR_fields_2 ADCx CFGR sub fields
  * @{
  */
/* ADC_CFGR fields of parameters that can be updated when no conversion
   (neither regular nor injected) is on-going  */
#define ADC_CFGR_FIELDS_2 ((ADC_CFGR_DMACFG | ADC_CFGR_AUTDLY))
/**
  * @}
  */

/**
  * @}
  */

/* Exported macros -----------------------------------------------------------*/


/** @defgroup ADCEx_Exported_Macro ADC Extended Exported Macros
  * @{
  */

/** @brief  Force ADC instance in multimode mode independent (multimode disable).
  * @note   This macro must be used only in case of transition from multimode
  *         to mode independent and in case of unknown previous state,
  *         to ensure ADC configuration is in mode independent.
  * @note   Standard way of multimode configuration change is done from
  *         HAL ADC handle of ADC master using function
  *         "HAL_ADCEx_MultiModeConfigChannel(..., ADC_MODE_INDEPENDENT)" )".
  *         Usage of this macro is not the Standard way of multimode
  *         configuration and can lead to have HAL ADC handles status
  *         misaligned. Usage of this macro must be limited to cases
  *         mentioned above.
  * @param __HANDLE__ ADC handle.
  * @retval None
  */
#define ADC_FORCE_MODE_INDEPENDENT(__HANDLE__) LL_ADC_SetMultimode(__LL_ADC_COMMON_INSTANCE((__HANDLE__)->Instance), LL_ADC_MULTI_INDEPENDENT)


/**
  * @}
  */


/* Private macros ------------------------------------------------------------*/

/** @defgroup ADCEx_Private_Macro_internal_HAL_driver ADC Extended Private Macros
  * @{
  */
/* Macro reserved for internal HAL driver usage, not intended to be used in   */
/* code of final user.                                                        */

/**
  * @brief Test if conversion trigger of injected group is software start
  *        or external trigger.
  * @param __HANDLE__ ADC handle.
  * @retval SET (software start) or RESET (external trigger).
  */
#define ADC_IS_SOFTWARE_START_INJECTED(__HANDLE__) (((__HANDLE__)->Instance->JSQR & ADC_JSQR_JEXTEN) == 0UL)


/**
  * @brief Check whether or not ADC is independent.
  * @param __HANDLE__ ADC handle.
  * @note  When multimode feature is not available, the macro always returns SET.
  * @retval SET (ADC is independent) or RESET (ADC is not).
  */

#define ADC_IS_INDEPENDENT(__HANDLE__) ( ( ( ((__HANDLE__)->Instance) == ADC5) )? SET : RESET )






# 637 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h"

/**
  * @brief Set the selected injected Channel rank.
  * @param __CHANNELNB__ Channel number.
  * @param __RANKNB__ Rank number.
  * @retval None
  */
#define ADC_JSQR_RK(__CHANNELNB__,__RANKNB__) ((((__CHANNELNB__) & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << ((__RANKNB__) & ADC_INJ_RANK_ID_JSQR_MASK))



/**
  * @brief Configure ADC injected context queue
  * @param __INJECT_CONTEXT_QUEUE_MODE__ Injected context queue mode.
  * @retval None
  */
#define ADC_CFGR_INJECT_CONTEXT_QUEUE(__INJECT_CONTEXT_QUEUE_MODE__) ((__INJECT_CONTEXT_QUEUE_MODE__) << ADC_CFGR_JQM_Pos)


/**
  * @brief Configure ADC discontinuous conversion mode for injected group
  * @param __INJECT_DISCONTINUOUS_MODE__ Injected discontinuous mode.
  * @retval None
  */
#define ADC_CFGR_INJECT_DISCCONTINUOUS(__INJECT_DISCONTINUOUS_MODE__) ((__INJECT_DISCONTINUOUS_MODE__) << ADC_CFGR_JDISCEN_Pos)


/**
  * @brief Configure ADC discontinuous conversion mode for regular group
  * @param __REG_DISCONTINUOUS_MODE__ Regular discontinuous mode.
  * @retval None
  */
#define ADC_CFGR_REG_DISCONTINUOUS(__REG_DISCONTINUOUS_MODE__) ((__REG_DISCONTINUOUS_MODE__) << ADC_CFGR_DISCEN_Pos)


/**
  * @brief Configure the number of discontinuous conversions for regular group.
  * @param __NBR_DISCONTINUOUS_CONV__ Number of discontinuous conversions.
  * @retval None
  */
#define ADC_CFGR_DISCONTINUOUS_NUM(__NBR_DISCONTINUOUS_CONV__) (((__NBR_DISCONTINUOUS_CONV__) - 1UL) << ADC_CFGR_DISCNUM_Pos)


/**
  * @brief Configure the ADC auto delay mode.
  * @param __AUTOWAIT__ Auto delay bit enable or disable.
  * @retval None
  */
#define ADC_CFGR_AUTOWAIT(__AUTOWAIT__) ((__AUTOWAIT__) << ADC_CFGR_AUTDLY_Pos)

/**
  * @brief Configure ADC continuous conversion mode.
  * @param __CONTINUOUS_MODE__ Continuous mode.
  * @retval None
  */
#define ADC_CFGR_CONTINUOUS(__CONTINUOUS_MODE__) ((__CONTINUOUS_MODE__) << ADC_CFGR_CONT_Pos)

/**
  * @brief Configure the ADC DMA continuous request.
  * @param __DMACONTREQ_MODE__ DMA continuous request mode.
  * @retval None
  */
#define ADC_CFGR_DMACONTREQ(__DMACONTREQ_MODE__) ((__DMACONTREQ_MODE__) << ADC_CFGR_DMACFG_Pos)


/**
  * @brief Configure the ADC DMA continuous request for ADC multimode.
  * @param __DMACONTREQ_MODE__ DMA continuous request mode.
  * @retval None
  */
#define ADC_CCR_MULTI_DMACONTREQ(__DMACONTREQ_MODE__) ((__DMACONTREQ_MODE__) << ADC_CCR_DMACFG_Pos)


/**
  * @brief Shift the offset with respect to the selected ADC resolution.
  * @note   Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0.
  *         If resolution 12 bits, no shift.
  *         If resolution 10 bits, shift of 2 ranks on the left.
  *         If resolution 8 bits, shift of 4 ranks on the left.
  *         If resolution 6 bits, shift of 6 ranks on the left.
  *         Therefore, shift = (12 - resolution) = 12 - (12- (((RES[1:0]) >> 3)*2)).
  * @param __HANDLE__ ADC handle
  * @param __OFFSET__ Value to be shifted
  * @retval None
  */
#define ADC_OFFSET_SHIFT_RESOLUTION(__HANDLE__,__OFFSET__) ((__OFFSET__) << ((((__HANDLE__)->Instance->CFGR & ADC_CFGR_RES) >> 3UL) * 2UL))


/**
  * @brief Shift the AWD1 threshold with respect to the selected ADC resolution.
  * @note  Thresholds have to be left-aligned on bit 11, the LSB (right bits) are set to 0.
  *        If resolution 12 bits, no shift.
  *        If resolution 10 bits, shift of 2 ranks on the left.
  *        If resolution 8 bits, shift of 4 ranks on the left.
  *        If resolution 6 bits, shift of 6 ranks on the left.
  *        Therefore, shift = (12 - resolution) = 12 - (12- (((RES[1:0]) >> 3)*2)).
  * @param __HANDLE__ ADC handle
  * @param __THRESHOLD__ Value to be shifted
  * @retval None
  */
#define ADC_AWD1THRESHOLD_SHIFT_RESOLUTION(__HANDLE__,__THRESHOLD__) ((__THRESHOLD__) << ((((__HANDLE__)->Instance->CFGR & ADC_CFGR_RES) >> 3UL) * 2UL))


/**
  * @brief Shift the AWD2 and AWD3 threshold with respect to the selected ADC resolution.
  * @note  Thresholds have to be left-aligned on bit 7.
  *        If resolution 12 bits, shift of 4 ranks on the right (the 4 LSB are discarded).
  *        If resolution 10 bits, shift of 2 ranks on the right (the 2 LSB are discarded).
  *        If resolution 8 bits, no shift.
  *        If resolution 6 bits, shift of 2 ranks on the left (the 2 LSB are set to 0).
  * @param __HANDLE__ ADC handle
  * @param __THRESHOLD__ Value to be shifted
  * @retval None
  */
#define ADC_AWD23THRESHOLD_SHIFT_RESOLUTION(__HANDLE__,__THRESHOLD__) ((((__HANDLE__)->Instance->CFGR & ADC_CFGR_RES) != (ADC_CFGR_RES_1 | ADC_CFGR_RES_0)) ? ((__THRESHOLD__) >> ((4UL - ((((__HANDLE__)->Instance->CFGR & ADC_CFGR_RES) >> 3UL) * 2UL)) & 0x1FUL)) : ((__THRESHOLD__) << 2UL) )





/**
  * @brief Clear Common Control Register.
  * @param __HANDLE__ ADC handle.
  * @retval None
  */

#define ADC_CLEAR_COMMON_CONTROL_REGISTER(__HANDLE__) CLEAR_BIT(__LL_ADC_COMMON_INSTANCE((__HANDLE__)->Instance)->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC | ADC_CCR_VBATSEL | ADC_CCR_VSENSESEL | ADC_CCR_VREFEN | ADC_CCR_MDMA | ADC_CCR_DMACFG | ADC_CCR_DELAY | ADC_CCR_DUAL)
# 773 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h"



/**
  * @brief Set handle instance of the ADC slave associated to the ADC master.
  * @param __HANDLE_MASTER__ ADC master handle.
  * @param __HANDLE_SLAVE__ ADC slave handle.
  * @note if __HANDLE_MASTER__ is the handle of a slave ADC or an independent ADC, __HANDLE_SLAVE__ instance is
  *       set to NULL.
  * @retval None
  */
#define ADC_MULTI_SLAVE(__HANDLE_MASTER__,__HANDLE_SLAVE__) ( ((__HANDLE_MASTER__)->Instance == ADC1) ? ((__HANDLE_SLAVE__)->Instance = ADC2) : ((__HANDLE_MASTER__)->Instance == ADC3) ? ((__HANDLE_SLAVE__)->Instance = ADC4) : ((__HANDLE_SLAVE__)->Instance = NULL) )
# 793 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h"
# 809 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h"


/**
  * @brief Verify the ADC instance connected to the temperature sensor.
  * @param __HANDLE__ ADC handle.
  * @retval SET (ADC instance is valid) or RESET (ADC instance is invalid)
  */

#define ADC_TEMPERATURE_SENSOR_INSTANCE(__HANDLE__) ((((__HANDLE__)->Instance) == ADC1) || (((__HANDLE__)->Instance) == ADC5))





/**
  * @brief Verify the ADC instance connected to the battery voltage VBAT.
  * @param __HANDLE__ ADC handle.
  * @retval SET (ADC instance is valid) or RESET (ADC instance is invalid)
  */

#define ADC_BATTERY_VOLTAGE_INSTANCE(__HANDLE__) ((((__HANDLE__)->Instance) != ADC2) || (((__HANDLE__)->Instance) != ADC4))







/**
  * @brief Verify the ADC instance connected to the internal voltage reference VREFINT.
  * @param __HANDLE__ ADC handle.
  * @retval SET (ADC instance is valid) or RESET (ADC instance is invalid)
  */
#define ADC_VREFINT_INSTANCE(__HANDLE__) (((__HANDLE__)->Instance) != ADC2)

/**
  * @brief Verify the length of scheduled injected conversions group.
  * @param __LENGTH__ number of programmed conversions.
  * @retval SET (__LENGTH__ is within the maximum number of possible programmable injected conversions)
  *         or RESET (__LENGTH__ is null or too large)
  */
#define IS_ADC_INJECTED_NB_CONV(__LENGTH__) (((__LENGTH__) >= (1U)) && ((__LENGTH__) <= (4U)))

/**
  * @brief Calibration factor size verification (7 bits maximum).
  * @param __CALIBRATION_FACTOR__ Calibration factor value.
  * @retval SET (__CALIBRATION_FACTOR__ is within the authorized size) or RESET (__CALIBRATION_FACTOR__ is too large)
  */
#define IS_ADC_CALFACT(__CALIBRATION_FACTOR__) ((__CALIBRATION_FACTOR__) <= (0x7FU))


/**
  * @brief Verify the ADC channel setting.
  * @param __HANDLE__ ADC handle.
  * @param __CHANNEL__ programmed ADC channel.
  * @retval SET (__CHANNEL__ is valid) or RESET (__CHANNEL__ is invalid)
  */

#define IS_ADC_CHANNEL(__HANDLE__,__CHANNEL__) ( ( ((__CHANNEL__) == ADC_CHANNEL_0) || ((__CHANNEL__) == ADC_CHANNEL_1) || ((__CHANNEL__) == ADC_CHANNEL_2) || ((__CHANNEL__) == ADC_CHANNEL_6) || ((__CHANNEL__) == ADC_CHANNEL_7) || ((__CHANNEL__) == ADC_CHANNEL_8) || ((__CHANNEL__) == ADC_CHANNEL_9) || ((__CHANNEL__) == ADC_CHANNEL_10) || ((__CHANNEL__) == ADC_CHANNEL_11) || ((__CHANNEL__) == ADC_CHANNEL_12) || ((__CHANNEL__) == ADC_CHANNEL_14) || ((__CHANNEL__) == ADC_CHANNEL_15)) || ((((__HANDLE__)->Instance) == ADC1) && (((__CHANNEL__) == ADC_CHANNEL_3) || ((__CHANNEL__) == ADC_CHANNEL_4) || ((__CHANNEL__) == ADC_CHANNEL_5) || ((__CHANNEL__) == ADC_CHANNEL_VOPAMP1) || ((__CHANNEL__) == ADC_CHANNEL_TEMPSENSOR_ADC1) || ((__CHANNEL__) == ADC_CHANNEL_VBAT) || ((__CHANNEL__) == ADC_CHANNEL_VREFINT))) || ((((__HANDLE__)->Instance) == ADC2) && (((__CHANNEL__) == ADC_CHANNEL_3) || ((__CHANNEL__) == ADC_CHANNEL_4) || ((__CHANNEL__) == ADC_CHANNEL_5) || ((__CHANNEL__) == ADC_CHANNEL_13) || ((__CHANNEL__) == ADC_CHANNEL_VOPAMP2) || ((__CHANNEL__) == ADC_CHANNEL_17) || ((__CHANNEL__) == ADC_CHANNEL_VOPAMP3_ADC2))) || ((((__HANDLE__)->Instance) == ADC3) && (((__CHANNEL__) == ADC_CHANNEL_3) || ((__CHANNEL__) == ADC_CHANNEL_4) || ((__CHANNEL__) == ADC_CHANNEL_5) || ((__CHANNEL__) == ADC_CHANNEL_VOPAMP3_ADC3) || ((__CHANNEL__) == ADC_CHANNEL_16) || ((__CHANNEL__) == ADC_CHANNEL_VBAT) || ((__CHANNEL__) == ADC_CHANNEL_VREFINT))) || ((((__HANDLE__)->Instance) == ADC4) && (((__CHANNEL__) == ADC_CHANNEL_3) || ((__CHANNEL__) == ADC_CHANNEL_4) || ((__CHANNEL__) == ADC_CHANNEL_5) || ((__CHANNEL__) == ADC_CHANNEL_13) || ((__CHANNEL__) == ADC_CHANNEL_16) || ((__CHANNEL__) == ADC_CHANNEL_VOPAMP6) || ((__CHANNEL__) == ADC_CHANNEL_VREFINT))) || ((((__HANDLE__)->Instance) == ADC5) && (((__CHANNEL__) == ADC_CHANNEL_VOPAMP5) || ((__CHANNEL__) == ADC_CHANNEL_TEMPSENSOR_ADC5) || ((__CHANNEL__) == ADC_CHANNEL_VOPAMP4) || ((__CHANNEL__) == ADC_CHANNEL_13) || ((__CHANNEL__) == ADC_CHANNEL_16) || ((__CHANNEL__) == ADC_CHANNEL_VBAT) || ((__CHANNEL__) == ADC_CHANNEL_VREFINT))))
# 919 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h"
# 1008 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h"

/**
  * @brief Verify the ADC channel setting in differential mode.
  * @param __HANDLE__ ADC handle.
  * @param __CHANNEL__ programmed ADC channel.
  * @retval SET (__CHANNEL__ is valid) or RESET (__CHANNEL__ is invalid)
  */

#define IS_ADC_DIFF_CHANNEL(__HANDLE__,__CHANNEL__) ( ( ((__CHANNEL__) == ADC_CHANNEL_1) || ((__CHANNEL__) == ADC_CHANNEL_6) || ((__CHANNEL__) == ADC_CHANNEL_7) || ((__CHANNEL__) == ADC_CHANNEL_8) || ((__CHANNEL__) == ADC_CHANNEL_9) || ((__CHANNEL__) == ADC_CHANNEL_10) || ((__CHANNEL__) == ADC_CHANNEL_11) || ((__CHANNEL__) == ADC_CHANNEL_14)) || ((((__HANDLE__)->Instance) == ADC1) && (((__CHANNEL__) == ADC_CHANNEL_2) || ((__CHANNEL__) == ADC_CHANNEL_3) || ((__CHANNEL__) == ADC_CHANNEL_4) || ((__CHANNEL__) == ADC_CHANNEL_5))) || ((((__HANDLE__)->Instance) == ADC2) && (((__CHANNEL__) == ADC_CHANNEL_2) || ((__CHANNEL__) == ADC_CHANNEL_3) || ((__CHANNEL__) == ADC_CHANNEL_4) || ((__CHANNEL__) == ADC_CHANNEL_5) || ((__CHANNEL__) == ADC_CHANNEL_12) || ((__CHANNEL__) == ADC_CHANNEL_13))) || ((((__HANDLE__)->Instance) == ADC3) && (((__CHANNEL__) == ADC_CHANNEL_2) || ((__CHANNEL__) == ADC_CHANNEL_3) || ((__CHANNEL__) == ADC_CHANNEL_4) || ((__CHANNEL__) == ADC_CHANNEL_5) || ((__CHANNEL__) == ADC_CHANNEL_15))) || ((((__HANDLE__)->Instance) == ADC4) && (((__CHANNEL__) == ADC_CHANNEL_2) || ((__CHANNEL__) == ADC_CHANNEL_3) || ((__CHANNEL__) == ADC_CHANNEL_4) || ((__CHANNEL__) == ADC_CHANNEL_5) || ((__CHANNEL__) == ADC_CHANNEL_12) || ((__CHANNEL__) == ADC_CHANNEL_13) || ((__CHANNEL__) == ADC_CHANNEL_15))) || ((((__HANDLE__)->Instance) == ADC5) && (((__CHANNEL__) == ADC_CHANNEL_12) || ((__CHANNEL__) == ADC_CHANNEL_13) || ((__CHANNEL__) == ADC_CHANNEL_15))) )
# 1054 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h"
# 1089 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h"

/**
  * @brief Verify the ADC single-ended input or differential mode setting.
  * @param __SING_DIFF__ programmed channel setting.
  * @retval SET (__SING_DIFF__ is valid) or RESET (__SING_DIFF__ is invalid)
  */
#define IS_ADC_SINGLE_DIFFERENTIAL(__SING_DIFF__) (((__SING_DIFF__) == ADC_SINGLE_ENDED) || ((__SING_DIFF__) == ADC_DIFFERENTIAL_ENDED) )


/**
  * @brief Verify the ADC offset management setting.
  * @param __OFFSET_NUMBER__ ADC offset management.
  * @retval SET (__OFFSET_NUMBER__ is valid) or RESET (__OFFSET_NUMBER__ is invalid)
  */
#define IS_ADC_OFFSET_NUMBER(__OFFSET_NUMBER__) (((__OFFSET_NUMBER__) == ADC_OFFSET_NONE) || ((__OFFSET_NUMBER__) == ADC_OFFSET_1) || ((__OFFSET_NUMBER__) == ADC_OFFSET_2) || ((__OFFSET_NUMBER__) == ADC_OFFSET_3) || ((__OFFSET_NUMBER__) == ADC_OFFSET_4) )





/**
  * @brief Verify the ADC offset sign setting.
  * @param __OFFSET_SIGN__ ADC offset sign.
  * @retval SET (__OFFSET_SIGN__ is valid) or RESET (__OFFSET_SIGN__ is invalid)
  */
#define IS_ADC_OFFSET_SIGN(__OFFSET_SIGN__) (((__OFFSET_SIGN__) == ADC_OFFSET_SIGN_NEGATIVE) || ((__OFFSET_SIGN__) == ADC_OFFSET_SIGN_POSITIVE) )


/**
  * @brief Verify the ADC injected channel setting.
  * @param __CHANNEL__ programmed ADC injected channel.
  * @retval SET (__CHANNEL__ is valid) or RESET (__CHANNEL__ is invalid)
  */
#define IS_ADC_INJECTED_RANK(__CHANNEL__) (((__CHANNEL__) == ADC_INJECTED_RANK_1) || ((__CHANNEL__) == ADC_INJECTED_RANK_2) || ((__CHANNEL__) == ADC_INJECTED_RANK_3) || ((__CHANNEL__) == ADC_INJECTED_RANK_4) )




/**
  * @brief Verify the ADC injected conversions external trigger.
  * @param __HANDLE__ ADC handle.
  * @param __INJTRIG__ programmed ADC injected conversions external trigger.
  * @retval SET (__INJTRIG__ is a valid value) or RESET (__INJTRIG__ is invalid)
  */
# 1179 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h"
#define IS_ADC_EXTTRIGINJEC(__HANDLE__,__INJTRIG__) (((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T1_TRGO) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T1_TRGO2) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T1_CC4) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T2_TRGO) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T3_TRGO) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T4_TRGO) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T6_TRGO) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T7_TRGO) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T8_TRGO) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T8_TRGO2) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T8_CC4) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T15_TRGO) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T20_TRGO) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T20_TRGO2) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_LPTIM_OUT) || ((((__HANDLE__)->Instance == ADC1) || ((__HANDLE__)->Instance == ADC2)) && (((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T2_CC1) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T3_CC1) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T3_CC3) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T3_CC4) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T16_CC1) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T20_CC4) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_EXT_IT15))) || ((((__HANDLE__)->Instance == ADC3) || ((__HANDLE__)->Instance == ADC4) || ((__HANDLE__)->Instance == ADC5)) && (((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T1_CC3) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T4_CC3) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T4_CC4) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T8_CC2) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_T20_CC2) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJEC_EXT_IT3))) || ((__INJTRIG__) == ADC_INJECTED_SOFTWARE_START) )
# 1213 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h"
# 1297 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h"

/**
  * @brief Verify the ADC edge trigger setting for injected group.
  * @param __EDGE__ programmed ADC edge trigger setting.
  * @retval SET (__EDGE__ is a valid value) or RESET (__EDGE__ is invalid)
  */
#define IS_ADC_EXTTRIGINJEC_EDGE(__EDGE__) (((__EDGE__) == ADC_EXTERNALTRIGINJECCONV_EDGE_NONE) || ((__EDGE__) == ADC_EXTERNALTRIGINJECCONV_EDGE_RISING) || ((__EDGE__) == ADC_EXTERNALTRIGINJECCONV_EDGE_FALLING) || ((__EDGE__) == ADC_EXTERNALTRIGINJECCONV_EDGE_RISINGFALLING) )





/**
  * @brief Verify the ADC multimode setting.
  * @param __MODE__ programmed ADC multimode setting.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_ADC_MULTIMODE(__MODE__) (((__MODE__) == ADC_MODE_INDEPENDENT) || ((__MODE__) == ADC_DUALMODE_REGSIMULT_INJECSIMULT) || ((__MODE__) == ADC_DUALMODE_REGSIMULT_ALTERTRIG) || ((__MODE__) == ADC_DUALMODE_REGINTERL_INJECSIMULT) || ((__MODE__) == ADC_DUALMODE_INJECSIMULT) || ((__MODE__) == ADC_DUALMODE_REGSIMULT) || ((__MODE__) == ADC_DUALMODE_INTERL) || ((__MODE__) == ADC_DUALMODE_ALTERTRIG) )








/**
  * @brief Verify the ADC multimode DMA access setting.
  * @param __MODE__ programmed ADC multimode DMA access setting.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_ADC_DMA_ACCESS_MULTIMODE(__MODE__) (((__MODE__) == ADC_DMAACCESSMODE_DISABLED) || ((__MODE__) == ADC_DMAACCESSMODE_12_10_BITS) || ((__MODE__) == ADC_DMAACCESSMODE_8_6_BITS) )



/**
  * @brief Verify the ADC multimode delay setting.
  * @param __DELAY__ programmed ADC multimode delay setting.
  * @retval SET (__DELAY__ is a valid value) or RESET (__DELAY__ is invalid)
  */
#define IS_ADC_SAMPLING_DELAY(__DELAY__) (((__DELAY__) == ADC_TWOSAMPLINGDELAY_1CYCLE) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_2CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_3CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_4CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_5CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_6CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_7CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_8CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_9CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_10CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_11CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_12CYCLES) )
# 1349 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h"


/**
  * @brief Verify the ADC analog watchdog setting.
  * @param __WATCHDOG__ programmed ADC analog watchdog setting.
  * @retval SET (__WATCHDOG__ is valid) or RESET (__WATCHDOG__ is invalid)
  */
#define IS_ADC_ANALOG_WATCHDOG_NUMBER(__WATCHDOG__) (((__WATCHDOG__) == ADC_ANALOGWATCHDOG_1) || ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_2) || ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_3) )



/**
  * @brief Verify the ADC analog watchdog mode setting.
  * @param __WATCHDOG_MODE__ programmed ADC analog watchdog mode setting.
  * @retval SET (__WATCHDOG_MODE__ is valid) or RESET (__WATCHDOG_MODE__ is invalid)
  */
#define IS_ADC_ANALOG_WATCHDOG_MODE(__WATCHDOG_MODE__) (((__WATCHDOG_MODE__) == ADC_ANALOGWATCHDOG_NONE) || ((__WATCHDOG_MODE__) == ADC_ANALOGWATCHDOG_SINGLE_REG) || ((__WATCHDOG_MODE__) == ADC_ANALOGWATCHDOG_SINGLE_INJEC) || ((__WATCHDOG_MODE__) == ADC_ANALOGWATCHDOG_SINGLE_REGINJEC) || ((__WATCHDOG_MODE__) == ADC_ANALOGWATCHDOG_ALL_REG) || ((__WATCHDOG_MODE__) == ADC_ANALOGWATCHDOG_ALL_INJEC) || ((__WATCHDOG_MODE__) == ADC_ANALOGWATCHDOG_ALL_REGINJEC) )







/**
  * @brief Verify the ADC analog watchdog filtering setting.
  * @param __FILTERING_MODE__ programmed ADC analog watchdog mode setting.
  * @retval SET (__FILTERING_MODE__ is valid) or RESET (__FILTERING_MODE__ is invalid)
  */
#define IS_ADC_ANALOG_WATCHDOG_FILTERING_MODE(__FILTERING_MODE__) (((__FILTERING_MODE__) == ADC_AWD_FILTERING_NONE) || ((__FILTERING_MODE__) == ADC_AWD_FILTERING_2SAMPLES) || ((__FILTERING_MODE__) == ADC_AWD_FILTERING_3SAMPLES) || ((__FILTERING_MODE__) == ADC_AWD_FILTERING_4SAMPLES) || ((__FILTERING_MODE__) == ADC_AWD_FILTERING_5SAMPLES) || ((__FILTERING_MODE__) == ADC_AWD_FILTERING_6SAMPLES) || ((__FILTERING_MODE__) == ADC_AWD_FILTERING_7SAMPLES) || ((__FILTERING_MODE__) == ADC_AWD_FILTERING_8SAMPLES) )
# 1387 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h"


/**
  * @brief Verify the ADC conversion (regular or injected or both).
  * @param __CONVERSION__ ADC conversion group.
  * @retval SET (__CONVERSION__ is valid) or RESET (__CONVERSION__ is invalid)
  */
#define IS_ADC_CONVERSION_GROUP(__CONVERSION__) (((__CONVERSION__) == ADC_REGULAR_GROUP) || ((__CONVERSION__) == ADC_INJECTED_GROUP) || ((__CONVERSION__) == ADC_REGULAR_INJECTED_GROUP) )



/**
  * @brief Verify the ADC event type.
  * @param __EVENT__ ADC event.
  * @retval SET (__EVENT__ is valid) or RESET (__EVENT__ is invalid)
  */
#define IS_ADC_EVENT_TYPE(__EVENT__) (((__EVENT__) == ADC_EOSMP_EVENT) || ((__EVENT__) == ADC_AWD_EVENT) || ((__EVENT__) == ADC_AWD2_EVENT) || ((__EVENT__) == ADC_AWD3_EVENT) || ((__EVENT__) == ADC_OVR_EVENT) || ((__EVENT__) == ADC_JQOVF_EVENT) )






/**
  * @brief Verify the ADC oversampling ratio.
  * @param __RATIO__ programmed ADC oversampling ratio.
  * @retval SET (__RATIO__ is a valid value) or RESET (__RATIO__ is invalid)
  */
#define IS_ADC_OVERSAMPLING_RATIO(__RATIO__) (((__RATIO__) == ADC_OVERSAMPLING_RATIO_2 ) || ((__RATIO__) == ADC_OVERSAMPLING_RATIO_4 ) || ((__RATIO__) == ADC_OVERSAMPLING_RATIO_8 ) || ((__RATIO__) == ADC_OVERSAMPLING_RATIO_16 ) || ((__RATIO__) == ADC_OVERSAMPLING_RATIO_32 ) || ((__RATIO__) == ADC_OVERSAMPLING_RATIO_64 ) || ((__RATIO__) == ADC_OVERSAMPLING_RATIO_128 ) || ((__RATIO__) == ADC_OVERSAMPLING_RATIO_256 ))








/**
  * @brief Verify the ADC oversampling shift.
  * @param __SHIFT__ programmed ADC oversampling shift.
  * @retval SET (__SHIFT__ is a valid value) or RESET (__SHIFT__ is invalid)
  */
#define IS_ADC_RIGHT_BIT_SHIFT(__SHIFT__) (((__SHIFT__) == ADC_RIGHTBITSHIFT_NONE) || ((__SHIFT__) == ADC_RIGHTBITSHIFT_1 ) || ((__SHIFT__) == ADC_RIGHTBITSHIFT_2 ) || ((__SHIFT__) == ADC_RIGHTBITSHIFT_3 ) || ((__SHIFT__) == ADC_RIGHTBITSHIFT_4 ) || ((__SHIFT__) == ADC_RIGHTBITSHIFT_5 ) || ((__SHIFT__) == ADC_RIGHTBITSHIFT_6 ) || ((__SHIFT__) == ADC_RIGHTBITSHIFT_7 ) || ((__SHIFT__) == ADC_RIGHTBITSHIFT_8 ))
# 1438 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc_ex.h"

/**
  * @brief Verify the ADC oversampling triggered mode.
  * @param __MODE__ programmed ADC oversampling triggered mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_ADC_TRIGGERED_OVERSAMPLING_MODE(__MODE__) (((__MODE__) == ADC_TRIGGEREDMODE_SINGLE_TRIGGER) || ((__MODE__) == ADC_TRIGGEREDMODE_MULTI_TRIGGER) )


/**
  * @brief Verify the ADC oversampling regular conversion resumed or continued mode.
  * @param __MODE__ programmed ADC oversampling regular conversion resumed or continued mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_ADC_REGOVERSAMPLING_MODE(__MODE__) (((__MODE__) == ADC_REGOVERSAMPLING_CONTINUED_MODE) || ((__MODE__) == ADC_REGOVERSAMPLING_RESUMED_MODE) )


/**
  * @brief Verify the DFSDM mode configuration.
  * @param __HANDLE__ ADC handle.
  * @note When DMSDFM configuration is not supported, the macro systematically reports SET. For
  *      this reason, the input parameter is the ADC handle and not the configuration parameter
  *      directly.
  * @retval SET (DFSDM mode configuration is valid) or RESET (DFSDM mode configuration is invalid)
  */
#define IS_ADC_DFSDMCFG_MODE(__HANDLE__) (SET)

/**
  * @brief Return the DFSDM configuration mode.
  * @param __HANDLE__ ADC handle.
  * @note When DMSDFM configuration is not supported, the macro systematically reports 0x0 (i.e disabled).
  *       For this reason, the input parameter is the ADC handle and not the configuration parameter
  *       directly.
  * @retval DFSDM configuration mode
  */
#define ADC_CFGR_DFSDM(__HANDLE__) (0x0UL)

/**
  * @}
  */


/* Exported functions --------------------------------------------------------*/
/** @addtogroup ADCEx_Exported_Functions
  * @{
  */

/** @addtogroup ADCEx_Exported_Functions_Group1
  * @{
  */
/* IO operation functions *****************************************************/

/* ADC calibration */
HAL_StatusTypeDef       HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc, uint32_t SingleDiff);
uint32_t                HAL_ADCEx_Calibration_GetValue(const ADC_HandleTypeDef *hadc, uint32_t SingleDiff);
HAL_StatusTypeDef       HAL_ADCEx_Calibration_SetValue(ADC_HandleTypeDef *hadc, uint32_t SingleDiff,
                                                       uint32_t CalibrationFactor);

/* Blocking mode: Polling */
HAL_StatusTypeDef       HAL_ADCEx_InjectedStart(ADC_HandleTypeDef *hadc);
HAL_StatusTypeDef       HAL_ADCEx_InjectedStop(ADC_HandleTypeDef *hadc);
HAL_StatusTypeDef       HAL_ADCEx_InjectedPollForConversion(ADC_HandleTypeDef *hadc, uint32_t Timeout);

/* Non-blocking mode: Interruption */
HAL_StatusTypeDef       HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef *hadc);
HAL_StatusTypeDef       HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef *hadc);


/* ADC multimode */
HAL_StatusTypeDef       HAL_ADCEx_MultiModeStart_DMA(ADC_HandleTypeDef *hadc, uint32_t *pData, uint32_t Length);
HAL_StatusTypeDef       HAL_ADCEx_MultiModeStop_DMA(ADC_HandleTypeDef *hadc);
uint32_t                HAL_ADCEx_MultiModeGetValue(const ADC_HandleTypeDef *hadc);


/* ADC retrieve conversion value intended to be used with polling or interruption */
uint32_t                HAL_ADCEx_InjectedGetValue(const ADC_HandleTypeDef *hadc, uint32_t InjectedRank);

/* ADC IRQHandler and Callbacks used in non-blocking modes (Interruption) */
void                    HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef *hadc);
void                    HAL_ADCEx_InjectedQueueOverflowCallback(ADC_HandleTypeDef *hadc);
void                    HAL_ADCEx_LevelOutOfWindow2Callback(ADC_HandleTypeDef *hadc);
void                    HAL_ADCEx_LevelOutOfWindow3Callback(ADC_HandleTypeDef *hadc);
void                    HAL_ADCEx_EndOfSamplingCallback(ADC_HandleTypeDef *hadc);

/* ADC group regular conversions stop */
HAL_StatusTypeDef       HAL_ADCEx_RegularStop(ADC_HandleTypeDef *hadc);
HAL_StatusTypeDef       HAL_ADCEx_RegularStop_IT(ADC_HandleTypeDef *hadc);
HAL_StatusTypeDef       HAL_ADCEx_RegularStop_DMA(ADC_HandleTypeDef *hadc);

HAL_StatusTypeDef       HAL_ADCEx_RegularMultiModeStop_DMA(ADC_HandleTypeDef *hadc);


/**
  * @}
  */

/** @addtogroup ADCEx_Exported_Functions_Group2
  * @{
  */
/* Peripheral Control functions ***********************************************/
HAL_StatusTypeDef       HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef *hadc,
                                                        const ADC_InjectionConfTypeDef *pConfigInjected);

HAL_StatusTypeDef       HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc,
                                                         const ADC_MultiModeTypeDef *pMultimode);


HAL_StatusTypeDef       HAL_ADCEx_EnableInjectedQueue(ADC_HandleTypeDef *hadc);
HAL_StatusTypeDef       HAL_ADCEx_DisableInjectedQueue(ADC_HandleTypeDef *hadc);
HAL_StatusTypeDef       HAL_ADCEx_DisableVoltageRegulator(ADC_HandleTypeDef *hadc);
HAL_StatusTypeDef       HAL_ADCEx_EnterADCDeepPowerDownMode(ADC_HandleTypeDef *hadc);

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */





# 2199 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_adc.h" 2

/* Exported functions --------------------------------------------------------*/
/** @addtogroup ADC_Exported_Functions
  * @{
  */

/** @addtogroup ADC_Exported_Functions_Group1
  * @brief    Initialization and Configuration functions
  * @{
  */
/* Initialization and de-initialization functions  ****************************/
HAL_StatusTypeDef       HAL_ADC_Init(ADC_HandleTypeDef *hadc);
HAL_StatusTypeDef       HAL_ADC_DeInit(ADC_HandleTypeDef *hadc);
void                    HAL_ADC_MspInit(ADC_HandleTypeDef *hadc);
void                    HAL_ADC_MspDeInit(ADC_HandleTypeDef *hadc);







/**
  * @}
  */

/** @addtogroup ADC_Exported_Functions_Group2
  * @brief    IO operation functions
  * @{
  */
/* IO operation functions  *****************************************************/

/* Blocking mode: Polling */
HAL_StatusTypeDef       HAL_ADC_Start(ADC_HandleTypeDef *hadc);
HAL_StatusTypeDef       HAL_ADC_Stop(ADC_HandleTypeDef *hadc);
HAL_StatusTypeDef       HAL_ADC_PollForConversion(ADC_HandleTypeDef *hadc, uint32_t Timeout);
HAL_StatusTypeDef       HAL_ADC_PollForEvent(ADC_HandleTypeDef *hadc, uint32_t EventType, uint32_t Timeout);

/* Non-blocking mode: Interruption */
HAL_StatusTypeDef       HAL_ADC_Start_IT(ADC_HandleTypeDef *hadc);
HAL_StatusTypeDef       HAL_ADC_Stop_IT(ADC_HandleTypeDef *hadc);

/* Non-blocking mode: DMA */
HAL_StatusTypeDef       HAL_ADC_Start_DMA(ADC_HandleTypeDef *hadc, uint32_t *pData, uint32_t Length);
HAL_StatusTypeDef       HAL_ADC_Stop_DMA(ADC_HandleTypeDef *hadc);

/* ADC retrieve conversion value intended to be used with polling or interruption */
uint32_t                HAL_ADC_GetValue(const ADC_HandleTypeDef *hadc);

/* ADC sampling control */
HAL_StatusTypeDef HAL_ADC_StartSampling(ADC_HandleTypeDef *hadc);
HAL_StatusTypeDef HAL_ADC_StopSampling(ADC_HandleTypeDef *hadc);

/* ADC IRQHandler and Callbacks used in non-blocking modes (Interruption and DMA) */
void                    HAL_ADC_IRQHandler(ADC_HandleTypeDef *hadc);
void                    HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc);
void                    HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef *hadc);
void                    HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef *hadc);
void                    HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc);
/**
  * @}
  */

/** @addtogroup ADC_Exported_Functions_Group3 Peripheral Control functions
  *  @brief    Peripheral Control functions
  * @{
  */
/* Peripheral Control functions ***********************************************/
HAL_StatusTypeDef       HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, const ADC_ChannelConfTypeDef *pConfig);
HAL_StatusTypeDef       HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef *hadc,
                                                const ADC_AnalogWDGConfTypeDef *pAnalogWDGConfig);

/**
  * @}
  */

/* Peripheral State functions *************************************************/
/** @addtogroup ADC_Exported_Functions_Group4
  * @{
  */
uint32_t                HAL_ADC_GetState(const ADC_HandleTypeDef *hadc);
uint32_t                HAL_ADC_GetError(const ADC_HandleTypeDef *hadc);

/**
  * @}
  */

/**
  * @}
  */

/* Private functions ---------------------------------------------------------*/
/** @addtogroup ADC_Private_Functions ADC Private Functions
  * @{
  */
HAL_StatusTypeDef ADC_ConversionStop(ADC_HandleTypeDef *hadc, uint32_t ConversionGroup);
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc);
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc);
void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma);
void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma);
void ADC_DMAError(DMA_HandleTypeDef *hdma);

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */






# 229 "Core/Inc/stm32g4xx_hal_conf.h" 2























# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_exti.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_exti.h
  * @author  MCD Application Team
  * @brief   Header file of EXTI HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_EXTI_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @defgroup EXTI EXTI
  * @brief EXTI HAL module driver
  * @{
  */

/* Exported types ------------------------------------------------------------*/

/** @defgroup EXTI_Exported_Types EXTI Exported Types
  * @{
  */
typedef enum
{
  HAL_EXTI_COMMON_CB_ID         = 0x00UL
} EXTI_CallbackIDTypeDef;


/**
  * @brief  EXTI Handle structure definition
  */
typedef struct
{
  uint32_t Line;                    /*!<  Exti line number */
  void (* PendingCallback)(void);   /*!<  Exti pending callback */
} EXTI_HandleTypeDef;

/**
  * @brief  EXTI Configuration structure definition
  */
typedef struct
{
  uint32_t Line;      /*!< The Exti line to be configured. This parameter
                           can be a value of @ref EXTI_Line */
  uint32_t Mode;      /*!< The Exit Mode to be configured for a core.
                           This parameter can be a combination of @ref EXTI_Mode */
  uint32_t Trigger;   /*!< The Exti Trigger to be configured. This parameter
                           can be a value of @ref EXTI_Trigger */
  uint32_t GPIOSel;   /*!< The Exti GPIO multiplexer selection to be configured.
                           This parameter is only possible for line 0 to 15. It
                           can be a value of @ref EXTI_GPIOSel */
} EXTI_ConfigTypeDef;

/**
  * @}
  */

/* Exported constants --------------------------------------------------------*/
/** @defgroup EXTI_Exported_Constants EXTI Exported Constants
  * @{
  */

/** @defgroup EXTI_Line  EXTI Line
  * @{
  */
#define EXTI_LINE_0 (EXTI_GPIO | EXTI_REG1 | 0x00u)
#define EXTI_LINE_1 (EXTI_GPIO | EXTI_REG1 | 0x01u)
#define EXTI_LINE_2 (EXTI_GPIO | EXTI_REG1 | 0x02u)
#define EXTI_LINE_3 (EXTI_GPIO | EXTI_REG1 | 0x03u)
#define EXTI_LINE_4 (EXTI_GPIO | EXTI_REG1 | 0x04u)
#define EXTI_LINE_5 (EXTI_GPIO | EXTI_REG1 | 0x05u)
#define EXTI_LINE_6 (EXTI_GPIO | EXTI_REG1 | 0x06u)
#define EXTI_LINE_7 (EXTI_GPIO | EXTI_REG1 | 0x07u)
#define EXTI_LINE_8 (EXTI_GPIO | EXTI_REG1 | 0x08u)
#define EXTI_LINE_9 (EXTI_GPIO | EXTI_REG1 | 0x09u)
#define EXTI_LINE_10 (EXTI_GPIO | EXTI_REG1 | 0x0Au)
#define EXTI_LINE_11 (EXTI_GPIO | EXTI_REG1 | 0x0Bu)
#define EXTI_LINE_12 (EXTI_GPIO | EXTI_REG1 | 0x0Cu)
#define EXTI_LINE_13 (EXTI_GPIO | EXTI_REG1 | 0x0Du)
#define EXTI_LINE_14 (EXTI_GPIO | EXTI_REG1 | 0x0Eu)
#define EXTI_LINE_15 (EXTI_GPIO | EXTI_REG1 | 0x0Fu)
#define EXTI_LINE_16 (EXTI_CONFIG | EXTI_REG1 | 0x10u)
#define EXTI_LINE_17 (EXTI_CONFIG | EXTI_REG1 | 0x11u)
#define EXTI_LINE_18 (EXTI_DIRECT | EXTI_REG1 | 0x12u)
#define EXTI_LINE_19 (EXTI_CONFIG | EXTI_REG1 | 0x13u)
#define EXTI_LINE_20 (EXTI_CONFIG | EXTI_REG1 | 0x14u)
#define EXTI_LINE_21 (EXTI_CONFIG | EXTI_REG1 | 0x15u)
#define EXTI_LINE_22 (EXTI_CONFIG | EXTI_REG1 | 0x16u)
#define EXTI_LINE_23 (EXTI_DIRECT | EXTI_REG1 | 0x17u)
#define EXTI_LINE_24 (EXTI_DIRECT | EXTI_REG1 | 0x18u)
#define EXTI_LINE_25 (EXTI_DIRECT | EXTI_REG1 | 0x19u)
#define EXTI_LINE_26 (EXTI_DIRECT | EXTI_REG1 | 0x1Au)
#define EXTI_LINE_27 (EXTI_DIRECT | EXTI_REG1 | 0x1Bu)
#define EXTI_LINE_28 (EXTI_DIRECT | EXTI_REG1 | 0x1Cu)
#define EXTI_LINE_29 (EXTI_CONFIG | EXTI_REG1 | 0x1Du)
#define EXTI_LINE_30 (EXTI_CONFIG | EXTI_REG1 | 0x1Eu)
#define EXTI_LINE_31 (EXTI_CONFIG | EXTI_REG1 | 0x1Fu)
#define EXTI_LINE_32 (EXTI_CONFIG | EXTI_REG2 | 0x00u)
#define EXTI_LINE_33 (EXTI_CONFIG | EXTI_REG2 | 0x01u)
#define EXTI_LINE_34 (EXTI_DIRECT | EXTI_REG2 | 0x02u)
#define EXTI_LINE_35 (EXTI_DIRECT | EXTI_REG2 | 0x03u)
#define EXTI_LINE_36 (EXTI_DIRECT | EXTI_REG2 | 0x04u)
#define EXTI_LINE_37 (EXTI_DIRECT | EXTI_REG2 | 0x05u)
#define EXTI_LINE_38 (EXTI_CONFIG | EXTI_REG2 | 0x06u)
#define EXTI_LINE_39 (EXTI_CONFIG | EXTI_REG2 | 0x07u)
#define EXTI_LINE_40 (EXTI_CONFIG | EXTI_REG2 | 0x08u)
#define EXTI_LINE_41 (EXTI_CONFIG | EXTI_REG2 | 0x09u)
#define EXTI_LINE_42 (EXTI_DIRECT | EXTI_REG2 | 0x0Au)
#define EXTI_LINE_43 (EXTI_DIRECT | EXTI_REG2 | 0x0Bu)
/**
  * @}
  */

/** @defgroup EXTI_Mode  EXTI Mode
  * @{
  */
#define EXTI_MODE_NONE 0x00000000U
#define EXTI_MODE_INTERRUPT 0x00000001U
#define EXTI_MODE_EVENT 0x00000002U
/**
  * @}
  */

/** @defgroup EXTI_Trigger  EXTI Trigger
  * @{
  */
#define EXTI_TRIGGER_NONE 0x00000000U
#define EXTI_TRIGGER_RISING 0x00000001U
#define EXTI_TRIGGER_FALLING 0x00000002U
#define EXTI_TRIGGER_RISING_FALLING (EXTI_TRIGGER_RISING | EXTI_TRIGGER_FALLING)
/**
  * @}
  */

/** @defgroup EXTI_GPIOSel  EXTI GPIOSel
  * @brief
  * @{
  */
#define EXTI_GPIOA 0x00000000U
#define EXTI_GPIOB 0x00000001U
#define EXTI_GPIOC 0x00000002U
#define EXTI_GPIOD 0x00000003U
#define EXTI_GPIOE 0x00000004U
#define EXTI_GPIOF 0x00000005U
#define EXTI_GPIOG 0x00000006U
/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/** @defgroup EXTI_Exported_Macros EXTI Exported Macros
  * @{
  */

/**
  * @}
  */

/* Private constants --------------------------------------------------------*/
/** @defgroup EXTI_Private_Constants EXTI Private Constants
  * @{
  */
/**
  * @brief  EXTI Line property definition
  */
#define EXTI_PROPERTY_SHIFT 24U
#define EXTI_DIRECT (0x01uL << EXTI_PROPERTY_SHIFT)
#define EXTI_CONFIG (0x02uL << EXTI_PROPERTY_SHIFT)
#define EXTI_GPIO ((0x04uL << EXTI_PROPERTY_SHIFT) | EXTI_CONFIG)
#define EXTI_RESERVED (0x08uL << EXTI_PROPERTY_SHIFT)
#define EXTI_PROPERTY_MASK (EXTI_DIRECT | EXTI_CONFIG | EXTI_GPIO)

/**
  * @brief  EXTI Register and bit usage
  */
#define EXTI_REG_SHIFT 16U
#define EXTI_REG1 (0x00uL << EXTI_REG_SHIFT)
#define EXTI_REG2 (0x01uL << EXTI_REG_SHIFT)
#define EXTI_REG_MASK (EXTI_REG1 | EXTI_REG2)
#define EXTI_PIN_MASK 0x0000001FU

/**
  * @brief  EXTI Mask for interrupt & event mode
  */
#define EXTI_MODE_MASK (EXTI_MODE_EVENT | EXTI_MODE_INTERRUPT)

/**
  * @brief  EXTI Mask for trigger possibilities
  */
#define EXTI_TRIGGER_MASK (EXTI_TRIGGER_RISING | EXTI_TRIGGER_FALLING)

/**
  * @brief  EXTI Line number
  */
#define EXTI_LINE_NB 44UL

/**
  * @}
  */

/* Private macros ------------------------------------------------------------*/
/** @defgroup EXTI_Private_Macros EXTI Private Macros
  * @{
  */
#define IS_EXTI_LINE(__EXTI_LINE__) ((((__EXTI_LINE__) & ~(EXTI_PROPERTY_MASK | EXTI_REG_MASK | EXTI_PIN_MASK)) == 0x00U) && ((((__EXTI_LINE__) & EXTI_PROPERTY_MASK) == EXTI_DIRECT) || (((__EXTI_LINE__) & EXTI_PROPERTY_MASK) == EXTI_CONFIG) || (((__EXTI_LINE__) & EXTI_PROPERTY_MASK) == EXTI_GPIO)) && (((__EXTI_LINE__) & (EXTI_REG_MASK | EXTI_PIN_MASK)) < (((EXTI_LINE_NB / 32u) << EXTI_REG_SHIFT) | (EXTI_LINE_NB % 32u))))






#define IS_EXTI_MODE(__EXTI_LINE__) ((((__EXTI_LINE__) & EXTI_MODE_MASK) != 0x00U) && (((__EXTI_LINE__) & ~EXTI_MODE_MASK) == 0x00U))


#define IS_EXTI_TRIGGER(__EXTI_LINE__) (((__EXTI_LINE__) & ~EXTI_TRIGGER_MASK) == 0x00U)

#define IS_EXTI_CONFIG_LINE(__EXTI_LINE__) (((__EXTI_LINE__) & EXTI_CONFIG) != 0x00U)

#define IS_EXTI_GPIO_PORT(__PORT__) (((__PORT__) == EXTI_GPIOA) || ((__PORT__) == EXTI_GPIOB) || ((__PORT__) == EXTI_GPIOC) || ((__PORT__) == EXTI_GPIOD) || ((__PORT__) == EXTI_GPIOE) || ((__PORT__) == EXTI_GPIOF) || ((__PORT__) == EXTI_GPIOG))







#define IS_EXTI_GPIO_PIN(__PIN__) ((__PIN__) < 16u)

#define IS_EXTI_PENDING_EDGE(__EDGE__) (((__EDGE__) == EXTI_TRIGGER_RISING) || ((__EDGE__) == EXTI_TRIGGER_FALLING)|| ((__EDGE__) == EXTI_TRIGGER_RISING_FALLING))



#define IS_EXTI_CB(__CB__) ((__CB__) == HAL_EXTI_COMMON_CB_ID)
/**
  * @}
  */


/* Exported functions --------------------------------------------------------*/
/** @defgroup EXTI_Exported_Functions EXTI Exported Functions
  * @brief    EXTI Exported Functions
  * @{
  */

/** @defgroup EXTI_Exported_Functions_Group1 Configuration functions
  * @brief    Configuration functions
  * @{
  */
/* Configuration functions ****************************************************/
HAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig);
HAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig);
HAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti);
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void));
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine);
/**
  * @}
  */

/** @defgroup EXTI_Exported_Functions_Group2 IO operation functions
  * @brief    IO operation functions
  * @{
  */
/* IO operation functions *****************************************************/
void              HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti);
uint32_t          HAL_EXTI_GetPending(EXTI_HandleTypeDef *hexti, uint32_t Edge);
void              HAL_EXTI_ClearPending(EXTI_HandleTypeDef *hexti, uint32_t Edge);
void              HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti);

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */







# 253 "Core/Inc/stm32g4xx_hal_conf.h" 2



# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_fdcan.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_fdcan.h
  * @author  MCD Application Team
  * @brief   Header file of FDCAN HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_FDCAN_H 





/* Includes ------------------------------------------------------------------*/




/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup FDCAN
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/** @defgroup FDCAN_Exported_Types FDCAN Exported Types
  * @{
  */

/**
  * @brief HAL State structures definition
  */
typedef enum
{
  HAL_FDCAN_STATE_RESET      = 0x00U, /*!< FDCAN not yet initialized or disabled */
  HAL_FDCAN_STATE_READY      = 0x01U, /*!< FDCAN initialized and ready for use   */
  HAL_FDCAN_STATE_BUSY       = 0x02U, /*!< FDCAN process is ongoing              */
  HAL_FDCAN_STATE_ERROR      = 0x03U  /*!< FDCAN error state                     */
} HAL_FDCAN_StateTypeDef;

/**
  * @brief FDCAN Init structure definition
  */
typedef struct
{
  uint32_t ClockDivider;                 /*!< Specifies the FDCAN kernel clock divider.
                                              The clock is common to all FDCAN instances.
                                              This parameter is applied only at initialisation of
                                              first FDCAN instance.
                                              This parameter can be a value of @ref FDCAN_clock_divider.   */

  uint32_t FrameFormat;                  /*!< Specifies the FDCAN frame format.
                                              This parameter can be a value of @ref FDCAN_frame_format     */

  uint32_t Mode;                         /*!< Specifies the FDCAN mode.
                                              This parameter can be a value of @ref FDCAN_operating_mode   */

  FunctionalState AutoRetransmission;    /*!< Enable or disable the automatic retransmission mode.
                                              This parameter can be set to ENABLE or DISABLE               */

  FunctionalState TransmitPause;         /*!< Enable or disable the Transmit Pause feature.
                                              This parameter can be set to ENABLE or DISABLE               */

  FunctionalState ProtocolException;      /*!< Enable or disable the Protocol Exception Handling.
                                              This parameter can be set to ENABLE or DISABLE               */

  uint32_t NominalPrescaler;             /*!< Specifies the value by which the oscillator frequency is
                                              divided for generating the nominal bit time quanta.
                                              This parameter must be a number between 1 and 512            */

  uint32_t NominalSyncJumpWidth;         /*!< Specifies the maximum number of time quanta the FDCAN
                                              hardware is allowed to lengthen or shorten a bit to perform
                                              resynchronization.
                                              This parameter must be a number between 1 and 128            */

  uint32_t NominalTimeSeg1;              /*!< Specifies the number of time quanta in Bit Segment 1.
                                              This parameter must be a number between 2 and 256            */

  uint32_t NominalTimeSeg2;              /*!< Specifies the number of time quanta in Bit Segment 2.
                                              This parameter must be a number between 2 and 128            */

  uint32_t DataPrescaler;                /*!< Specifies the value by which the oscillator frequency is
                                              divided for generating the data bit time quanta.
                                              This parameter must be a number between 1 and 32             */

  uint32_t DataSyncJumpWidth;            /*!< Specifies the maximum number of time quanta the FDCAN
                                              hardware is allowed to lengthen or shorten a data bit to
                                              perform resynchronization.
                                              This parameter must be a number between 1 and 16             */

  uint32_t DataTimeSeg1;                 /*!< Specifies the number of time quanta in Data Bit Segment 1.
                                              This parameter must be a number between 1 and 32             */

  uint32_t DataTimeSeg2;                 /*!< Specifies the number of time quanta in Data Bit Segment 2.
                                              This parameter must be a number between 1 and 16             */

  uint32_t StdFiltersNbr;                /*!< Specifies the number of standard Message ID filters.
                                              This parameter must be a number between 0 and 28             */

  uint32_t ExtFiltersNbr;                /*!< Specifies the number of extended Message ID filters.
                                              This parameter must be a number between 0 and 8             */

  uint32_t TxFifoQueueMode;              /*!< Tx FIFO/Queue Mode selection.
                                              This parameter can be a value of @ref FDCAN_txFifoQueue_Mode */

} FDCAN_InitTypeDef;

/**
  * @brief  FDCAN filter structure definition
  */
typedef struct
{
  uint32_t IdType;           /*!< Specifies the identifier type.
                                  This parameter can be a value of @ref FDCAN_id_type       */

  uint32_t FilterIndex;      /*!< Specifies the filter which will be initialized.
                                  This parameter must be a number between:
                                   - 0 and (SRAMCAN_FLS_NBR-1), if IdType is FDCAN_STANDARD_ID
                                   - 0 and (SRAMCAN_FLE_NBR-1), if IdType is FDCAN_EXTENDED_ID */

  uint32_t FilterType;       /*!< Specifies the filter type.
                                  This parameter can be a value of @ref FDCAN_filter_type.
                                  The value FDCAN_FILTER_RANGE_NO_EIDM is permitted
                                  only when IdType is FDCAN_EXTENDED_ID.                    */

  uint32_t FilterConfig;     /*!< Specifies the filter configuration.
                                  This parameter can be a value of @ref FDCAN_filter_config */

  uint32_t FilterID1;        /*!< Specifies the filter identification 1.
                                  This parameter must be a number between:
                                   - 0 and 0x7FF, if IdType is FDCAN_STANDARD_ID
                                   - 0 and 0x1FFFFFFF, if IdType is FDCAN_EXTENDED_ID       */

  uint32_t FilterID2;        /*!< Specifies the filter identification 2.
                                  This parameter must be a number between:
                                   - 0 and 0x7FF, if IdType is FDCAN_STANDARD_ID
                                   - 0 and 0x1FFFFFFF, if IdType is FDCAN_EXTENDED_ID       */

} FDCAN_FilterTypeDef;

/**
  * @brief  FDCAN Tx header structure definition
  */
typedef struct
{
  uint32_t Identifier;          /*!< Specifies the identifier.
                                     This parameter must be a number between:
                                      - 0 and 0x7FF, if IdType is FDCAN_STANDARD_ID
                                      - 0 and 0x1FFFFFFF, if IdType is FDCAN_EXTENDED_ID               */

  uint32_t IdType;              /*!< Specifies the identifier type for the message that will be
                                     transmitted.
                                     This parameter can be a value of @ref FDCAN_id_type               */

  uint32_t TxFrameType;         /*!< Specifies the frame type of the message that will be transmitted.
                                     This parameter can be a value of @ref FDCAN_frame_type            */

  uint32_t DataLength;          /*!< Specifies the length of the frame that will be transmitted.
                                      This parameter can be a value of @ref FDCAN_data_length_code     */

  uint32_t ErrorStateIndicator; /*!< Specifies the error state indicator.
                                     This parameter can be a value of @ref FDCAN_error_state_indicator */

  uint32_t BitRateSwitch;       /*!< Specifies whether the Tx frame will be transmitted with or without
                                     bit rate switching.
                                     This parameter can be a value of @ref FDCAN_bit_rate_switching    */

  uint32_t FDFormat;            /*!< Specifies whether the Tx frame will be transmitted in classic or
                                     FD format.
                                     This parameter can be a value of @ref FDCAN_format                */

  uint32_t TxEventFifoControl;  /*!< Specifies the event FIFO control.
                                     This parameter can be a value of @ref FDCAN_EFC                   */

  uint32_t MessageMarker;       /*!< Specifies the message marker to be copied into Tx Event FIFO
                                     element for identification of Tx message status.
                                     This parameter must be a number between 0 and 0xFF                */

} FDCAN_TxHeaderTypeDef;

/**
  * @brief  FDCAN Rx header structure definition
  */
typedef struct
{
  uint32_t Identifier;            /*!< Specifies the identifier.
                                       This parameter must be a number between:
                                        - 0 and 0x7FF, if IdType is FDCAN_STANDARD_ID
                                        - 0 and 0x1FFFFFFF, if IdType is FDCAN_EXTENDED_ID               */

  uint32_t IdType;                /*!< Specifies the identifier type of the received message.
                                       This parameter can be a value of @ref FDCAN_id_type               */

  uint32_t RxFrameType;           /*!< Specifies the the received message frame type.
                                       This parameter can be a value of @ref FDCAN_frame_type            */

  uint32_t DataLength;            /*!< Specifies the received frame length.
                                        This parameter can be a value of @ref FDCAN_data_length_code     */

  uint32_t ErrorStateIndicator;   /*!< Specifies the error state indicator.
                                       This parameter can be a value of @ref FDCAN_error_state_indicator */

  uint32_t BitRateSwitch;         /*!< Specifies whether the Rx frame is received with or without bit
                                       rate switching.
                                       This parameter can be a value of @ref FDCAN_bit_rate_switching    */

  uint32_t FDFormat;              /*!< Specifies whether the Rx frame is received in classic or FD
                                       format.
                                       This parameter can be a value of @ref FDCAN_format                */

  uint32_t RxTimestamp;           /*!< Specifies the timestamp counter value captured on start of frame
                                       reception.
                                       This parameter must be a number between 0 and 0xFFFF              */

  uint32_t FilterIndex;           /*!< Specifies the index of matching Rx acceptance filter element.
                                       This parameter must be a number between:
                                        - 0 and (SRAMCAN_FLS_NBR-1), if IdType is FDCAN_STANDARD_ID
                                        - 0 and (SRAMCAN_FLE_NBR-1), if IdType is FDCAN_EXTENDED_ID
                                       When the frame is a Non-Filter matching frame, this parameter
                                       is unused.                                                        */

  uint32_t IsFilterMatchingFrame; /*!< Specifies whether the accepted frame did not match any Rx filter.
                                       Acceptance of non-matching frames may be enabled via
                                       HAL_FDCAN_ConfigGlobalFilter().
                                       This parameter takes 0 if the frame matched an Rx filter or
                                       1 if it did not match any Rx filter                               */

} FDCAN_RxHeaderTypeDef;

/**
  * @brief  FDCAN Tx event FIFO structure definition
  */
typedef struct
{
  uint32_t Identifier;          /*!< Specifies the identifier.
                                     This parameter must be a number between:
                                      - 0 and 0x7FF, if IdType is FDCAN_STANDARD_ID
                                      - 0 and 0x1FFFFFFF, if IdType is FDCAN_EXTENDED_ID               */

  uint32_t IdType;              /*!< Specifies the identifier type for the transmitted message.
                                     This parameter can be a value of @ref FDCAN_id_type               */

  uint32_t TxFrameType;         /*!< Specifies the frame type of the transmitted message.
                                     This parameter can be a value of @ref FDCAN_frame_type            */

  uint32_t DataLength;          /*!< Specifies the length of the transmitted frame.
                                     This parameter can be a value of @ref FDCAN_data_length_code      */

  uint32_t ErrorStateIndicator; /*!< Specifies the error state indicator.
                                     This parameter can be a value of @ref FDCAN_error_state_indicator */

  uint32_t BitRateSwitch;       /*!< Specifies whether the Tx frame is transmitted with or without bit
                                     rate switching.
                                     This parameter can be a value of @ref FDCAN_bit_rate_switching    */

  uint32_t FDFormat;            /*!< Specifies whether the Tx frame is transmitted in classic or FD
                                     format.
                                     This parameter can be a value of @ref FDCAN_format                */

  uint32_t TxTimestamp;         /*!< Specifies the timestamp counter value captured on start of frame
                                     transmission.
                                     This parameter must be a number between 0 and 0xFFFF              */

  uint32_t MessageMarker;       /*!< Specifies the message marker copied into Tx Event FIFO element
                                     for identification of Tx message status.
                                     This parameter must be a number between 0 and 0xFF                */

  uint32_t EventType;           /*!< Specifies the event type.
                                     This parameter can be a value of @ref FDCAN_event_type            */

} FDCAN_TxEventFifoTypeDef;

/**
  * @brief  FDCAN High Priority Message Status structure definition
  */
typedef struct
{
  uint32_t FilterList;     /*!< Specifies the filter list of the matching filter element.
                                This parameter can be:
                                 - 0 : Standard Filter List
                                 - 1 : Extended Filter List                                */

  uint32_t FilterIndex;    /*!< Specifies the index of matching filter element.
                                This parameter can be a number between:
                                - 0 and (SRAMCAN_FLS_NBR-1), if FilterList is 0 (Standard)
                                - 0 and (SRAMCAN_FLE_NBR-1), if FilterList is 1 (Extended) */

  uint32_t MessageStorage; /*!< Specifies the HP Message Storage.
                                This parameter can be a value of @ref FDCAN_hp_msg_storage */

  uint32_t MessageIndex;   /*!< Specifies the Index of Rx FIFO element to which the
                                message was stored.
                                This parameter is valid only when MessageStorage is:
                                  FDCAN_HP_STORAGE_RXFIFO0
                                 or
                                  FDCAN_HP_STORAGE_RXFIFO1                                 */

} FDCAN_HpMsgStatusTypeDef;

/**
  * @brief FDCAN Protocol Status structure definition
  */
typedef struct
{
  uint32_t LastErrorCode;     /*!< Specifies the type of the last error that occurred on the FDCAN bus.
                                   This parameter can be a value of @ref FDCAN_protocol_error_code             */

  uint32_t DataLastErrorCode; /*!< Specifies the type of the last error that occurred in the data phase
                                   of a CAN FD format frame with its BRS flag set.
                                   This parameter can be a value of @ref FDCAN_protocol_error_code             */

  uint32_t Activity;          /*!< Specifies the FDCAN module communication state.
                                   This parameter can be a value of @ref FDCAN_communication_state             */

  uint32_t ErrorPassive;      /*!< Specifies the FDCAN module error status.
                                   This parameter can be:
                                    - 0 : The FDCAN is in Error_Active state
                                    - 1 : The FDCAN is in Error_Passive state                                  */

  uint32_t Warning;           /*!< Specifies the FDCAN module warning status.
                                   This parameter can be:
                                    - 0 : error counters (RxErrorCnt and TxErrorCnt) are below the
                                          Error_Warning limit of 96
                                    - 1 : at least one of error counters has reached the Error_Warning
                                          limit of 96                                                          */

  uint32_t BusOff;            /*!< Specifies the FDCAN module Bus_Off status.
                                   This parameter can be:
                                    - 0 : The FDCAN is not in Bus_Off state
                                    - 1 : The FDCAN is in Bus_Off state                                        */

  uint32_t RxESIflag;         /*!< Specifies ESI flag of last received CAN FD message.
                                   This parameter can be:
                                    - 0 : Last received CAN FD message did not have its ESI flag set
                                    - 1 : Last received CAN FD message had its ESI flag set                    */

  uint32_t RxBRSflag;         /*!< Specifies BRS flag of last received CAN FD message.
                                   This parameter can be:
                                    - 0 : Last received CAN FD message did not have its BRS flag set
                                    - 1 : Last received CAN FD message had its BRS flag set                    */

  uint32_t RxFDFflag;         /*!< Specifies if CAN FD message (FDF flag set) has been received
                                   since last protocol status.
                                   This parameter can be:
                                    - 0 : No CAN FD message received
                                    - 1 : CAN FD message received                                              */

  uint32_t ProtocolException; /*!< Specifies the FDCAN module Protocol Exception status.
                                   This parameter can be:
                                    - 0 : No protocol exception event occurred since last read access
                                    - 1 : Protocol exception event occurred                                    */

  uint32_t TDCvalue;          /*!< Specifies the Transmitter Delay Compensation Value.
                                   This parameter can be a number between 0 and 127                            */

} FDCAN_ProtocolStatusTypeDef;

/**
  * @brief FDCAN Error Counters structure definition
  */
typedef struct
{
  uint32_t TxErrorCnt;     /*!< Specifies the Transmit Error Counter Value.
                                This parameter can be a number between 0 and 255                               */

  uint32_t RxErrorCnt;     /*!< Specifies the Receive Error Counter Value.
                                This parameter can be a number between 0 and 127                               */

  uint32_t RxErrorPassive; /*!< Specifies the Receive Error Passive status.
                                This parameter can be:
                                 - 0 : The Receive Error Counter (RxErrorCnt) is below the error
                                       passive level of 128
                                 - 1 : The Receive Error Counter (RxErrorCnt) has reached the error
                                       passive level of 128                                                    */

  uint32_t ErrorLogging;   /*!< Specifies the Transmit/Receive error logging counter value.
                                This parameter can be a number between 0 and 255.
                                This counter is incremented each time when a FDCAN protocol error causes
                                the TxErrorCnt or the RxErrorCnt to be incremented. The counter stops at 255;
                                the next increment of TxErrorCnt or RxErrorCnt sets interrupt flag
                                FDCAN_FLAG_ERROR_LOGGING_OVERFLOW                                              */

} FDCAN_ErrorCountersTypeDef;

/**
  * @brief  FDCAN Message RAM blocks
  */
typedef struct
{
  uint32_t StandardFilterSA; /*!< Specifies the Standard Filter List Start Address.
                                  This parameter must be a 32-bit word address      */

  uint32_t ExtendedFilterSA; /*!< Specifies the Extended Filter List Start Address.
                                  This parameter must be a 32-bit word address      */

  uint32_t RxFIFO0SA;        /*!< Specifies the Rx FIFO 0 Start Address.
                                  This parameter must be a 32-bit word address      */

  uint32_t RxFIFO1SA;        /*!< Specifies the Rx FIFO 1 Start Address.
                                  This parameter must be a 32-bit word address      */

  uint32_t TxEventFIFOSA;    /*!< Specifies the Tx Event FIFO Start Address.
                                  This parameter must be a 32-bit word address      */

  uint32_t TxFIFOQSA;        /*!< Specifies the Tx FIFO/Queue Start Address.
                                  This parameter must be a 32-bit word address      */

} FDCAN_MsgRamAddressTypeDef;

/**
  * @brief  FDCAN handle structure definition
  */



typedef struct

{
  FDCAN_GlobalTypeDef         *Instance;        /*!< Register base address     */

  FDCAN_InitTypeDef           Init;             /*!< FDCAN required parameters */

  FDCAN_MsgRamAddressTypeDef  msgRam;           /*!< FDCAN Message RAM blocks  */

  uint32_t                    LatestTxFifoQRequest; /*!< FDCAN Tx buffer index
                                               of latest Tx FIFO/Queue request */

  __IO HAL_FDCAN_StateTypeDef State;            /*!< FDCAN communication state */

  HAL_LockTypeDef             Lock;             /*!< FDCAN locking object      */

  __IO uint32_t               ErrorCode;        /*!< FDCAN Error code          */

# 466 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_fdcan.h"

} FDCAN_HandleTypeDef;

# 498 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_fdcan.h"

/**
  * @}
  */

/* Exported constants --------------------------------------------------------*/
/** @defgroup FDCAN_Exported_Constants FDCAN Exported Constants
  * @{
  */

/** @defgroup HAL_FDCAN_Error_Code HAL FDCAN Error Code
  * @{
  */
#define HAL_FDCAN_ERROR_NONE ((uint32_t)0x00000000U)
#define HAL_FDCAN_ERROR_TIMEOUT ((uint32_t)0x00000001U)
#define HAL_FDCAN_ERROR_NOT_INITIALIZED ((uint32_t)0x00000002U)
#define HAL_FDCAN_ERROR_NOT_READY ((uint32_t)0x00000004U)
#define HAL_FDCAN_ERROR_NOT_STARTED ((uint32_t)0x00000008U)
#define HAL_FDCAN_ERROR_NOT_SUPPORTED ((uint32_t)0x00000010U)
#define HAL_FDCAN_ERROR_PARAM ((uint32_t)0x00000020U)
#define HAL_FDCAN_ERROR_PENDING ((uint32_t)0x00000040U)
#define HAL_FDCAN_ERROR_RAM_ACCESS ((uint32_t)0x00000080U)
#define HAL_FDCAN_ERROR_FIFO_EMPTY ((uint32_t)0x00000100U)
#define HAL_FDCAN_ERROR_FIFO_FULL ((uint32_t)0x00000200U)
#define HAL_FDCAN_ERROR_LOG_OVERFLOW FDCAN_IR_ELO
#define HAL_FDCAN_ERROR_RAM_WDG FDCAN_IR_WDI
#define HAL_FDCAN_ERROR_PROTOCOL_ARBT FDCAN_IR_PEA
#define HAL_FDCAN_ERROR_PROTOCOL_DATA FDCAN_IR_PED
#define HAL_FDCAN_ERROR_RESERVED_AREA FDCAN_IR_ARA




/**
  * @}
  */

/** @defgroup FDCAN_frame_format FDCAN Frame Format
  * @{
  */
#define FDCAN_FRAME_CLASSIC ((uint32_t)0x00000000U)
#define FDCAN_FRAME_FD_NO_BRS ((uint32_t)FDCAN_CCCR_FDOE)
#define FDCAN_FRAME_FD_BRS ((uint32_t)(FDCAN_CCCR_FDOE | FDCAN_CCCR_BRSE))
/**
  * @}
  */

/** @defgroup FDCAN_operating_mode FDCAN Operating Mode
  * @{
  */
#define FDCAN_MODE_NORMAL ((uint32_t)0x00000000U)
#define FDCAN_MODE_RESTRICTED_OPERATION ((uint32_t)0x00000001U)
#define FDCAN_MODE_BUS_MONITORING ((uint32_t)0x00000002U)
#define FDCAN_MODE_INTERNAL_LOOPBACK ((uint32_t)0x00000003U)
#define FDCAN_MODE_EXTERNAL_LOOPBACK ((uint32_t)0x00000004U)
/**
  * @}
  */

/** @defgroup FDCAN_clock_divider FDCAN Clock Divider
  * @{
  */
#define FDCAN_CLOCK_DIV1 ((uint32_t)0x00000000U)
#define FDCAN_CLOCK_DIV2 ((uint32_t)0x00000001U)
#define FDCAN_CLOCK_DIV4 ((uint32_t)0x00000002U)
#define FDCAN_CLOCK_DIV6 ((uint32_t)0x00000003U)
#define FDCAN_CLOCK_DIV8 ((uint32_t)0x00000004U)
#define FDCAN_CLOCK_DIV10 ((uint32_t)0x00000005U)
#define FDCAN_CLOCK_DIV12 ((uint32_t)0x00000006U)
#define FDCAN_CLOCK_DIV14 ((uint32_t)0x00000007U)
#define FDCAN_CLOCK_DIV16 ((uint32_t)0x00000008U)
#define FDCAN_CLOCK_DIV18 ((uint32_t)0x00000009U)
#define FDCAN_CLOCK_DIV20 ((uint32_t)0x0000000AU)
#define FDCAN_CLOCK_DIV22 ((uint32_t)0x0000000BU)
#define FDCAN_CLOCK_DIV24 ((uint32_t)0x0000000CU)
#define FDCAN_CLOCK_DIV26 ((uint32_t)0x0000000DU)
#define FDCAN_CLOCK_DIV28 ((uint32_t)0x0000000EU)
#define FDCAN_CLOCK_DIV30 ((uint32_t)0x0000000FU)
/**
  * @}
  */

/** @defgroup FDCAN_txFifoQueue_Mode FDCAN Tx FIFO/Queue Mode
  * @{
  */
#define FDCAN_TX_FIFO_OPERATION ((uint32_t)0x00000000U)
#define FDCAN_TX_QUEUE_OPERATION ((uint32_t)FDCAN_TXBC_TFQM)
/**
  * @}
  */

/** @defgroup FDCAN_id_type FDCAN ID Type
  * @{
  */
#define FDCAN_STANDARD_ID ((uint32_t)0x00000000U)
#define FDCAN_EXTENDED_ID ((uint32_t)0x40000000U)
/**
  * @}
  */

/** @defgroup FDCAN_frame_type FDCAN Frame Type
  * @{
  */
#define FDCAN_DATA_FRAME ((uint32_t)0x00000000U)
#define FDCAN_REMOTE_FRAME ((uint32_t)0x20000000U)
/**
  * @}
  */

/** @defgroup FDCAN_data_length_code FDCAN Data Length Code
  * @{
  */
#define FDCAN_DLC_BYTES_0 ((uint32_t)0x00000000U)
#define FDCAN_DLC_BYTES_1 ((uint32_t)0x00000001U)
#define FDCAN_DLC_BYTES_2 ((uint32_t)0x00000002U)
#define FDCAN_DLC_BYTES_3 ((uint32_t)0x00000003U)
#define FDCAN_DLC_BYTES_4 ((uint32_t)0x00000004U)
#define FDCAN_DLC_BYTES_5 ((uint32_t)0x00000005U)
#define FDCAN_DLC_BYTES_6 ((uint32_t)0x00000006U)
#define FDCAN_DLC_BYTES_7 ((uint32_t)0x00000007U)
#define FDCAN_DLC_BYTES_8 ((uint32_t)0x00000008U)
#define FDCAN_DLC_BYTES_12 ((uint32_t)0x00000009U)
#define FDCAN_DLC_BYTES_16 ((uint32_t)0x0000000AU)
#define FDCAN_DLC_BYTES_20 ((uint32_t)0x0000000BU)
#define FDCAN_DLC_BYTES_24 ((uint32_t)0x0000000CU)
#define FDCAN_DLC_BYTES_32 ((uint32_t)0x0000000DU)
#define FDCAN_DLC_BYTES_48 ((uint32_t)0x0000000EU)
#define FDCAN_DLC_BYTES_64 ((uint32_t)0x0000000FU)
/**
  * @}
  */

/** @defgroup FDCAN_error_state_indicator FDCAN Error State Indicator
  * @{
  */
#define FDCAN_ESI_ACTIVE ((uint32_t)0x00000000U)
#define FDCAN_ESI_PASSIVE ((uint32_t)0x80000000U)
/**
  * @}
  */

/** @defgroup FDCAN_bit_rate_switching FDCAN Bit Rate Switching
  * @{
  */
#define FDCAN_BRS_OFF ((uint32_t)0x00000000U)
#define FDCAN_BRS_ON ((uint32_t)0x00100000U)
/**
  * @}
  */

/** @defgroup FDCAN_format FDCAN format
  * @{
  */
#define FDCAN_CLASSIC_CAN ((uint32_t)0x00000000U)
#define FDCAN_FD_CAN ((uint32_t)0x00200000U)
/**
  * @}
  */

/** @defgroup FDCAN_EFC FDCAN Event FIFO control
  * @{
  */
#define FDCAN_NO_TX_EVENTS ((uint32_t)0x00000000U)
#define FDCAN_STORE_TX_EVENTS ((uint32_t)0x00800000U)
/**
  * @}
  */

/** @defgroup FDCAN_filter_type FDCAN Filter Type
  * @{
  */
#define FDCAN_FILTER_RANGE ((uint32_t)0x00000000U)
#define FDCAN_FILTER_DUAL ((uint32_t)0x00000001U)
#define FDCAN_FILTER_MASK ((uint32_t)0x00000002U)
#define FDCAN_FILTER_RANGE_NO_EIDM ((uint32_t)0x00000003U)
/**
  * @}
  */

/** @defgroup FDCAN_filter_config FDCAN Filter Configuration
  * @{
  */
#define FDCAN_FILTER_DISABLE ((uint32_t)0x00000000U)
#define FDCAN_FILTER_TO_RXFIFO0 ((uint32_t)0x00000001U)
#define FDCAN_FILTER_TO_RXFIFO1 ((uint32_t)0x00000002U)
#define FDCAN_FILTER_REJECT ((uint32_t)0x00000003U)
#define FDCAN_FILTER_HP ((uint32_t)0x00000004U)
#define FDCAN_FILTER_TO_RXFIFO0_HP ((uint32_t)0x00000005U)
#define FDCAN_FILTER_TO_RXFIFO1_HP ((uint32_t)0x00000006U)
/**
  * @}
  */

/** @defgroup FDCAN_Tx_location FDCAN Tx Location
  * @{
  */
#define FDCAN_TX_BUFFER0 ((uint32_t)0x00000001U)
#define FDCAN_TX_BUFFER1 ((uint32_t)0x00000002U)
#define FDCAN_TX_BUFFER2 ((uint32_t)0x00000004U)
/**
  * @}
  */

/** @defgroup FDCAN_Rx_location FDCAN Rx Location
  * @{
  */
#define FDCAN_RX_FIFO0 ((uint32_t)0x00000040U)
#define FDCAN_RX_FIFO1 ((uint32_t)0x00000041U)
/**
  * @}
  */

/** @defgroup FDCAN_event_type FDCAN Event Type
  * @{
  */
#define FDCAN_TX_EVENT ((uint32_t)0x00400000U)
#define FDCAN_TX_IN_SPITE_OF_ABORT ((uint32_t)0x00800000U)
/**
  * @}
  */

/** @defgroup FDCAN_hp_msg_storage FDCAN High Priority Message Storage
  * @{
  */
#define FDCAN_HP_STORAGE_NO_FIFO ((uint32_t)0x00000000U)
#define FDCAN_HP_STORAGE_MSG_LOST ((uint32_t)0x00000040U)
#define FDCAN_HP_STORAGE_RXFIFO0 ((uint32_t)0x00000080U)
#define FDCAN_HP_STORAGE_RXFIFO1 ((uint32_t)0x000000C0U)
/**
  * @}
  */

/** @defgroup FDCAN_protocol_error_code FDCAN protocol error code
  * @{
  */
#define FDCAN_PROTOCOL_ERROR_NONE ((uint32_t)0x00000000U)
#define FDCAN_PROTOCOL_ERROR_STUFF ((uint32_t)0x00000001U)
#define FDCAN_PROTOCOL_ERROR_FORM ((uint32_t)0x00000002U)
#define FDCAN_PROTOCOL_ERROR_ACK ((uint32_t)0x00000003U)
#define FDCAN_PROTOCOL_ERROR_BIT1 ((uint32_t)0x00000004U)
#define FDCAN_PROTOCOL_ERROR_BIT0 ((uint32_t)0x00000005U)
#define FDCAN_PROTOCOL_ERROR_CRC ((uint32_t)0x00000006U)
#define FDCAN_PROTOCOL_ERROR_NO_CHANGE ((uint32_t)0x00000007U)
/**
  * @}
  */

/** @defgroup FDCAN_communication_state FDCAN communication state
  * @{
  */
#define FDCAN_COM_STATE_SYNC ((uint32_t)0x00000000U)
#define FDCAN_COM_STATE_IDLE ((uint32_t)0x00000008U)
#define FDCAN_COM_STATE_RX ((uint32_t)0x00000010U)
#define FDCAN_COM_STATE_TX ((uint32_t)0x00000018U)
/**
  * @}
  */

/** @defgroup FDCAN_Rx_FIFO_operation_mode FDCAN FIFO operation mode
  * @{
  */
#define FDCAN_RX_FIFO_BLOCKING ((uint32_t)0x00000000U)
#define FDCAN_RX_FIFO_OVERWRITE ((uint32_t)0x00000001U)
/**
  * @}
  */

/** @defgroup FDCAN_Non_Matching_Frames FDCAN non-matching frames
  * @{
  */
#define FDCAN_ACCEPT_IN_RX_FIFO0 ((uint32_t)0x00000000U)
#define FDCAN_ACCEPT_IN_RX_FIFO1 ((uint32_t)0x00000001U)
#define FDCAN_REJECT ((uint32_t)0x00000002U)
/**
  * @}
  */

/** @defgroup FDCAN_Reject_Remote_Frames FDCAN reject remote frames
  * @{
  */
#define FDCAN_FILTER_REMOTE ((uint32_t)0x00000000U)
#define FDCAN_REJECT_REMOTE ((uint32_t)0x00000001U)
/**
  * @}
  */

/** @defgroup FDCAN_Interrupt_Line FDCAN interrupt line
  * @{
  */
#define FDCAN_INTERRUPT_LINE0 ((uint32_t)0x00000001U)
#define FDCAN_INTERRUPT_LINE1 ((uint32_t)0x00000002U)
/**
  * @}
  */

/** @defgroup FDCAN_Timestamp FDCAN timestamp
  * @{
  */
#define FDCAN_TIMESTAMP_INTERNAL ((uint32_t)0x00000001U)
#define FDCAN_TIMESTAMP_EXTERNAL ((uint32_t)0x00000002U)
/**
  * @}
  */

/** @defgroup FDCAN_Timestamp_Prescaler FDCAN timestamp prescaler
  * @{
  */
#define FDCAN_TIMESTAMP_PRESC_1 ((uint32_t)0x00000000U)
#define FDCAN_TIMESTAMP_PRESC_2 ((uint32_t)0x00010000U)
#define FDCAN_TIMESTAMP_PRESC_3 ((uint32_t)0x00020000U)
#define FDCAN_TIMESTAMP_PRESC_4 ((uint32_t)0x00030000U)
#define FDCAN_TIMESTAMP_PRESC_5 ((uint32_t)0x00040000U)
#define FDCAN_TIMESTAMP_PRESC_6 ((uint32_t)0x00050000U)
#define FDCAN_TIMESTAMP_PRESC_7 ((uint32_t)0x00060000U)
#define FDCAN_TIMESTAMP_PRESC_8 ((uint32_t)0x00070000U)
#define FDCAN_TIMESTAMP_PRESC_9 ((uint32_t)0x00080000U)
#define FDCAN_TIMESTAMP_PRESC_10 ((uint32_t)0x00090000U)
#define FDCAN_TIMESTAMP_PRESC_11 ((uint32_t)0x000A0000U)
#define FDCAN_TIMESTAMP_PRESC_12 ((uint32_t)0x000B0000U)
#define FDCAN_TIMESTAMP_PRESC_13 ((uint32_t)0x000C0000U)
#define FDCAN_TIMESTAMP_PRESC_14 ((uint32_t)0x000D0000U)
#define FDCAN_TIMESTAMP_PRESC_15 ((uint32_t)0x000E0000U)
#define FDCAN_TIMESTAMP_PRESC_16 ((uint32_t)0x000F0000U)
/**
  * @}
  */

/** @defgroup FDCAN_Timeout_Operation FDCAN timeout operation
  * @{
  */
#define FDCAN_TIMEOUT_CONTINUOUS ((uint32_t)0x00000000U)
#define FDCAN_TIMEOUT_TX_EVENT_FIFO ((uint32_t)0x00000002U)
#define FDCAN_TIMEOUT_RX_FIFO0 ((uint32_t)0x00000004U)
#define FDCAN_TIMEOUT_RX_FIFO1 ((uint32_t)0x00000006U)
/**
  * @}
  */

/** @defgroup Interrupt_Masks Interrupt masks
  * @{
  */
#define FDCAN_IR_MASK ((uint32_t)0x00FFFFFFU)
#define FDCAN_ILS_MASK ((uint32_t)0x0000007FU)
/**
  * @}
  */

/** @defgroup FDCAN_flags FDCAN Flags
  * @{
  */
#define FDCAN_FLAG_TX_COMPLETE FDCAN_IR_TC
#define FDCAN_FLAG_TX_ABORT_COMPLETE FDCAN_IR_TCF
#define FDCAN_FLAG_TX_FIFO_EMPTY FDCAN_IR_TFE
#define FDCAN_FLAG_RX_HIGH_PRIORITY_MSG FDCAN_IR_HPM
#define FDCAN_FLAG_TX_EVT_FIFO_ELT_LOST FDCAN_IR_TEFL
#define FDCAN_FLAG_TX_EVT_FIFO_FULL FDCAN_IR_TEFF
#define FDCAN_FLAG_TX_EVT_FIFO_NEW_DATA FDCAN_IR_TEFN
#define FDCAN_FLAG_RX_FIFO0_MESSAGE_LOST FDCAN_IR_RF0L
#define FDCAN_FLAG_RX_FIFO0_FULL FDCAN_IR_RF0F
#define FDCAN_FLAG_RX_FIFO0_NEW_MESSAGE FDCAN_IR_RF0N
#define FDCAN_FLAG_RX_FIFO1_MESSAGE_LOST FDCAN_IR_RF1L
#define FDCAN_FLAG_RX_FIFO1_FULL FDCAN_IR_RF1F
#define FDCAN_FLAG_RX_FIFO1_NEW_MESSAGE FDCAN_IR_RF1N
#define FDCAN_FLAG_RAM_ACCESS_FAILURE FDCAN_IR_MRAF
#define FDCAN_FLAG_ERROR_LOGGING_OVERFLOW FDCAN_IR_ELO
#define FDCAN_FLAG_ERROR_PASSIVE FDCAN_IR_EP
#define FDCAN_FLAG_ERROR_WARNING FDCAN_IR_EW
#define FDCAN_FLAG_BUS_OFF FDCAN_IR_BO
#define FDCAN_FLAG_RAM_WATCHDOG FDCAN_IR_WDI
#define FDCAN_FLAG_ARB_PROTOCOL_ERROR FDCAN_IR_PEA
#define FDCAN_FLAG_DATA_PROTOCOL_ERROR FDCAN_IR_PED
#define FDCAN_FLAG_RESERVED_ADDRESS_ACCESS FDCAN_IR_ARA
#define FDCAN_FLAG_TIMESTAMP_WRAPAROUND FDCAN_IR_TSW
#define FDCAN_FLAG_TIMEOUT_OCCURRED FDCAN_IR_TOO
/**
  * @}
  */

/** @defgroup FDCAN_Interrupts FDCAN Interrupts
  * @{
  */

/** @defgroup FDCAN_Tx_Interrupts FDCAN Tx Interrupts
  * @{
  */
#define FDCAN_IT_TX_COMPLETE FDCAN_IE_TCE
#define FDCAN_IT_TX_ABORT_COMPLETE FDCAN_IE_TCFE
#define FDCAN_IT_TX_FIFO_EMPTY FDCAN_IE_TFEE
/**
  * @}
  */

/** @defgroup FDCAN_Rx_Interrupts FDCAN Rx Interrupts
  * @{
  */
#define FDCAN_IT_RX_HIGH_PRIORITY_MSG FDCAN_IE_HPME
/**
  * @}
  */

/** @defgroup FDCAN_Counter_Interrupts FDCAN Counter Interrupts
  * @{
  */
#define FDCAN_IT_TIMESTAMP_WRAPAROUND FDCAN_IE_TSWE
#define FDCAN_IT_TIMEOUT_OCCURRED FDCAN_IE_TOOE
/**
  * @}
  */

/** @defgroup FDCAN_Tx_Event_Fifo_Interrupts FDCAN Tx Event FIFO Interrupts
  * @{
  */
#define FDCAN_IT_TX_EVT_FIFO_ELT_LOST FDCAN_IE_TEFLE
#define FDCAN_IT_TX_EVT_FIFO_FULL FDCAN_IE_TEFFE
#define FDCAN_IT_TX_EVT_FIFO_NEW_DATA FDCAN_IE_TEFNE
/**
  * @}
  */

/** @defgroup FDCAN_Rx_Fifo0_Interrupts FDCAN Rx FIFO 0 Interrupts
  * @{
  */
#define FDCAN_IT_RX_FIFO0_MESSAGE_LOST FDCAN_IE_RF0LE
#define FDCAN_IT_RX_FIFO0_FULL FDCAN_IE_RF0FE
#define FDCAN_IT_RX_FIFO0_NEW_MESSAGE FDCAN_IE_RF0NE
/**
  * @}
  */

/** @defgroup FDCAN_Rx_Fifo1_Interrupts FDCAN Rx FIFO 1 Interrupts
  * @{
  */
#define FDCAN_IT_RX_FIFO1_MESSAGE_LOST FDCAN_IE_RF1LE
#define FDCAN_IT_RX_FIFO1_FULL FDCAN_IE_RF1FE
#define FDCAN_IT_RX_FIFO1_NEW_MESSAGE FDCAN_IE_RF1NE
/**
  * @}
  */

/** @defgroup FDCAN_Error_Interrupts FDCAN Error Interrupts
  * @{
  */
#define FDCAN_IT_RAM_ACCESS_FAILURE FDCAN_IE_MRAFE
#define FDCAN_IT_ERROR_LOGGING_OVERFLOW FDCAN_IE_ELOE
#define FDCAN_IT_RAM_WATCHDOG FDCAN_IE_WDIE
#define FDCAN_IT_ARB_PROTOCOL_ERROR FDCAN_IE_PEAE
#define FDCAN_IT_DATA_PROTOCOL_ERROR FDCAN_IE_PEDE
#define FDCAN_IT_RESERVED_ADDRESS_ACCESS FDCAN_IE_ARAE
/**
  * @}
  */

/** @defgroup FDCAN_Error_Status_Interrupts FDCAN Error Status Interrupts
  * @{
  */
#define FDCAN_IT_ERROR_PASSIVE FDCAN_IE_EPE
#define FDCAN_IT_ERROR_WARNING FDCAN_IE_EWE
#define FDCAN_IT_BUS_OFF FDCAN_IE_BOE
/**
  * @}
  */

/**
  * @}
  */

/** @defgroup FDCAN_Interrupts_List FDCAN Interrupts List
  * @{
  */
#define FDCAN_IT_LIST_RX_FIFO0 (FDCAN_IT_RX_FIFO0_MESSAGE_LOST | FDCAN_IT_RX_FIFO0_FULL | FDCAN_IT_RX_FIFO0_NEW_MESSAGE)


#define FDCAN_IT_LIST_RX_FIFO1 (FDCAN_IT_RX_FIFO1_MESSAGE_LOST | FDCAN_IT_RX_FIFO1_FULL | FDCAN_IT_RX_FIFO1_NEW_MESSAGE)


#define FDCAN_IT_LIST_SMSG (FDCAN_IT_TX_ABORT_COMPLETE | FDCAN_IT_TX_COMPLETE | FDCAN_IT_RX_HIGH_PRIORITY_MSG)


#define FDCAN_IT_LIST_TX_FIFO_ERROR (FDCAN_IT_TX_EVT_FIFO_ELT_LOST | FDCAN_IT_TX_EVT_FIFO_FULL | FDCAN_IT_TX_EVT_FIFO_NEW_DATA | FDCAN_IT_TX_FIFO_EMPTY)



#define FDCAN_IT_LIST_MISC (FDCAN_IT_TIMEOUT_OCCURRED | FDCAN_IT_RAM_ACCESS_FAILURE | FDCAN_IT_TIMESTAMP_WRAPAROUND)


#define FDCAN_IT_LIST_BIT_LINE_ERROR (FDCAN_IT_ERROR_PASSIVE | FDCAN_IT_ERROR_LOGGING_OVERFLOW)

#define FDCAN_IT_LIST_PROTOCOL_ERROR (FDCAN_IT_RESERVED_ADDRESS_ACCESS | FDCAN_IT_DATA_PROTOCOL_ERROR | FDCAN_IT_ARB_PROTOCOL_ERROR | FDCAN_IT_RAM_WATCHDOG | FDCAN_IT_BUS_OFF | FDCAN_IT_ERROR_WARNING)





/**
  * @}
  */

/** @defgroup FDCAN_Interrupts_Group FDCAN Interrupts Group
  * @{
  */
#define FDCAN_IT_GROUP_RX_FIFO0 FDCAN_ILS_RXFIFO0



#define FDCAN_IT_GROUP_RX_FIFO1 FDCAN_ILS_RXFIFO1



#define FDCAN_IT_GROUP_SMSG FDCAN_ILS_SMSG



#define FDCAN_IT_GROUP_TX_FIFO_ERROR FDCAN_ILS_TFERR




#define FDCAN_IT_GROUP_MISC FDCAN_ILS_MISC



#define FDCAN_IT_GROUP_BIT_LINE_ERROR FDCAN_ILS_BERR


#define FDCAN_IT_GROUP_PROTOCOL_ERROR FDCAN_ILS_PERR






/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/** @defgroup FDCAN_Exported_Macros FDCAN Exported Macros
  * @{
  */

/** @brief  Reset FDCAN handle state.
  * @param  __HANDLE__ FDCAN handle.
  * @retval None
  */







#define __HAL_FDCAN_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_FDCAN_STATE_RESET)


/**
  * @brief  Enable the specified FDCAN interrupts.
  * @param  __HANDLE__ FDCAN handle.
  * @param  __INTERRUPT__ FDCAN interrupt.
  *         This parameter can be any combination of @arg FDCAN_Interrupts
  * @retval None
  */
#define __HAL_FDCAN_ENABLE_IT(__HANDLE__,__INTERRUPT__) (__HANDLE__)->Instance->IE |= (__INTERRUPT__)


/**
  * @brief  Disable the specified FDCAN interrupts.
  * @param  __HANDLE__ FDCAN handle.
  * @param  __INTERRUPT__ FDCAN interrupt.
  *         This parameter can be any combination of @arg FDCAN_Interrupts
  * @retval None
  */
#define __HAL_FDCAN_DISABLE_IT(__HANDLE__,__INTERRUPT__) ((__HANDLE__)->Instance->IE) &= ~(__INTERRUPT__)


/**
  * @brief  Check whether the specified FDCAN interrupt is set or not.
  * @param  __HANDLE__ FDCAN handle.
  * @param  __INTERRUPT__ FDCAN interrupt.
  *         This parameter can be one of @arg FDCAN_Interrupts
  * @retval ITStatus
  */
#define __HAL_FDCAN_GET_IT(__HANDLE__,__INTERRUPT__) ((__HANDLE__)->Instance->IR & (__INTERRUPT__))

/**
  * @brief  Clear the specified FDCAN interrupts.
  * @param  __HANDLE__ FDCAN handle.
  * @param  __INTERRUPT__ specifies the interrupts to clear.
  *         This parameter can be any combination of @arg FDCAN_Interrupts
  * @retval None
  */
#define __HAL_FDCAN_CLEAR_IT(__HANDLE__,__INTERRUPT__) ((__HANDLE__)->Instance->IR) = (__INTERRUPT__)


/**
  * @brief  Check whether the specified FDCAN flag is set or not.
  * @param  __HANDLE__ FDCAN handle.
  * @param  __FLAG__ FDCAN flag.
  *         This parameter can be one of @arg FDCAN_flags
  * @retval FlagStatus
  */
#define __HAL_FDCAN_GET_FLAG(__HANDLE__,__FLAG__) ((__HANDLE__)->Instance->IR & (__FLAG__))

/**
  * @brief  Clear the specified FDCAN flags.
  * @param  __HANDLE__ FDCAN handle.
  * @param  __FLAG__ specifies the flags to clear.
  *         This parameter can be any combination of @arg FDCAN_flags
  * @retval None
  */
#define __HAL_FDCAN_CLEAR_FLAG(__HANDLE__,__FLAG__) ((__HANDLE__)->Instance->IR) = (__FLAG__)


/** @brief  Check if the specified FDCAN interrupt source is enabled or disabled.
  * @param  __HANDLE__ FDCAN handle.
  * @param  __INTERRUPT__ specifies the FDCAN interrupt source to check.
  *         This parameter can be a value of @arg FDCAN_Interrupts
  * @retval ITStatus
  */
#define __HAL_FDCAN_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__) ((__HANDLE__)->Instance->IE & (__INTERRUPT__))

/**
  * @}
  */

/* Exported functions --------------------------------------------------------*/
/** @addtogroup FDCAN_Exported_Functions
  * @{
  */

/** @addtogroup FDCAN_Exported_Functions_Group1
  * @{
  */
/* Initialization and de-initialization functions *****************************/
HAL_StatusTypeDef HAL_FDCAN_Init(FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_DeInit(FDCAN_HandleTypeDef *hfdcan);
void              HAL_FDCAN_MspInit(FDCAN_HandleTypeDef *hfdcan);
void              HAL_FDCAN_MspDeInit(FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_EnterPowerDownMode(FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_ExitPowerDownMode(FDCAN_HandleTypeDef *hfdcan);

# 1166 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_fdcan.h"
/**
  * @}
  */

/** @addtogroup FDCAN_Exported_Functions_Group2
  * @{
  */
/* Configuration functions ****************************************************/
HAL_StatusTypeDef HAL_FDCAN_ConfigFilter(FDCAN_HandleTypeDef *hfdcan, const FDCAN_FilterTypeDef *sFilterConfig);
HAL_StatusTypeDef HAL_FDCAN_ConfigGlobalFilter(FDCAN_HandleTypeDef *hfdcan, uint32_t NonMatchingStd,
                                               uint32_t NonMatchingExt, uint32_t RejectRemoteStd,
                                               uint32_t RejectRemoteExt);
HAL_StatusTypeDef HAL_FDCAN_ConfigExtendedIdMask(FDCAN_HandleTypeDef *hfdcan, uint32_t Mask);
HAL_StatusTypeDef HAL_FDCAN_ConfigRxFifoOverwrite(FDCAN_HandleTypeDef *hfdcan, uint32_t RxFifo, uint32_t OperationMode);
HAL_StatusTypeDef HAL_FDCAN_ConfigRamWatchdog(FDCAN_HandleTypeDef *hfdcan, uint32_t CounterStartValue);
HAL_StatusTypeDef HAL_FDCAN_ConfigTimestampCounter(FDCAN_HandleTypeDef *hfdcan, uint32_t TimestampPrescaler);
HAL_StatusTypeDef HAL_FDCAN_EnableTimestampCounter(FDCAN_HandleTypeDef *hfdcan, uint32_t TimestampOperation);
HAL_StatusTypeDef HAL_FDCAN_DisableTimestampCounter(FDCAN_HandleTypeDef *hfdcan);
uint16_t          HAL_FDCAN_GetTimestampCounter(const FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_ResetTimestampCounter(FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_ConfigTimeoutCounter(FDCAN_HandleTypeDef *hfdcan, uint32_t TimeoutOperation,
                                                 uint32_t TimeoutPeriod);
HAL_StatusTypeDef HAL_FDCAN_EnableTimeoutCounter(FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_DisableTimeoutCounter(FDCAN_HandleTypeDef *hfdcan);
uint16_t          HAL_FDCAN_GetTimeoutCounter(const FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_ResetTimeoutCounter(FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_ConfigTxDelayCompensation(FDCAN_HandleTypeDef *hfdcan, uint32_t TdcOffset,
                                                      uint32_t TdcFilter);
HAL_StatusTypeDef HAL_FDCAN_EnableTxDelayCompensation(FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_DisableTxDelayCompensation(FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_EnableISOMode(FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_DisableISOMode(FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_EnableEdgeFiltering(FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_DisableEdgeFiltering(FDCAN_HandleTypeDef *hfdcan);
/**
  * @}
  */

/** @addtogroup FDCAN_Exported_Functions_Group3
  * @{
  */
/* Control functions **********************************************************/
HAL_StatusTypeDef HAL_FDCAN_Start(FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_Stop(FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_AddMessageToTxFifoQ(FDCAN_HandleTypeDef *hfdcan, const FDCAN_TxHeaderTypeDef *pTxHeader,
                                                const uint8_t *pTxData);
uint32_t HAL_FDCAN_GetLatestTxFifoQRequestBuffer(const FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_AbortTxRequest(FDCAN_HandleTypeDef *hfdcan, uint32_t BufferIndex);
HAL_StatusTypeDef HAL_FDCAN_GetRxMessage(FDCAN_HandleTypeDef *hfdcan, uint32_t RxLocation,
                                         FDCAN_RxHeaderTypeDef *pRxHeader, uint8_t *pRxData);
HAL_StatusTypeDef HAL_FDCAN_GetTxEvent(FDCAN_HandleTypeDef *hfdcan, FDCAN_TxEventFifoTypeDef *pTxEvent);
HAL_StatusTypeDef HAL_FDCAN_GetHighPriorityMessageStatus(const FDCAN_HandleTypeDef *hfdcan,
                                                         FDCAN_HpMsgStatusTypeDef *HpMsgStatus);
HAL_StatusTypeDef HAL_FDCAN_GetProtocolStatus(const FDCAN_HandleTypeDef *hfdcan,
                                              FDCAN_ProtocolStatusTypeDef *ProtocolStatus);
HAL_StatusTypeDef HAL_FDCAN_GetErrorCounters(const FDCAN_HandleTypeDef *hfdcan,
                                             FDCAN_ErrorCountersTypeDef *ErrorCounters);
uint32_t HAL_FDCAN_IsTxBufferMessagePending(const FDCAN_HandleTypeDef *hfdcan, uint32_t TxBufferIndex);
uint32_t HAL_FDCAN_GetRxFifoFillLevel(const FDCAN_HandleTypeDef *hfdcan, uint32_t RxFifo);
uint32_t HAL_FDCAN_GetTxFifoFreeLevel(const FDCAN_HandleTypeDef *hfdcan);
uint32_t HAL_FDCAN_IsRestrictedOperationMode(const FDCAN_HandleTypeDef *hfdcan);
HAL_StatusTypeDef HAL_FDCAN_ExitRestrictedOperationMode(FDCAN_HandleTypeDef *hfdcan);
/**
  * @}
  */

/** @addtogroup FDCAN_Exported_Functions_Group4
  * @{
  */
/* Interrupts management ******************************************************/
HAL_StatusTypeDef HAL_FDCAN_ConfigInterruptLines(FDCAN_HandleTypeDef *hfdcan, uint32_t ITList, uint32_t InterruptLine);
HAL_StatusTypeDef HAL_FDCAN_ActivateNotification(FDCAN_HandleTypeDef *hfdcan, uint32_t ActiveITs,
                                                 uint32_t BufferIndexes);
HAL_StatusTypeDef HAL_FDCAN_DeactivateNotification(FDCAN_HandleTypeDef *hfdcan, uint32_t InactiveITs);
void              HAL_FDCAN_IRQHandler(FDCAN_HandleTypeDef *hfdcan);
/**
  * @}
  */

/** @addtogroup FDCAN_Exported_Functions_Group5
  * @{
  */
/* Callback functions *********************************************************/
void HAL_FDCAN_TxEventFifoCallback(FDCAN_HandleTypeDef *hfdcan, uint32_t TxEventFifoITs);
void HAL_FDCAN_RxFifo0Callback(FDCAN_HandleTypeDef *hfdcan, uint32_t RxFifo0ITs);
void HAL_FDCAN_RxFifo1Callback(FDCAN_HandleTypeDef *hfdcan, uint32_t RxFifo1ITs);
void HAL_FDCAN_TxFifoEmptyCallback(FDCAN_HandleTypeDef *hfdcan);
void HAL_FDCAN_TxBufferCompleteCallback(FDCAN_HandleTypeDef *hfdcan, uint32_t BufferIndexes);
void HAL_FDCAN_TxBufferAbortCallback(FDCAN_HandleTypeDef *hfdcan, uint32_t BufferIndexes);
void HAL_FDCAN_HighPriorityMessageCallback(FDCAN_HandleTypeDef *hfdcan);
void HAL_FDCAN_TimestampWraparoundCallback(FDCAN_HandleTypeDef *hfdcan);
void HAL_FDCAN_TimeoutOccurredCallback(FDCAN_HandleTypeDef *hfdcan);
void HAL_FDCAN_ErrorCallback(FDCAN_HandleTypeDef *hfdcan);
void HAL_FDCAN_ErrorStatusCallback(FDCAN_HandleTypeDef *hfdcan, uint32_t ErrorStatusITs);
/**
  * @}
  */

/** @addtogroup FDCAN_Exported_Functions_Group6
  * @{
  */
/* Peripheral State functions *************************************************/
uint32_t HAL_FDCAN_GetError(const FDCAN_HandleTypeDef *hfdcan);
HAL_FDCAN_StateTypeDef HAL_FDCAN_GetState(const FDCAN_HandleTypeDef *hfdcan);
/**
  * @}
  */

/**
  * @}
  */

/* Private types -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/** @defgroup FDCAN_Private_Variables FDCAN Private Variables
  * @{
  */

/**
  * @}
  */

/* Private constants ---------------------------------------------------------*/
/** @defgroup FDCAN_Private_Constants FDCAN Private Constants
  * @{
  */

/**
  * @}
  */

/* Private macros ------------------------------------------------------------*/
/** @defgroup FDCAN_Private_Macros FDCAN Private Macros
  * @{
  */
#define IS_FDCAN_FRAME_FORMAT(FORMAT) (((FORMAT) == FDCAN_FRAME_CLASSIC ) || ((FORMAT) == FDCAN_FRAME_FD_NO_BRS) || ((FORMAT) == FDCAN_FRAME_FD_BRS ))


#define IS_FDCAN_MODE(MODE) (((MODE) == FDCAN_MODE_NORMAL ) || ((MODE) == FDCAN_MODE_RESTRICTED_OPERATION) || ((MODE) == FDCAN_MODE_BUS_MONITORING ) || ((MODE) == FDCAN_MODE_INTERNAL_LOOPBACK ) || ((MODE) == FDCAN_MODE_EXTERNAL_LOOPBACK ))




#define IS_FDCAN_CKDIV(CKDIV) (((CKDIV) == FDCAN_CLOCK_DIV1 ) || ((CKDIV) == FDCAN_CLOCK_DIV2 ) || ((CKDIV) == FDCAN_CLOCK_DIV4 ) || ((CKDIV) == FDCAN_CLOCK_DIV6 ) || ((CKDIV) == FDCAN_CLOCK_DIV8 ) || ((CKDIV) == FDCAN_CLOCK_DIV10) || ((CKDIV) == FDCAN_CLOCK_DIV12) || ((CKDIV) == FDCAN_CLOCK_DIV14) || ((CKDIV) == FDCAN_CLOCK_DIV16) || ((CKDIV) == FDCAN_CLOCK_DIV18) || ((CKDIV) == FDCAN_CLOCK_DIV20) || ((CKDIV) == FDCAN_CLOCK_DIV22) || ((CKDIV) == FDCAN_CLOCK_DIV24) || ((CKDIV) == FDCAN_CLOCK_DIV26) || ((CKDIV) == FDCAN_CLOCK_DIV28) || ((CKDIV) == FDCAN_CLOCK_DIV30))
# 1325 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_fdcan.h"
#define IS_FDCAN_NOMINAL_PRESCALER(PRESCALER) (((PRESCALER) >= 1U) && ((PRESCALER) <= 512U))
#define IS_FDCAN_NOMINAL_SJW(SJW) (((SJW) >= 1U) && ((SJW) <= 128U))
#define IS_FDCAN_NOMINAL_TSEG1(TSEG1) (((TSEG1) >= 1U) && ((TSEG1) <= 256U))
#define IS_FDCAN_NOMINAL_TSEG2(TSEG2) (((TSEG2) >= 1U) && ((TSEG2) <= 128U))
#define IS_FDCAN_DATA_PRESCALER(PRESCALER) (((PRESCALER) >= 1U) && ((PRESCALER) <= 32U))
#define IS_FDCAN_DATA_SJW(SJW) (((SJW) >= 1U) && ((SJW) <= 16U))
#define IS_FDCAN_DATA_TSEG1(TSEG1) (((TSEG1) >= 1U) && ((TSEG1) <= 32U))
#define IS_FDCAN_DATA_TSEG2(TSEG2) (((TSEG2) >= 1U) && ((TSEG2) <= 16U))
#define IS_FDCAN_MAX_VALUE(VALUE,_MAX_) ((VALUE) <= (_MAX_))
#define IS_FDCAN_MIN_VALUE(VALUE,_MIN_) ((VALUE) >= (_MIN_))
#define IS_FDCAN_TX_FIFO_QUEUE_MODE(MODE) (((MODE) == FDCAN_TX_FIFO_OPERATION ) || ((MODE) == FDCAN_TX_QUEUE_OPERATION))

#define IS_FDCAN_ID_TYPE(ID_TYPE) (((ID_TYPE) == FDCAN_STANDARD_ID) || ((ID_TYPE) == FDCAN_EXTENDED_ID))

#define IS_FDCAN_FILTER_CFG(CONFIG) (((CONFIG) == FDCAN_FILTER_DISABLE ) || ((CONFIG) == FDCAN_FILTER_TO_RXFIFO0 ) || ((CONFIG) == FDCAN_FILTER_TO_RXFIFO1 ) || ((CONFIG) == FDCAN_FILTER_REJECT ) || ((CONFIG) == FDCAN_FILTER_HP ) || ((CONFIG) == FDCAN_FILTER_TO_RXFIFO0_HP) || ((CONFIG) == FDCAN_FILTER_TO_RXFIFO1_HP))






#define IS_FDCAN_TX_LOCATION(LOCATION) (((LOCATION) == FDCAN_TX_BUFFER0 ) || ((LOCATION) == FDCAN_TX_BUFFER1 ) || ((LOCATION) == FDCAN_TX_BUFFER2 ))

#define IS_FDCAN_TX_LOCATION_LIST(LOCATION) (((LOCATION) >= FDCAN_TX_BUFFER0) && ((LOCATION) <= (FDCAN_TX_BUFFER0 | FDCAN_TX_BUFFER1 | FDCAN_TX_BUFFER2)))

#define IS_FDCAN_RX_FIFO(FIFO) (((FIFO) == FDCAN_RX_FIFO0) || ((FIFO) == FDCAN_RX_FIFO1))

#define IS_FDCAN_RX_FIFO_MODE(MODE) (((MODE) == FDCAN_RX_FIFO_BLOCKING ) || ((MODE) == FDCAN_RX_FIFO_OVERWRITE))

#define IS_FDCAN_STD_FILTER_TYPE(TYPE) (((TYPE) == FDCAN_FILTER_RANGE) || ((TYPE) == FDCAN_FILTER_DUAL ) || ((TYPE) == FDCAN_FILTER_MASK ))


#define IS_FDCAN_EXT_FILTER_TYPE(TYPE) (((TYPE) == FDCAN_FILTER_RANGE ) || ((TYPE) == FDCAN_FILTER_DUAL ) || ((TYPE) == FDCAN_FILTER_MASK ) || ((TYPE) == FDCAN_FILTER_RANGE_NO_EIDM))



#define IS_FDCAN_FRAME_TYPE(TYPE) (((TYPE) == FDCAN_DATA_FRAME ) || ((TYPE) == FDCAN_REMOTE_FRAME))

#define IS_FDCAN_DLC(DLC) (((DLC) == FDCAN_DLC_BYTES_0 ) || ((DLC) == FDCAN_DLC_BYTES_1 ) || ((DLC) == FDCAN_DLC_BYTES_2 ) || ((DLC) == FDCAN_DLC_BYTES_3 ) || ((DLC) == FDCAN_DLC_BYTES_4 ) || ((DLC) == FDCAN_DLC_BYTES_5 ) || ((DLC) == FDCAN_DLC_BYTES_6 ) || ((DLC) == FDCAN_DLC_BYTES_7 ) || ((DLC) == FDCAN_DLC_BYTES_8 ) || ((DLC) == FDCAN_DLC_BYTES_12) || ((DLC) == FDCAN_DLC_BYTES_16) || ((DLC) == FDCAN_DLC_BYTES_20) || ((DLC) == FDCAN_DLC_BYTES_24) || ((DLC) == FDCAN_DLC_BYTES_32) || ((DLC) == FDCAN_DLC_BYTES_48) || ((DLC) == FDCAN_DLC_BYTES_64))
# 1379 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_fdcan.h"
#define IS_FDCAN_ESI(ESI) (((ESI) == FDCAN_ESI_ACTIVE ) || ((ESI) == FDCAN_ESI_PASSIVE))

#define IS_FDCAN_BRS(BRS) (((BRS) == FDCAN_BRS_OFF) || ((BRS) == FDCAN_BRS_ON ))

#define IS_FDCAN_FDF(FDF) (((FDF) == FDCAN_CLASSIC_CAN) || ((FDF) == FDCAN_FD_CAN ))

#define IS_FDCAN_EFC(EFC) (((EFC) == FDCAN_NO_TX_EVENTS ) || ((EFC) == FDCAN_STORE_TX_EVENTS))

#define IS_FDCAN_IT(IT) (((IT) & ~(FDCAN_IR_MASK)) == 0U)
#define IS_FDCAN_IT_GROUP(IT_GROUP) (((IT_GROUP) & ~(FDCAN_ILS_MASK)) == 0U)
#define IS_FDCAN_NON_MATCHING(DESTINATION) (((DESTINATION) == FDCAN_ACCEPT_IN_RX_FIFO0) || ((DESTINATION) == FDCAN_ACCEPT_IN_RX_FIFO1) || ((DESTINATION) == FDCAN_REJECT ))


#define IS_FDCAN_REJECT_REMOTE(DESTINATION) (((DESTINATION) == FDCAN_FILTER_REMOTE) || ((DESTINATION) == FDCAN_REJECT_REMOTE))

#define IS_FDCAN_IT_LINE(IT_LINE) (((IT_LINE) == FDCAN_INTERRUPT_LINE0) || ((IT_LINE) == FDCAN_INTERRUPT_LINE1))

#define IS_FDCAN_TIMESTAMP(OPERATION) (((OPERATION) == FDCAN_TIMESTAMP_INTERNAL) || ((OPERATION) == FDCAN_TIMESTAMP_EXTERNAL))

#define IS_FDCAN_TIMESTAMP_PRESCALER(PRESCALER) (((PRESCALER) == FDCAN_TIMESTAMP_PRESC_1 ) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_2 ) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_3 ) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_4 ) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_5 ) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_6 ) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_7 ) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_8 ) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_9 ) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_10) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_11) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_12) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_13) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_14) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_15) || ((PRESCALER) == FDCAN_TIMESTAMP_PRESC_16))
# 1414 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_fdcan.h"
#define IS_FDCAN_TIMEOUT(OPERATION) (((OPERATION) == FDCAN_TIMEOUT_CONTINUOUS ) || ((OPERATION) == FDCAN_TIMEOUT_TX_EVENT_FIFO) || ((OPERATION) == FDCAN_TIMEOUT_RX_FIFO0 ) || ((OPERATION) == FDCAN_TIMEOUT_RX_FIFO1 ))




#define FDCAN_CHECK_IT_SOURCE(__IE__,__IT__) ((((__IE__) & (__IT__)) == (__IT__)) ? SET : RESET)

#define FDCAN_CHECK_FLAG(__IR__,__FLAG__) ((((__IR__) & (__FLAG__)) == (__FLAG__)) ? SET : RESET)
/**
  * @}
  */

/* Private functions prototypes ----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/**
  * @}
  */

/**
  * @}
  */






# 257 "Core/Inc/stm32g4xx_hal_conf.h" 2



# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_flash.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_flash.h
  * @author  MCD Application Team
  * @brief   Header file of FLASH HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_FLASH_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup FLASH
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/** @defgroup FLASH_Exported_Types FLASH Exported Types
  * @{
  */

/**
  * @brief  FLASH Erase structure definition
  */
typedef struct
{
  uint32_t TypeErase;   /*!< Mass erase or page erase.
                             This parameter can be a value of @ref FLASH_Type_Erase */
  uint32_t Banks;       /*!< Select bank to erase.
                             This parameter must be a value of @ref FLASH_Banks
                             (FLASH_BANK_BOTH should be used only for mass erase) */
  uint32_t Page;        /*!< Initial Flash page to erase when page erase is disabled.
                             This parameter must be a value between 0 and (max number of pages in the bank - 1)
                             (eg : 127 for 512KB dual bank) */
  uint32_t NbPages;     /*!< Number of pages to be erased.
                             This parameter must be a value between 1 and (max number of pages in the bank - value of initial page)*/
} FLASH_EraseInitTypeDef;

/**
  * @brief  FLASH Option Bytes Program structure definition
  */
typedef struct
{
  uint32_t OptionType;     /*!< Option byte to be configured.
                                This parameter can be a combination of the values of @ref FLASH_OB_Type */
  uint32_t WRPArea;        /*!< Write protection area to be programmed (used for OPTIONBYTE_WRP).
                                Only one WRP area could be programmed at the same time.
                                This parameter can be value of @ref FLASH_OB_WRP_Area */
  uint32_t WRPStartOffset; /*!< Write protection start offset (used for OPTIONBYTE_WRP).
                                This parameter must be a value between 0 and (max number of pages in the bank - 1) */
  uint32_t WRPEndOffset;   /*!< Write protection end offset (used for OPTIONBYTE_WRP).
                                This parameter must be a value between WRPStartOffset and (max number of pages in the bank - 1) */
  uint32_t RDPLevel;       /*!< Set the read protection level.. (used for OPTIONBYTE_RDP).
                                This parameter can be a value of @ref FLASH_OB_Read_Protection */
  uint32_t USERType;       /*!< User option byte(s) to be configured (used for OPTIONBYTE_USER).
                                This parameter can be a combination of @ref FLASH_OB_USER_Type */
  uint32_t USERConfig;     /*!< Value of the user option byte (used for OPTIONBYTE_USER).
                                This parameter can be a combination of @ref FLASH_OB_USER_BOR_LEVEL,
                                @ref FLASH_OB_USER_nRST_STOP, @ref FLASH_OB_USER_nRST_STANDBY,
                                @ref FLASH_OB_USER_nRST_SHUTDOWN, @ref FLASH_OB_USER_IWDG_SW,
                                @ref FLASH_OB_USER_IWDG_STOP, @ref FLASH_OB_USER_IWDG_STANDBY,
                                @ref FLASH_OB_USER_WWDG_SW, @ref FLASH_OB_USER_BFB2 (*),
                                @ref FLASH_OB_USER_nBOOT1, @ref FLASH_OB_USER_SRAM_PE,
                                @ref FLASH_OB_USER_CCMSRAM_RST
                                @note (*) availability depends on devices */
  uint32_t PCROPConfig;    /*!< Configuration of the PCROP (used for OPTIONBYTE_PCROP).
                                This parameter must be a combination of @ref FLASH_Banks (except FLASH_BANK_BOTH)
                                and @ref FLASH_OB_PCROP_RDP */
  uint32_t PCROPStartAddr; /*!< PCROP Start address (used for OPTIONBYTE_PCROP).
                                This parameter must be a value between begin and end of bank
                                => Be careful of the bank swapping for the address */
  uint32_t PCROPEndAddr;   /*!< PCROP End address (used for OPTIONBYTE_PCROP).
                                This parameter must be a value between PCROP Start address and end of bank */
  uint32_t BootEntryPoint; /*!< Set the Boot Lock (used for OPTIONBYTE_BOOT_LOCK).
                                This parameter can be a value of @ref FLASH_OB_Boot_Lock */
  uint32_t SecBank;        /*!< Bank of securable memory area to be programmed (used for OPTIONBYTE_SEC).
                                Only one securable memory area could be programmed at the same time.
                                This parameter can be one of the following values:
                                FLASH_BANK_1: Securable memory area to be programmed in bank 1
                                FLASH_BANK_2: Securable memory area to be programmed in bank 2 (*)
                                @note (*) availability depends on devices */
  uint32_t SecSize;        /*!< Size of securable memory area to be programmed (used for OPTIONBYTE_SEC),
                                in number of pages. Securable memory area is starting from first page of the bank.
                                Only one securable memory could be programmed at the same time.
                                This parameter must be a value between 0 and (max number of pages in the bank - 1) */
} FLASH_OBProgramInitTypeDef;

/**
  * @brief  FLASH Procedure structure definition
  */
typedef enum
{
  FLASH_PROC_NONE = 0,
  FLASH_PROC_PAGE_ERASE,
  FLASH_PROC_MASS_ERASE,
  FLASH_PROC_PROGRAM,
  FLASH_PROC_PROGRAM_LAST
} FLASH_ProcedureTypeDef;

/**
  * @brief  FLASH Cache structure definition
  */
typedef enum
{
  FLASH_CACHE_DISABLED = 0,
  FLASH_CACHE_ICACHE_ENABLED,
  FLASH_CACHE_DCACHE_ENABLED,
  FLASH_CACHE_ICACHE_DCACHE_ENABLED
} FLASH_CacheTypeDef;

/**
  * @brief  FLASH handle Structure definition
  */
typedef struct
{
  HAL_LockTypeDef             Lock;              /* FLASH locking object */
  __IO uint32_t               ErrorCode;         /* FLASH error code */
  __IO FLASH_ProcedureTypeDef ProcedureOnGoing;  /* Internal variable to indicate which procedure is ongoing or not in IT context */
  __IO uint32_t               Address;           /* Internal variable to save address selected for program in IT context */
  __IO uint32_t               Bank;              /* Internal variable to save current bank selected during erase in IT context */
  __IO uint32_t               Page;              /* Internal variable to define the current page which is erasing in IT context */
  __IO uint32_t               NbPagesToErase;    /* Internal variable to save the remaining pages to erase in IT context */
  __IO FLASH_CacheTypeDef     CacheToReactivate; /* Internal variable to indicate which caches should be reactivated */
} FLASH_ProcessTypeDef;

/**
  * @}
  */

/* Exported constants --------------------------------------------------------*/
/** @defgroup FLASH_Exported_Constants FLASH Exported Constants
  * @{
  */

/** @defgroup FLASH_Error FLASH Error
  * @{
  */
#define HAL_FLASH_ERROR_NONE 0x00000000U
#define HAL_FLASH_ERROR_OP FLASH_FLAG_OPERR
#define HAL_FLASH_ERROR_PROG FLASH_FLAG_PROGERR
#define HAL_FLASH_ERROR_WRP FLASH_FLAG_WRPERR
#define HAL_FLASH_ERROR_PGA FLASH_FLAG_PGAERR
#define HAL_FLASH_ERROR_SIZ FLASH_FLAG_SIZERR
#define HAL_FLASH_ERROR_PGS FLASH_FLAG_PGSERR
#define HAL_FLASH_ERROR_MIS FLASH_FLAG_MISERR
#define HAL_FLASH_ERROR_FAST FLASH_FLAG_FASTERR
#define HAL_FLASH_ERROR_RD FLASH_FLAG_RDERR
#define HAL_FLASH_ERROR_OPTV FLASH_FLAG_OPTVERR
#define HAL_FLASH_ERROR_ECCC FLASH_FLAG_ECCC
#define HAL_FLASH_ERROR_ECCD FLASH_FLAG_ECCD

#define HAL_FLASH_ERROR_ECCC2 FLASH_FLAG_ECCC2
#define HAL_FLASH_ERROR_ECCD2 FLASH_FLAG_ECCD2

/**
  * @}
  */

/** @defgroup FLASH_Type_Erase FLASH Erase Type
  * @{
  */
#define FLASH_TYPEERASE_PAGES 0x00U
#define FLASH_TYPEERASE_MASSERASE 0x01U
/**
  * @}
  */

/** @defgroup FLASH_Banks FLASH Banks
  * @{
  */
#define FLASH_BANK_1 0x00000001U

#define FLASH_BANK_2 0x00000002U
#define FLASH_BANK_BOTH (FLASH_BANK_1 | FLASH_BANK_2)



/**
  * @}
  */


/** @defgroup FLASH_Type_Program FLASH Program Type
  * @{
  */
#define FLASH_TYPEPROGRAM_DOUBLEWORD 0x00U
#define FLASH_TYPEPROGRAM_FAST 0x01U

#define FLASH_TYPEPROGRAM_FAST_AND_LAST 0x02U

/**
  * @}
  */

/** @defgroup FLASH_OB_Type FLASH Option Bytes Type
  * @{
  */
#define OPTIONBYTE_WRP 0x01U
#define OPTIONBYTE_RDP 0x02U
#define OPTIONBYTE_USER 0x04U
#define OPTIONBYTE_PCROP 0x08U
#define OPTIONBYTE_BOOT_LOCK 0x10U
#define OPTIONBYTE_SEC 0x20U
/**
  * @}
  */

/** @defgroup FLASH_OB_WRP_Area FLASH WRP Area
  * @{
  */
#define OB_WRPAREA_BANK1_AREAA 0x00U
#define OB_WRPAREA_BANK1_AREAB 0x01U

#define OB_WRPAREA_BANK2_AREAA 0x02U
#define OB_WRPAREA_BANK2_AREAB 0x04U

/**
  * @}
  */

/** @defgroup FLASH_OB_Boot_Lock FLASH Boot Lock
  * @{
  */
#define OB_BOOT_LOCK_DISABLE 0x00000000U
#define OB_BOOT_LOCK_ENABLE FLASH_SEC1R_BOOT_LOCK
/**
  * @}
  */

/** @defgroup FLASH_OB_Read_Protection FLASH Option Bytes Read Protection
  * @{
  */
#define OB_RDP_LEVEL_0 0xAAU
#define OB_RDP_LEVEL_1 0xBBU
#define OB_RDP_LEVEL_2 0xCCU

/**
  * @}
  */

/** @defgroup FLASH_OB_USER_Type FLASH Option Bytes User Type
  * @{
  */
#define OB_USER_BOR_LEV 0x00000001U
#define OB_USER_nRST_STOP 0x00000002U
#define OB_USER_nRST_STDBY 0x00000004U
#define OB_USER_IWDG_SW 0x00000008U
#define OB_USER_IWDG_STOP 0x00000010U
#define OB_USER_IWDG_STDBY 0x00000020U
#define OB_USER_WWDG_SW 0x00000040U

#define OB_USER_BFB2 0x00000080U
#define OB_USER_DBANK 0x00000100U




#define OB_USER_nBOOT1 0x00000200U
#define OB_USER_SRAM_PE 0x00000400U
#define OB_USER_CCMSRAM_RST 0x00000800U
#define OB_USER_nRST_SHDW 0x00001000U
#define OB_USER_nSWBOOT0 0x00002000U
#define OB_USER_nBOOT0 0x00004000U
#define OB_USER_NRST_MODE 0x00008000U
#define OB_USER_IRHEN 0x00010000U
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_BOR_LEVEL FLASH Option Bytes User BOR Level
  * @{
  */
#define OB_BOR_LEVEL_0 FLASH_OPTR_BOR_LEV_0
#define OB_BOR_LEVEL_1 FLASH_OPTR_BOR_LEV_1
#define OB_BOR_LEVEL_2 FLASH_OPTR_BOR_LEV_2
#define OB_BOR_LEVEL_3 FLASH_OPTR_BOR_LEV_3
#define OB_BOR_LEVEL_4 FLASH_OPTR_BOR_LEV_4
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_nRST_STOP FLASH Option Bytes User Reset On Stop
  * @{
  */
#define OB_STOP_RST 0x00000000U
#define OB_STOP_NORST FLASH_OPTR_nRST_STOP
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_nRST_STANDBY FLASH Option Bytes User Reset On Standby
  * @{
  */
#define OB_STANDBY_RST 0x00000000U
#define OB_STANDBY_NORST FLASH_OPTR_nRST_STDBY
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_nRST_SHUTDOWN FLASH Option Bytes User Reset On Shutdown
  * @{
  */
#define OB_SHUTDOWN_RST 0x00000000U
#define OB_SHUTDOWN_NORST FLASH_OPTR_nRST_SHDW
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_IWDG_SW FLASH Option Bytes User IWDG Type
  * @{
  */
#define OB_IWDG_HW 0x00000000U
#define OB_IWDG_SW FLASH_OPTR_IWDG_SW
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_IWDG_STOP FLASH Option Bytes User IWDG Mode On Stop
  * @{
  */
#define OB_IWDG_STOP_FREEZE 0x00000000U
#define OB_IWDG_STOP_RUN FLASH_OPTR_IWDG_STOP
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_IWDG_STANDBY FLASH Option Bytes User IWDG Mode On Standby
  * @{
  */
#define OB_IWDG_STDBY_FREEZE 0x00000000U
#define OB_IWDG_STDBY_RUN FLASH_OPTR_IWDG_STDBY
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_WWDG_SW FLASH Option Bytes User WWDG Type
  * @{
  */
#define OB_WWDG_HW 0x00000000U
#define OB_WWDG_SW FLASH_OPTR_WWDG_SW
/**
  * @}
  */


/** @defgroup FLASH_OB_USER_BFB2 FLASH Option Bytes User BFB2 Mode
  * @{
  */
#define OB_BFB2_DISABLE 0x00000000U
#define OB_BFB2_ENABLE FLASH_OPTR_BFB2
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_DBANK FLASH Option Bytes User DBANK Type
  * @{
  */
#define OB_DBANK_128_BITS 0x00000000U
#define OB_DBANK_64_BITS FLASH_OPTR_DBANK
/**
  * @}
  */


# 395 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_flash.h"

/** @defgroup FLASH_OB_USER_nBOOT1 FLASH Option Bytes User BOOT1 Type
  * @{
  */
#define OB_BOOT1_SRAM 0x00000000U
#define OB_BOOT1_SYSTEM FLASH_OPTR_nBOOT1
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_SRAM_PE FLASH Option Bytes User SRAM Parity Check Type
  * @{
  */
#define OB_SRAM_PARITY_ENABLE 0x00000000U
#define OB_SRAM_PARITY_DISABLE FLASH_OPTR_SRAM_PE
/**
  * @}
  */
/** @defgroup FLASH_OB_USER_CCMSRAM_RST FLASH Option Bytes User CCMSRAM Erase On Reset Type
  * @{
  */
#define OB_CCMSRAM_RST_ERASE 0x00000000U
#define OB_CCMSRAM_RST_NOT_ERASE FLASH_OPTR_CCMSRAM_RST
/**
  * @}
  */
/** @defgroup FLASH_OB_USER_nSWBOOT0 FLASH Option Bytes User Software BOOT0
  * @{
  */
#define OB_BOOT0_FROM_OB 0x00000000U
#define OB_BOOT0_FROM_PIN FLASH_OPTR_nSWBOOT0
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_nBOOT0 FLASH Option Bytes User nBOOT0 option bit
  * @{
  */
#define OB_nBOOT0_RESET 0x00000000U
#define OB_nBOOT0_SET FLASH_OPTR_nBOOT0
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_NRST_MODE FLASH Option Bytes User NRST mode bit
  * @{
  */
#define OB_NRST_MODE_INPUT_ONLY FLASH_OPTR_NRST_MODE_0
#define OB_NRST_MODE_GPIO FLASH_OPTR_NRST_MODE_1
#define OB_NRST_MODE_INPUT_OUTPUT FLASH_OPTR_NRST_MODE
/**
  * @}
  */

/** @defgroup FLASH_OB_USER_INTERNAL_RESET_HOLDER FLASH Option Bytes User internal reset holder bit
  * @{
  */
#define OB_IRH_DISABLE 0x00000000U
#define OB_IRH_ENABLE FLASH_OPTR_IRHEN
/**
  * @}
  */

/** @defgroup FLASH_OB_PCROP_RDP FLASH Option Bytes PCROP On RDP Level Type
  * @{
  */
#define OB_PCROP_RDP_NOT_ERASE 0x00000000U

#define OB_PCROP_RDP_ERASE FLASH_PCROP1ER_PCROP_RDP

/**
  * @}
  */

/** @defgroup FLASH_Latency FLASH Latency
  * @{
  */
#define FLASH_LATENCY_0 FLASH_ACR_LATENCY_0WS
#define FLASH_LATENCY_1 FLASH_ACR_LATENCY_1WS
#define FLASH_LATENCY_2 FLASH_ACR_LATENCY_2WS
#define FLASH_LATENCY_3 FLASH_ACR_LATENCY_3WS
#define FLASH_LATENCY_4 FLASH_ACR_LATENCY_4WS
#define FLASH_LATENCY_5 FLASH_ACR_LATENCY_5WS
#define FLASH_LATENCY_6 FLASH_ACR_LATENCY_6WS
#define FLASH_LATENCY_7 FLASH_ACR_LATENCY_7WS
#define FLASH_LATENCY_8 FLASH_ACR_LATENCY_8WS
#define FLASH_LATENCY_9 FLASH_ACR_LATENCY_9WS
#define FLASH_LATENCY_10 FLASH_ACR_LATENCY_10WS
#define FLASH_LATENCY_11 FLASH_ACR_LATENCY_11WS
#define FLASH_LATENCY_12 FLASH_ACR_LATENCY_12WS
#define FLASH_LATENCY_13 FLASH_ACR_LATENCY_13WS
#define FLASH_LATENCY_14 FLASH_ACR_LATENCY_14WS
#define FLASH_LATENCY_15 FLASH_ACR_LATENCY_15WS
/**
  * @}
  */

/** @defgroup FLASH_Keys FLASH Keys
  * @{
  */
#define FLASH_KEY1 0x45670123U
#define FLASH_KEY2 0xCDEF89ABU


#define FLASH_PDKEY1 0x04152637U
#define FLASH_PDKEY2 0xFAFBFCFDU


#define FLASH_OPTKEY1 0x08192A3BU
#define FLASH_OPTKEY2 0x4C5D6E7FU

/**
  * @}
  */

/** @defgroup FLASH_Flags FLASH Flags Definition
  * @{
  */
#define FLASH_FLAG_EOP FLASH_SR_EOP
#define FLASH_FLAG_OPERR FLASH_SR_OPERR
#define FLASH_FLAG_PROGERR FLASH_SR_PROGERR
#define FLASH_FLAG_WRPERR FLASH_SR_WRPERR
#define FLASH_FLAG_PGAERR FLASH_SR_PGAERR
#define FLASH_FLAG_SIZERR FLASH_SR_SIZERR
#define FLASH_FLAG_PGSERR FLASH_SR_PGSERR
#define FLASH_FLAG_MISERR FLASH_SR_MISERR
#define FLASH_FLAG_FASTERR FLASH_SR_FASTERR
#define FLASH_FLAG_RDERR FLASH_SR_RDERR
#define FLASH_FLAG_OPTVERR FLASH_SR_OPTVERR
#define FLASH_FLAG_BSY FLASH_SR_BSY
#define FLASH_FLAG_ECCC FLASH_ECCR_ECCC
#define FLASH_FLAG_ECCD FLASH_ECCR_ECCD

#define FLASH_FLAG_ECCC2 FLASH_ECCR_ECCC2
#define FLASH_FLAG_ECCD2 FLASH_ECCR_ECCD2


#define FLASH_FLAG_SR_ERRORS (FLASH_FLAG_OPERR | FLASH_FLAG_PROGERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_SIZERR | FLASH_FLAG_PGSERR | FLASH_FLAG_MISERR | FLASH_FLAG_FASTERR | FLASH_FLAG_RDERR | FLASH_FLAG_OPTVERR)




#define FLASH_FLAG_ECCR_ERRORS (FLASH_FLAG_ECCC | FLASH_FLAG_ECCD | FLASH_FLAG_ECCC2 | FLASH_FLAG_ECCD2)



#define FLASH_FLAG_ALL_ERRORS (FLASH_FLAG_SR_ERRORS | FLASH_FLAG_ECCR_ERRORS)
/**
  * @}
  */

/** @defgroup FLASH_Interrupt_definition FLASH Interrupts Definition
  * @brief FLASH Interrupt definition
  * @{
  */
#define FLASH_IT_EOP FLASH_CR_EOPIE
#define FLASH_IT_OPERR FLASH_CR_ERRIE
#define FLASH_IT_RDERR FLASH_CR_RDERRIE
#define FLASH_IT_ECCC (FLASH_ECCR_ECCIE >> 24U)
/**
  * @}
  */

/**
  * @}
  */

/* Exported macros -----------------------------------------------------------*/
/** @defgroup FLASH_Exported_Macros FLASH Exported Macros
  * @brief macros to control FLASH features
  * @{
  */

/**
  * @brief  Set the FLASH Latency.
  * @param  __LATENCY__ FLASH Latency.
  *         This parameter can be one of the following values :
  *           @arg FLASH_LATENCY_0:  FLASH Zero wait state
  *           @arg FLASH_LATENCY_1:  FLASH One wait state
  *           @arg FLASH_LATENCY_2:  FLASH Two wait states
  *           @arg FLASH_LATENCY_3:  FLASH Three wait states
  *           @arg FLASH_LATENCY_4:  FLASH Four wait states
  *           @arg FLASH_LATENCY_5:  FLASH Five wait states
  *           @arg FLASH_LATENCY_6:  FLASH Six wait states
  *           @arg FLASH_LATENCY_7:  FLASH Seven wait states
  *           @arg FLASH_LATENCY_8:  FLASH Eight wait states 
  *           @arg FLASH_LATENCY_9:  FLASH Nine wait states 
  *           @arg FLASH_LATENCY_10: FLASH Ten wait state
  *           @arg FLASH_LATENCY_11: FLASH Eleven wait state
  *           @arg FLASH_LATENCY_12: FLASH Twelve wait states
  *           @arg FLASH_LATENCY_13: FLASH Thirteen wait states
  *           @arg FLASH_LATENCY_14: FLASH Fourteen wait states
  *           @arg FLASH_LATENCY_15: FLASH Fifteen wait states
  * @retval None
  */
#define __HAL_FLASH_SET_LATENCY(__LATENCY__) MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (__LATENCY__))

/**
  * @brief  Get the FLASH Latency.
  * @retval FLASH_Latency.
  *         This parameter can be one of the following values :
  *           @arg FLASH_LATENCY_0:  FLASH Zero wait state
  *           @arg FLASH_LATENCY_1:  FLASH One wait state
  *           @arg FLASH_LATENCY_2:  FLASH Two wait states
  *           @arg FLASH_LATENCY_3:  FLASH Three wait states
  *           @arg FLASH_LATENCY_4:  FLASH Four wait states
  *           @arg FLASH_LATENCY_5:  FLASH Five wait states
  *           @arg FLASH_LATENCY_6:  FLASH Six wait states
  *           @arg FLASH_LATENCY_7:  FLASH Seven wait states
  *           @arg FLASH_LATENCY_8:  FLASH Eight wait states 
  *           @arg FLASH_LATENCY_9:  FLASH Nine wait states 
  *           @arg FLASH_LATENCY_10: FLASH Ten wait state
  *           @arg FLASH_LATENCY_11: FLASH Eleven wait state
  *           @arg FLASH_LATENCY_12: FLASH Twelve wait states
  *           @arg FLASH_LATENCY_13: FLASH Thirteen wait states
  *           @arg FLASH_LATENCY_14: FLASH Fourteen wait states
  *           @arg FLASH_LATENCY_15: FLASH Fifteen wait states
  */
#define __HAL_FLASH_GET_LATENCY() READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY)

/**
  * @brief  Enable the FLASH prefetch buffer.
  * @retval None
  */
#define __HAL_FLASH_PREFETCH_BUFFER_ENABLE() SET_BIT(FLASH->ACR, FLASH_ACR_PRFTEN)

/**
  * @brief  Disable the FLASH prefetch buffer.
  * @retval None
  */
#define __HAL_FLASH_PREFETCH_BUFFER_DISABLE() CLEAR_BIT(FLASH->ACR, FLASH_ACR_PRFTEN)

/**
  * @brief  Enable the FLASH instruction cache.
  * @retval none
  */
#define __HAL_FLASH_INSTRUCTION_CACHE_ENABLE() SET_BIT(FLASH->ACR, FLASH_ACR_ICEN)

/**
  * @brief  Disable the FLASH instruction cache.
  * @retval none
  */
#define __HAL_FLASH_INSTRUCTION_CACHE_DISABLE() CLEAR_BIT(FLASH->ACR, FLASH_ACR_ICEN)

/**
  * @brief  Enable the FLASH data cache.
  * @retval none
  */
#define __HAL_FLASH_DATA_CACHE_ENABLE() SET_BIT(FLASH->ACR, FLASH_ACR_DCEN)

/**
  * @brief  Disable the FLASH data cache.
  * @retval none
  */
#define __HAL_FLASH_DATA_CACHE_DISABLE() CLEAR_BIT(FLASH->ACR, FLASH_ACR_DCEN)

/**
  * @brief  Reset the FLASH instruction Cache.
  * @note   This function must be used only when the Instruction Cache is disabled.
  * @retval None
  */
#define __HAL_FLASH_INSTRUCTION_CACHE_RESET() do { SET_BIT(FLASH->ACR, FLASH_ACR_ICRST); CLEAR_BIT(FLASH->ACR, FLASH_ACR_ICRST); } while (0)



/**
  * @brief  Reset the FLASH data Cache.
  * @note   This function must be used only when the data Cache is disabled.
  * @retval None
  */
#define __HAL_FLASH_DATA_CACHE_RESET() do { SET_BIT(FLASH->ACR, FLASH_ACR_DCRST); CLEAR_BIT(FLASH->ACR, FLASH_ACR_DCRST); } while (0)



/**
  * @brief  Enable the FLASH power down during Low-power run mode.
  * @note   Writing this bit to 1, automatically the keys are
  *         lost and a new unlock sequence is necessary to re-write it to 0.
  */
#define __HAL_FLASH_POWER_DOWN_ENABLE() do { WRITE_REG(FLASH->PDKEYR, FLASH_PDKEY1); WRITE_REG(FLASH->PDKEYR, FLASH_PDKEY2); SET_BIT(FLASH->ACR, FLASH_ACR_RUN_PD); } while (0)




/**
  * @brief  Disable the FLASH power down during Low-power run mode.
  * @note   Writing this bit to 0, automatically the keys are
  *         lost and a new unlock sequence is necessary to re-write it to 1.
  */
#define __HAL_FLASH_POWER_DOWN_DISABLE() do { WRITE_REG(FLASH->PDKEYR, FLASH_PDKEY1); WRITE_REG(FLASH->PDKEYR, FLASH_PDKEY2); CLEAR_BIT(FLASH->ACR, FLASH_ACR_RUN_PD); } while (0)




/**
  * @brief  Enable the FLASH power down during Low-Power sleep mode
  * @retval none
  */
#define __HAL_FLASH_SLEEP_POWERDOWN_ENABLE() SET_BIT(FLASH->ACR, FLASH_ACR_SLEEP_PD)

/**
  * @brief  Disable the FLASH power down during Low-Power sleep mode
  * @retval none
  */
#define __HAL_FLASH_SLEEP_POWERDOWN_DISABLE() CLEAR_BIT(FLASH->ACR, FLASH_ACR_SLEEP_PD)

/**
  * @}
  */

/** @defgroup FLASH_Interrupt FLASH Interrupts Macros
  *  @brief macros to handle FLASH interrupts
  * @{
  */

/**
  * @brief  Enable the specified FLASH interrupt.
  * @param  __INTERRUPT__ FLASH interrupt
  *         This parameter can be any combination of the following values:
  *     @arg FLASH_IT_EOP: End of FLASH Operation Interrupt
  *     @arg FLASH_IT_OPERR: Error Interrupt
  *     @arg FLASH_IT_RDERR: PCROP Read Error Interrupt
  *     @arg FLASH_IT_ECCC: ECC Correction Interrupt
  * @retval none
  */
#define __HAL_FLASH_ENABLE_IT(__INTERRUPT__) do { if(((__INTERRUPT__) & FLASH_IT_ECCC) != 0U) { SET_BIT(FLASH->ECCR, FLASH_ECCR_ECCIE); } if(((__INTERRUPT__) & (~FLASH_IT_ECCC)) != 0U) { SET_BIT(FLASH->CR, ((__INTERRUPT__) & (~FLASH_IT_ECCC))); } } while (0)



/**
  * @brief  Disable the specified FLASH interrupt.
  * @param  __INTERRUPT__ FLASH interrupt
  *         This parameter can be any combination of the following values:
  *     @arg FLASH_IT_EOP: End of FLASH Operation Interrupt
  *     @arg FLASH_IT_OPERR: Error Interrupt
  *     @arg FLASH_IT_RDERR: PCROP Read Error Interrupt
  *     @arg FLASH_IT_ECCC: ECC Correction Interrupt
  * @retval none
  */
#define __HAL_FLASH_DISABLE_IT(__INTERRUPT__) do { if(((__INTERRUPT__) & FLASH_IT_ECCC) != 0U) { CLEAR_BIT(FLASH->ECCR, FLASH_ECCR_ECCIE); } if(((__INTERRUPT__) & (~FLASH_IT_ECCC)) != 0U) { CLEAR_BIT(FLASH->CR, ((__INTERRUPT__) & (~FLASH_IT_ECCC))); } } while (0)



/**
  * @brief  Check whether the specified FLASH flag is set or not.
  * @param  __FLAG__ specifies the FLASH flag to check.
  *   This parameter can be one of the following values:
  *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag
  *     @arg FLASH_FLAG_OPERR: FLASH Operation error flag
  *     @arg FLASH_FLAG_PROGERR: FLASH Programming error flag
  *     @arg FLASH_FLAG_WRPERR: FLASH Write protection error flag
  *     @arg FLASH_FLAG_PGAERR: FLASH Programming alignment error flag
  *     @arg FLASH_FLAG_SIZERR: FLASH Size error flag
  *     @arg FLASH_FLAG_PGSERR: FLASH Programming sequence error flag
  *     @arg FLASH_FLAG_MISERR: FLASH Fast programming data miss error flag
  *     @arg FLASH_FLAG_FASTERR: FLASH Fast programming error flag
  *     @arg FLASH_FLAG_RDERR: FLASH PCROP read  error flag
  *     @arg FLASH_FLAG_OPTVERR: FLASH Option validity error flag
  *     @arg FLASH_FLAG_BSY: FLASH write/erase operations in progress flag
  *     @arg FLASH_FLAG_ECCC: FLASH one ECC error has been detected and corrected in 64 LSB bits
  *     @arg FLASH_FLAG_ECCD: FLASH two ECC errors have been detected in 64 LSB bits
  *     @arg FLASH_FLAG_ECCC2(*): FLASH one ECC error has been detected and corrected in 64 MSB bits (mode 128 bits only)
  *     @arg FLASH_FLAG_ECCD2(*): FLASH two ECC errors have been detected in 64 MSB bits (mode 128 bits only)
  * @note  (*) availability depends on devices
  * @retval The new state of FLASH_FLAG (SET or RESET).
  */
#define __HAL_FLASH_GET_FLAG(__FLAG__) ((((__FLAG__) & FLASH_FLAG_ECCR_ERRORS) != 0U) ? (READ_BIT(FLASH->ECCR, (__FLAG__)) == (__FLAG__)) : (READ_BIT(FLASH->SR, (__FLAG__)) == (__FLAG__)))



/**
  * @brief  Clear the FLASH's pending flags.
  * @param  __FLAG__ specifies the FLASH flags to clear.
  *   This parameter can be any combination of the following values:
  *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag
  *     @arg FLASH_FLAG_OPERR: FLASH Operation error flag
  *     @arg FLASH_FLAG_PROGERR: FLASH Programming error flag
  *     @arg FLASH_FLAG_WRPERR: FLASH Write protection error flag
  *     @arg FLASH_FLAG_PGAERR: FLASH Programming alignment error flag
  *     @arg FLASH_FLAG_SIZERR: FLASH Size error flag
  *     @arg FLASH_FLAG_PGSERR: FLASH Programming sequence error flag
  *     @arg FLASH_FLAG_MISERR: FLASH Fast programming data miss error flag
  *     @arg FLASH_FLAG_FASTERR: FLASH Fast programming error flag
  *     @arg FLASH_FLAG_RDERR: FLASH PCROP read  error flag
  *     @arg FLASH_FLAG_OPTVERR: FLASH Option validity error flag
  *     @arg FLASH_FLAG_ECCC: FLASH one ECC error has been detected and corrected in 64 LSB bits
  *     @arg FLASH_FLAG_ECCD: FLASH two ECC errors have been detected in 64 LSB bits
  *     @arg FLASH_FLAG_ECCC2(*): FLASH one ECC error has been detected and corrected in 64 MSB bits (mode 128 bits only)
  *     @arg FLASH_FLAG_ECCD2(*): FLASH two ECC errors have been detected in 64 MSB bits (mode 128 bits only)
  *     @arg FLASH_FLAG_SR_ERRORS: FLASH All SR errors flags
  *     @arg FLASH_FLAG_ECCR_ERRORS: FLASH All ECCR errors flags
  * @note  (*) availability depends on devices
  * @retval None
  */
#define __HAL_FLASH_CLEAR_FLAG(__FLAG__) do { if(((__FLAG__) & FLASH_FLAG_ECCR_ERRORS) != 0U) { SET_BIT(FLASH->ECCR, ((__FLAG__) & FLASH_FLAG_ECCR_ERRORS)); } if(((__FLAG__) & ~(FLASH_FLAG_ECCR_ERRORS)) != 0U) { WRITE_REG(FLASH->SR, ((__FLAG__) & ~(FLASH_FLAG_ECCR_ERRORS))); } } while (0)


/**
  * @}
  */

/* Include FLASH HAL Extended module */
# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_flash_ex.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_flash_ex.h
  * @author  MCD Application Team
  * @brief   Header file of FLASH HAL Extended module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_FLASH_EX_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup FLASHEx
  * @{
  */

/* Exported types ------------------------------------------------------------*/

/* Exported constants --------------------------------------------------------*/

/* Exported macro ------------------------------------------------------------*/

/* Exported functions --------------------------------------------------------*/
/** @addtogroup FLASHEx_Exported_Functions
  * @{
  */

/* Extended Program operation functions  *************************************/
/** @addtogroup FLASHEx_Exported_Functions_Group1
  * @{
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError);
HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit);
HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit);
void              HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit);
HAL_StatusTypeDef HAL_FLASHEx_EnableSecMemProtection(uint32_t Bank);
void              HAL_FLASHEx_EnableDebugger(void);
void              HAL_FLASHEx_DisableDebugger(void);
/**
  * @}
  */

/**
  * @}
  */

/** @addtogroup FLASHEx_Private_Functions
  * @{
  */
void              FLASH_PageErase(uint32_t Page, uint32_t Banks);
void              FLASH_FlushCaches(void);
/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */







# 798 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_flash.h" 2
# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_flash_ramfunc.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_flash_ramfunc.h
  * @author  MCD Application Team
  * @brief   Header file of FLASH RAMFUNC driver.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_FLASH_RAMFUNC_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup FLASH_RAMFUNC
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
/** @addtogroup FLASH_RAMFUNC_Exported_Functions
  * @{
  */

/** @addtogroup FLASH_RAMFUNC_Exported_Functions_Group1
  * @{
  */
/* Peripheral Control functions  ************************************************/
__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_EnableRunPowerDown(void);
__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_DisableRunPowerDown(void);

__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_OB_DBankConfig(uint32_t DBankConfig);

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */







# 799 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_flash.h" 2

/* Exported variables --------------------------------------------------------*/
/** @defgroup FLASH_Exported_Variables FLASH Exported Variables
  * @{
  */
extern FLASH_ProcessTypeDef pFlash;
/**
  * @}
  */

/* Exported functions --------------------------------------------------------*/
/** @addtogroup FLASH_Exported_Functions
  * @{
  */

/* Program operation functions  ***********************************************/
/** @addtogroup FLASH_Exported_Functions_Group1
  * @{
  */
HAL_StatusTypeDef  HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data);
HAL_StatusTypeDef  HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data);
/* FLASH IRQ handler method */
void               HAL_FLASH_IRQHandler(void);
/* Callbacks in non blocking modes */
void               HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue);
void               HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue);
/**
  * @}
  */

/* Peripheral Control functions  **********************************************/
/** @addtogroup FLASH_Exported_Functions_Group2
  * @{
  */
HAL_StatusTypeDef  HAL_FLASH_Unlock(void);
HAL_StatusTypeDef  HAL_FLASH_Lock(void);
/* Option bytes control */
HAL_StatusTypeDef  HAL_FLASH_OB_Unlock(void);
HAL_StatusTypeDef  HAL_FLASH_OB_Lock(void);
HAL_StatusTypeDef  HAL_FLASH_OB_Launch(void);
/**
  * @}
  */

/* Peripheral State functions  ************************************************/
/** @addtogroup FLASH_Exported_Functions_Group3
  * @{
  */
uint32_t HAL_FLASH_GetError(void);
/**
  * @}
  */

/**
  * @}
  */

/** @addtogroup FLASH_Private_Functions
  * @{
  */
HAL_StatusTypeDef  FLASH_WaitForLastOperation(uint32_t Timeout);
/**
  * @}
  */

/* Private constants --------------------------------------------------------*/
/** @defgroup FLASH_Private_Constants FLASH Private Constants
  * @{
  */
#define FLASH_SIZE_DATA_REGISTER FLASHSIZE_BASE


#define FLASH_SIZE ((((*((uint16_t *)FLASH_SIZE_DATA_REGISTER)) == 0xFFFFU)) ? (0x200UL << 10U) : (((*((uint32_t *)FLASH_SIZE_DATA_REGISTER)) & 0xFFFFUL) << 10U))

#define FLASH_BANK_SIZE (FLASH_SIZE >> 1)
#define FLASH_PAGE_NB ((FLASH_SIZE == 0x00080000U) ? 128U : ((FLASH_SIZE == 0x00040000U) ? 64U : 32U))

#define FLASH_PAGE_SIZE_128_BITS 0x1000U








#define FLASH_PAGE_SIZE 0x800U

#define FLASH_TIMEOUT_VALUE 1000U

/**
  * @}
  */

/* Private macros ------------------------------------------------------------*/
/** @defgroup FLASH_Private_Macros FLASH Private Macros
  *  @{
  */

#define IS_FLASH_TYPEERASE(VALUE) (((VALUE) == FLASH_TYPEERASE_PAGES) || ((VALUE) == FLASH_TYPEERASE_MASSERASE))



#define IS_FLASH_BANK(BANK) (((BANK) == FLASH_BANK_1) || ((BANK) == FLASH_BANK_2) || ((BANK) == FLASH_BANK_BOTH))



#define IS_FLASH_BANK_EXCLUSIVE(BANK) (((BANK) == FLASH_BANK_1) || ((BANK) == FLASH_BANK_2))







#define IS_FLASH_TYPEPROGRAM(VALUE) (((VALUE) == FLASH_TYPEPROGRAM_DOUBLEWORD) || ((VALUE) == FLASH_TYPEPROGRAM_FAST) || ((VALUE) == FLASH_TYPEPROGRAM_FAST_AND_LAST))



#define IS_FLASH_MAIN_MEM_ADDRESS(ADDRESS) (((ADDRESS) >= FLASH_BASE) && ((ADDRESS) < (FLASH_BASE+FLASH_SIZE)))

#define IS_FLASH_OTP_ADDRESS(ADDRESS) (((ADDRESS) >= 0x1FFF7000U) && ((ADDRESS) <= 0x1FFF73FFU))

#define IS_FLASH_PROGRAM_ADDRESS(ADDRESS) (IS_FLASH_MAIN_MEM_ADDRESS(ADDRESS) || IS_FLASH_OTP_ADDRESS(ADDRESS))

#define IS_FLASH_PAGE(PAGE) ((PAGE) < FLASH_PAGE_NB)

#define IS_OPTIONBYTE(VALUE) (((VALUE) <= (OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER | OPTIONBYTE_PCROP | OPTIONBYTE_BOOT_LOCK | OPTIONBYTE_SEC)))



#define IS_OB_WRPAREA(VALUE) (((VALUE) == OB_WRPAREA_BANK1_AREAA) || ((VALUE) == OB_WRPAREA_BANK1_AREAB) || ((VALUE) == OB_WRPAREA_BANK2_AREAA) || ((VALUE) == OB_WRPAREA_BANK2_AREAB))





#define IS_OB_BOOT_LOCK(VALUE) (((VALUE) == OB_BOOT_LOCK_ENABLE) || ((VALUE) == OB_BOOT_LOCK_DISABLE))

#define IS_OB_RDP_LEVEL(LEVEL) (((LEVEL) == OB_RDP_LEVEL_0) || ((LEVEL) == OB_RDP_LEVEL_1) || ((LEVEL) == OB_RDP_LEVEL_2))



#define IS_OB_USER_TYPE(TYPE) (((TYPE) <= 0x1FFFFU) && ((TYPE) != 0U))

#define IS_OB_USER_BOR_LEVEL(LEVEL) (((LEVEL) == OB_BOR_LEVEL_0) || ((LEVEL) == OB_BOR_LEVEL_1) || ((LEVEL) == OB_BOR_LEVEL_2) || ((LEVEL) == OB_BOR_LEVEL_3) || ((LEVEL) == OB_BOR_LEVEL_4))



#define IS_OB_USER_STOP(VALUE) (((VALUE) == OB_STOP_RST) || ((VALUE) == OB_STOP_NORST))

#define IS_OB_USER_STANDBY(VALUE) (((VALUE) == OB_STANDBY_RST) || ((VALUE) == OB_STANDBY_NORST))

#define IS_OB_USER_SHUTDOWN(VALUE) (((VALUE) == OB_SHUTDOWN_RST) || ((VALUE) == OB_SHUTDOWN_NORST))

#define IS_OB_USER_IWDG(VALUE) (((VALUE) == OB_IWDG_HW) || ((VALUE) == OB_IWDG_SW))

#define IS_OB_USER_IWDG_STOP(VALUE) (((VALUE) == OB_IWDG_STOP_FREEZE) || ((VALUE) == OB_IWDG_STOP_RUN))

#define IS_OB_USER_IWDG_STDBY(VALUE) (((VALUE) == OB_IWDG_STDBY_FREEZE) || ((VALUE) == OB_IWDG_STDBY_RUN))

#define IS_OB_USER_WWDG(VALUE) (((VALUE) == OB_WWDG_HW) || ((VALUE) == OB_WWDG_SW))


#define IS_OB_USER_BFB2(VALUE) (((VALUE) == OB_BFB2_DISABLE) || ((VALUE) == OB_BFB2_ENABLE))

#define IS_OB_USER_DBANK(VALUE) (((VALUE) == OB_DBANK_128_BITS) || ((VALUE) == OB_DBANK_64_BITS))






#define IS_OB_USER_BOOT1(VALUE) (((VALUE) == OB_BOOT1_SRAM) || ((VALUE) == OB_BOOT1_SYSTEM))

#define IS_OB_USER_SRAM_PARITY(VALUE) (((VALUE) == OB_SRAM_PARITY_ENABLE) || ((VALUE) == OB_SRAM_PARITY_DISABLE))


#define IS_OB_USER_CCMSRAM_RST(VALUE) (((VALUE) == OB_CCMSRAM_RST_ERASE) || ((VALUE) == OB_CCMSRAM_RST_NOT_ERASE))

#define IS_OB_USER_SWBOOT0(VALUE) (((VALUE) == OB_BOOT0_FROM_OB) || ((VALUE) == OB_BOOT0_FROM_PIN))

#define IS_OB_USER_BOOT0(VALUE) (((VALUE) == OB_nBOOT0_RESET) || ((VALUE) == OB_nBOOT0_SET))

#define IS_OB_USER_NRST_MODE(VALUE) (((VALUE) == OB_NRST_MODE_GPIO) || ((VALUE) == OB_NRST_MODE_INPUT_ONLY) || ((VALUE) == OB_NRST_MODE_INPUT_OUTPUT))


#define IS_OB_USER_IRHEN(VALUE) (((VALUE) == OB_IRH_ENABLE) || ((VALUE) == OB_IRH_DISABLE))

#define IS_OB_PCROP_RDP(VALUE) (((VALUE) == OB_PCROP_RDP_NOT_ERASE) || ((VALUE) == OB_PCROP_RDP_ERASE))

#define IS_OB_SECMEM_SIZE(VALUE) ((VALUE) <= FLASH_PAGE_NB)

#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_LATENCY_0) || ((LATENCY) == FLASH_LATENCY_1) || ((LATENCY) == FLASH_LATENCY_2) || ((LATENCY) == FLASH_LATENCY_3) || ((LATENCY) == FLASH_LATENCY_4) || ((LATENCY) == FLASH_LATENCY_5) || ((LATENCY) == FLASH_LATENCY_6) || ((LATENCY) == FLASH_LATENCY_7) || ((LATENCY) == FLASH_LATENCY_8) || ((LATENCY) == FLASH_LATENCY_9) || ((LATENCY) == FLASH_LATENCY_10) || ((LATENCY) == FLASH_LATENCY_11) || ((LATENCY) == FLASH_LATENCY_12) || ((LATENCY) == FLASH_LATENCY_13) || ((LATENCY) == FLASH_LATENCY_14) || ((LATENCY) == FLASH_LATENCY_15))







/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */







# 261 "Core/Inc/stm32g4xx_hal_conf.h" 2















































# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_pwr.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_pwr.h
  * @author  MCD Application Team
  * @brief   Header file of PWR HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_PWR_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup PWR
  * @{
  */

/* Exported types ------------------------------------------------------------*/

/** @defgroup PWR_Exported_Types PWR Exported Types
  * @{
  */

/**
  * @brief  PWR PVD configuration structure definition
  */
typedef struct
{
  uint32_t PVDLevel;   /*!< PVDLevel: Specifies the PVD detection level.
                            This parameter can be a value of @ref PWR_PVD_detection_level. */

  uint32_t Mode;      /*!< Mode: Specifies the operating mode for the selected pins.
                           This parameter can be a value of @ref PWR_PVD_Mode. */
}PWR_PVDTypeDef;


/**
  * @}
  */

/* Exported constants --------------------------------------------------------*/

/** @defgroup PWR_Exported_Constants PWR Exported Constants
  * @{
  */


/** @defgroup PWR_PVD_detection_level Programmable Voltage Detection levels
  * @{
  */
#define PWR_PVDLEVEL_0 PWR_CR2_PLS_LEV0
#define PWR_PVDLEVEL_1 PWR_CR2_PLS_LEV1
#define PWR_PVDLEVEL_2 PWR_CR2_PLS_LEV2
#define PWR_PVDLEVEL_3 PWR_CR2_PLS_LEV3
#define PWR_PVDLEVEL_4 PWR_CR2_PLS_LEV4
#define PWR_PVDLEVEL_5 PWR_CR2_PLS_LEV5
#define PWR_PVDLEVEL_6 PWR_CR2_PLS_LEV6
#define PWR_PVDLEVEL_7 PWR_CR2_PLS_LEV7
/**
  * @}
  */

/** @defgroup PWR_PVD_Mode  PWR PVD interrupt and event mode
  * @{
  */
#define PWR_PVD_MODE_NORMAL ((uint32_t)0x00000000)
#define PWR_PVD_MODE_IT_RISING ((uint32_t)0x00010001)
#define PWR_PVD_MODE_IT_FALLING ((uint32_t)0x00010002)
#define PWR_PVD_MODE_IT_RISING_FALLING ((uint32_t)0x00010003)
#define PWR_PVD_MODE_EVENT_RISING ((uint32_t)0x00020001)
#define PWR_PVD_MODE_EVENT_FALLING ((uint32_t)0x00020002)
#define PWR_PVD_MODE_EVENT_RISING_FALLING ((uint32_t)0x00020003)
/**
  * @}
  */




/** @defgroup PWR_Regulator_state_in_SLEEP_STOP_mode  PWR regulator mode
  * @{
  */
#define PWR_MAINREGULATOR_ON ((uint32_t)0x00000000)
#define PWR_LOWPOWERREGULATOR_ON PWR_CR1_LPR
/**
  * @}
  */

/** @defgroup PWR_SLEEP_mode_entry  PWR SLEEP mode entry
  * @{
  */
#define PWR_SLEEPENTRY_WFI ((uint8_t)0x01)
#define PWR_SLEEPENTRY_WFE ((uint8_t)0x02)
/**
  * @}
  */

/** @defgroup PWR_STOP_mode_entry  PWR STOP mode entry
  * @{
  */
#define PWR_STOPENTRY_WFI ((uint8_t)0x01)
#define PWR_STOPENTRY_WFE ((uint8_t)0x02)
/**
  * @}
  */


/** @defgroup PWR_PVD_EXTI_LINE  PWR PVD external interrupt line
  * @{
  */
#define PWR_EXTI_LINE_PVD ((uint32_t)0x00010000)
/**
  * @}
  */

/** @defgroup PWR_PVD_EVENT_LINE  PWR PVD event line
  * @{
  */
#define PWR_EVENT_LINE_PVD ((uint32_t)0x00010000)
/**
  * @}
  */

/**
  * @}
  */

/* Exported macros -----------------------------------------------------------*/
/** @defgroup PWR_Exported_Macros  PWR Exported Macros
  * @{
  */

/** @brief  Check whether or not a specific PWR flag is set.
  * @param  __FLAG__: specifies the flag to check.
  *           This parameter can be one of the following values:
  *            @arg @ref PWR_FLAG_WUF1 Wake Up Flag 1. Indicates that a wakeup event
  *                  was received from the WKUP pin 1.
  *            @arg @ref PWR_FLAG_WUF2 Wake Up Flag 2. Indicates that a wakeup event
  *                  was received from the WKUP pin 2.
  *            @arg @ref PWR_FLAG_WUF3 Wake Up Flag 3. Indicates that a wakeup event
  *                  was received from the WKUP pin 3.
  *            @arg @ref PWR_FLAG_WUF4 Wake Up Flag 4. Indicates that a wakeup event
  *                  was received from the WKUP pin 4.
  *            @arg @ref PWR_FLAG_WUF5 Wake Up Flag 5. Indicates that a wakeup event
  *                  was received from the WKUP pin 5.
  *            @arg @ref PWR_FLAG_SB StandBy Flag. Indicates that the system
  *                  entered StandBy mode.
  *            @arg @ref PWR_FLAG_WUFI Wake-Up Flag Internal. Set when a wakeup is detected on
  *                 the internal wakeup line.
  *            @arg @ref PWR_FLAG_REGLPS Low Power Regulator Started. Indicates whether or not the
  *                 low-power regulator is ready.
  *            @arg @ref PWR_FLAG_REGLPF Low Power Regulator Flag. Indicates whether the
  *                 regulator is ready in main mode or is in low-power mode.
  *            @arg @ref PWR_FLAG_VOSF Voltage Scaling Flag. Indicates whether the regulator is ready
  *                 in the selected voltage range or is still changing to the required voltage level.
  *            @arg @ref PWR_FLAG_PVDO Power Voltage Detector Output. Indicates whether VDD voltage is
  *                  below or above the selected PVD threshold.
@if PWR_CR2_PVME1
  *            @arg @ref PWR_FLAG_PVMO1 Peripheral Voltage Monitoring Output 1. Indicates whether VDDUSB voltage is
  *                  is below or above PVM1 threshold (applicable when USB feature is supported).
@endif
@if PWR_CR2_PVME2
  *            @arg @ref PWR_FLAG_PVMO2 Peripheral Voltage Monitoring Output 2. Indicates whether VDDIO2 voltage is
  *                  is below or above PVM2 threshold (applicable when VDDIO2 is present on device).
@endif
  *            @arg @ref PWR_FLAG_PVMO3 Peripheral Voltage Monitoring Output 3. Indicates whether VDDA voltage is
  *                  is below or above PVM3 threshold.
  *            @arg @ref PWR_FLAG_PVMO4 Peripheral Voltage Monitoring Output 4. Indicates whether VDDA voltage is
  *                  is below or above PVM4 threshold.
  *
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  */
#define __HAL_PWR_GET_FLAG(__FLAG__) ( ((((uint8_t)(__FLAG__)) >> 5U) == 1) ? (PWR->SR1 & (1U << ((__FLAG__) & 31U))) : (PWR->SR2 & (1U << ((__FLAG__) & 31U))) )



/** @brief  Clear a specific PWR flag.
  * @param  __FLAG__: specifies the flag to clear.
  *          This parameter can be one of the following values:
  *            @arg @ref PWR_FLAG_WUF1 Wake Up Flag 1. Indicates that a wakeup event
  *                  was received from the WKUP pin 1.
  *            @arg @ref PWR_FLAG_WUF2 Wake Up Flag 2. Indicates that a wakeup event
  *                  was received from the WKUP pin 2.
  *            @arg @ref PWR_FLAG_WUF3 Wake Up Flag 3. Indicates that a wakeup event
  *                  was received from the WKUP pin 3.
  *            @arg @ref PWR_FLAG_WUF4 Wake Up Flag 4. Indicates that a wakeup event
  *                  was received from the WKUP pin 4.
  *            @arg @ref PWR_FLAG_WUF5 Wake Up Flag 5. Indicates that a wakeup event
  *                  was received from the WKUP pin 5.
  *            @arg @ref PWR_FLAG_WU Encompasses all five Wake Up Flags.
  *            @arg @ref PWR_FLAG_SB Standby Flag. Indicates that the system
  *                  entered Standby mode.
  * @retval None
  */
#define __HAL_PWR_CLEAR_FLAG(__FLAG__) ( (((uint8_t)(__FLAG__)) == PWR_FLAG_WU) ? (PWR->SCR = (__FLAG__)) : (PWR->SCR = (1U << ((__FLAG__) & 31U))) )


/**
  * @brief Enable the PVD Extended Interrupt Line.
  * @retval None
  */
#define __HAL_PWR_PVD_EXTI_ENABLE_IT() SET_BIT(EXTI->IMR1, PWR_EXTI_LINE_PVD)

/**
  * @brief Disable the PVD Extended Interrupt Line.
  * @retval None
  */
#define __HAL_PWR_PVD_EXTI_DISABLE_IT() CLEAR_BIT(EXTI->IMR1, PWR_EXTI_LINE_PVD)

/**
  * @brief Enable the PVD Event Line.
  * @retval None
  */
#define __HAL_PWR_PVD_EXTI_ENABLE_EVENT() SET_BIT(EXTI->EMR1, PWR_EVENT_LINE_PVD)

/**
  * @brief Disable the PVD Event Line.
  * @retval None
  */
#define __HAL_PWR_PVD_EXTI_DISABLE_EVENT() CLEAR_BIT(EXTI->EMR1, PWR_EVENT_LINE_PVD)

/**
  * @brief Enable the PVD Extended Interrupt Rising Trigger.
  * @retval None
  */
#define __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE() SET_BIT(EXTI->RTSR1, PWR_EXTI_LINE_PVD)

/**
  * @brief Disable the PVD Extended Interrupt Rising Trigger.
  * @retval None
  */
#define __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE() CLEAR_BIT(EXTI->RTSR1, PWR_EXTI_LINE_PVD)

/**
  * @brief Enable the PVD Extended Interrupt Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE() SET_BIT(EXTI->FTSR1, PWR_EXTI_LINE_PVD)


/**
  * @brief Disable the PVD Extended Interrupt Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE() CLEAR_BIT(EXTI->FTSR1, PWR_EXTI_LINE_PVD)


/**
  * @brief  Enable the PVD Extended Interrupt Rising & Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVD_EXTI_ENABLE_RISING_FALLING_EDGE() do { __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE(); __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE(); } while(0)





/**
  * @brief Disable the PVD Extended Interrupt Rising & Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVD_EXTI_DISABLE_RISING_FALLING_EDGE() do { __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE(); __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); } while(0)





/**
  * @brief  Generate a Software interrupt on selected EXTI line.
  * @retval None
  */
#define __HAL_PWR_PVD_EXTI_GENERATE_SWIT() SET_BIT(EXTI->SWIER1, PWR_EXTI_LINE_PVD)

/**
  * @brief Check whether or not the PVD EXTI interrupt flag is set.
  * @retval EXTI PVD Line Status.
  */
#define __HAL_PWR_PVD_EXTI_GET_FLAG() (EXTI->PR1 & PWR_EXTI_LINE_PVD)

/**
  * @brief Clear the PVD EXTI interrupt flag.
  * @retval None
  */
#define __HAL_PWR_PVD_EXTI_CLEAR_FLAG() WRITE_REG(EXTI->PR1, PWR_EXTI_LINE_PVD)

/**
  * @}
  */


/* Private macros --------------------------------------------------------*/
/** @addtogroup  PWR_Private_Macros   PWR Private Macros
  * @{
  */

#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLEVEL_0) || ((LEVEL) == PWR_PVDLEVEL_1)|| ((LEVEL) == PWR_PVDLEVEL_2) || ((LEVEL) == PWR_PVDLEVEL_3)|| ((LEVEL) == PWR_PVDLEVEL_4) || ((LEVEL) == PWR_PVDLEVEL_5)|| ((LEVEL) == PWR_PVDLEVEL_6) || ((LEVEL) == PWR_PVDLEVEL_7))




#define IS_PWR_PVD_MODE(MODE) (((MODE) == PWR_PVD_MODE_NORMAL) || ((MODE) == PWR_PVD_MODE_IT_RISING) || ((MODE) == PWR_PVD_MODE_IT_FALLING) || ((MODE) == PWR_PVD_MODE_IT_RISING_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING) || ((MODE) == PWR_PVD_MODE_EVENT_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING_FALLING))







#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_ON) || ((REGULATOR) == PWR_LOWPOWERREGULATOR_ON))


#define IS_PWR_SLEEP_ENTRY(ENTRY) (((ENTRY) == PWR_SLEEPENTRY_WFI) || ((ENTRY) == PWR_SLEEPENTRY_WFE))

#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPENTRY_WFI) || ((ENTRY) == PWR_STOPENTRY_WFE) )

/**
  * @}
  */

/* Include PWR HAL Extended module */
# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_pwr_ex.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_pwr_ex.h
  * @author  MCD Application Team
  * @brief   Header file of PWR HAL Extended module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_PWR_EX_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup PWREx
  * @{
  */


/* Exported types ------------------------------------------------------------*/

/** @defgroup PWREx_Exported_Types PWR Extended Exported Types
  * @{
  */


/**
  * @brief  PWR PVM configuration structure definition
  */
typedef struct
{
  uint32_t PVMType;   /*!< PVMType: Specifies which voltage is monitored and against which threshold.
                           This parameter can be a value of @ref PWREx_PVM_Type. */
  uint32_t Mode;      /*!< Mode: Specifies the operating mode for the selected pins.
                           This parameter can be a value of @ref PWREx_PVM_Mode. */
}PWR_PVMTypeDef;

/**
  * @}
  */

/* Exported constants --------------------------------------------------------*/

/** @defgroup PWREx_Exported_Constants  PWR Extended Exported Constants
  * @{
  */

/** @defgroup PWREx_WUP_Polarity Shift to apply to retrieve polarity information from PWR_WAKEUP_PINy_xxx constants
  * @{
  */
#define PWR_WUP_POLARITY_SHIFT 0x05U
/**
  * @}
  */


/** @defgroup PWREx_WakeUp_Pins  PWR wake-up pins
  * @{
  */
#define PWR_WAKEUP_PIN1 PWR_CR3_EWUP1
#define PWR_WAKEUP_PIN2 PWR_CR3_EWUP2
#define PWR_WAKEUP_PIN3 PWR_CR3_EWUP3
#define PWR_WAKEUP_PIN4 PWR_CR3_EWUP4
#define PWR_WAKEUP_PIN5 PWR_CR3_EWUP5
#define PWR_WAKEUP_PIN1_HIGH PWR_CR3_EWUP1
#define PWR_WAKEUP_PIN2_HIGH PWR_CR3_EWUP2
#define PWR_WAKEUP_PIN3_HIGH PWR_CR3_EWUP3
#define PWR_WAKEUP_PIN4_HIGH PWR_CR3_EWUP4
#define PWR_WAKEUP_PIN5_HIGH PWR_CR3_EWUP5
#define PWR_WAKEUP_PIN1_LOW (uint32_t)((PWR_CR4_WP1<<PWR_WUP_POLARITY_SHIFT) | PWR_CR3_EWUP1)
#define PWR_WAKEUP_PIN2_LOW (uint32_t)((PWR_CR4_WP2<<PWR_WUP_POLARITY_SHIFT) | PWR_CR3_EWUP2)
#define PWR_WAKEUP_PIN3_LOW (uint32_t)((PWR_CR4_WP3<<PWR_WUP_POLARITY_SHIFT) | PWR_CR3_EWUP3)
#define PWR_WAKEUP_PIN4_LOW (uint32_t)((PWR_CR4_WP4<<PWR_WUP_POLARITY_SHIFT) | PWR_CR3_EWUP4)
#define PWR_WAKEUP_PIN5_LOW (uint32_t)((PWR_CR4_WP5<<PWR_WUP_POLARITY_SHIFT) | PWR_CR3_EWUP5)
/**
  * @}
  */

/** @defgroup PWREx_PVM_Type Peripheral Voltage Monitoring type
  * @{
  */

#define PWR_PVM_1 PWR_CR2_PVME1


#define PWR_PVM_2 PWR_CR2_PVME2

#define PWR_PVM_3 PWR_CR2_PVME3
#define PWR_PVM_4 PWR_CR2_PVME4
/**
  * @}
  */

/** @defgroup PWREx_PVM_Mode  PWR PVM interrupt and event mode
  * @{
  */
#define PWR_PVM_MODE_NORMAL 0x00000000U
#define PWR_PVM_MODE_IT_RISING 0x00010001U
#define PWR_PVM_MODE_IT_FALLING 0x00010002U
#define PWR_PVM_MODE_IT_RISING_FALLING 0x00010003U
#define PWR_PVM_MODE_EVENT_RISING 0x00020001U
#define PWR_PVM_MODE_EVENT_FALLING 0x00020002U
#define PWR_PVM_MODE_EVENT_RISING_FALLING 0x00020003U
/**
  * @}
  */



/** @defgroup PWREx_Regulator_Voltage_Scale  PWR Regulator voltage scale
  * @{
  */

#define PWR_REGULATOR_VOLTAGE_SCALE1_BOOST ((uint32_t)0x00000000)

#define PWR_REGULATOR_VOLTAGE_SCALE1 PWR_CR1_VOS_0
#define PWR_REGULATOR_VOLTAGE_SCALE2 PWR_CR1_VOS_1
/**
  * @}
  */


/** @defgroup PWREx_VBAT_Battery_Charging_Selection PWR battery charging resistor selection
  * @{
  */
#define PWR_BATTERY_CHARGING_RESISTOR_5 0x00000000U
#define PWR_BATTERY_CHARGING_RESISTOR_1_5 PWR_CR4_VBRS
/**
  * @}
  */

/** @defgroup PWREx_VBAT_Battery_Charging PWR battery charging
  * @{
  */
#define PWR_BATTERY_CHARGING_DISABLE 0x00000000U
#define PWR_BATTERY_CHARGING_ENABLE PWR_CR4_VBE
/**
  * @}
  */

/** @defgroup PWREx_GPIO_Bit_Number GPIO bit number for I/O setting in standby/shutdown mode
  * @{
  */
#define PWR_GPIO_BIT_0 PWR_PUCRA_PA0
#define PWR_GPIO_BIT_1 PWR_PUCRA_PA1
#define PWR_GPIO_BIT_2 PWR_PUCRA_PA2
#define PWR_GPIO_BIT_3 PWR_PUCRA_PA3
#define PWR_GPIO_BIT_4 PWR_PUCRA_PA4
#define PWR_GPIO_BIT_5 PWR_PUCRA_PA5
#define PWR_GPIO_BIT_6 PWR_PUCRA_PA6
#define PWR_GPIO_BIT_7 PWR_PUCRA_PA7
#define PWR_GPIO_BIT_8 PWR_PUCRA_PA8
#define PWR_GPIO_BIT_9 PWR_PUCRA_PA9
#define PWR_GPIO_BIT_10 PWR_PUCRA_PA10
#define PWR_GPIO_BIT_11 PWR_PUCRA_PA11
#define PWR_GPIO_BIT_12 PWR_PUCRA_PA12
#define PWR_GPIO_BIT_13 PWR_PUCRA_PA13
#define PWR_GPIO_BIT_14 PWR_PDCRA_PA14
#define PWR_GPIO_BIT_15 PWR_PUCRA_PA15
/**
  * @}
  */

/** @defgroup PWREx_GPIO GPIO port
  * @{
  */
#define PWR_GPIO_A 0x00000000U
#define PWR_GPIO_B 0x00000001U
#define PWR_GPIO_C 0x00000002U
#define PWR_GPIO_D 0x00000003U
#define PWR_GPIO_E 0x00000004U
#define PWR_GPIO_F 0x00000005U
#define PWR_GPIO_G 0x00000006U
/**
  * @}
  */

/** @defgroup PWREx_PVM_EXTI_LINE PWR PVM external interrupts lines
  * @{
  */

#define PWR_EXTI_LINE_PVM1 0x00000008U


#define PWR_EXTI_LINE_PVM2 0x00000010U

#define PWR_EXTI_LINE_PVM3 0x00000020U
#define PWR_EXTI_LINE_PVM4 0x00000040U
/**
  * @}
  */

/** @defgroup PWREx_PVM_EVENT_LINE PWR PVM event lines
  * @{
  */

#define PWR_EVENT_LINE_PVM1 0x00000008U


#define PWR_EVENT_LINE_PVM2 0x00000010U

#define PWR_EVENT_LINE_PVM3 0x00000020U
#define PWR_EVENT_LINE_PVM4 0x00000040U
/**
  * @}
  */

/** @defgroup PWREx_Flag  PWR Status Flags
  *        Elements values convention: 0000 0000 0XXY YYYYb
  *           - Y YYYY  : Flag position in the XX register (5 bits)
  *           - XX  : Status register (2 bits)
  *                 - 01: SR1 register
  *                 - 10: SR2 register
  *        The only exception is PWR_FLAG_WU, encompassing all
  *        wake-up flags and set to PWR_SR1_WUF.
  * @{
  */
#define PWR_FLAG_WUF1 0x0020U
#define PWR_FLAG_WUF2 0x0021U
#define PWR_FLAG_WUF3 0x0022U
#define PWR_FLAG_WUF4 0x0023U
#define PWR_FLAG_WUF5 0x0024U
#define PWR_FLAG_WU PWR_SR1_WUF
#define PWR_FLAG_SB 0x0028U
#define PWR_FLAG_WUFI 0x002FU

#define PWR_FLAG_REGLPS 0x0048U
#define PWR_FLAG_REGLPF 0x0049U
#define PWR_FLAG_VOSF 0x004AU
#define PWR_FLAG_PVDO 0x004BU

#define PWR_FLAG_PVMO1 0x004CU


#define PWR_FLAG_PVMO2 0x004DU

#define PWR_FLAG_PVMO3 0x004EU
#define PWR_FLAG_PVMO4 0x004FU
/**
  * @}
  */

/**
  * @}
  */

/* Exported macros -----------------------------------------------------------*/
/** @defgroup PWREx_Exported_Macros PWR Extended Exported Macros
 * @{
 */


/**
  * @brief Enable the PVM1 Extended Interrupt Line.
  * @retval None
  */
#define __HAL_PWR_PVM1_EXTI_ENABLE_IT() SET_BIT(EXTI->IMR2, PWR_EXTI_LINE_PVM1)

/**
  * @brief Disable the PVM1 Extended Interrupt Line.
  * @retval None
  */
#define __HAL_PWR_PVM1_EXTI_DISABLE_IT() CLEAR_BIT(EXTI->IMR2, PWR_EXTI_LINE_PVM1)

/**
  * @brief Enable the PVM1 Event Line.
  * @retval None
  */
#define __HAL_PWR_PVM1_EXTI_ENABLE_EVENT() SET_BIT(EXTI->EMR2, PWR_EVENT_LINE_PVM1)

/**
  * @brief Disable the PVM1 Event Line.
  * @retval None
  */
#define __HAL_PWR_PVM1_EXTI_DISABLE_EVENT() CLEAR_BIT(EXTI->EMR2, PWR_EVENT_LINE_PVM1)

/**
  * @brief Enable the PVM1 Extended Interrupt Rising Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM1_EXTI_ENABLE_RISING_EDGE() SET_BIT(EXTI->RTSR2, PWR_EXTI_LINE_PVM1)

/**
  * @brief Disable the PVM1 Extended Interrupt Rising Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM1_EXTI_DISABLE_RISING_EDGE() CLEAR_BIT(EXTI->RTSR2, PWR_EXTI_LINE_PVM1)

/**
  * @brief Enable the PVM1 Extended Interrupt Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM1_EXTI_ENABLE_FALLING_EDGE() SET_BIT(EXTI->FTSR2, PWR_EXTI_LINE_PVM1)


/**
  * @brief Disable the PVM1 Extended Interrupt Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM1_EXTI_DISABLE_FALLING_EDGE() CLEAR_BIT(EXTI->FTSR2, PWR_EXTI_LINE_PVM1)


/**
  * @brief  PVM1 EXTI line configuration: set rising & falling edge trigger.
  * @retval None
  */
#define __HAL_PWR_PVM1_EXTI_ENABLE_RISING_FALLING_EDGE() do { __HAL_PWR_PVM1_EXTI_ENABLE_RISING_EDGE(); __HAL_PWR_PVM1_EXTI_ENABLE_FALLING_EDGE(); } while(0)





/**
  * @brief Disable the PVM1 Extended Interrupt Rising & Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM1_EXTI_DISABLE_RISING_FALLING_EDGE() do { __HAL_PWR_PVM1_EXTI_DISABLE_RISING_EDGE(); __HAL_PWR_PVM1_EXTI_DISABLE_FALLING_EDGE(); } while(0)





/**
  * @brief  Generate a Software interrupt on selected EXTI line.
  * @retval None
  */
#define __HAL_PWR_PVM1_EXTI_GENERATE_SWIT() SET_BIT(EXTI->SWIER2, PWR_EXTI_LINE_PVM1)

/**
  * @brief Check whether the specified PVM1 EXTI interrupt flag is set or not.
  * @retval EXTI PVM1 Line Status.
  */
#define __HAL_PWR_PVM1_EXTI_GET_FLAG() (EXTI->PR2 & PWR_EXTI_LINE_PVM1)

/**
  * @brief Clear the PVM1 EXTI flag.
  * @retval None
  */
#define __HAL_PWR_PVM1_EXTI_CLEAR_FLAG() WRITE_REG(EXTI->PR2, PWR_EXTI_LINE_PVM1)





/**
  * @brief Enable the PVM2 Extended Interrupt Line.
  * @retval None
  */
#define __HAL_PWR_PVM2_EXTI_ENABLE_IT() SET_BIT(EXTI->IMR2, PWR_EXTI_LINE_PVM2)

/**
  * @brief Disable the PVM2 Extended Interrupt Line.
  * @retval None
  */
#define __HAL_PWR_PVM2_EXTI_DISABLE_IT() CLEAR_BIT(EXTI->IMR2, PWR_EXTI_LINE_PVM2)

/**
  * @brief Enable the PVM2 Event Line.
  * @retval None
  */
#define __HAL_PWR_PVM2_EXTI_ENABLE_EVENT() SET_BIT(EXTI->EMR2, PWR_EVENT_LINE_PVM2)

/**
  * @brief Disable the PVM2 Event Line.
  * @retval None
  */
#define __HAL_PWR_PVM2_EXTI_DISABLE_EVENT() CLEAR_BIT(EXTI->EMR2, PWR_EVENT_LINE_PVM2)

/**
  * @brief Enable the PVM2 Extended Interrupt Rising Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM2_EXTI_ENABLE_RISING_EDGE() SET_BIT(EXTI->RTSR2, PWR_EXTI_LINE_PVM2)

/**
  * @brief Disable the PVM2 Extended Interrupt Rising Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM2_EXTI_DISABLE_RISING_EDGE() CLEAR_BIT(EXTI->RTSR2, PWR_EXTI_LINE_PVM2)

/**
  * @brief Enable the PVM2 Extended Interrupt Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM2_EXTI_ENABLE_FALLING_EDGE() SET_BIT(EXTI->FTSR2, PWR_EXTI_LINE_PVM2)


/**
  * @brief Disable the PVM2 Extended Interrupt Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM2_EXTI_DISABLE_FALLING_EDGE() CLEAR_BIT(EXTI->FTSR2, PWR_EXTI_LINE_PVM2)


/**
  * @brief  PVM2 EXTI line configuration: set rising & falling edge trigger.
  * @retval None
  */
#define __HAL_PWR_PVM2_EXTI_ENABLE_RISING_FALLING_EDGE() do { __HAL_PWR_PVM2_EXTI_ENABLE_RISING_EDGE(); __HAL_PWR_PVM2_EXTI_ENABLE_FALLING_EDGE(); } while(0)





/**
  * @brief Disable the PVM2 Extended Interrupt Rising & Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM2_EXTI_DISABLE_RISING_FALLING_EDGE() do { __HAL_PWR_PVM2_EXTI_DISABLE_RISING_EDGE(); __HAL_PWR_PVM2_EXTI_DISABLE_FALLING_EDGE(); } while(0)





/**
  * @brief  Generate a Software interrupt on selected EXTI line.
  * @retval None
  */
#define __HAL_PWR_PVM2_EXTI_GENERATE_SWIT() SET_BIT(EXTI->SWIER2, PWR_EXTI_LINE_PVM2)

/**
  * @brief Check whether the specified PVM2 EXTI interrupt flag is set or not.
  * @retval EXTI PVM2 Line Status.
  */
#define __HAL_PWR_PVM2_EXTI_GET_FLAG() (EXTI->PR2 & PWR_EXTI_LINE_PVM2)

/**
  * @brief Clear the PVM2 EXTI flag.
  * @retval None
  */
#define __HAL_PWR_PVM2_EXTI_CLEAR_FLAG() WRITE_REG(EXTI->PR2, PWR_EXTI_LINE_PVM2)




/**
  * @brief Enable the PVM3 Extended Interrupt Line.
  * @retval None
  */
#define __HAL_PWR_PVM3_EXTI_ENABLE_IT() SET_BIT(EXTI->IMR2, PWR_EXTI_LINE_PVM3)

/**
  * @brief Disable the PVM3 Extended Interrupt Line.
  * @retval None
  */
#define __HAL_PWR_PVM3_EXTI_DISABLE_IT() CLEAR_BIT(EXTI->IMR2, PWR_EXTI_LINE_PVM3)

/**
  * @brief Enable the PVM3 Event Line.
  * @retval None
  */
#define __HAL_PWR_PVM3_EXTI_ENABLE_EVENT() SET_BIT(EXTI->EMR2, PWR_EVENT_LINE_PVM3)

/**
  * @brief Disable the PVM3 Event Line.
  * @retval None
  */
#define __HAL_PWR_PVM3_EXTI_DISABLE_EVENT() CLEAR_BIT(EXTI->EMR2, PWR_EVENT_LINE_PVM3)

/**
  * @brief Enable the PVM3 Extended Interrupt Rising Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM3_EXTI_ENABLE_RISING_EDGE() SET_BIT(EXTI->RTSR2, PWR_EXTI_LINE_PVM3)

/**
  * @brief Disable the PVM3 Extended Interrupt Rising Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM3_EXTI_DISABLE_RISING_EDGE() CLEAR_BIT(EXTI->RTSR2, PWR_EXTI_LINE_PVM3)

/**
  * @brief Enable the PVM3 Extended Interrupt Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM3_EXTI_ENABLE_FALLING_EDGE() SET_BIT(EXTI->FTSR2, PWR_EXTI_LINE_PVM3)


/**
  * @brief Disable the PVM3 Extended Interrupt Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM3_EXTI_DISABLE_FALLING_EDGE() CLEAR_BIT(EXTI->FTSR2, PWR_EXTI_LINE_PVM3)


/**
  * @brief  PVM3 EXTI line configuration: set rising & falling edge trigger.
  * @retval None
  */
#define __HAL_PWR_PVM3_EXTI_ENABLE_RISING_FALLING_EDGE() do { __HAL_PWR_PVM3_EXTI_ENABLE_RISING_EDGE(); __HAL_PWR_PVM3_EXTI_ENABLE_FALLING_EDGE(); } while(0)





/**
  * @brief Disable the PVM3 Extended Interrupt Rising & Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM3_EXTI_DISABLE_RISING_FALLING_EDGE() do { __HAL_PWR_PVM3_EXTI_DISABLE_RISING_EDGE(); __HAL_PWR_PVM3_EXTI_DISABLE_FALLING_EDGE(); } while(0)





/**
  * @brief  Generate a Software interrupt on selected EXTI line.
  * @retval None
  */
#define __HAL_PWR_PVM3_EXTI_GENERATE_SWIT() SET_BIT(EXTI->SWIER2, PWR_EXTI_LINE_PVM3)

/**
  * @brief Check whether the specified PVM3 EXTI interrupt flag is set or not.
  * @retval EXTI PVM3 Line Status.
  */
#define __HAL_PWR_PVM3_EXTI_GET_FLAG() (EXTI->PR2 & PWR_EXTI_LINE_PVM3)

/**
  * @brief Clear the PVM3 EXTI flag.
  * @retval None
  */
#define __HAL_PWR_PVM3_EXTI_CLEAR_FLAG() WRITE_REG(EXTI->PR2, PWR_EXTI_LINE_PVM3)




/**
  * @brief Enable the PVM4 Extended Interrupt Line.
  * @retval None
  */
#define __HAL_PWR_PVM4_EXTI_ENABLE_IT() SET_BIT(EXTI->IMR2, PWR_EXTI_LINE_PVM4)

/**
  * @brief Disable the PVM4 Extended Interrupt Line.
  * @retval None
  */
#define __HAL_PWR_PVM4_EXTI_DISABLE_IT() CLEAR_BIT(EXTI->IMR2, PWR_EXTI_LINE_PVM4)

/**
  * @brief Enable the PVM4 Event Line.
  * @retval None
  */
#define __HAL_PWR_PVM4_EXTI_ENABLE_EVENT() SET_BIT(EXTI->EMR2, PWR_EVENT_LINE_PVM4)

/**
  * @brief Disable the PVM4 Event Line.
  * @retval None
  */
#define __HAL_PWR_PVM4_EXTI_DISABLE_EVENT() CLEAR_BIT(EXTI->EMR2, PWR_EVENT_LINE_PVM4)

/**
  * @brief Enable the PVM4 Extended Interrupt Rising Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM4_EXTI_ENABLE_RISING_EDGE() SET_BIT(EXTI->RTSR2, PWR_EXTI_LINE_PVM4)

/**
  * @brief Disable the PVM4 Extended Interrupt Rising Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM4_EXTI_DISABLE_RISING_EDGE() CLEAR_BIT(EXTI->RTSR2, PWR_EXTI_LINE_PVM4)

/**
  * @brief Enable the PVM4 Extended Interrupt Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM4_EXTI_ENABLE_FALLING_EDGE() SET_BIT(EXTI->FTSR2, PWR_EXTI_LINE_PVM4)


/**
  * @brief Disable the PVM4 Extended Interrupt Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM4_EXTI_DISABLE_FALLING_EDGE() CLEAR_BIT(EXTI->FTSR2, PWR_EXTI_LINE_PVM4)


/**
  * @brief  PVM4 EXTI line configuration: set rising & falling edge trigger.
  * @retval None
  */
#define __HAL_PWR_PVM4_EXTI_ENABLE_RISING_FALLING_EDGE() do { __HAL_PWR_PVM4_EXTI_ENABLE_RISING_EDGE(); __HAL_PWR_PVM4_EXTI_ENABLE_FALLING_EDGE(); } while(0)





/**
  * @brief Disable the PVM4 Extended Interrupt Rising & Falling Trigger.
  * @retval None
  */
#define __HAL_PWR_PVM4_EXTI_DISABLE_RISING_FALLING_EDGE() do { __HAL_PWR_PVM4_EXTI_DISABLE_RISING_EDGE(); __HAL_PWR_PVM4_EXTI_DISABLE_FALLING_EDGE(); } while(0)





/**
  * @brief  Generate a Software interrupt on selected EXTI line.
  * @retval None
  */
#define __HAL_PWR_PVM4_EXTI_GENERATE_SWIT() SET_BIT(EXTI->SWIER2, PWR_EXTI_LINE_PVM4)

/**
  * @brief Check whether or not the specified PVM4 EXTI interrupt flag is set.
  * @retval EXTI PVM4 Line Status.
  */
#define __HAL_PWR_PVM4_EXTI_GET_FLAG() (EXTI->PR2 & PWR_EXTI_LINE_PVM4)

/**
  * @brief Clear the PVM4 EXTI flag.
  * @retval None
  */
#define __HAL_PWR_PVM4_EXTI_CLEAR_FLAG() WRITE_REG(EXTI->PR2, PWR_EXTI_LINE_PVM4)


/**
  * @brief Configure the main internal regulator output voltage.
  * @param  __REGULATOR__: specifies the regulator output voltage to achieve
  *         a tradeoff between performance and power consumption.
  *          This parameter can be one of the following values:
  *            @arg @ref PWR_REGULATOR_VOLTAGE_SCALE1_BOOST  Regulator voltage output range 1 mode,
  *                                                typical output voltage at 1.28 V,
  *                                                system frequency up to 170 MHz.
  *            @arg @ref PWR_REGULATOR_VOLTAGE_SCALE1  Regulator voltage output range 1 mode,
  *                                                typical output voltage at 1.2 V,
  *                                                system frequency up to 150 MHz.
  *            @arg @ref PWR_REGULATOR_VOLTAGE_SCALE2  Regulator voltage output range 2 mode,
  *                                                typical output voltage at 1.0 V,
  *                                                system frequency up to 26 MHz.
  * @note  This macro is similar to HAL_PWREx_ControlVoltageScaling() API but doesn't check
  *        whether or not VOSF flag is cleared when moving from range 2 to range 1. User
  *        may resort to __HAL_PWR_GET_FLAG() macro to check VOSF bit resetting.
  * @retval None
  */
#define __HAL_PWR_VOLTAGESCALING_CONFIG(__REGULATOR__) do { __IO uint32_t tmpreg; MODIFY_REG(PWR->CR1, PWR_CR1_VOS, (__REGULATOR__)); tmpreg = READ_BIT(PWR->CR1, PWR_CR1_VOS); UNUSED(tmpreg); } while(0)







/**
  * @}
  */

/* Private macros --------------------------------------------------------*/
/** @addtogroup  PWREx_Private_Macros   PWR Extended Private Macros
  * @{
  */

#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) || ((PIN) == PWR_WAKEUP_PIN2) || ((PIN) == PWR_WAKEUP_PIN3) || ((PIN) == PWR_WAKEUP_PIN4) || ((PIN) == PWR_WAKEUP_PIN5) || ((PIN) == PWR_WAKEUP_PIN1_HIGH) || ((PIN) == PWR_WAKEUP_PIN2_HIGH) || ((PIN) == PWR_WAKEUP_PIN3_HIGH) || ((PIN) == PWR_WAKEUP_PIN4_HIGH) || ((PIN) == PWR_WAKEUP_PIN5_HIGH) || ((PIN) == PWR_WAKEUP_PIN1_LOW) || ((PIN) == PWR_WAKEUP_PIN2_LOW) || ((PIN) == PWR_WAKEUP_PIN3_LOW) || ((PIN) == PWR_WAKEUP_PIN4_LOW) || ((PIN) == PWR_WAKEUP_PIN5_LOW))
# 686 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_pwr_ex.h"

#define IS_PWR_PVM_TYPE(TYPE) (((TYPE) == PWR_PVM_1) || ((TYPE) == PWR_PVM_2) || ((TYPE) == PWR_PVM_3) || ((TYPE) == PWR_PVM_4))




#define IS_PWR_PVM_MODE(MODE) (((MODE) == PWR_PVM_MODE_NORMAL) || ((MODE) == PWR_PVM_MODE_IT_RISING) || ((MODE) == PWR_PVM_MODE_IT_FALLING) || ((MODE) == PWR_PVM_MODE_IT_RISING_FALLING) || ((MODE) == PWR_PVM_MODE_EVENT_RISING) || ((MODE) == PWR_PVM_MODE_EVENT_FALLING) || ((MODE) == PWR_PVM_MODE_EVENT_RISING_FALLING))








#define IS_PWR_VOLTAGE_SCALING_RANGE(RANGE) (((RANGE) == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST) || ((RANGE) == PWR_REGULATOR_VOLTAGE_SCALE1) || ((RANGE) == PWR_REGULATOR_VOLTAGE_SCALE2))








#define IS_PWR_BATTERY_RESISTOR_SELECT(RESISTOR) (((RESISTOR) == PWR_BATTERY_CHARGING_RESISTOR_5) || ((RESISTOR) == PWR_BATTERY_CHARGING_RESISTOR_1_5))


#define IS_PWR_BATTERY_CHARGING(CHARGING) (((CHARGING) == PWR_BATTERY_CHARGING_DISABLE) || ((CHARGING) == PWR_BATTERY_CHARGING_ENABLE))


#define IS_PWR_GPIO_BIT_NUMBER(BIT_NUMBER) (((BIT_NUMBER) & GPIO_PIN_MASK) != (uint32_t)0x00U)
#define IS_PWR_GPIO(GPIO) (((GPIO) == PWR_GPIO_A) || ((GPIO) == PWR_GPIO_B) || ((GPIO) == PWR_GPIO_C) || ((GPIO) == PWR_GPIO_D) || ((GPIO) == PWR_GPIO_E) || ((GPIO) == PWR_GPIO_F) || ((GPIO) == PWR_GPIO_G))








/**
  * @}
  */


/** @addtogroup PWREx_Exported_Functions PWR Extended Exported Functions
  * @{
  */

/** @addtogroup PWREx_Exported_Functions_Group1 Extended Peripheral Control functions
  * @{
  */


/* Peripheral Control functions  **********************************************/
uint32_t HAL_PWREx_GetVoltageRange(void);
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling);
void HAL_PWREx_EnableBatteryCharging(uint32_t ResistorSelection);
void HAL_PWREx_DisableBatteryCharging(void);
void HAL_PWREx_EnableInternalWakeUpLine(void);
void HAL_PWREx_DisableInternalWakeUpLine(void);
HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber);
HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber);
HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber);
HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber);
void HAL_PWREx_EnablePullUpPullDownConfig(void);
void HAL_PWREx_DisablePullUpPullDownConfig(void);
void HAL_PWREx_EnableSRAM2ContentRetention(void);
void HAL_PWREx_DisableSRAM2ContentRetention(void);

void HAL_PWREx_EnablePVM1(void);
void HAL_PWREx_DisablePVM1(void);


void HAL_PWREx_EnablePVM2(void);
void HAL_PWREx_DisablePVM2(void);

void HAL_PWREx_EnablePVM3(void);
void HAL_PWREx_DisablePVM3(void);
void HAL_PWREx_EnablePVM4(void);
void HAL_PWREx_DisablePVM4(void);
HAL_StatusTypeDef HAL_PWREx_ConfigPVM(PWR_PVMTypeDef *sConfigPVM);

/* Low Power modes configuration functions ************************************/
void HAL_PWREx_EnableLowPowerRunMode(void);
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void);
void HAL_PWREx_EnterSTOP0Mode(uint8_t STOPEntry);
void HAL_PWREx_EnterSTOP1Mode(uint8_t STOPEntry);
void HAL_PWREx_EnterSHUTDOWNMode(void);

void HAL_PWREx_PVD_PVM_IRQHandler(void);

void HAL_PWREx_PVM1Callback(void);


void HAL_PWREx_PVM2Callback(void);

void HAL_PWREx_PVM3Callback(void);
void HAL_PWREx_PVM4Callback(void);


void HAL_PWREx_EnableUCPDStandbyMode(void);
void HAL_PWREx_DisableUCPDStandbyMode(void);


void HAL_PWREx_EnableUCPDDeadBattery(void);
void HAL_PWREx_DisableUCPDDeadBattery(void);


/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */








# 342 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_pwr.h" 2

/* Exported functions --------------------------------------------------------*/

/** @addtogroup PWR_Exported_Functions PWR Exported Functions
  * @{
  */

/** @addtogroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions
  * @{
  */

/* Initialization and de-initialization functions *******************************/
void HAL_PWR_DeInit(void);
void HAL_PWR_EnableBkUpAccess(void);
void HAL_PWR_DisableBkUpAccess(void);

/**
  * @}
  */

/** @addtogroup PWR_Exported_Functions_Group2 Peripheral Control functions
  * @{
  */

/* Peripheral Control functions  ************************************************/
HAL_StatusTypeDef HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD);
void HAL_PWR_EnablePVD(void);
void HAL_PWR_DisablePVD(void);


/* WakeUp pins configuration functions ****************************************/
void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinPolarity);
void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx);

/* Low Power modes configuration functions ************************************/
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry);
void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry);
void HAL_PWR_EnterSTANDBYMode(void);

void HAL_PWR_EnableSleepOnExit(void);
void HAL_PWR_DisableSleepOnExit(void);
void HAL_PWR_EnableSEVOnPend(void);
void HAL_PWR_DisableSEVOnPend(void);

void HAL_PWR_PVDCallback(void);


/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */








# 309 "Core/Inc/stm32g4xx_hal_conf.h" 2



































# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_tim.h
  * @author  MCD Application Team
  * @brief   Header file of TIM HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_TIM_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup TIM
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/** @defgroup TIM_Exported_Types TIM Exported Types
  * @{
  */

/**
  * @brief  TIM Time base Configuration Structure definition
  */
typedef struct
{
  uint32_t Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.
                                   This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF
                                   Macro __HAL_TIM_CALC_PSC() can be used to calculate prescaler value */

  uint32_t CounterMode;       /*!< Specifies the counter mode.
                                   This parameter can be a value of @ref TIM_Counter_Mode */

  uint32_t Period;            /*!< Specifies the period value to be loaded into the active
                                   Auto-Reload Register at the next update event.
                                   This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF
                                   (or 0xFFEF if dithering is activated)Macros __HAL_TIM_CALC_PERIOD(),
                                    __HAL_TIM_CALC_PERIOD_DITHER(),__HAL_TIM_CALC_PERIOD_BY_DELAY(),
                                    __HAL_TIM_CALC_PERIOD_DITHER_BY_DELAY()can be used to calculate Period value */

  uint32_t ClockDivision;     /*!< Specifies the clock division.
                                   This parameter can be a value of @ref TIM_ClockDivision */

  uint32_t RepetitionCounter;  /*!< Specifies the repetition counter value. Each time the RCR downcounter
                                    reaches zero, an update event is generated and counting restarts
                                    from the RCR value (N).
                                    This means in PWM mode that (N+1) corresponds to:
                                        - the number of PWM periods in edge-aligned mode
                                        - the number of half PWM period in center-aligned mode
                                     GP timers: this parameter must be a number between Min_Data = 0x00 and
                                     Max_Data = 0xFF.
                                     Advanced timers: this parameter must be a number between Min_Data = 0x0000 and
                                     Max_Data = 0xFFFF. */

  uint32_t AutoReloadPreload;  /*!< Specifies the auto-reload preload.
                                   This parameter can be a value of @ref TIM_AutoReloadPreload */
} TIM_Base_InitTypeDef;

/**
  * @brief  TIM Output Compare Configuration Structure definition
  */
typedef struct
{
  uint32_t OCMode;        /*!< Specifies the TIM mode.
                               This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */

  uint32_t Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register.
                               This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF
                               (or 0xFFEF if dithering is activated)
                               Macros __HAL_TIM_CALC_PULSE(), __HAL_TIM_CALC_PULSE_DITHER() can be used to calculate
                               Pulse value */

  uint32_t OCPolarity;    /*!< Specifies the output polarity.
                               This parameter can be a value of @ref TIM_Output_Compare_Polarity */

  uint32_t OCNPolarity;   /*!< Specifies the complementary output polarity.
                               This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
                               @note This parameter is valid only for timer instances supporting break feature. */

  uint32_t OCFastMode;    /*!< Specifies the Fast mode state.
                               This parameter can be a value of @ref TIM_Output_Fast_State
                               @note This parameter is valid only in PWM1 and PWM2 mode. */


  uint32_t OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
                               This parameter can be a value of @ref TIM_Output_Compare_Idle_State
                               @note This parameter is valid only for timer instances supporting break feature. */

  uint32_t OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
                               This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
                               @note This parameter is valid only for timer instances supporting break feature. */
} TIM_OC_InitTypeDef;

/**
  * @brief  TIM One Pulse Mode Configuration Structure definition
  */
typedef struct
{
  uint32_t OCMode;        /*!< Specifies the TIM mode.
                               This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */

  uint32_t Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register.
                               This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF
                               (or 0xFFEF if dithering is activated)
                               Macros __HAL_TIM_CALC_PULSE(), __HAL_TIM_CALC_PULSE_DITHER() can be used to calculate
                               Pulse value */

  uint32_t OCPolarity;    /*!< Specifies the output polarity.
                               This parameter can be a value of @ref TIM_Output_Compare_Polarity */

  uint32_t OCNPolarity;   /*!< Specifies the complementary output polarity.
                               This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
                               @note This parameter is valid only for timer instances supporting break feature. */

  uint32_t OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
                               This parameter can be a value of @ref TIM_Output_Compare_Idle_State
                               @note This parameter is valid only for timer instances supporting break feature. */

  uint32_t OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
                               This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
                               @note This parameter is valid only for timer instances supporting break feature. */

  uint32_t ICPolarity;    /*!< Specifies the active edge of the input signal.
                               This parameter can be a value of @ref TIM_Input_Capture_Polarity */

  uint32_t ICSelection;   /*!< Specifies the input.
                              This parameter can be a value of @ref TIM_Input_Capture_Selection */

  uint32_t ICFilter;      /*!< Specifies the input capture filter.
                              This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
} TIM_OnePulse_InitTypeDef;

/**
  * @brief  TIM Input Capture Configuration Structure definition
  */
typedef struct
{
  uint32_t  ICPolarity;  /*!< Specifies the active edge of the input signal.
                              This parameter can be a value of @ref TIM_Input_Capture_Polarity */

  uint32_t ICSelection;  /*!< Specifies the input.
                              This parameter can be a value of @ref TIM_Input_Capture_Selection */

  uint32_t ICPrescaler;  /*!< Specifies the Input Capture Prescaler.
                              This parameter can be a value of @ref TIM_Input_Capture_Prescaler */

  uint32_t ICFilter;     /*!< Specifies the input capture filter.
                              This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
} TIM_IC_InitTypeDef;

/**
  * @brief  TIM Encoder Configuration Structure definition
  */
typedef struct
{
  uint32_t EncoderMode;   /*!< Specifies the active edge of the input signal.
                               This parameter can be a value of @ref TIM_Encoder_Mode */

  uint32_t IC1Polarity;   /*!< Specifies the active edge of the input signal.
                               This parameter can be a value of @ref TIM_Encoder_Input_Polarity */

  uint32_t IC1Selection;  /*!< Specifies the input.
                               This parameter can be a value of @ref TIM_Input_Capture_Selection */

  uint32_t IC1Prescaler;  /*!< Specifies the Input Capture Prescaler.
                               This parameter can be a value of @ref TIM_Input_Capture_Prescaler */

  uint32_t IC1Filter;     /*!< Specifies the input capture filter.
                               This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */

  uint32_t IC2Polarity;   /*!< Specifies the active edge of the input signal.
                               This parameter can be a value of @ref TIM_Encoder_Input_Polarity */

  uint32_t IC2Selection;  /*!< Specifies the input.
                              This parameter can be a value of @ref TIM_Input_Capture_Selection */

  uint32_t IC2Prescaler;  /*!< Specifies the Input Capture Prescaler.
                               This parameter can be a value of @ref TIM_Input_Capture_Prescaler */

  uint32_t IC2Filter;     /*!< Specifies the input capture filter.
                               This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
} TIM_Encoder_InitTypeDef;

/**
  * @brief  Clock Configuration Handle Structure definition
  */
typedef struct
{
  uint32_t ClockSource;     /*!< TIM clock sources
                                 This parameter can be a value of @ref TIM_Clock_Source */
  uint32_t ClockPolarity;   /*!< TIM clock polarity
                                 This parameter can be a value of @ref TIM_Clock_Polarity */
  uint32_t ClockPrescaler;  /*!< TIM clock prescaler
                                 This parameter can be a value of @ref TIM_Clock_Prescaler */
  uint32_t ClockFilter;     /*!< TIM clock filter
                                 This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
} TIM_ClockConfigTypeDef;

/**
  * @brief  TIM Clear Input Configuration Handle Structure definition
  */
typedef struct
{
  uint32_t ClearInputState;      /*!< TIM clear Input state
                                      This parameter can be ENABLE or DISABLE */
  uint32_t ClearInputSource;     /*!< TIM clear Input sources
                                      This parameter can be a value of @ref TIM_ClearInput_Source */
  uint32_t ClearInputPolarity;   /*!< TIM Clear Input polarity
                                      This parameter can be a value of @ref TIM_ClearInput_Polarity */
  uint32_t ClearInputPrescaler;  /*!< TIM Clear Input prescaler
                                      This parameter must be 0: When OCRef clear feature is used with ETR source,
                                      ETR prescaler must be off */
  uint32_t ClearInputFilter;     /*!< TIM Clear Input filter
                                      This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */
} TIM_ClearInputConfigTypeDef;

/**
  * @brief  TIM Master configuration Structure definition
  * @note   Advanced timers provide TRGO2 internal line which is redirected
  *         to the ADC
  */
typedef struct
{
  uint32_t  MasterOutputTrigger;   /*!< Trigger output (TRGO) selection
                                        This parameter can be a value of @ref TIM_Master_Mode_Selection */
  uint32_t  MasterOutputTrigger2;  /*!< Trigger output2 (TRGO2) selection
                                        This parameter can be a value of @ref TIM_Master_Mode_Selection_2 */
  uint32_t  MasterSlaveMode;       /*!< Master/slave mode selection
                                        This parameter can be a value of @ref TIM_Master_Slave_Mode
                                        @note When the Master/slave mode is enabled, the effect of
                                        an event on the trigger input (TRGI) is delayed to allow a
                                        perfect synchronization between the current timer and its
                                        slaves (through TRGO). It is not mandatory in case of timer
                                        synchronization mode. */
} TIM_MasterConfigTypeDef;

/**
  * @brief  TIM Slave configuration Structure definition
  */
typedef struct
{
  uint32_t  SlaveMode;         /*!< Slave mode selection
                                    This parameter can be a value of @ref TIM_Slave_Mode */
  uint32_t  InputTrigger;      /*!< Input Trigger source
                                    This parameter can be a value of @ref TIM_Trigger_Selection */
  uint32_t  TriggerPolarity;   /*!< Input Trigger polarity
                                    This parameter can be a value of @ref TIM_Trigger_Polarity */
  uint32_t  TriggerPrescaler;  /*!< Input trigger prescaler
                                    This parameter can be a value of @ref TIM_Trigger_Prescaler */
  uint32_t  TriggerFilter;     /*!< Input trigger filter
                                    This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF  */

} TIM_SlaveConfigTypeDef;

/**
  * @brief  TIM Break input(s) and Dead time configuration Structure definition
  * @note   2 break inputs can be configured (BKIN and BKIN2) with configurable
  *        filter and polarity.
  */
typedef struct
{
  uint32_t OffStateRunMode;      /*!< TIM off state in run mode, This parameter can be a value of @ref TIM_OSSR_Off_State_Selection_for_Run_mode_state */

  uint32_t OffStateIDLEMode;     /*!< TIM off state in IDLE mode, This parameter can be a value of @ref TIM_OSSI_Off_State_Selection_for_Idle_mode_state */

  uint32_t LockLevel;            /*!< TIM Lock level, This parameter can be a value of @ref TIM_Lock_level */

  uint32_t DeadTime;             /*!< TIM dead Time, This parameter can be a number between Min_Data = 0x00 and Max_Data = 0xFF */

  uint32_t BreakState;           /*!< TIM Break State, This parameter can be a value of @ref TIM_Break_Input_enable_disable */

  uint32_t BreakPolarity;        /*!< TIM Break input polarity, This parameter can be a value of @ref TIM_Break_Polarity */

  uint32_t BreakFilter;          /*!< Specifies the break input filter.This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */

  uint32_t BreakAFMode;          /*!< Specifies the alternate function mode of the break input.This parameter can be a value of @ref TIM_Break_Input_AF_Mode */

  uint32_t Break2State;          /*!< TIM Break2 State, This parameter can be a value of @ref TIM_Break2_Input_enable_disable */

  uint32_t Break2Polarity;       /*!< TIM Break2 input polarity, This parameter can be a value of @ref TIM_Break2_Polarity */

  uint32_t Break2Filter;         /*!< TIM break2 input filter.This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */

  uint32_t Break2AFMode;         /*!< Specifies the alternate function mode of the break2 input.This parameter can be a value of @ref TIM_Break2_Input_AF_Mode */

  uint32_t AutomaticOutput;      /*!< TIM Automatic Output Enable state, This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */

} TIM_BreakDeadTimeConfigTypeDef;

/**
  * @brief  HAL State structures definition
  */
typedef enum
{
  HAL_TIM_STATE_RESET             = 0x00U,    /*!< Peripheral not yet initialized or disabled  */
  HAL_TIM_STATE_READY             = 0x01U,    /*!< Peripheral Initialized and ready for use    */
  HAL_TIM_STATE_BUSY              = 0x02U,    /*!< An internal process is ongoing              */
  HAL_TIM_STATE_TIMEOUT           = 0x03U,    /*!< Timeout state                               */
  HAL_TIM_STATE_ERROR             = 0x04U     /*!< Reception process is ongoing                */
} HAL_TIM_StateTypeDef;

/**
  * @brief  TIM Channel States definition
  */
typedef enum
{
  HAL_TIM_CHANNEL_STATE_RESET             = 0x00U,    /*!< TIM Channel initial state                         */
  HAL_TIM_CHANNEL_STATE_READY             = 0x01U,    /*!< TIM Channel ready for use                         */
  HAL_TIM_CHANNEL_STATE_BUSY              = 0x02U,    /*!< An internal process is ongoing on the TIM channel */
} HAL_TIM_ChannelStateTypeDef;

/**
  * @brief  DMA Burst States definition
  */
typedef enum
{
  HAL_DMA_BURST_STATE_RESET             = 0x00U,    /*!< DMA Burst initial state */
  HAL_DMA_BURST_STATE_READY             = 0x01U,    /*!< DMA Burst ready for use */
  HAL_DMA_BURST_STATE_BUSY              = 0x02U,    /*!< Ongoing DMA Burst       */
} HAL_TIM_DMABurstStateTypeDef;

/**
  * @brief  HAL Active channel structures definition
  */
typedef enum
{
  HAL_TIM_ACTIVE_CHANNEL_1        = 0x01U,    /*!< The active channel is 1     */
  HAL_TIM_ACTIVE_CHANNEL_2        = 0x02U,    /*!< The active channel is 2     */
  HAL_TIM_ACTIVE_CHANNEL_3        = 0x04U,    /*!< The active channel is 3     */
  HAL_TIM_ACTIVE_CHANNEL_4        = 0x08U,    /*!< The active channel is 4     */
  HAL_TIM_ACTIVE_CHANNEL_5        = 0x10U,    /*!< The active channel is 5     */
  HAL_TIM_ACTIVE_CHANNEL_6        = 0x20U,    /*!< The active channel is 6     */
  HAL_TIM_ACTIVE_CHANNEL_CLEARED  = 0x00U     /*!< All active channels cleared */
} HAL_TIM_ActiveChannel;

/**
  * @brief  TIM Time Base Handle Structure definition
  */



typedef struct

{
  TIM_TypeDef                        *Instance;         /*!< Register base address                             */
  TIM_Base_InitTypeDef               Init;              /*!< TIM Time Base required parameters                 */
  HAL_TIM_ActiveChannel              Channel;           /*!< Active channel                                    */
  DMA_HandleTypeDef                  *hdma[7];          /*!< DMA Handlers array
                                                             This array is accessed by a @ref DMA_Handle_index */
  HAL_LockTypeDef                    Lock;              /*!< Locking object                                    */
  __IO HAL_TIM_StateTypeDef          State;             /*!< TIM operation state                               */
  __IO HAL_TIM_ChannelStateTypeDef   ChannelState[6];   /*!< TIM channel operation state                       */
  __IO HAL_TIM_ChannelStateTypeDef   ChannelNState[4];  /*!< TIM complementary channel operation state         */
  __IO HAL_TIM_DMABurstStateTypeDef  DMABurstState;     /*!< DMA burst operation state                         */

# 411 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"
} TIM_HandleTypeDef;

# 459 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"

/**
  * @}
  */
/* End of exported types -----------------------------------------------------*/

/* Exported constants --------------------------------------------------------*/
/** @defgroup TIM_Exported_Constants TIM Exported Constants
  * @{
  */

/** @defgroup TIM_ClearInput_Source TIM Clear Input Source
  * @{
  */
#define TIM_CLEARINPUTSOURCE_NONE 0xFFFFFFFFU
#define TIM_CLEARINPUTSOURCE_ETR 0x00000001U
#define TIM_CLEARINPUTSOURCE_COMP1 0x00000000U
#define TIM_CLEARINPUTSOURCE_COMP2 TIM1_AF2_OCRSEL_0
#define TIM_CLEARINPUTSOURCE_COMP3 TIM1_AF2_OCRSEL_1
#define TIM_CLEARINPUTSOURCE_COMP4 (TIM1_AF2_OCRSEL_1 | TIM1_AF2_OCRSEL_0)

#define TIM_CLEARINPUTSOURCE_COMP5 TIM1_AF2_OCRSEL_2


#define TIM_CLEARINPUTSOURCE_COMP6 (TIM1_AF2_OCRSEL_2 | TIM1_AF2_OCRSEL_0)


#define TIM_CLEARINPUTSOURCE_COMP7 (TIM1_AF2_OCRSEL_2 | TIM1_AF2_OCRSEL_1)

/**
  * @}
  */

/** @defgroup TIM_DMA_Base_address TIM DMA Base Address
  * @{
  */
#define TIM_DMABASE_CR1 0x00000000U
#define TIM_DMABASE_CR2 0x00000001U
#define TIM_DMABASE_SMCR 0x00000002U
#define TIM_DMABASE_DIER 0x00000003U
#define TIM_DMABASE_SR 0x00000004U
#define TIM_DMABASE_EGR 0x00000005U
#define TIM_DMABASE_CCMR1 0x00000006U
#define TIM_DMABASE_CCMR2 0x00000007U
#define TIM_DMABASE_CCER 0x00000008U
#define TIM_DMABASE_CNT 0x00000009U
#define TIM_DMABASE_PSC 0x0000000AU
#define TIM_DMABASE_ARR 0x0000000BU
#define TIM_DMABASE_RCR 0x0000000CU
#define TIM_DMABASE_CCR1 0x0000000DU
#define TIM_DMABASE_CCR2 0x0000000EU
#define TIM_DMABASE_CCR3 0x0000000FU
#define TIM_DMABASE_CCR4 0x00000010U
#define TIM_DMABASE_BDTR 0x00000011U
#define TIM_DMABASE_CCR5 0x00000012U
#define TIM_DMABASE_CCR6 0x00000013U
#define TIM_DMABASE_CCMR3 0x00000014U
#define TIM_DMABASE_DTR2 0x00000015U
#define TIM_DMABASE_ECR 0x00000016U
#define TIM_DMABASE_TISEL 0x00000017U
#define TIM_DMABASE_AF1 0x00000018U
#define TIM_DMABASE_AF2 0x00000019U
#define TIM_DMABASE_OR 0x0000001AU
/**
  * @}
  */

/** @defgroup TIM_Event_Source TIM Event Source
  * @{
  */
#define TIM_EVENTSOURCE_UPDATE TIM_EGR_UG
#define TIM_EVENTSOURCE_CC1 TIM_EGR_CC1G
#define TIM_EVENTSOURCE_CC2 TIM_EGR_CC2G
#define TIM_EVENTSOURCE_CC3 TIM_EGR_CC3G
#define TIM_EVENTSOURCE_CC4 TIM_EGR_CC4G
#define TIM_EVENTSOURCE_COM TIM_EGR_COMG
#define TIM_EVENTSOURCE_TRIGGER TIM_EGR_TG
#define TIM_EVENTSOURCE_BREAK TIM_EGR_BG
#define TIM_EVENTSOURCE_BREAK2 TIM_EGR_B2G
/**
  * @}
  */

/** @defgroup TIM_Input_Channel_Polarity TIM Input Channel polarity
  * @{
  */
#define TIM_INPUTCHANNELPOLARITY_RISING 0x00000000U
#define TIM_INPUTCHANNELPOLARITY_FALLING TIM_CCER_CC1P
#define TIM_INPUTCHANNELPOLARITY_BOTHEDGE (TIM_CCER_CC1P | TIM_CCER_CC1NP)
/**
  * @}
  */

/** @defgroup TIM_ETR_Polarity TIM ETR Polarity
  * @{
  */
#define TIM_ETRPOLARITY_INVERTED TIM_SMCR_ETP
#define TIM_ETRPOLARITY_NONINVERTED 0x00000000U
/**
  * @}
  */

/** @defgroup TIM_ETR_Prescaler TIM ETR Prescaler
  * @{
  */
#define TIM_ETRPRESCALER_DIV1 0x00000000U
#define TIM_ETRPRESCALER_DIV2 TIM_SMCR_ETPS_0
#define TIM_ETRPRESCALER_DIV4 TIM_SMCR_ETPS_1
#define TIM_ETRPRESCALER_DIV8 TIM_SMCR_ETPS
/**
  * @}
  */

/** @defgroup TIM_Counter_Mode TIM Counter Mode
  * @{
  */
#define TIM_COUNTERMODE_UP 0x00000000U
#define TIM_COUNTERMODE_DOWN TIM_CR1_DIR
#define TIM_COUNTERMODE_CENTERALIGNED1 TIM_CR1_CMS_0
#define TIM_COUNTERMODE_CENTERALIGNED2 TIM_CR1_CMS_1
#define TIM_COUNTERMODE_CENTERALIGNED3 TIM_CR1_CMS
/**
  * @}
  */

/** @defgroup TIM_Update_Interrupt_Flag_Remap TIM Update Interrupt Flag Remap
  * @{
  */
#define TIM_UIFREMAP_DISABLE 0x00000000U
#define TIM_UIFREMAP_ENABLE TIM_CR1_UIFREMAP
/**
  * @}
  */

/** @defgroup TIM_ClockDivision TIM Clock Division
  * @{
  */
#define TIM_CLOCKDIVISION_DIV1 0x00000000U
#define TIM_CLOCKDIVISION_DIV2 TIM_CR1_CKD_0
#define TIM_CLOCKDIVISION_DIV4 TIM_CR1_CKD_1
/**
  * @}
  */

/** @defgroup TIM_Output_Compare_State TIM Output Compare State
  * @{
  */
#define TIM_OUTPUTSTATE_DISABLE 0x00000000U
#define TIM_OUTPUTSTATE_ENABLE TIM_CCER_CC1E
/**
  * @}
  */

/** @defgroup TIM_AutoReloadPreload TIM Auto-Reload Preload
  * @{
  */
#define TIM_AUTORELOAD_PRELOAD_DISABLE 0x00000000U
#define TIM_AUTORELOAD_PRELOAD_ENABLE TIM_CR1_ARPE

/**
  * @}
  */

/** @defgroup TIM_Output_Fast_State TIM Output Fast State
  * @{
  */
#define TIM_OCFAST_DISABLE 0x00000000U
#define TIM_OCFAST_ENABLE TIM_CCMR1_OC1FE
/**
  * @}
  */

/** @defgroup TIM_Output_Compare_N_State TIM Complementary Output Compare State
  * @{
  */
#define TIM_OUTPUTNSTATE_DISABLE 0x00000000U
#define TIM_OUTPUTNSTATE_ENABLE TIM_CCER_CC1NE
/**
  * @}
  */

/** @defgroup TIM_Output_Compare_Polarity TIM Output Compare Polarity
  * @{
  */
#define TIM_OCPOLARITY_HIGH 0x00000000U
#define TIM_OCPOLARITY_LOW TIM_CCER_CC1P
/**
  * @}
  */

/** @defgroup TIM_Output_Compare_N_Polarity TIM Complementary Output Compare Polarity
  * @{
  */
#define TIM_OCNPOLARITY_HIGH 0x00000000U
#define TIM_OCNPOLARITY_LOW TIM_CCER_CC1NP
/**
  * @}
  */

/** @defgroup TIM_Output_Compare_Idle_State TIM Output Compare Idle State
  * @{
  */
#define TIM_OCIDLESTATE_SET TIM_CR2_OIS1
#define TIM_OCIDLESTATE_RESET 0x00000000U
/**
  * @}
  */

/** @defgroup TIM_Output_Compare_N_Idle_State TIM Complementary Output Compare Idle State
  * @{
  */
#define TIM_OCNIDLESTATE_SET TIM_CR2_OIS1N
#define TIM_OCNIDLESTATE_RESET 0x00000000U
/**
  * @}
  */

/** @defgroup TIM_Input_Capture_Polarity TIM Input Capture Polarity
  * @{
  */
#define TIM_ICPOLARITY_RISING TIM_INPUTCHANNELPOLARITY_RISING
#define TIM_ICPOLARITY_FALLING TIM_INPUTCHANNELPOLARITY_FALLING
#define TIM_ICPOLARITY_BOTHEDGE TIM_INPUTCHANNELPOLARITY_BOTHEDGE
/**
  * @}
  */

/** @defgroup TIM_Encoder_Input_Polarity TIM Encoder Input Polarity
  * @{
  */
#define TIM_ENCODERINPUTPOLARITY_RISING TIM_INPUTCHANNELPOLARITY_RISING
#define TIM_ENCODERINPUTPOLARITY_FALLING TIM_INPUTCHANNELPOLARITY_FALLING
/**
  * @}
  */

/** @defgroup TIM_Input_Capture_Selection TIM Input Capture Selection
  * @{
  */
#define TIM_ICSELECTION_DIRECTTI TIM_CCMR1_CC1S_0
#define TIM_ICSELECTION_INDIRECTTI TIM_CCMR1_CC1S_1
#define TIM_ICSELECTION_TRC TIM_CCMR1_CC1S
/**
  * @}
  */

/** @defgroup TIM_Input_Capture_Prescaler TIM Input Capture Prescaler
  * @{
  */
#define TIM_ICPSC_DIV1 0x00000000U
#define TIM_ICPSC_DIV2 TIM_CCMR1_IC1PSC_0
#define TIM_ICPSC_DIV4 TIM_CCMR1_IC1PSC_1
#define TIM_ICPSC_DIV8 TIM_CCMR1_IC1PSC
/**
  * @}
  */

/** @defgroup TIM_One_Pulse_Mode TIM One Pulse Mode
  * @{
  */
#define TIM_OPMODE_SINGLE TIM_CR1_OPM
#define TIM_OPMODE_REPETITIVE 0x00000000U
/**
  * @}
  */

/** @defgroup TIM_Encoder_Mode TIM Encoder Mode
  * @{
  */
#define TIM_ENCODERMODE_TI1 TIM_SMCR_SMS_0
#define TIM_ENCODERMODE_TI2 TIM_SMCR_SMS_1
#define TIM_ENCODERMODE_TI12 (TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0)
#define TIM_ENCODERMODE_CLOCKPLUSDIRECTION_X2 (TIM_SMCR_SMS_3 | TIM_SMCR_SMS_1)
#define TIM_ENCODERMODE_CLOCKPLUSDIRECTION_X1 (TIM_SMCR_SMS_3 | TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0)
#define TIM_ENCODERMODE_DIRECTIONALCLOCK_X2 (TIM_SMCR_SMS_3 | TIM_SMCR_SMS_2)
#define TIM_ENCODERMODE_DIRECTIONALCLOCK_X1_TI12 (TIM_SMCR_SMS_3 | TIM_SMCR_SMS_2 | TIM_SMCR_SMS_0)
#define TIM_ENCODERMODE_X1_TI1 (TIM_SMCR_SMS_3 | TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1)
#define TIM_ENCODERMODE_X1_TI2 (TIM_SMCR_SMS_3 | TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0)
/**
  * @}
  */

/** @defgroup TIM_Interrupt_definition TIM interrupt Definition
  * @{
  */
#define TIM_IT_UPDATE TIM_DIER_UIE
#define TIM_IT_CC1 TIM_DIER_CC1IE
#define TIM_IT_CC2 TIM_DIER_CC2IE
#define TIM_IT_CC3 TIM_DIER_CC3IE
#define TIM_IT_CC4 TIM_DIER_CC4IE
#define TIM_IT_COM TIM_DIER_COMIE
#define TIM_IT_TRIGGER TIM_DIER_TIE
#define TIM_IT_BREAK TIM_DIER_BIE
#define TIM_IT_IDX TIM_DIER_IDXIE
#define TIM_IT_DIR TIM_DIER_DIRIE
#define TIM_IT_IERR TIM_DIER_IERRIE
#define TIM_IT_TERR TIM_DIER_TERRIE
/**
  * @}
  */

/** @defgroup TIM_Commutation_Source  TIM Commutation Source
  * @{
  */
#define TIM_COMMUTATION_TRGI TIM_CR2_CCUS
#define TIM_COMMUTATION_SOFTWARE 0x00000000U
/**
  * @}
  */

/** @defgroup TIM_DMA_sources TIM DMA Sources
  * @{
  */
#define TIM_DMA_UPDATE TIM_DIER_UDE
#define TIM_DMA_CC1 TIM_DIER_CC1DE
#define TIM_DMA_CC2 TIM_DIER_CC2DE
#define TIM_DMA_CC3 TIM_DIER_CC3DE
#define TIM_DMA_CC4 TIM_DIER_CC4DE
#define TIM_DMA_COM TIM_DIER_COMDE
#define TIM_DMA_TRIGGER TIM_DIER_TDE
/**
  * @}
  */

/** @defgroup TIM_CC_DMA_Request CCx DMA request selection
  * @{
  */
#define TIM_CCDMAREQUEST_CC 0x00000000U
#define TIM_CCDMAREQUEST_UPDATE TIM_CR2_CCDS
/**
  * @}
  */

/** @defgroup TIM_Flag_definition TIM Flag Definition
  * @{
  */
#define TIM_FLAG_UPDATE TIM_SR_UIF
#define TIM_FLAG_CC1 TIM_SR_CC1IF
#define TIM_FLAG_CC2 TIM_SR_CC2IF
#define TIM_FLAG_CC3 TIM_SR_CC3IF
#define TIM_FLAG_CC4 TIM_SR_CC4IF
#define TIM_FLAG_CC5 TIM_SR_CC5IF
#define TIM_FLAG_CC6 TIM_SR_CC6IF
#define TIM_FLAG_COM TIM_SR_COMIF
#define TIM_FLAG_TRIGGER TIM_SR_TIF
#define TIM_FLAG_BREAK TIM_SR_BIF
#define TIM_FLAG_BREAK2 TIM_SR_B2IF
#define TIM_FLAG_SYSTEM_BREAK TIM_SR_SBIF
#define TIM_FLAG_CC1OF TIM_SR_CC1OF
#define TIM_FLAG_CC2OF TIM_SR_CC2OF
#define TIM_FLAG_CC3OF TIM_SR_CC3OF
#define TIM_FLAG_CC4OF TIM_SR_CC4OF
#define TIM_FLAG_IDX TIM_SR_IDXF
#define TIM_FLAG_DIR TIM_SR_DIRF
#define TIM_FLAG_IERR TIM_SR_IERRF
#define TIM_FLAG_TERR TIM_SR_TERRF
/**
  * @}
  */

/** @defgroup TIM_Channel TIM Channel
  * @{
  */
#define TIM_CHANNEL_1 0x00000000U
#define TIM_CHANNEL_2 0x00000004U
#define TIM_CHANNEL_3 0x00000008U
#define TIM_CHANNEL_4 0x0000000CU
#define TIM_CHANNEL_5 0x00000010U
#define TIM_CHANNEL_6 0x00000014U
#define TIM_CHANNEL_ALL 0x0000003CU
/**
  * @}
  */

/** @defgroup TIM_Clock_Source TIM Clock Source
  * @{
  */
#define TIM_CLOCKSOURCE_INTERNAL TIM_SMCR_ETPS_0
#define TIM_CLOCKSOURCE_ETRMODE1 TIM_TS_ETRF
#define TIM_CLOCKSOURCE_ETRMODE2 TIM_SMCR_ETPS_1
#define TIM_CLOCKSOURCE_TI1ED TIM_TS_TI1F_ED
#define TIM_CLOCKSOURCE_TI1 TIM_TS_TI1FP1
#define TIM_CLOCKSOURCE_TI2 TIM_TS_TI2FP2
#define TIM_CLOCKSOURCE_ITR0 TIM_TS_ITR0
#define TIM_CLOCKSOURCE_ITR1 TIM_TS_ITR1
#define TIM_CLOCKSOURCE_ITR2 TIM_TS_ITR2
#define TIM_CLOCKSOURCE_ITR3 TIM_TS_ITR3

#define TIM_CLOCKSOURCE_ITR4 TIM_TS_ITR4

#define TIM_CLOCKSOURCE_ITR5 TIM_TS_ITR5
#define TIM_CLOCKSOURCE_ITR6 TIM_TS_ITR6
#define TIM_CLOCKSOURCE_ITR7 TIM_TS_ITR7
#define TIM_CLOCKSOURCE_ITR8 TIM_TS_ITR8

#define TIM_CLOCKSOURCE_ITR9 TIM_TS_ITR9

#define TIM_CLOCKSOURCE_ITR10 TIM_TS_ITR10
#define TIM_CLOCKSOURCE_ITR11 TIM_TS_ITR11
/**
  * @}
  */

/** @defgroup TIM_Clock_Polarity TIM Clock Polarity
  * @{
  */
#define TIM_CLOCKPOLARITY_INVERTED TIM_ETRPOLARITY_INVERTED
#define TIM_CLOCKPOLARITY_NONINVERTED TIM_ETRPOLARITY_NONINVERTED
#define TIM_CLOCKPOLARITY_RISING TIM_INPUTCHANNELPOLARITY_RISING
#define TIM_CLOCKPOLARITY_FALLING TIM_INPUTCHANNELPOLARITY_FALLING
#define TIM_CLOCKPOLARITY_BOTHEDGE TIM_INPUTCHANNELPOLARITY_BOTHEDGE
/**
  * @}
  */

/** @defgroup TIM_Clock_Prescaler TIM Clock Prescaler
  * @{
  */
#define TIM_CLOCKPRESCALER_DIV1 TIM_ETRPRESCALER_DIV1
#define TIM_CLOCKPRESCALER_DIV2 TIM_ETRPRESCALER_DIV2
#define TIM_CLOCKPRESCALER_DIV4 TIM_ETRPRESCALER_DIV4
#define TIM_CLOCKPRESCALER_DIV8 TIM_ETRPRESCALER_DIV8
/**
  * @}
  */

/** @defgroup TIM_ClearInput_Polarity TIM Clear Input Polarity
  * @{
  */
#define TIM_CLEARINPUTPOLARITY_INVERTED TIM_ETRPOLARITY_INVERTED
#define TIM_CLEARINPUTPOLARITY_NONINVERTED TIM_ETRPOLARITY_NONINVERTED
/**
  * @}
  */

/** @defgroup TIM_ClearInput_Prescaler TIM Clear Input Prescaler
  * @{
  */
#define TIM_CLEARINPUTPRESCALER_DIV1 TIM_ETRPRESCALER_DIV1
#define TIM_CLEARINPUTPRESCALER_DIV2 TIM_ETRPRESCALER_DIV2
#define TIM_CLEARINPUTPRESCALER_DIV4 TIM_ETRPRESCALER_DIV4
#define TIM_CLEARINPUTPRESCALER_DIV8 TIM_ETRPRESCALER_DIV8
/**
  * @}
  */

/** @defgroup TIM_OSSR_Off_State_Selection_for_Run_mode_state TIM OSSR OffState Selection for Run mode state
  * @{
  */
#define TIM_OSSR_ENABLE TIM_BDTR_OSSR
#define TIM_OSSR_DISABLE 0x00000000U
/**
  * @}
  */

/** @defgroup TIM_OSSI_Off_State_Selection_for_Idle_mode_state TIM OSSI OffState Selection for Idle mode state
  * @{
  */
#define TIM_OSSI_ENABLE TIM_BDTR_OSSI
#define TIM_OSSI_DISABLE 0x00000000U
/**
  * @}
  */
/** @defgroup TIM_Lock_level  TIM Lock level
  * @{
  */
#define TIM_LOCKLEVEL_OFF 0x00000000U
#define TIM_LOCKLEVEL_1 TIM_BDTR_LOCK_0
#define TIM_LOCKLEVEL_2 TIM_BDTR_LOCK_1
#define TIM_LOCKLEVEL_3 TIM_BDTR_LOCK
/**
  * @}
  */

/** @defgroup TIM_Break_Input_enable_disable TIM Break Input Enable
  * @{
  */
#define TIM_BREAK_ENABLE TIM_BDTR_BKE
#define TIM_BREAK_DISABLE 0x00000000U
/**
  * @}
  */

/** @defgroup TIM_Break_Polarity TIM Break Input Polarity
  * @{
  */
#define TIM_BREAKPOLARITY_LOW 0x00000000U
#define TIM_BREAKPOLARITY_HIGH TIM_BDTR_BKP
/**
  * @}
  */

/** @defgroup TIM_Break_Input_AF_Mode TIM Break Input Alternate Function Mode
  * @{
  */
#define TIM_BREAK_AFMODE_INPUT 0x00000000U
#define TIM_BREAK_AFMODE_BIDIRECTIONAL TIM_BDTR_BKBID
/**
  * @}
  */

/** @defgroup TIM_Break2_Input_enable_disable TIM Break input 2 Enable
  * @{
  */
#define TIM_BREAK2_DISABLE 0x00000000U
#define TIM_BREAK2_ENABLE TIM_BDTR_BK2E
/**
  * @}
  */

/** @defgroup TIM_Break2_Polarity TIM Break Input 2 Polarity
  * @{
  */
#define TIM_BREAK2POLARITY_LOW 0x00000000U
#define TIM_BREAK2POLARITY_HIGH TIM_BDTR_BK2P
/**
  * @}
  */

/** @defgroup TIM_Break2_Input_AF_Mode TIM Break2 Input Alternate Function Mode
  * @{
  */
#define TIM_BREAK2_AFMODE_INPUT 0x00000000U
#define TIM_BREAK2_AFMODE_BIDIRECTIONAL TIM_BDTR_BK2BID
/**
  * @}
  */

/** @defgroup TIM_AOE_Bit_Set_Reset TIM Automatic Output Enable
  * @{
  */
#define TIM_AUTOMATICOUTPUT_DISABLE 0x00000000U
#define TIM_AUTOMATICOUTPUT_ENABLE TIM_BDTR_AOE
/**
  * @}
  */

/** @defgroup TIM_Group_Channel5 TIM Group Channel 5 and Channel 1, 2 or 3
  * @{
  */
#define TIM_GROUPCH5_NONE 0x00000000U
#define TIM_GROUPCH5_OC1REFC TIM_CCR5_GC5C1
#define TIM_GROUPCH5_OC2REFC TIM_CCR5_GC5C2
#define TIM_GROUPCH5_OC3REFC TIM_CCR5_GC5C3
/**
  * @}
  */

/** @defgroup TIM_Master_Mode_Selection TIM Master Mode Selection
  * @{
  */
#define TIM_TRGO_RESET 0x00000000U
#define TIM_TRGO_ENABLE TIM_CR2_MMS_0
#define TIM_TRGO_UPDATE TIM_CR2_MMS_1
#define TIM_TRGO_OC1 (TIM_CR2_MMS_1 | TIM_CR2_MMS_0)
#define TIM_TRGO_OC1REF TIM_CR2_MMS_2
#define TIM_TRGO_OC2REF (TIM_CR2_MMS_2 | TIM_CR2_MMS_0)
#define TIM_TRGO_OC3REF (TIM_CR2_MMS_2 | TIM_CR2_MMS_1)
#define TIM_TRGO_OC4REF (TIM_CR2_MMS_2 | TIM_CR2_MMS_1 | TIM_CR2_MMS_0)
#define TIM_TRGO_ENCODER_CLK TIM_CR2_MMS_3
/**
  * @}
  */

/** @defgroup TIM_Master_Mode_Selection_2 TIM Master Mode Selection 2 (TRGO2)
  * @{
  */
#define TIM_TRGO2_RESET 0x00000000U
#define TIM_TRGO2_ENABLE TIM_CR2_MMS2_0
#define TIM_TRGO2_UPDATE TIM_CR2_MMS2_1
#define TIM_TRGO2_OC1 (TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0)
#define TIM_TRGO2_OC1REF TIM_CR2_MMS2_2
#define TIM_TRGO2_OC2REF (TIM_CR2_MMS2_2 | TIM_CR2_MMS2_0)
#define TIM_TRGO2_OC3REF (TIM_CR2_MMS2_2 | TIM_CR2_MMS2_1)
#define TIM_TRGO2_OC4REF (TIM_CR2_MMS2_2 | TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0)
#define TIM_TRGO2_OC5REF TIM_CR2_MMS2_3
#define TIM_TRGO2_OC6REF (TIM_CR2_MMS2_3 | TIM_CR2_MMS2_0)
#define TIM_TRGO2_OC4REF_RISINGFALLING (TIM_CR2_MMS2_3 | TIM_CR2_MMS2_1)
#define TIM_TRGO2_OC6REF_RISINGFALLING (TIM_CR2_MMS2_3 | TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0)
#define TIM_TRGO2_OC4REF_RISING_OC6REF_RISING (TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2)
#define TIM_TRGO2_OC4REF_RISING_OC6REF_FALLING (TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2 | TIM_CR2_MMS2_0)
#define TIM_TRGO2_OC5REF_RISING_OC6REF_RISING (TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2 |TIM_CR2_MMS2_1)
#define TIM_TRGO2_OC5REF_RISING_OC6REF_FALLING (TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2 | TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0)
/**
  * @}
  */

/** @defgroup TIM_Master_Slave_Mode TIM Master/Slave Mode
  * @{
  */
#define TIM_MASTERSLAVEMODE_ENABLE TIM_SMCR_MSM
#define TIM_MASTERSLAVEMODE_DISABLE 0x00000000U
/**
  * @}
  */

/** @defgroup TIM_Slave_Mode TIM Slave mode
  * @{
  */
#define TIM_SLAVEMODE_DISABLE 0x00000000U
#define TIM_SLAVEMODE_RESET TIM_SMCR_SMS_2
#define TIM_SLAVEMODE_GATED (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_0)
#define TIM_SLAVEMODE_TRIGGER (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1)
#define TIM_SLAVEMODE_EXTERNAL1 (TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0)
#define TIM_SLAVEMODE_COMBINED_RESETTRIGGER TIM_SMCR_SMS_3
#define TIM_SLAVEMODE_COMBINED_GATEDRESET (TIM_SMCR_SMS_3 | TIM_SMCR_SMS_0)
/**
  * @}
  */

/** @defgroup TIM_Output_Compare_and_PWM_modes TIM Output Compare and PWM Modes
  * @{
  */
#define TIM_OCMODE_TIMING 0x00000000U
#define TIM_OCMODE_ACTIVE TIM_CCMR1_OC1M_0
#define TIM_OCMODE_INACTIVE TIM_CCMR1_OC1M_1
#define TIM_OCMODE_TOGGLE (TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_0)
#define TIM_OCMODE_PWM1 (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1)
#define TIM_OCMODE_PWM2 (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_0)
#define TIM_OCMODE_FORCED_ACTIVE (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_0)
#define TIM_OCMODE_FORCED_INACTIVE TIM_CCMR1_OC1M_2
#define TIM_OCMODE_RETRIGERRABLE_OPM1 TIM_CCMR1_OC1M_3
#define TIM_OCMODE_RETRIGERRABLE_OPM2 (TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_0)
#define TIM_OCMODE_COMBINED_PWM1 (TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_2)
#define TIM_OCMODE_COMBINED_PWM2 (TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_0 | TIM_CCMR1_OC1M_2)
#define TIM_OCMODE_ASYMMETRIC_PWM1 (TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_2)
#define TIM_OCMODE_ASYMMETRIC_PWM2 TIM_CCMR1_OC1M
#define TIM_OCMODE_PULSE_ON_COMPARE (TIM_CCMR2_OC3M_3 | TIM_CCMR2_OC3M_1)
#define TIM_OCMODE_DIRECTION_OUTPUT (TIM_CCMR2_OC3M_3 | TIM_CCMR2_OC3M_1 | TIM_CCMR2_OC3M_0)
/**
  * @}
  */

/** @defgroup TIM_Trigger_Selection TIM Trigger Selection
  * @{
  */
#define TIM_TS_ITR0 0x00000000U
#define TIM_TS_ITR1 TIM_SMCR_TS_0
#define TIM_TS_ITR2 TIM_SMCR_TS_1
#define TIM_TS_ITR3 (TIM_SMCR_TS_0 | TIM_SMCR_TS_1)

#define TIM_TS_ITR4 TIM_SMCR_TS_3

#define TIM_TS_ITR5 (TIM_SMCR_TS_0 | TIM_SMCR_TS_3)
#define TIM_TS_ITR6 (TIM_SMCR_TS_1 | TIM_SMCR_TS_3)
#define TIM_TS_ITR7 (TIM_SMCR_TS_0 | TIM_SMCR_TS_1 | TIM_SMCR_TS_3)
#define TIM_TS_ITR8 (TIM_SMCR_TS_2 | TIM_SMCR_TS_3)

#define TIM_TS_ITR9 (TIM_SMCR_TS_0 | TIM_SMCR_TS_2 | TIM_SMCR_TS_3)

#define TIM_TS_ITR10 (TIM_SMCR_TS_1 | TIM_SMCR_TS_2 | TIM_SMCR_TS_3)
#define TIM_TS_ITR11 (TIM_SMCR_TS_0 | TIM_SMCR_TS_1 | TIM_SMCR_TS_2 | TIM_SMCR_TS_3)
#define TIM_TS_TI1F_ED TIM_SMCR_TS_2
#define TIM_TS_TI1FP1 (TIM_SMCR_TS_0 | TIM_SMCR_TS_2)
#define TIM_TS_TI2FP2 (TIM_SMCR_TS_1 | TIM_SMCR_TS_2)
#define TIM_TS_ETRF (TIM_SMCR_TS_0 | TIM_SMCR_TS_1 | TIM_SMCR_TS_2)
#define TIM_TS_NONE 0x0000FFFFU
/**
  * @}
  */

/** @defgroup TIM_Trigger_Polarity TIM Trigger Polarity
  * @{
  */
#define TIM_TRIGGERPOLARITY_INVERTED TIM_ETRPOLARITY_INVERTED
#define TIM_TRIGGERPOLARITY_NONINVERTED TIM_ETRPOLARITY_NONINVERTED
#define TIM_TRIGGERPOLARITY_RISING TIM_INPUTCHANNELPOLARITY_RISING
#define TIM_TRIGGERPOLARITY_FALLING TIM_INPUTCHANNELPOLARITY_FALLING
#define TIM_TRIGGERPOLARITY_BOTHEDGE TIM_INPUTCHANNELPOLARITY_BOTHEDGE
/**
  * @}
  */

/** @defgroup TIM_Trigger_Prescaler TIM Trigger Prescaler
  * @{
  */
#define TIM_TRIGGERPRESCALER_DIV1 TIM_ETRPRESCALER_DIV1
#define TIM_TRIGGERPRESCALER_DIV2 TIM_ETRPRESCALER_DIV2
#define TIM_TRIGGERPRESCALER_DIV4 TIM_ETRPRESCALER_DIV4
#define TIM_TRIGGERPRESCALER_DIV8 TIM_ETRPRESCALER_DIV8
/**
  * @}
  */

/** @defgroup TIM_TI1_Selection TIM TI1 Input Selection
  * @{
  */
#define TIM_TI1SELECTION_CH1 0x00000000U
#define TIM_TI1SELECTION_XORCOMBINATION TIM_CR2_TI1S
/**
  * @}
  */

/** @defgroup TIM_DMA_Burst_Length TIM DMA Burst Length
  * @{
  */
#define TIM_DMABURSTLENGTH_1TRANSFER 0x00000000U
#define TIM_DMABURSTLENGTH_2TRANSFERS 0x00000100U
#define TIM_DMABURSTLENGTH_3TRANSFERS 0x00000200U
#define TIM_DMABURSTLENGTH_4TRANSFERS 0x00000300U
#define TIM_DMABURSTLENGTH_5TRANSFERS 0x00000400U
#define TIM_DMABURSTLENGTH_6TRANSFERS 0x00000500U
#define TIM_DMABURSTLENGTH_7TRANSFERS 0x00000600U
#define TIM_DMABURSTLENGTH_8TRANSFERS 0x00000700U
#define TIM_DMABURSTLENGTH_9TRANSFERS 0x00000800U
#define TIM_DMABURSTLENGTH_10TRANSFERS 0x00000900U
#define TIM_DMABURSTLENGTH_11TRANSFERS 0x00000A00U
#define TIM_DMABURSTLENGTH_12TRANSFERS 0x00000B00U
#define TIM_DMABURSTLENGTH_13TRANSFERS 0x00000C00U
#define TIM_DMABURSTLENGTH_14TRANSFERS 0x00000D00U
#define TIM_DMABURSTLENGTH_15TRANSFERS 0x00000E00U
#define TIM_DMABURSTLENGTH_16TRANSFERS 0x00000F00U
#define TIM_DMABURSTLENGTH_17TRANSFERS 0x00001000U
#define TIM_DMABURSTLENGTH_18TRANSFERS 0x00001100U
#define TIM_DMABURSTLENGTH_19TRANSFERS 0x00001200U
#define TIM_DMABURSTLENGTH_20TRANSFERS 0x00001300U
#define TIM_DMABURSTLENGTH_21TRANSFERS 0x00001400U
#define TIM_DMABURSTLENGTH_22TRANSFERS 0x00001500U
#define TIM_DMABURSTLENGTH_23TRANSFERS 0x00001600U
#define TIM_DMABURSTLENGTH_24TRANSFERS 0x00001700U
#define TIM_DMABURSTLENGTH_25TRANSFERS 0x00001800U
#define TIM_DMABURSTLENGTH_26TRANSFERS 0x00001900U
/**
  * @}
  */

/** @defgroup DMA_Handle_index TIM DMA Handle Index
  * @{
  */
#define TIM_DMA_ID_UPDATE ((uint16_t) 0x0000)
#define TIM_DMA_ID_CC1 ((uint16_t) 0x0001)
#define TIM_DMA_ID_CC2 ((uint16_t) 0x0002)
#define TIM_DMA_ID_CC3 ((uint16_t) 0x0003)
#define TIM_DMA_ID_CC4 ((uint16_t) 0x0004)
#define TIM_DMA_ID_COMMUTATION ((uint16_t) 0x0005)
#define TIM_DMA_ID_TRIGGER ((uint16_t) 0x0006)
/**
  * @}
  */

/** @defgroup Channel_CC_State TIM Capture/Compare Channel State
  * @{
  */
#define TIM_CCx_ENABLE 0x00000001U
#define TIM_CCx_DISABLE 0x00000000U
#define TIM_CCxN_ENABLE 0x00000004U
#define TIM_CCxN_DISABLE 0x00000000U
/**
  * @}
  */

/** @defgroup TIM_Break_System TIM Break System
  * @{
  */
#define TIM_BREAK_SYSTEM_ECC SYSCFG_CFGR2_ECCL
#define TIM_BREAK_SYSTEM_PVD SYSCFG_CFGR2_PVDL
#define TIM_BREAK_SYSTEM_SRAM_PARITY_ERROR SYSCFG_CFGR2_SPL
#define TIM_BREAK_SYSTEM_LOCKUP SYSCFG_CFGR2_CLL
/**
  * @}
  */

/**
  * @}
  */
/* End of exported constants -------------------------------------------------*/

/* Exported macros -----------------------------------------------------------*/
/** @defgroup TIM_Exported_Macros TIM Exported Macros
  * @{
  */

/** @brief  Reset TIM handle state.
  * @param  __HANDLE__ TIM handle.
  * @retval None
  */
# 1265 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"
#define __HAL_TIM_RESET_HANDLE_STATE(__HANDLE__) do { (__HANDLE__)->State = HAL_TIM_STATE_RESET; (__HANDLE__)->ChannelState[0] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelState[1] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelState[2] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelState[3] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelState[4] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelState[5] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelNState[0] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelNState[1] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelNState[2] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelNState[3] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->DMABurstState = HAL_DMA_BURST_STATE_RESET; } while(0)
# 1279 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"


/**
  * @brief  Enable the TIM peripheral.
  * @param  __HANDLE__ TIM handle
  * @retval None
  */
#define __HAL_TIM_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR1|=(TIM_CR1_CEN))

/**
  * @brief  Enable the TIM main Output.
  * @param  __HANDLE__ TIM handle
  * @retval None
  */
#define __HAL_TIM_MOE_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->BDTR|=(TIM_BDTR_MOE))

/**
  * @brief  Disable the TIM peripheral.
  * @param  __HANDLE__ TIM handle
  * @retval None
  */
#define __HAL_TIM_DISABLE(__HANDLE__) do { if (((__HANDLE__)->Instance->CCER & TIM_CCER_CCxE_MASK) == 0UL) { if(((__HANDLE__)->Instance->CCER & TIM_CCER_CCxNE_MASK) == 0UL) { (__HANDLE__)->Instance->CR1 &= ~(TIM_CR1_CEN); } } } while(0)
# 1310 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"

/**
  * @brief  Disable the TIM main Output.
  * @param  __HANDLE__ TIM handle
  * @retval None
  * @note The Main Output Enable of a timer instance is disabled only if all the CCx and CCxN channels have been
  *       disabled
  */
#define __HAL_TIM_MOE_DISABLE(__HANDLE__) do { if (((__HANDLE__)->Instance->CCER & TIM_CCER_CCxE_MASK) == 0UL) { if(((__HANDLE__)->Instance->CCER & TIM_CCER_CCxNE_MASK) == 0UL) { (__HANDLE__)->Instance->BDTR &= ~(TIM_BDTR_MOE); } } } while(0)
# 1328 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"

/**
  * @brief  Disable the TIM main Output.
  * @param  __HANDLE__ TIM handle
  * @retval None
  * @note The Main Output Enable of a timer instance is disabled unconditionally
  */
#define __HAL_TIM_MOE_DISABLE_UNCONDITIONALLY(__HANDLE__) (__HANDLE__)->Instance->BDTR &= ~(TIM_BDTR_MOE)

/** @brief  Enable the specified TIM interrupt.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __INTERRUPT__ specifies the TIM interrupt source to enable.
  *          This parameter can be one of the following values:
  *            @arg TIM_IT_UPDATE: Update interrupt
  *            @arg TIM_IT_CC1:   Capture/Compare 1 interrupt
  *            @arg TIM_IT_CC2:  Capture/Compare 2 interrupt
  *            @arg TIM_IT_CC3:  Capture/Compare 3 interrupt
  *            @arg TIM_IT_CC4:  Capture/Compare 4 interrupt
  *            @arg TIM_IT_COM:   Commutation interrupt
  *            @arg TIM_IT_TRIGGER: Trigger interrupt
  *            @arg TIM_IT_BREAK: Break interrupt
  *            @arg TIM_IT_IDX: Index interrupt
  *            @arg TIM_IT_DIR: Direction change interrupt
  *            @arg TIM_IT_IERR: Index error interrupt
  *            @arg TIM_IT_TERR: Transition error interrupt
  * @retval None
  */
#define __HAL_TIM_ENABLE_IT(__HANDLE__,__INTERRUPT__) ((__HANDLE__)->Instance->DIER |= (__INTERRUPT__))

/** @brief  Disable the specified TIM interrupt.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __INTERRUPT__ specifies the TIM interrupt source to disable.
  *          This parameter can be one of the following values:
  *            @arg TIM_IT_UPDATE: Update interrupt
  *            @arg TIM_IT_CC1:   Capture/Compare 1 interrupt
  *            @arg TIM_IT_CC2:  Capture/Compare 2 interrupt
  *            @arg TIM_IT_CC3:  Capture/Compare 3 interrupt
  *            @arg TIM_IT_CC4:  Capture/Compare 4 interrupt
  *            @arg TIM_IT_COM:   Commutation interrupt
  *            @arg TIM_IT_TRIGGER: Trigger interrupt
  *            @arg TIM_IT_BREAK: Break interrupt
  *            @arg TIM_IT_IDX: Index interrupt
  *            @arg TIM_IT_DIR: Direction change interrupt
  *            @arg TIM_IT_IERR: Index error interrupt
  *            @arg TIM_IT_TERR: Transition error interrupt
  * @retval None
  */
#define __HAL_TIM_DISABLE_IT(__HANDLE__,__INTERRUPT__) ((__HANDLE__)->Instance->DIER &= ~(__INTERRUPT__))

/** @brief  Enable the specified DMA request.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __DMA__ specifies the TIM DMA request to enable.
  *          This parameter can be one of the following values:
  *            @arg TIM_DMA_UPDATE: Update DMA request
  *            @arg TIM_DMA_CC1:   Capture/Compare 1 DMA request
  *            @arg TIM_DMA_CC2:  Capture/Compare 2 DMA request
  *            @arg TIM_DMA_CC3:  Capture/Compare 3 DMA request
  *            @arg TIM_DMA_CC4:  Capture/Compare 4 DMA request
  *            @arg TIM_DMA_COM:   Commutation DMA request
  *            @arg TIM_DMA_TRIGGER: Trigger DMA request
  * @retval None
  */
#define __HAL_TIM_ENABLE_DMA(__HANDLE__,__DMA__) ((__HANDLE__)->Instance->DIER |= (__DMA__))

/** @brief  Disable the specified DMA request.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __DMA__ specifies the TIM DMA request to disable.
  *          This parameter can be one of the following values:
  *            @arg TIM_DMA_UPDATE: Update DMA request
  *            @arg TIM_DMA_CC1:   Capture/Compare 1 DMA request
  *            @arg TIM_DMA_CC2:  Capture/Compare 2 DMA request
  *            @arg TIM_DMA_CC3:  Capture/Compare 3 DMA request
  *            @arg TIM_DMA_CC4:  Capture/Compare 4 DMA request
  *            @arg TIM_DMA_COM:   Commutation DMA request
  *            @arg TIM_DMA_TRIGGER: Trigger DMA request
  * @retval None
  */
#define __HAL_TIM_DISABLE_DMA(__HANDLE__,__DMA__) ((__HANDLE__)->Instance->DIER &= ~(__DMA__))

/** @brief  Check whether the specified TIM interrupt flag is set or not.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __FLAG__ specifies the TIM interrupt flag to check.
  *        This parameter can be one of the following values:
  *            @arg TIM_FLAG_UPDATE: Update interrupt flag
  *            @arg TIM_FLAG_CC1: Capture/Compare 1 interrupt flag
  *            @arg TIM_FLAG_CC2: Capture/Compare 2 interrupt flag
  *            @arg TIM_FLAG_CC3: Capture/Compare 3 interrupt flag
  *            @arg TIM_FLAG_CC4: Capture/Compare 4 interrupt flag
  *            @arg TIM_FLAG_CC5: Compare 5 interrupt flag
  *            @arg TIM_FLAG_CC6: Compare 6 interrupt flag
  *            @arg TIM_FLAG_COM:  Commutation interrupt flag
  *            @arg TIM_FLAG_TRIGGER: Trigger interrupt flag
  *            @arg TIM_FLAG_BREAK: Break interrupt flag
  *            @arg TIM_FLAG_BREAK2: Break 2 interrupt flag
  *            @arg TIM_FLAG_SYSTEM_BREAK: System Break interrupt flag
  *            @arg TIM_FLAG_CC1OF: Capture/Compare 1 overcapture flag
  *            @arg TIM_FLAG_CC2OF: Capture/Compare 2 overcapture flag
  *            @arg TIM_FLAG_CC3OF: Capture/Compare 3 overcapture flag
  *            @arg TIM_FLAG_CC4OF: Capture/Compare 4 overcapture flag
  *            @arg TIM_FLAG_IDX: Index interrupt flag
  *            @arg TIM_FLAG_DIR: Direction change interrupt flag
  *            @arg TIM_FLAG_IERR: Index error interrupt flag
  *            @arg TIM_FLAG_TERR: Transition error interrupt flag
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  */
#define __HAL_TIM_GET_FLAG(__HANDLE__,__FLAG__) (((__HANDLE__)->Instance->SR &(__FLAG__)) == (__FLAG__))

/** @brief  Clear the specified TIM interrupt flag.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __FLAG__ specifies the TIM interrupt flag to clear.
  *        This parameter can be one of the following values:
  *            @arg TIM_FLAG_UPDATE: Update interrupt flag
  *            @arg TIM_FLAG_CC1: Capture/Compare 1 interrupt flag
  *            @arg TIM_FLAG_CC2: Capture/Compare 2 interrupt flag
  *            @arg TIM_FLAG_CC3: Capture/Compare 3 interrupt flag
  *            @arg TIM_FLAG_CC4: Capture/Compare 4 interrupt flag
  *            @arg TIM_FLAG_CC5: Compare 5 interrupt flag
  *            @arg TIM_FLAG_CC6: Compare 6 interrupt flag
  *            @arg TIM_FLAG_COM:  Commutation interrupt flag
  *            @arg TIM_FLAG_TRIGGER: Trigger interrupt flag
  *            @arg TIM_FLAG_BREAK: Break interrupt flag
  *            @arg TIM_FLAG_BREAK2: Break 2 interrupt flag
  *            @arg TIM_FLAG_SYSTEM_BREAK: System Break interrupt flag
  *            @arg TIM_FLAG_CC1OF: Capture/Compare 1 overcapture flag
  *            @arg TIM_FLAG_CC2OF: Capture/Compare 2 overcapture flag
  *            @arg TIM_FLAG_CC3OF: Capture/Compare 3 overcapture flag
  *            @arg TIM_FLAG_CC4OF: Capture/Compare 4 overcapture flag
  *            @arg TIM_FLAG_IDX: Index interrupt flag
  *            @arg TIM_FLAG_DIR: Direction change interrupt flag
  *            @arg TIM_FLAG_IERR: Index error interrupt flag
  *            @arg TIM_FLAG_TERR: Transition error interrupt flag
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  */
#define __HAL_TIM_CLEAR_FLAG(__HANDLE__,__FLAG__) ((__HANDLE__)->Instance->SR = ~(__FLAG__))

/**
  * @brief  Check whether the specified TIM interrupt source is enabled or not.
  * @param  __HANDLE__ TIM handle
  * @param  __INTERRUPT__ specifies the TIM interrupt source to check.
  *          This parameter can be one of the following values:
  *            @arg TIM_IT_UPDATE: Update interrupt
  *            @arg TIM_IT_CC1:   Capture/Compare 1 interrupt
  *            @arg TIM_IT_CC2:  Capture/Compare 2 interrupt
  *            @arg TIM_IT_CC3:  Capture/Compare 3 interrupt
  *            @arg TIM_IT_CC4:  Capture/Compare 4 interrupt
  *            @arg TIM_IT_COM:   Commutation interrupt
  *            @arg TIM_IT_TRIGGER: Trigger interrupt
  *            @arg TIM_IT_BREAK: Break interrupt
  *            @arg TIM_IT_IDX: Index interrupt
  *            @arg TIM_IT_DIR: Direction change interrupt
  *            @arg TIM_IT_IERR: Index error interrupt
  *            @arg TIM_IT_TERR: Transition error interrupt
  * @retval The state of TIM_IT (SET or RESET).
  */
#define __HAL_TIM_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__) ((((__HANDLE__)->Instance->DIER & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)


/** @brief Clear the TIM interrupt pending bits.
  * @param  __HANDLE__ TIM handle
  * @param  __INTERRUPT__ specifies the interrupt pending bit to clear.
  *          This parameter can be one of the following values:
  *            @arg TIM_IT_UPDATE: Update interrupt
  *            @arg TIM_IT_CC1:   Capture/Compare 1 interrupt
  *            @arg TIM_IT_CC2:  Capture/Compare 2 interrupt
  *            @arg TIM_IT_CC3:  Capture/Compare 3 interrupt
  *            @arg TIM_IT_CC4:  Capture/Compare 4 interrupt
  *            @arg TIM_IT_COM:   Commutation interrupt
  *            @arg TIM_IT_TRIGGER: Trigger interrupt
  *            @arg TIM_IT_BREAK: Break interrupt
  *            @arg TIM_IT_IDX: Index interrupt
  *            @arg TIM_IT_DIR: Direction change interrupt
  *            @arg TIM_IT_IERR: Index error interrupt
  *            @arg TIM_IT_TERR: Transition error interrupt
  * @retval None
  */
#define __HAL_TIM_CLEAR_IT(__HANDLE__,__INTERRUPT__) ((__HANDLE__)->Instance->SR = ~(__INTERRUPT__))

/**
  * @brief  Force a continuous copy of the update interrupt flag (UIF) into the timer counter register (bit 31).
  * @note This allows both the counter value and a potential roll-over condition signalled by the UIFCPY flag to be read
  *       in an atomic way.
  * @param  __HANDLE__ TIM handle.
  * @retval None
mode.
  */
#define __HAL_TIM_UIFREMAP_ENABLE(__HANDLE__) (((__HANDLE__)->Instance->CR1 |= TIM_CR1_UIFREMAP))

/**
  * @brief  Disable update interrupt flag (UIF) remapping.
  * @param  __HANDLE__ TIM handle.
  * @retval None
mode.
  */
#define __HAL_TIM_UIFREMAP_DISABLE(__HANDLE__) (((__HANDLE__)->Instance->CR1 &= ~TIM_CR1_UIFREMAP))

/**
  * @brief  Get update interrupt flag (UIF) copy status.
  * @param  __COUNTER__ Counter value.
  * @retval The state of UIFCPY (TRUE or FALSE).
mode.
  */
#define __HAL_TIM_GET_UIFCPY(__COUNTER__) (((__COUNTER__) & (TIM_CNT_UIFCPY)) == (TIM_CNT_UIFCPY))

/**
  * @brief  Indicates whether or not the TIM Counter is used as downcounter.
  * @param  __HANDLE__ TIM handle.
  * @retval False (Counter used as upcounter) or True (Counter used as downcounter)
  * @note This macro is particularly useful to get the counting mode when the timer operates in Center-aligned mode
  *       or Encoder mode.
  */
#define __HAL_TIM_IS_TIM_COUNTING_DOWN(__HANDLE__) (((__HANDLE__)->Instance->CR1 &(TIM_CR1_DIR)) == (TIM_CR1_DIR))

/**
  * @brief  Set the TIM Prescaler on runtime.
  * @param  __HANDLE__ TIM handle.
  * @param  __PRESC__ specifies the Prescaler new value.
  * @retval None
  */
#define __HAL_TIM_SET_PRESCALER(__HANDLE__,__PRESC__) ((__HANDLE__)->Instance->PSC = (__PRESC__))

/**
  * @brief  Set the TIM Counter Register value on runtime.
  * Note Please check if the bit 31 of CNT register is used as UIF copy or not, this may affect the counter range in
  *      case of 32 bits counter TIM instance.
  *      Bit 31 of CNT can be enabled/disabled using __HAL_TIM_UIFREMAP_ENABLE()/__HAL_TIM_UIFREMAP_DISABLE() macros.
  * @param  __HANDLE__ TIM handle.
  * @param  __COUNTER__ specifies the Counter register new value.
  * @retval None
  */
#define __HAL_TIM_SET_COUNTER(__HANDLE__,__COUNTER__) ((__HANDLE__)->Instance->CNT = (__COUNTER__))

/**
  * @brief  Get the TIM Counter Register value on runtime.
  * @param  __HANDLE__ TIM handle.
  * @retval 16-bit or 32-bit value of the timer counter register (TIMx_CNT)
  */
#define __HAL_TIM_GET_COUNTER(__HANDLE__) ((__HANDLE__)->Instance->CNT)

/**
  * @brief  Set the TIM Autoreload Register value on runtime without calling another time any Init function.
  * @param  __HANDLE__ TIM handle.
  * @param  __AUTORELOAD__ specifies the Counter register new value.
  * @retval None
  */
#define __HAL_TIM_SET_AUTORELOAD(__HANDLE__,__AUTORELOAD__) do{ (__HANDLE__)->Instance->ARR = (__AUTORELOAD__); (__HANDLE__)->Init.Period = (__AUTORELOAD__); } while(0)





/**
  * @brief  Get the TIM Autoreload Register value on runtime.
  * @param  __HANDLE__ TIM handle.
  * @retval 16-bit or 32-bit value of the timer auto-reload register(TIMx_ARR)
  */
#define __HAL_TIM_GET_AUTORELOAD(__HANDLE__) ((__HANDLE__)->Instance->ARR)

/**
  * @brief  Set the TIM Clock Division value on runtime without calling another time any Init function.
  * @param  __HANDLE__ TIM handle.
  * @param  __CKD__ specifies the clock division value.
  *          This parameter can be one of the following value:
  *            @arg TIM_CLOCKDIVISION_DIV1: tDTS=tCK_INT
  *            @arg TIM_CLOCKDIVISION_DIV2: tDTS=2*tCK_INT
  *            @arg TIM_CLOCKDIVISION_DIV4: tDTS=4*tCK_INT
  * @retval None
  */
#define __HAL_TIM_SET_CLOCKDIVISION(__HANDLE__,__CKD__) do{ (__HANDLE__)->Instance->CR1 &= (~TIM_CR1_CKD); (__HANDLE__)->Instance->CR1 |= (__CKD__); (__HANDLE__)->Init.ClockDivision = (__CKD__); } while(0)






/**
  * @brief  Get the TIM Clock Division value on runtime.
  * @param  __HANDLE__ TIM handle.
  * @retval The clock division can be one of the following values:
  *            @arg TIM_CLOCKDIVISION_DIV1: tDTS=tCK_INT
  *            @arg TIM_CLOCKDIVISION_DIV2: tDTS=2*tCK_INT
  *            @arg TIM_CLOCKDIVISION_DIV4: tDTS=4*tCK_INT
  */
#define __HAL_TIM_GET_CLOCKDIVISION(__HANDLE__) ((__HANDLE__)->Instance->CR1 & TIM_CR1_CKD)

/**
  * @brief  Set the TIM Input Capture prescaler on runtime without calling another time HAL_TIM_IC_ConfigChannel()
  *         function.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @param  __ICPSC__ specifies the Input Capture4 prescaler new value.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICPSC_DIV1: no prescaler
  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
#define __HAL_TIM_SET_ICPRESCALER(__HANDLE__,__CHANNEL__,__ICPSC__) do{ TIM_RESET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__)); TIM_SET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__), (__ICPSC__)); } while(0)





/**
  * @brief  Get the TIM Input Capture prescaler on runtime.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: get input capture 1 prescaler value
  *            @arg TIM_CHANNEL_2: get input capture 2 prescaler value
  *            @arg TIM_CHANNEL_3: get input capture 3 prescaler value
  *            @arg TIM_CHANNEL_4: get input capture 4 prescaler value
  * @retval The input capture prescaler can be one of the following values:
  *            @arg TIM_ICPSC_DIV1: no prescaler
  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  */
#define __HAL_TIM_GET_ICPRESCALER(__HANDLE__,__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 & TIM_CCMR1_IC1PSC) : ((__CHANNEL__) == TIM_CHANNEL_2) ? (((__HANDLE__)->Instance->CCMR1 & TIM_CCMR1_IC2PSC) >> 8U) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 & TIM_CCMR2_IC3PSC) : (((__HANDLE__)->Instance->CCMR2 & TIM_CCMR2_IC4PSC)) >> 8U)





/**
  * @brief  Set the TIM Capture Compare Register value on runtime without calling another time ConfigChannel function.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @param  __COMPARE__ specifies the Capture Compare register new value.
  * @retval None
  */
#define __HAL_TIM_SET_COMPARE(__HANDLE__,__CHANNEL__,__COMPARE__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1 = (__COMPARE__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2 = (__COMPARE__)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3 = (__COMPARE__)) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCR4 = (__COMPARE__)) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCR5 = (__COMPARE__)) : ((__HANDLE__)->Instance->CCR6 = (__COMPARE__)))







/**
  * @brief  Get the TIM Capture Compare Register value on runtime.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channel associated with the capture compare register
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: get capture/compare 1 register value
  *            @arg TIM_CHANNEL_2: get capture/compare 2 register value
  *            @arg TIM_CHANNEL_3: get capture/compare 3 register value
  *            @arg TIM_CHANNEL_4: get capture/compare 4 register value
  *            @arg TIM_CHANNEL_5: get capture/compare 5 register value
  *            @arg TIM_CHANNEL_6: get capture/compare 6 register value
  * @retval 16-bit or 32-bit value of the capture/compare register (TIMx_CCRy)
  */
#define __HAL_TIM_GET_COMPARE(__HANDLE__,__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCR4) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCR5) : ((__HANDLE__)->Instance->CCR6))







/**
  * @brief  Set the TIM Output compare preload.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval None
  */
#define __HAL_TIM_ENABLE_OCxPRELOAD(__HANDLE__,__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 |= TIM_CCMR1_OC1PE) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 |= TIM_CCMR1_OC2PE) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 |= TIM_CCMR2_OC3PE) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCMR2 |= TIM_CCMR2_OC4PE) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCMR3 |= TIM_CCMR3_OC5PE) : ((__HANDLE__)->Instance->CCMR3 |= TIM_CCMR3_OC6PE))







/**
  * @brief  Reset the TIM Output compare preload.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval None
  */
#define __HAL_TIM_DISABLE_OCxPRELOAD(__HANDLE__,__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 &= ~TIM_CCMR1_OC1PE) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 &= ~TIM_CCMR1_OC2PE) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 &= ~TIM_CCMR2_OC3PE) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCMR2 &= ~TIM_CCMR2_OC4PE) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCMR3 &= ~TIM_CCMR3_OC5PE) : ((__HANDLE__)->Instance->CCMR3 &= ~TIM_CCMR3_OC6PE))







/**
  * @brief  Enable fast mode for a given channel.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @note  When fast mode is enabled an active edge on the trigger input acts
  *        like a compare match on CCx output. Delay to sample the trigger
  *        input and to activate CCx output is reduced to 3 clock cycles.
  * @note  Fast mode acts only if the channel is configured in PWM1 or PWM2 mode.
  * @retval None
  */
#define __HAL_TIM_ENABLE_OCxFAST(__HANDLE__,__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 |= TIM_CCMR1_OC1FE) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 |= TIM_CCMR1_OC2FE) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 |= TIM_CCMR2_OC3FE) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCMR2 |= TIM_CCMR2_OC4FE) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCMR3 |= TIM_CCMR3_OC5FE) : ((__HANDLE__)->Instance->CCMR3 |= TIM_CCMR3_OC6FE))







/**
  * @brief  Disable fast mode for a given channel.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @note  When fast mode is disabled CCx output behaves normally depending
  *        on counter and CCRx values even when the trigger is ON. The minimum
  *        delay to activate CCx output when an active edge occurs on the
  *        trigger input is 5 clock cycles.
  * @retval None
  */
#define __HAL_TIM_DISABLE_OCxFAST(__HANDLE__,__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE) : ((__HANDLE__)->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE))







/**
  * @brief  Set the Update Request Source (URS) bit of the TIMx_CR1 register.
  * @param  __HANDLE__ TIM handle.
  * @note  When the URS bit of the TIMx_CR1 register is set, only counter
  *        overflow/underflow generates an update interrupt or DMA request (if
  *        enabled)
  * @retval None
  */
#define __HAL_TIM_URS_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR1|= TIM_CR1_URS)

/**
  * @brief  Reset the Update Request Source (URS) bit of the TIMx_CR1 register.
  * @param  __HANDLE__ TIM handle.
  * @note  When the URS bit of the TIMx_CR1 register is reset, any of the
  *        following events generate an update interrupt or DMA request (if
  *        enabled):
  *           _ Counter overflow underflow
  *           _ Setting the UG bit
  *           _ Update generation through the slave mode controller
  * @retval None
  */
#define __HAL_TIM_URS_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR1&=~TIM_CR1_URS)

/**
  * @brief  Set the TIM Capture x input polarity on runtime.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @param  __POLARITY__ Polarity for TIx source
  *            @arg TIM_INPUTCHANNELPOLARITY_RISING: Rising Edge
  *            @arg TIM_INPUTCHANNELPOLARITY_FALLING: Falling Edge
  *            @arg TIM_INPUTCHANNELPOLARITY_BOTHEDGE: Rising and Falling Edge
  * @retval None
  */
#define __HAL_TIM_SET_CAPTUREPOLARITY(__HANDLE__,__CHANNEL__,__POLARITY__) do{ TIM_RESET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__)); TIM_SET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__), (__POLARITY__)); }while(0)





/** @brief  Select the Capture/compare DMA request source.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __CCDMA__ specifies Capture/compare DMA request source
  *          This parameter can be one of the following values:
  *            @arg TIM_CCDMAREQUEST_CC: CCx DMA request generated on Capture/Compare event
  *            @arg TIM_CCDMAREQUEST_UPDATE: CCx DMA request generated on Update event
  * @retval None
  */
#define __HAL_TIM_SELECT_CCDMAREQUEST(__HANDLE__,__CCDMA__) MODIFY_REG((__HANDLE__)->Instance->CR2, TIM_CR2_CCDS, (__CCDMA__))


/**
  * @}
  */
/* End of exported macros ----------------------------------------------------*/

/* Private constants ---------------------------------------------------------*/
/** @defgroup TIM_Private_Constants TIM Private Constants
  * @{
  */
/* The counter of a timer instance is disabled only if all the CCx and CCxN
   channels have been disabled */
#define TIM_CCER_CCxE_MASK ((uint32_t)(TIM_CCER_CC1E | TIM_CCER_CC2E | TIM_CCER_CC3E | TIM_CCER_CC4E))
#define TIM_CCER_CCxNE_MASK ((uint32_t)(TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE | TIM_CCER_CC4NE))
/**
  * @}
  */
/* End of private constants --------------------------------------------------*/

/* Private macros ------------------------------------------------------------*/
/** @defgroup TIM_Private_Macros TIM Private Macros
  * @{
  */

#define IS_TIM_CLEARINPUT_SOURCE(__MODE__) (((__MODE__) == TIM_CLEARINPUTSOURCE_ETR) || ((__MODE__) == TIM_CLEARINPUTSOURCE_COMP1) || ((__MODE__) == TIM_CLEARINPUTSOURCE_COMP2) || ((__MODE__) == TIM_CLEARINPUTSOURCE_COMP3) || ((__MODE__) == TIM_CLEARINPUTSOURCE_COMP4) || ((__MODE__) == TIM_CLEARINPUTSOURCE_COMP5) || ((__MODE__) == TIM_CLEARINPUTSOURCE_COMP6) || ((__MODE__) == TIM_CLEARINPUTSOURCE_COMP7) || ((__MODE__) == TIM_CLEARINPUTSOURCE_NONE))
# 1879 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"
# 1887 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"

#define IS_TIM_DMA_BASE(__BASE__) (((__BASE__) == TIM_DMABASE_CR1) || ((__BASE__) == TIM_DMABASE_CR2) || ((__BASE__) == TIM_DMABASE_SMCR) || ((__BASE__) == TIM_DMABASE_DIER) || ((__BASE__) == TIM_DMABASE_SR) || ((__BASE__) == TIM_DMABASE_EGR) || ((__BASE__) == TIM_DMABASE_CCMR1) || ((__BASE__) == TIM_DMABASE_CCMR2) || ((__BASE__) == TIM_DMABASE_CCER) || ((__BASE__) == TIM_DMABASE_CNT) || ((__BASE__) == TIM_DMABASE_PSC) || ((__BASE__) == TIM_DMABASE_ARR) || ((__BASE__) == TIM_DMABASE_RCR) || ((__BASE__) == TIM_DMABASE_CCR1) || ((__BASE__) == TIM_DMABASE_CCR2) || ((__BASE__) == TIM_DMABASE_CCR3) || ((__BASE__) == TIM_DMABASE_CCR4) || ((__BASE__) == TIM_DMABASE_BDTR) || ((__BASE__) == TIM_DMABASE_CCMR3) || ((__BASE__) == TIM_DMABASE_CCR5) || ((__BASE__) == TIM_DMABASE_CCR6) || ((__BASE__) == TIM_DMABASE_AF1) || ((__BASE__) == TIM_DMABASE_AF2) || ((__BASE__) == TIM_DMABASE_TISEL) || ((__BASE__) == TIM_DMABASE_DTR2) || ((__BASE__) == TIM_DMABASE_ECR) || ((__BASE__) == TIM_DMABASE_OR))
# 1915 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"

#define IS_TIM_EVENT_SOURCE(__SOURCE__) ((((__SOURCE__) & 0xFFFFFE00U) == 0x00000000U) && ((__SOURCE__) != 0x00000000U))

#define IS_TIM_COUNTER_MODE(__MODE__) (((__MODE__) == TIM_COUNTERMODE_UP) || ((__MODE__) == TIM_COUNTERMODE_DOWN) || ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED1) || ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED2) || ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED3))





#define IS_TIM_UIFREMAP_MODE(__MODE__) (((__MODE__) == TIM_UIFREMAP_DISABLE) || ((__MODE__) == TIM_UIFREMAP_ENABLE))


#define IS_TIM_CLOCKDIVISION_DIV(__DIV__) (((__DIV__) == TIM_CLOCKDIVISION_DIV1) || ((__DIV__) == TIM_CLOCKDIVISION_DIV2) || ((__DIV__) == TIM_CLOCKDIVISION_DIV4))



#define IS_TIM_AUTORELOAD_PRELOAD(PRELOAD) (((PRELOAD) == TIM_AUTORELOAD_PRELOAD_DISABLE) || ((PRELOAD) == TIM_AUTORELOAD_PRELOAD_ENABLE))


#define IS_TIM_FAST_STATE(__STATE__) (((__STATE__) == TIM_OCFAST_DISABLE) || ((__STATE__) == TIM_OCFAST_ENABLE))


#define IS_TIM_OC_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_OCPOLARITY_HIGH) || ((__POLARITY__) == TIM_OCPOLARITY_LOW))


#define IS_TIM_OCN_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_OCNPOLARITY_HIGH) || ((__POLARITY__) == TIM_OCNPOLARITY_LOW))


#define IS_TIM_OCIDLE_STATE(__STATE__) (((__STATE__) == TIM_OCIDLESTATE_SET) || ((__STATE__) == TIM_OCIDLESTATE_RESET))


#define IS_TIM_OCNIDLE_STATE(__STATE__) (((__STATE__) == TIM_OCNIDLESTATE_SET) || ((__STATE__) == TIM_OCNIDLESTATE_RESET))


#define IS_TIM_ENCODERINPUT_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_ENCODERINPUTPOLARITY_RISING) || ((__POLARITY__) == TIM_ENCODERINPUTPOLARITY_FALLING))


#define IS_TIM_IC_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_ICPOLARITY_RISING) || ((__POLARITY__) == TIM_ICPOLARITY_FALLING) || ((__POLARITY__) == TIM_ICPOLARITY_BOTHEDGE))



#define IS_TIM_IC_SELECTION(__SELECTION__) (((__SELECTION__) == TIM_ICSELECTION_DIRECTTI) || ((__SELECTION__) == TIM_ICSELECTION_INDIRECTTI) || ((__SELECTION__) == TIM_ICSELECTION_TRC))



#define IS_TIM_IC_PRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_ICPSC_DIV1) || ((__PRESCALER__) == TIM_ICPSC_DIV2) || ((__PRESCALER__) == TIM_ICPSC_DIV4) || ((__PRESCALER__) == TIM_ICPSC_DIV8))




#define IS_TIM_CCX_CHANNEL(__INSTANCE__,__CHANNEL__) (IS_TIM_CCX_INSTANCE(__INSTANCE__, __CHANNEL__) && ((__CHANNEL__) != (TIM_CHANNEL_5)) && ((__CHANNEL__) != (TIM_CHANNEL_6)))



#define IS_TIM_OPM_MODE(__MODE__) (((__MODE__) == TIM_OPMODE_SINGLE) || ((__MODE__) == TIM_OPMODE_REPETITIVE))


#define IS_TIM_ENCODER_MODE(__MODE__) (((__MODE__) == TIM_ENCODERMODE_TI1) || ((__MODE__) == TIM_ENCODERMODE_TI2) || ((__MODE__) == TIM_ENCODERMODE_TI12) || ((__MODE__) == TIM_ENCODERMODE_CLOCKPLUSDIRECTION_X2) || ((__MODE__) == TIM_ENCODERMODE_CLOCKPLUSDIRECTION_X1) || ((__MODE__) == TIM_ENCODERMODE_DIRECTIONALCLOCK_X2) || ((__MODE__) == TIM_ENCODERMODE_DIRECTIONALCLOCK_X1_TI12) || ((__MODE__) == TIM_ENCODERMODE_X1_TI1) || ((__MODE__) == TIM_ENCODERMODE_X1_TI2))
# 1981 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"

#define IS_TIM_DMA_SOURCE(__SOURCE__) ((((__SOURCE__) & 0xFFFF80FFU) == 0x00000000U) && ((__SOURCE__) != 0x00000000U))

#define IS_TIM_CHANNELS(__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) || ((__CHANNEL__) == TIM_CHANNEL_2) || ((__CHANNEL__) == TIM_CHANNEL_3) || ((__CHANNEL__) == TIM_CHANNEL_4) || ((__CHANNEL__) == TIM_CHANNEL_5) || ((__CHANNEL__) == TIM_CHANNEL_6) || ((__CHANNEL__) == TIM_CHANNEL_ALL))







#define IS_TIM_OPM_CHANNELS(__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) || ((__CHANNEL__) == TIM_CHANNEL_2))


#define IS_TIM_PERIOD(__HANDLE__,__PERIOD__) ((IS_TIM_32B_COUNTER_INSTANCE(((__HANDLE__)->Instance)) == 0U) ? ((READ_BIT((__HANDLE__)->Instance->CR1, TIM_CR1_DITHEN) == 0U) ? (((__PERIOD__) > 0U) && ((__PERIOD__) <= 0x0000FFFFU)) : (((__PERIOD__) > 0U) && ((__PERIOD__) <= 0x000FFFEFU))) : ((__PERIOD__) > 0U ))





#define IS_TIM_COMPLEMENTARY_CHANNELS(__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) || ((__CHANNEL__) == TIM_CHANNEL_2) || ((__CHANNEL__) == TIM_CHANNEL_3) || ((__CHANNEL__) == TIM_CHANNEL_4))





#define IS_TIM_CLOCKSOURCE(__CLOCK__) (((__CLOCK__) == TIM_CLOCKSOURCE_INTERNAL) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE2) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1ED) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR0) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR3) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR4) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR5) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR6) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR7) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR8) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR9) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR10) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR11))
# 2025 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"
# 2076 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"

#define IS_TIM_CLOCKPOLARITY(__POLARITY__) (((__POLARITY__) == TIM_CLOCKPOLARITY_INVERTED) || ((__POLARITY__) == TIM_CLOCKPOLARITY_NONINVERTED) || ((__POLARITY__) == TIM_CLOCKPOLARITY_RISING) || ((__POLARITY__) == TIM_CLOCKPOLARITY_FALLING) || ((__POLARITY__) == TIM_CLOCKPOLARITY_BOTHEDGE))





#define IS_TIM_CLOCKPRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV1) || ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV2) || ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV4) || ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV8))




#define IS_TIM_CLOCKFILTER(__ICFILTER__) ((__ICFILTER__) <= 0xFU)

#define IS_TIM_CLEARINPUT_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_CLEARINPUTPOLARITY_INVERTED) || ((__POLARITY__) == TIM_CLEARINPUTPOLARITY_NONINVERTED))


#define IS_TIM_CLEARINPUT_PRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV1) || ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV2) || ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV4) || ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV8))




#define IS_TIM_CLEARINPUT_FILTER(__ICFILTER__) ((__ICFILTER__) <= 0xFU)

#define IS_TIM_OSSR_STATE(__STATE__) (((__STATE__) == TIM_OSSR_ENABLE) || ((__STATE__) == TIM_OSSR_DISABLE))


#define IS_TIM_OSSI_STATE(__STATE__) (((__STATE__) == TIM_OSSI_ENABLE) || ((__STATE__) == TIM_OSSI_DISABLE))


#define IS_TIM_LOCK_LEVEL(__LEVEL__) (((__LEVEL__) == TIM_LOCKLEVEL_OFF) || ((__LEVEL__) == TIM_LOCKLEVEL_1) || ((__LEVEL__) == TIM_LOCKLEVEL_2) || ((__LEVEL__) == TIM_LOCKLEVEL_3))




#define IS_TIM_BREAK_FILTER(__BRKFILTER__) ((__BRKFILTER__) <= 0xFUL)

#define IS_TIM_BREAK_STATE(__STATE__) (((__STATE__) == TIM_BREAK_ENABLE) || ((__STATE__) == TIM_BREAK_DISABLE))


#define IS_TIM_BREAK_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_BREAKPOLARITY_LOW) || ((__POLARITY__) == TIM_BREAKPOLARITY_HIGH))


#define IS_TIM_BREAK_AFMODE(__AFMODE__) (((__AFMODE__) == TIM_BREAK_AFMODE_INPUT) || ((__AFMODE__) == TIM_BREAK_AFMODE_BIDIRECTIONAL))



#define IS_TIM_BREAK2_STATE(__STATE__) (((__STATE__) == TIM_BREAK2_ENABLE) || ((__STATE__) == TIM_BREAK2_DISABLE))


#define IS_TIM_BREAK2_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_BREAK2POLARITY_LOW) || ((__POLARITY__) == TIM_BREAK2POLARITY_HIGH))


#define IS_TIM_BREAK2_AFMODE(__AFMODE__) (((__AFMODE__) == TIM_BREAK2_AFMODE_INPUT) || ((__AFMODE__) == TIM_BREAK2_AFMODE_BIDIRECTIONAL))



#define IS_TIM_AUTOMATIC_OUTPUT_STATE(__STATE__) (((__STATE__) == TIM_AUTOMATICOUTPUT_ENABLE) || ((__STATE__) == TIM_AUTOMATICOUTPUT_DISABLE))


#define IS_TIM_GROUPCH5(__OCREF__) ((((__OCREF__) & 0x1FFFFFFFU) == 0x00000000U))

#define IS_TIM_TRGO_SOURCE(__SOURCE__) (((__SOURCE__) == TIM_TRGO_RESET) || ((__SOURCE__) == TIM_TRGO_ENABLE) || ((__SOURCE__) == TIM_TRGO_UPDATE) || ((__SOURCE__) == TIM_TRGO_OC1) || ((__SOURCE__) == TIM_TRGO_OC1REF) || ((__SOURCE__) == TIM_TRGO_OC2REF) || ((__SOURCE__) == TIM_TRGO_OC3REF) || ((__SOURCE__) == TIM_TRGO_OC4REF) || ((__SOURCE__) == TIM_TRGO_ENCODER_CLK))
# 2147 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"

#define IS_TIM_TRGO2_SOURCE(__SOURCE__) (((__SOURCE__) == TIM_TRGO2_RESET) || ((__SOURCE__) == TIM_TRGO2_ENABLE) || ((__SOURCE__) == TIM_TRGO2_UPDATE) || ((__SOURCE__) == TIM_TRGO2_OC1) || ((__SOURCE__) == TIM_TRGO2_OC1REF) || ((__SOURCE__) == TIM_TRGO2_OC2REF) || ((__SOURCE__) == TIM_TRGO2_OC3REF) || ((__SOURCE__) == TIM_TRGO2_OC3REF) || ((__SOURCE__) == TIM_TRGO2_OC4REF) || ((__SOURCE__) == TIM_TRGO2_OC5REF) || ((__SOURCE__) == TIM_TRGO2_OC6REF) || ((__SOURCE__) == TIM_TRGO2_OC4REF_RISINGFALLING) || ((__SOURCE__) == TIM_TRGO2_OC6REF_RISINGFALLING) || ((__SOURCE__) == TIM_TRGO2_OC4REF_RISING_OC6REF_RISING) || ((__SOURCE__) == TIM_TRGO2_OC4REF_RISING_OC6REF_FALLING) || ((__SOURCE__) == TIM_TRGO2_OC5REF_RISING_OC6REF_RISING) || ((__SOURCE__) == TIM_TRGO2_OC5REF_RISING_OC6REF_FALLING))
# 2165 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"

#define IS_TIM_MSM_STATE(__STATE__) (((__STATE__) == TIM_MASTERSLAVEMODE_ENABLE) || ((__STATE__) == TIM_MASTERSLAVEMODE_DISABLE))


#define IS_TIM_SLAVE_MODE(__MODE__) (((__MODE__) == TIM_SLAVEMODE_DISABLE) || ((__MODE__) == TIM_SLAVEMODE_RESET) || ((__MODE__) == TIM_SLAVEMODE_GATED) || ((__MODE__) == TIM_SLAVEMODE_TRIGGER) || ((__MODE__) == TIM_SLAVEMODE_EXTERNAL1) || ((__MODE__) == TIM_SLAVEMODE_COMBINED_RESETTRIGGER) || ((__MODE__) == TIM_SLAVEMODE_COMBINED_GATEDRESET))







#define IS_TIM_PWM_MODE(__MODE__) (((__MODE__) == TIM_OCMODE_PWM1) || ((__MODE__) == TIM_OCMODE_PWM2) || ((__MODE__) == TIM_OCMODE_COMBINED_PWM1) || ((__MODE__) == TIM_OCMODE_COMBINED_PWM2) || ((__MODE__) == TIM_OCMODE_ASYMMETRIC_PWM1) || ((__MODE__) == TIM_OCMODE_ASYMMETRIC_PWM2))






#define IS_TIM_OC_MODE(__MODE__) (((__MODE__) == TIM_OCMODE_TIMING) || ((__MODE__) == TIM_OCMODE_ACTIVE) || ((__MODE__) == TIM_OCMODE_INACTIVE) || ((__MODE__) == TIM_OCMODE_TOGGLE) || ((__MODE__) == TIM_OCMODE_FORCED_ACTIVE) || ((__MODE__) == TIM_OCMODE_FORCED_INACTIVE) || ((__MODE__) == TIM_OCMODE_RETRIGERRABLE_OPM1) || ((__MODE__) == TIM_OCMODE_RETRIGERRABLE_OPM2) || ((__MODE__) == TIM_OCMODE_DIRECTION_OUTPUT) || ((__MODE__) == TIM_OCMODE_PULSE_ON_COMPARE))
# 2194 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"

#define IS_TIM_TRIGGERPOLARITY(__POLARITY__) (((__POLARITY__) == TIM_TRIGGERPOLARITY_INVERTED ) || ((__POLARITY__) == TIM_TRIGGERPOLARITY_NONINVERTED) || ((__POLARITY__) == TIM_TRIGGERPOLARITY_RISING ) || ((__POLARITY__) == TIM_TRIGGERPOLARITY_FALLING ) || ((__POLARITY__) == TIM_TRIGGERPOLARITY_BOTHEDGE ))





#define IS_TIM_TRIGGERPRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV1) || ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV2) || ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV4) || ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV8))




#define IS_TIM_TRIGGERFILTER(__ICFILTER__) ((__ICFILTER__) <= 0xFU)

#define IS_TIM_TI1SELECTION(__TI1SELECTION__) (((__TI1SELECTION__) == TIM_TI1SELECTION_CH1) || ((__TI1SELECTION__) == TIM_TI1SELECTION_XORCOMBINATION))


#define IS_TIM_DMA_LENGTH(__LENGTH__) (((__LENGTH__) == TIM_DMABURSTLENGTH_1TRANSFER) || ((__LENGTH__) == TIM_DMABURSTLENGTH_2TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_3TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_4TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_5TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_6TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_7TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_8TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_9TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_10TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_11TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_12TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_13TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_14TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_15TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_16TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_17TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_18TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_19TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_20TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_21TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_22TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_23TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_24TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_25TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_26TRANSFERS))
# 2237 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"

#define IS_TIM_DMA_DATA_LENGTH(LENGTH) (((LENGTH) >= 0x1U) && ((LENGTH) < 0x10000U))

#define IS_TIM_IC_FILTER(__ICFILTER__) ((__ICFILTER__) <= 0xFU)

#define IS_TIM_DEADTIME(__DEADTIME__) ((__DEADTIME__) <= 0xFFU)

#define IS_TIM_BREAK_SYSTEM(__CONFIG__) (((__CONFIG__) == TIM_BREAK_SYSTEM_ECC) || ((__CONFIG__) == TIM_BREAK_SYSTEM_PVD) || ((__CONFIG__) == TIM_BREAK_SYSTEM_SRAM_PARITY_ERROR) || ((__CONFIG__) == TIM_BREAK_SYSTEM_LOCKUP))




#define IS_TIM_SLAVEMODE_TRIGGER_ENABLED(__TRIGGER__) (((__TRIGGER__) == TIM_SLAVEMODE_TRIGGER) || ((__TRIGGER__) == TIM_SLAVEMODE_COMBINED_RESETTRIGGER))


#define TIM_SET_ICPRESCALERVALUE(__HANDLE__,__CHANNEL__,__ICPSC__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 |= (__ICPSC__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 |= ((__ICPSC__) << 8U)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 |= (__ICPSC__)) : ((__HANDLE__)->Instance->CCMR2 |= ((__ICPSC__) << 8U)))





#define TIM_RESET_ICPRESCALERVALUE(__HANDLE__,__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC) : ((__HANDLE__)->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC))





#define TIM_SET_CAPTUREPOLARITY(__HANDLE__,__CHANNEL__,__POLARITY__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCER |= (__POLARITY__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCER |= ((__POLARITY__) << 4U)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCER |= ((__POLARITY__) << 8U)) : ((__HANDLE__)->Instance->CCER |= (((__POLARITY__) << 12U))))





#define TIM_RESET_CAPTUREPOLARITY(__HANDLE__,__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCER &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCER &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCER &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP)) : ((__HANDLE__)->Instance->CCER &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP)))





#define TIM_CHANNEL_STATE_GET(__HANDLE__,__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? (__HANDLE__)->ChannelState[0] : ((__CHANNEL__) == TIM_CHANNEL_2) ? (__HANDLE__)->ChannelState[1] : ((__CHANNEL__) == TIM_CHANNEL_3) ? (__HANDLE__)->ChannelState[2] : ((__CHANNEL__) == TIM_CHANNEL_4) ? (__HANDLE__)->ChannelState[3] : ((__CHANNEL__) == TIM_CHANNEL_5) ? (__HANDLE__)->ChannelState[4] : (__HANDLE__)->ChannelState[5])







#define TIM_CHANNEL_STATE_SET(__HANDLE__,__CHANNEL__,__CHANNEL_STATE__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->ChannelState[0] = (__CHANNEL_STATE__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->ChannelState[1] = (__CHANNEL_STATE__)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->ChannelState[2] = (__CHANNEL_STATE__)) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->ChannelState[3] = (__CHANNEL_STATE__)) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->ChannelState[4] = (__CHANNEL_STATE__)) : ((__HANDLE__)->ChannelState[5] = (__CHANNEL_STATE__)))







#define TIM_CHANNEL_STATE_SET_ALL(__HANDLE__,__CHANNEL_STATE__) do { (__HANDLE__)->ChannelState[0] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelState[1] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelState[2] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelState[3] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelState[4] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelState[5] = (__CHANNEL_STATE__); } while(0)
# 2306 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"

#define TIM_CHANNEL_N_STATE_GET(__HANDLE__,__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_1) ? (__HANDLE__)->ChannelNState[0] : ((__CHANNEL__) == TIM_CHANNEL_2) ? (__HANDLE__)->ChannelNState[1] : ((__CHANNEL__) == TIM_CHANNEL_3) ? (__HANDLE__)->ChannelNState[2] : (__HANDLE__)->ChannelNState[3])





#define TIM_CHANNEL_N_STATE_SET(__HANDLE__,__CHANNEL__,__CHANNEL_STATE__) (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->ChannelNState[0] = (__CHANNEL_STATE__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->ChannelNState[1] = (__CHANNEL_STATE__)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->ChannelNState[2] = (__CHANNEL_STATE__)) : ((__HANDLE__)->ChannelNState[3] = (__CHANNEL_STATE__)))





#define TIM_CHANNEL_N_STATE_SET_ALL(__HANDLE__,__CHANNEL_STATE__) do { (__HANDLE__)->ChannelNState[0] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelNState[1] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelNState[2] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelNState[3] = (__CHANNEL_STATE__); } while(0)
# 2329 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h"

/**
  * @}
  */
/* End of private macros -----------------------------------------------------*/

/* Include TIM HAL Extended module */
# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim_ex.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_tim_ex.h
  * @author  MCD Application Team
  * @brief   Header file of TIM HAL Extended module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_TIM_EX_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup TIMEx
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/** @defgroup TIMEx_Exported_Types TIM Extended Exported Types
  * @{
  */

/**
  * @brief  TIM Hall sensor Configuration Structure definition
  */

typedef struct
{
  uint32_t IC1Polarity;         /*!< Specifies the active edge of the input signal.
                                     This parameter can be a value of @ref TIM_Input_Capture_Polarity */

  uint32_t IC1Prescaler;        /*!< Specifies the Input Capture Prescaler.
                                     This parameter can be a value of @ref TIM_Input_Capture_Prescaler */

  uint32_t IC1Filter;           /*!< Specifies the input capture filter.
                                     This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */

  uint32_t Commutation_Delay;   /*!< Specifies the pulse value to be loaded into the Capture Compare Register.
                                     This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF */
} TIM_HallSensor_InitTypeDef;

/**
  * @brief  TIM Break/Break2 input configuration
  */
typedef struct
{
  uint32_t Source;         /*!< Specifies the source of the timer break input.
                                This parameter can be a value of @ref TIMEx_Break_Input_Source */
  uint32_t Enable;         /*!< Specifies whether or not the break input source is enabled.
                                This parameter can be a value of @ref TIMEx_Break_Input_Source_Enable */
  uint32_t Polarity;       /*!< Specifies the break input source polarity.
                                This parameter can be a value of @ref TIMEx_Break_Input_Source_Polarity */
} TIMEx_BreakInputConfigTypeDef;

/**
  * @brief  TIM Encoder index configuration
  */
typedef struct
{
  uint32_t Polarity;                  /*!< TIM Encoder index polarity.This parameter can be a value of @ref TIMEx_Encoder_Index_Polarity */

  uint32_t Prescaler;                 /*!< TIM Encoder index prescaler.This parameter can be a value of @ref TIMEx_Encoder_Index_Prescaler */

  uint32_t Filter;                    /*!< TIM Encoder index filter.This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF */

  FunctionalState  FirstIndexEnable;  /*!< Specifies whether or not the encoder first index is enabled.This parameter value can be ENABLE or DISABLE. */

  uint32_t Position;                  /*!< Specifies in which AB input configuration the index event resets the counter.This parameter can be a value of @ref TIMEx_Encoder_Index_Position */

  uint32_t Direction;                 /*!< Specifies in which counter direction the index event resets the counter.This parameter can be a value of @ref TIMEx_Encoder_Index_Direction */

} TIMEx_EncoderIndexConfigTypeDef;

/**
  * @}
  */
/* End of exported types -----------------------------------------------------*/

/* Exported constants --------------------------------------------------------*/
/** @defgroup TIMEx_Exported_Constants TIM Extended Exported Constants
  * @{
  */

/** @defgroup TIMEx_Remap TIM Extended Remapping
  * @{
  */
#define TIM_TIM1_ETR_GPIO 0x00000000U
#define TIM_TIM1_ETR_COMP1 TIM1_AF1_ETRSEL_0
#define TIM_TIM1_ETR_COMP2 TIM1_AF1_ETRSEL_1
#define TIM_TIM1_ETR_COMP3 (TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM1_ETR_COMP4 TIM1_AF1_ETRSEL_2

#define TIM_TIM1_ETR_COMP5 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_0)


#define TIM_TIM1_ETR_COMP6 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_1)


#define TIM_TIM1_ETR_COMP7 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)

#define TIM_TIM1_ETR_ADC1_AWD1 TIM1_AF1_ETRSEL_3
#define TIM_TIM1_ETR_ADC1_AWD2 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM1_ETR_ADC1_AWD3 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_1)

#define TIM_TIM1_ETR_ADC4_AWD1 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM1_ETR_ADC4_AWD2 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_2)
#define TIM_TIM1_ETR_ADC4_AWD3 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_0)


#define TIM_TIM2_ETR_GPIO 0x00000000U
#define TIM_TIM2_ETR_COMP1 TIM1_AF1_ETRSEL_0
#define TIM_TIM2_ETR_COMP2 TIM1_AF1_ETRSEL_1
#define TIM_TIM2_ETR_COMP3 (TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM2_ETR_COMP4 TIM1_AF1_ETRSEL_2

#define TIM_TIM2_ETR_COMP5 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_0)


#define TIM_TIM2_ETR_COMP6 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_1)


#define TIM_TIM2_ETR_COMP7 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)

#define TIM_TIM2_ETR_TIM3_ETR TIM1_AF1_ETRSEL_3
#define TIM_TIM2_ETR_TIM4_ETR (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_0)

#define TIM_TIM2_ETR_TIM5_ETR (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_1)

#define TIM_TIM2_ETR_LSE (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)

#define TIM_TIM3_ETR_GPIO 0x00000000U
#define TIM_TIM3_ETR_COMP1 TIM1_AF1_ETRSEL_0
#define TIM_TIM3_ETR_COMP2 TIM1_AF1_ETRSEL_1
#define TIM_TIM3_ETR_COMP3 (TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM3_ETR_COMP4 TIM1_AF1_ETRSEL_2

#define TIM_TIM3_ETR_COMP5 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_0)


#define TIM_TIM3_ETR_COMP6 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_1)


#define TIM_TIM3_ETR_COMP7 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)

#define TIM_TIM3_ETR_TIM2_ETR TIM1_AF1_ETRSEL_3
#define TIM_TIM3_ETR_TIM4_ETR (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM3_ETR_ADC2_AWD1 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM3_ETR_ADC2_AWD2 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_2)
#define TIM_TIM3_ETR_ADC2_AWD3 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_0)

#define TIM_TIM4_ETR_GPIO 0x00000000U
#define TIM_TIM4_ETR_COMP1 TIM1_AF1_ETRSEL_0
#define TIM_TIM4_ETR_COMP2 TIM1_AF1_ETRSEL_1
#define TIM_TIM4_ETR_COMP3 (TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM4_ETR_COMP4 TIM1_AF1_ETRSEL_2

#define TIM_TIM4_ETR_COMP5 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_0)


#define TIM_TIM4_ETR_COMP6 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_1)


#define TIM_TIM4_ETR_COMP7 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)

#define TIM_TIM4_ETR_TIM3_ETR TIM1_AF1_ETRSEL_3

#define TIM_TIM4_ETR_TIM5_ETR (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_0)



#define TIM_TIM5_ETR_GPIO 0x00000000U
#define TIM_TIM5_ETR_COMP1 TIM1_AF1_ETRSEL_0
#define TIM_TIM5_ETR_COMP2 TIM1_AF1_ETRSEL_1
#define TIM_TIM5_ETR_COMP3 (TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM5_ETR_COMP4 TIM1_AF1_ETRSEL_2

#define TIM_TIM5_ETR_COMP5 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_0)


#define TIM_TIM5_ETR_COMP6 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_1)


#define TIM_TIM5_ETR_COMP7 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)

#define TIM_TIM5_ETR_TIM2_ETR TIM1_AF1_ETRSEL_3
#define TIM_TIM5_ETR_TIM3_ETR (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_0)


#define TIM_TIM8_ETR_GPIO 0x00000000U
#define TIM_TIM8_ETR_COMP1 TIM1_AF1_ETRSEL_0
#define TIM_TIM8_ETR_COMP2 TIM1_AF1_ETRSEL_1
#define TIM_TIM8_ETR_COMP3 (TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM8_ETR_COMP4 TIM1_AF1_ETRSEL_2

#define TIM_TIM8_ETR_COMP5 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_0)


#define TIM_TIM8_ETR_COMP6 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_1)


#define TIM_TIM8_ETR_COMP7 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)

#define TIM_TIM8_ETR_ADC2_AWD1 TIM1_AF1_ETRSEL_3
#define TIM_TIM8_ETR_ADC2_AWD2 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM8_ETR_ADC2_AWD3 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_1)

#define TIM_TIM8_ETR_ADC3_AWD1 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM8_ETR_ADC3_AWD2 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_2)
#define TIM_TIM8_ETR_ADC3_AWD3 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_0)



#define TIM_TIM20_ETR_GPIO 0x00000000U
#define TIM_TIM20_ETR_COMP1 TIM1_AF1_ETRSEL_0
#define TIM_TIM20_ETR_COMP2 TIM1_AF1_ETRSEL_1
#define TIM_TIM20_ETR_COMP3 (TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM20_ETR_COMP4 TIM1_AF1_ETRSEL_2

#define TIM_TIM20_ETR_COMP5 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_0)


#define TIM_TIM20_ETR_COMP6 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_1)


#define TIM_TIM20_ETR_COMP7 (TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)

#define TIM_TIM20_ETR_ADC3_AWD1 TIM1_AF1_ETRSEL_3
#define TIM_TIM20_ETR_ADC3_AWD2 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM20_ETR_ADC3_AWD3 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_1)

#define TIM_TIM20_ETR_ADC5_AWD1 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_1 | TIM1_AF1_ETRSEL_0)
#define TIM_TIM20_ETR_ADC5_AWD2 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_2)
#define TIM_TIM20_ETR_ADC5_AWD3 (TIM1_AF1_ETRSEL_3 | TIM1_AF1_ETRSEL_2 | TIM1_AF1_ETRSEL_0)


/**
  * @}
  */

/** @defgroup TIMEx_Break_Input TIM Extended Break input
  * @{
  */
#define TIM_BREAKINPUT_BRK 0x00000001U
#define TIM_BREAKINPUT_BRK2 0x00000002U
/**
  * @}
  */

/** @defgroup TIMEx_Break_Input_Source TIM Extended Break input source
  * @{
  */
#define TIM_BREAKINPUTSOURCE_BKIN 0x00000001U
#define TIM_BREAKINPUTSOURCE_COMP1 0x00000002U
#define TIM_BREAKINPUTSOURCE_COMP2 0x00000004U
#define TIM_BREAKINPUTSOURCE_COMP3 0x00000008U
#define TIM_BREAKINPUTSOURCE_COMP4 0x00000010U

#define TIM_BREAKINPUTSOURCE_COMP5 0x00000020U


#define TIM_BREAKINPUTSOURCE_COMP6 0x00000040U


#define TIM_BREAKINPUTSOURCE_COMP7 0x00000080U

/**
  * @}
  */

/** @defgroup TIMEx_Break_Input_Source_Enable TIM Extended Break input source enabling
  * @{
  */
#define TIM_BREAKINPUTSOURCE_DISABLE 0x00000000U
#define TIM_BREAKINPUTSOURCE_ENABLE 0x00000001U
/**
  * @}
  */

/** @defgroup TIMEx_Break_Input_Source_Polarity TIM Extended Break input polarity
  * @{
  */
#define TIM_BREAKINPUTSOURCE_POLARITY_LOW 0x00000001U
#define TIM_BREAKINPUTSOURCE_POLARITY_HIGH 0x00000000U
/**
  * @}
  */

/** @defgroup TIMEx_Timer_Input_Selection TIM Extended Timer input selection
  * @{
  */
#define TIM_TIM1_TI1_GPIO 0x00000000U
#define TIM_TIM1_TI1_COMP1 TIM_TISEL_TI1SEL_0
#define TIM_TIM1_TI1_COMP2 TIM_TISEL_TI1SEL_1
#define TIM_TIM1_TI1_COMP3 (TIM_TISEL_TI1SEL_1 | TIM_TISEL_TI1SEL_0)
#define TIM_TIM1_TI1_COMP4 TIM_TISEL_TI1SEL_2


#define TIM_TIM2_TI1_GPIO 0x00000000U
#define TIM_TIM2_TI1_COMP1 TIM_TISEL_TI1SEL_0
#define TIM_TIM2_TI1_COMP2 TIM_TISEL_TI1SEL_1
#define TIM_TIM2_TI1_COMP3 (TIM_TISEL_TI1SEL_1 | TIM_TISEL_TI1SEL_0)
#define TIM_TIM2_TI1_COMP4 TIM_TISEL_TI1SEL_2

#define TIM_TIM2_TI1_COMP5 (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_0)


#define TIM_TIM2_TI2_GPIO 0x00000000U
#define TIM_TIM2_TI2_COMP1 TIM_TISEL_TI2SEL_0
#define TIM_TIM2_TI2_COMP2 TIM_TISEL_TI2SEL_1
#define TIM_TIM2_TI2_COMP3 (TIM_TISEL_TI2SEL_1 | TIM_TISEL_TI2SEL_0)
#define TIM_TIM2_TI2_COMP4 TIM_TISEL_TI2SEL_2

#define TIM_TIM2_TI2_COMP6 (TIM_TISEL_TI2SEL_2 | TIM_TISEL_TI2SEL_0)


#define TIM_TIM2_TI3_GPIO 0x00000000U
#define TIM_TIM2_TI3_COMP4 TIM_TISEL_TI3SEL_0

#define TIM_TIM2_TI4_GPIO 0x00000000U
#define TIM_TIM2_TI4_COMP1 TIM_TISEL_TI4SEL_0
#define TIM_TIM2_TI4_COMP2 TIM_TISEL_TI4SEL_1


#define TIM_TIM3_TI1_GPIO 0x00000000U
#define TIM_TIM3_TI1_COMP1 TIM_TISEL_TI1SEL_0
#define TIM_TIM3_TI1_COMP2 TIM_TISEL_TI1SEL_1
#define TIM_TIM3_TI1_COMP3 (TIM_TISEL_TI1SEL_1 | TIM_TISEL_TI1SEL_0)
#define TIM_TIM3_TI1_COMP4 TIM_TISEL_TI1SEL_2

#define TIM_TIM3_TI1_COMP5 (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_0)


#define TIM_TIM3_TI1_COMP6 (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_1)


#define TIM_TIM3_TI1_COMP7 (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_1 | TIM_TISEL_TI1SEL_0)


#define TIM_TIM3_TI2_GPIO 0x00000000U
#define TIM_TIM3_TI2_COMP1 TIM_TISEL_TI2SEL_0
#define TIM_TIM3_TI2_COMP2 TIM_TISEL_TI2SEL_1
#define TIM_TIM3_TI2_COMP3 (TIM_TISEL_TI2SEL_1 | TIM_TISEL_TI2SEL_0)
#define TIM_TIM3_TI2_COMP4 TIM_TISEL_TI2SEL_2

#define TIM_TIM3_TI2_COMP5 (TIM_TISEL_TI2SEL_2 | TIM_TISEL_TI2SEL_0)


#define TIM_TIM3_TI2_COMP6 (TIM_TISEL_TI2SEL_2 | TIM_TISEL_TI2SEL_1)


#define TIM_TIM3_TI2_COMP7 (TIM_TISEL_TI2SEL_2 | TIM_TISEL_TI2SEL_1 | TIM_TISEL_TI2SEL_0)


#define TIM_TIM3_TI3_GPIO 0x00000000U
#define TIM_TIM3_TI3_COMP3 TIM_TISEL_TI3SEL_0


#define TIM_TIM4_TI1_GPIO 0x00000000U
#define TIM_TIM4_TI1_COMP1 TIM_TISEL_TI1SEL_0
#define TIM_TIM4_TI1_COMP2 TIM_TISEL_TI1SEL_1
#define TIM_TIM4_TI1_COMP3 (TIM_TISEL_TI1SEL_1 | TIM_TISEL_TI1SEL_0)
#define TIM_TIM4_TI1_COMP4 TIM_TISEL_TI1SEL_2

#define TIM_TIM4_TI1_COMP5 (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_0)


#define TIM_TIM4_TI1_COMP6 (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_1)


#define TIM_TIM4_TI1_COMP7 (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_1 | TIM_TISEL_TI1SEL_0)


#define TIM_TIM4_TI2_GPIO 0x00000000U
#define TIM_TIM4_TI2_COMP1 TIM_TISEL_TI2SEL_0
#define TIM_TIM4_TI2_COMP2 TIM_TISEL_TI2SEL_1
#define TIM_TIM4_TI2_COMP3 (TIM_TISEL_TI2SEL_1 | TIM_TISEL_TI2SEL_0)
#define TIM_TIM4_TI2_COMP4 TIM_TISEL_TI2SEL_2

#define TIM_TIM4_TI2_COMP5 (TIM_TISEL_TI2SEL_2 | TIM_TISEL_TI2SEL_0)


#define TIM_TIM4_TI2_COMP6 (TIM_TISEL_TI2SEL_2 | TIM_TISEL_TI2SEL_1)


#define TIM_TIM4_TI2_COMP7 (TIM_TISEL_TI2SEL_2 | TIM_TISEL_TI2SEL_1 | TIM_TISEL_TI2SEL_0)


#define TIM_TIM4_TI3_GPIO 0x00000000U

#define TIM_TIM4_TI3_COMP5 TIM_TISEL_TI3SEL_0


#define TIM_TIM4_TI4_GPIO 0x00000000U

#define TIM_TIM4_TI4_COMP6 TIM_TISEL_TI4SEL_0




#define TIM_TIM5_TI1_GPIO 0x00000000U
#define TIM_TIM5_TI1_LSI TIM_TISEL_TI1SEL_0
#define TIM_TIM5_TI1_LSE TIM_TISEL_TI1SEL_1
#define TIM_TIM5_TI1_RTC_WK (TIM_TISEL_TI1SEL_1 | TIM_TISEL_TI1SEL_0)
#define TIM_TIM5_TI1_COMP1 TIM_TISEL_TI1SEL_2
#define TIM_TIM5_TI1_COMP2 (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_0)
#define TIM_TIM5_TI1_COMP3 (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_1)
#define TIM_TIM5_TI1_COMP4 (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_1 | TIM_TISEL_TI1SEL_0)

#define TIM_TIM5_TI1_COMP5 TIM_TISEL_TI1SEL_3


#define TIM_TIM5_TI1_COMP6 (TIM_TISEL_TI1SEL_3 | TIM_TISEL_TI1SEL_0)


#define TIM_TIM5_TI1_COMP7 (TIM_TISEL_TI1SEL_3 | TIM_TISEL_TI1SEL_1)


#define TIM_TIM5_TI2_GPIO 0x00000000U
#define TIM_TIM5_TI2_COMP1 TIM_TISEL_TI2SEL_0
#define TIM_TIM5_TI2_COMP2 TIM_TISEL_TI2SEL_1
#define TIM_TIM5_TI2_COMP3 (TIM_TISEL_TI2SEL_1 | TIM_TISEL_TI2SEL_0)
#define TIM_TIM5_TI2_COMP4 TIM_TISEL_TI2SEL_2

#define TIM_TIM5_TI2_COMP5 (TIM_TISEL_TI2SEL_2 | TIM_TISEL_TI2SEL_0)


#define TIM_TIM5_TI2_COMP6 (TIM_TISEL_TI2SEL_2 | TIM_TISEL_TI2SEL_1)


#define TIM_TIM5_TI2_COMP7 (TIM_TISEL_TI2SEL_2 | TIM_TISEL_TI2SEL_1 | TIM_TISEL_TI2SEL_0)




#define TIM_TIM8_TI1_GPIO 0x00000000U
#define TIM_TIM8_TI1_COMP1 TIM_TISEL_TI1SEL_0
#define TIM_TIM8_TI1_COMP2 TIM_TISEL_TI1SEL_1
#define TIM_TIM8_TI1_COMP3 (TIM_TISEL_TI1SEL_1 | TIM_TISEL_TI1SEL_0)
#define TIM_TIM8_TI1_COMP4 TIM_TISEL_TI1SEL_2


#define TIM_TIM15_TI1_GPIO 0x00000000U
#define TIM_TIM15_TI1_LSE TIM_TISEL_TI1SEL_0
#define TIM_TIM15_TI1_COMP1 TIM_TISEL_TI1SEL_1
#define TIM_TIM15_TI1_COMP2 (TIM_TISEL_TI1SEL_1 | TIM_TISEL_TI1SEL_0)

#define TIM_TIM15_TI1_COMP5 TIM_TISEL_TI1SEL_2


#define TIM_TIM15_TI1_COMP7 (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_0)


#define TIM_TIM15_TI2_GPIO 0x00000000U
#define TIM_TIM15_TI2_COMP2 TIM_TISEL_TI2SEL_0
#define TIM_TIM15_TI2_COMP3 TIM_TISEL_TI2SEL_1

#define TIM_TIM15_TI2_COMP6 (TIM_TISEL_TI2SEL_1 | TIM_TISEL_TI2SEL_0)


#define TIM_TIM15_TI2_COMP7 TIM_TISEL_TI2SEL_2



#define TIM_TIM16_TI1_GPIO 0x00000000U

#define TIM_TIM16_TI1_COMP6 TIM_TISEL_TI1SEL_0

#define TIM_TIM16_TI1_MCO TIM_TISEL_TI1SEL_1
#define TIM_TIM16_TI1_HSE_32 (TIM_TISEL_TI1SEL_1 | TIM_TISEL_TI1SEL_0)
#define TIM_TIM16_TI1_RTC_WK TIM_TISEL_TI1SEL_2
#define TIM_TIM16_TI1_LSE (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_0)
#define TIM_TIM16_TI1_LSI (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_1)


#define TIM_TIM17_TI1_GPIO 0x00000000U

#define TIM_TIM17_TI1_COMP5 TIM_TISEL_TI1SEL_0

#define TIM_TIM17_TI1_MCO TIM_TISEL_TI1SEL_1
#define TIM_TIM17_TI1_HSE_32 (TIM_TISEL_TI1SEL_1 | TIM_TISEL_TI1SEL_0)
#define TIM_TIM17_TI1_RTC_WK TIM_TISEL_TI1SEL_2
#define TIM_TIM17_TI1_LSE (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_0)
#define TIM_TIM17_TI1_LSI (TIM_TISEL_TI1SEL_2 | TIM_TISEL_TI1SEL_1)



#define TIM_TIM20_TI1_GPIO 0x00000000U
#define TIM_TIM20_TI1_COMP1 TIM_TISEL_TI1SEL_0
#define TIM_TIM20_TI1_COMP2 TIM_TISEL_TI1SEL_1
#define TIM_TIM20_TI1_COMP3 (TIM_TISEL_TI1SEL_1 | TIM_TISEL_TI1SEL_0)
#define TIM_TIM20_TI1_COMP4 TIM_TISEL_TI1SEL_2

/**
  * @}
  */

/** @defgroup TIMEx_SMS_Preload_Enable TIM Extended Bitfield SMS preload enabling
  * @{
  */
#define TIM_SMS_PRELOAD_SOURCE_UPDATE 0x00000000U
#define TIM_SMS_PRELOAD_SOURCE_INDEX TIM_SMCR_SMSPS
/**
  * @}
  */

/** @defgroup TIMEx_Encoder_Index_Position TIM Extended Encoder index position
  * @{
  */
#define TIM_ENCODERINDEX_POSITION_00 0x00000000U
#define TIM_ENCODERINDEX_POSITION_01 TIM_ECR_IPOS_0
#define TIM_ENCODERINDEX_POSITION_10 TIM_ECR_IPOS_1
#define TIM_ENCODERINDEX_POSITION_11 (TIM_ECR_IPOS_1 | TIM_ECR_IPOS_0)
#define TIM_ENCODERINDEX_POSITION_0 0x00000000U
#define TIM_ENCODERINDEX_POSITION_1 TIM_ECR_IPOS_0
/**
  * @}
  */

/** @defgroup TIMEx_Encoder_Index_Direction TIM Extended Encoder index direction
  * @{
  */
#define TIM_ENCODERINDEX_DIRECTION_UP_DOWN 0x00000000U
#define TIM_ENCODERINDEX_DIRECTION_UP TIM_ECR_IDIR_0
#define TIM_ENCODERINDEX_DIRECTION_DOWN TIM_ECR_IDIR_1
/**
  * @}
  */

/** @defgroup TIMEx_Encoder_Index_Polarity TIM Extended Encoder index polarity
  * @{
  */
#define TIM_ENCODERINDEX_POLARITY_INVERTED TIM_ETRPOLARITY_INVERTED
#define TIM_ENCODERINDEX_POLARITY_NONINVERTED TIM_ETRPOLARITY_NONINVERTED
/**
  * @}
  */

/** @defgroup TIMEx_Encoder_Index_Prescaler TIM Extended Encodder index prescaler
  * @{
  */
#define TIM_ENCODERINDEX_PRESCALER_DIV1 TIM_ETRPRESCALER_DIV1
#define TIM_ENCODERINDEX_PRESCALER_DIV2 TIM_ETRPRESCALER_DIV2
#define TIM_ENCODERINDEX_PRESCALER_DIV4 TIM_ETRPRESCALER_DIV4
#define TIM_ENCODERINDEX_PRESCALER_DIV8 TIM_ETRPRESCALER_DIV8
/**
  * @}
  */

/**
  * @}
  */
/* End of exported constants -------------------------------------------------*/

/* Exported macro ------------------------------------------------------------*/
/** @defgroup TIMEx_Exported_Macros TIM Extended Exported Macros
  * @{
  */

/**
  * @brief  HELPER macro calculating the prescaler value to achieve the required counter clock frequency.
  * @note   ex: @ref __HAL_TIM_CALC_PSC(80000000, 1000000);
  * @param  __TIMCLK__ timer input clock frequency (in Hz)
  * @param  __CNTCLK__ counter clock frequency (in Hz)
  * @retval Prescaler value  (between Min_Data=0 and Max_Data=65535)
  */
#define __HAL_TIM_CALC_PSC(__TIMCLK__,__CNTCLK__) ((__TIMCLK__) >= (__CNTCLK__)) ? (uint32_t)((__TIMCLK__)/(__CNTCLK__) - 1U) : 0U


/**
  * @brief  HELPER macro calculating the auto-reload value to achieve the required output signal frequency.
  * @note   ex: @ref __HAL_TIM_CALC_PERIOD(1000000, 0, 10000);
  * @param  __TIMCLK__ timer input clock frequency (in Hz)
  * @param  __PSC__ prescaler
  * @param  __FREQ__ output signal frequency (in Hz)
  * @retval  Auto-reload value  (between Min_Data=0 and Max_Data=65535)
  */
#define __HAL_TIM_CALC_PERIOD(__TIMCLK__,__PSC__,__FREQ__) (((__TIMCLK__)/((__PSC__) + 1U)) >= (__FREQ__)) ? ((__TIMCLK__)/((__FREQ__) * ((__PSC__) + 1U)) - 1U) : 0U


/**
  * @brief  HELPER macro calculating the auto-reload value, with dithering feature enabled, to achieve the required
  *         output signal frequency.
  * @note   ex: @ref __HAL_TIM_CALC_PERIOD_DITHER(1000000, 0, 10000);
  * @note   This macro should be used only if dithering is already enabled
  * @param  __TIMCLK__ timer input clock frequency (in Hz)
  * @param  __PSC__ prescaler
  * @param  __FREQ__ output signal frequency (in Hz)
  * @retval  Auto-reload value  (between Min_Data=0 and Max_Data=65519)
  */
#define __HAL_TIM_CALC_PERIOD_DITHER(__TIMCLK__,__PSC__,__FREQ__) (((__TIMCLK__)/((__PSC__) + 1U)) >= (__FREQ__)) ? (uint32_t)(((uint64_t)(__TIMCLK__)*16/((__FREQ__) * ((__PSC__) + 1U)) - 16U)) : 0U



/**
  * @brief  HELPER macro calculating the compare value required to achieve the required timer output compare
  *         active/inactive delay.
  * @note   ex: @ref __HAL_TIM_CALC_PULSE(1000000, 0, 10);
  * @param  __TIMCLK__ timer input clock frequency (in Hz)
  * @param  __PSC__ prescaler
  * @param  __DELAY__ timer output compare active/inactive delay (in us)
  * @retval Compare value  (between Min_Data=0 and Max_Data=65535)
  */
#define __HAL_TIM_CALC_PULSE(__TIMCLK__,__PSC__,__DELAY__) ((uint32_t)(((uint64_t)(__TIMCLK__) * (uint64_t)(__DELAY__)) / ((uint64_t)1000000U * (uint64_t)((__PSC__) + 1U))))



/**
  * @brief  HELPER macro calculating the compare value, with dithering feature enabled, to achieve the required timer
  *         output compare active/inactive delay.
  * @note   ex: @ref __HAL_TIM_CALC_PULSE_DITHER(1000000, 0, 10);
  * @note   This macro should be used only if dithering is already enabled
  * @param  __TIMCLK__ timer input clock frequency (in Hz)
  * @param  __PSC__ prescaler
  * @param  __DELAY__ timer output compare active/inactive delay (in us)
  * @retval Compare value  (between Min_Data=0 and Max_Data=65519)
  */
#define __HAL_TIM_CALC_PULSE_DITHER(__TIMCLK__,__PSC__,__DELAY__) ((uint32_t)(((uint64_t)(__TIMCLK__) * (uint64_t)(__DELAY__) * 16U) / ((uint64_t)1000000U * (uint64_t)((__PSC__) + 1U))))



/**
  * @brief  HELPER macro calculating the auto-reload value to achieve the required pulse duration
  *        (when the timer operates in one pulse mode).
  * @note   ex: @ref __HAL_TIM_CALC_PERIOD_BY_DELAY(1000000, 0, 10, 20);
  * @param  __TIMCLK__ timer input clock frequency (in Hz)
  * @param  __PSC__ prescaler
  * @param  __DELAY__ timer output compare active/inactive delay (in us)
  * @param  __PULSE__ pulse duration (in us)
  * @retval Auto-reload value  (between Min_Data=0 and Max_Data=65535)
  */
#define __HAL_TIM_CALC_PERIOD_BY_DELAY(__TIMCLK__,__PSC__,__DELAY__,__PULSE__) ((uint32_t)(__HAL_TIM_CALC_PULSE((__TIMCLK__), (__PSC__), (__PULSE__)) + __HAL_TIM_CALC_PULSE((__TIMCLK__), (__PSC__), (__DELAY__))))



/**
  * @brief  HELPER macro calculating the auto-reload value, with dithering feature enabled, to achieve the required
  *         pulse duration (when the timer operates in one pulse mode).
  * @note   ex: @ref __HAL_TIM_CALC_PERIOD_DITHER_BY_DELAY(1000000, 0, 10, 20);
  * @note   This macro should be used only if dithering is already enabled
  * @param  __TIMCLK__ timer input clock frequency (in Hz)
  * @param  __PSC__ prescaler
  * @param  __DELAY__ timer output compare active/inactive delay (in us)
  * @param  __PULSE__ pulse duration (in us)
  * @retval Auto-reload value  (between Min_Data=0 and Max_Data=65519)
  */
#define __HAL_TIM_CALC_PERIOD_DITHER_BY_DELAY(__TIMCLK__,__PSC__,__DELAY__,__PULSE__) ((uint32_t)(__HAL_TIM_CALC_PULSE_DITHER((__TIMCLK__), (__PSC__), (__PULSE__)) + __HAL_TIM_CALC_PULSE_DITHER((__TIMCLK__), (__PSC__), (__DELAY__))))



/**
  * @}
  */
/* End of exported macro -----------------------------------------------------*/

/* Private macro -------------------------------------------------------------*/
/** @defgroup TIMEx_Private_Macros TIM Extended Private Macros
  * @{
  */
#define IS_TIM_REMAP(__REMAP__) ((((__REMAP__) & 0xFFFC3FFFU) == 0x00000000U))

#define IS_TIM_BREAKINPUT(__BREAKINPUT__) (((__BREAKINPUT__) == TIM_BREAKINPUT_BRK) || ((__BREAKINPUT__) == TIM_BREAKINPUT_BRK2))



#define IS_TIM_BREAKINPUTSOURCE(__SOURCE__) (((__SOURCE__) == TIM_BREAKINPUTSOURCE_BKIN) || ((__SOURCE__) == TIM_BREAKINPUTSOURCE_COMP1) || ((__SOURCE__) == TIM_BREAKINPUTSOURCE_COMP2) || ((__SOURCE__) == TIM_BREAKINPUTSOURCE_COMP3) || ((__SOURCE__) == TIM_BREAKINPUTSOURCE_COMP4) || ((__SOURCE__) == TIM_BREAKINPUTSOURCE_COMP5) || ((__SOURCE__) == TIM_BREAKINPUTSOURCE_COMP6) || ((__SOURCE__) == TIM_BREAKINPUTSOURCE_COMP7))









# 703 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim_ex.h"
#define IS_TIM_BREAKINPUTSOURCE_STATE(__STATE__) (((__STATE__) == TIM_BREAKINPUTSOURCE_DISABLE) || ((__STATE__) == TIM_BREAKINPUTSOURCE_ENABLE))


#define IS_TIM_BREAKINPUTSOURCE_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_BREAKINPUTSOURCE_POLARITY_LOW) || ((__POLARITY__) == TIM_BREAKINPUTSOURCE_POLARITY_HIGH))


#define IS_TIM_TISEL(__TISEL__) ((((__TISEL__) & 0xF0F0F0F0U) == 0x00000000U))

#define IS_TIM_TISEL_TIX_INSTANCE(INSTANCE,CHANNEL) (IS_TIM_CCX_INSTANCE(INSTANCE, CHANNEL) && ((CHANNEL) < TIM_CHANNEL_5))



#define IS_TIM_CLOCKSOURCE_INSTANCE(INSTANCE,__CLOCK__) ((((INSTANCE) == TIM1) && (((__CLOCK__) == TIM_CLOCKSOURCE_INTERNAL) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE2) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1ED) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR3) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR4) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR5) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR6) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR7) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR8) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR9) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR10))) || (((INSTANCE) == TIM2) && (((__CLOCK__) == TIM_CLOCKSOURCE_INTERNAL) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE2) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1ED) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR0) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR3) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR4) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR5) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR6) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR7) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR8) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR9) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR10) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR11))) || (((INSTANCE) == TIM3) && (((__CLOCK__) == TIM_CLOCKSOURCE_INTERNAL) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE2) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1ED) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR0) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR3) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR4) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR5) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR6) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR7) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR8) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR9) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR10))) || (((INSTANCE) == TIM4) && (((__CLOCK__) == TIM_CLOCKSOURCE_INTERNAL) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE2) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1ED) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR0) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR4) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR5) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR6) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR7) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR8) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR9) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR10))) || (((INSTANCE) == TIM5) && (((__CLOCK__) == TIM_CLOCKSOURCE_INTERNAL) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE2) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1ED) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR0) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR3) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR5) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR6) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR7) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR8) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR9) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR10))) || (((INSTANCE) == TIM8) && (((__CLOCK__) == TIM_CLOCKSOURCE_INTERNAL) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE2) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1ED) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR0) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR3) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR4) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR6) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR7) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR8) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR9) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR10))) || (((INSTANCE) == TIM15) && (((__CLOCK__) == TIM_CLOCKSOURCE_INTERNAL) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1ED) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR0) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR3) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR4) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR5) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR7) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR8) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR9) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR10))) || (((INSTANCE) == TIM20) && (((__CLOCK__) == TIM_CLOCKSOURCE_INTERNAL) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE2) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1ED) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR0) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR3) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR4) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR5) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR6) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR7) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR8) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR10))))
# 858 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim_ex.h"

#define IS_TIM_TRIGGER_INSTANCE(INSTANCE,__SELECTION__) ((((INSTANCE) == TIM1) && (((__SELECTION__) == TIM_TS_TI1F_ED) || ((__SELECTION__) == TIM_TS_TI1FP1) || ((__SELECTION__) == TIM_TS_TI2FP2) || ((__SELECTION__) == TIM_TS_ETRF) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_ITR4) || ((__SELECTION__) == TIM_TS_ITR5) || ((__SELECTION__) == TIM_TS_ITR6) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR9) || ((__SELECTION__) == TIM_TS_ITR10))) || (((INSTANCE) == TIM2) && (((__SELECTION__) == TIM_TS_TI1F_ED) || ((__SELECTION__) == TIM_TS_TI1FP1) || ((__SELECTION__) == TIM_TS_TI2FP2) || ((__SELECTION__) == TIM_TS_ETRF) || ((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_ITR4) || ((__SELECTION__) == TIM_TS_ITR5) || ((__SELECTION__) == TIM_TS_ITR6) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR9) || ((__SELECTION__) == TIM_TS_ITR10) || ((__SELECTION__) == TIM_TS_ITR11))) || (((INSTANCE) == TIM3) && (((__SELECTION__) == TIM_TS_TI1F_ED) || ((__SELECTION__) == TIM_TS_TI1FP1) || ((__SELECTION__) == TIM_TS_TI2FP2) || ((__SELECTION__) == TIM_TS_ETRF) || ((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_ITR4) || ((__SELECTION__) == TIM_TS_ITR5) || ((__SELECTION__) == TIM_TS_ITR6) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR9) || ((__SELECTION__) == TIM_TS_ITR10))) || (((INSTANCE) == TIM4) && (((__SELECTION__) == TIM_TS_TI1F_ED) || ((__SELECTION__) == TIM_TS_TI1FP1) || ((__SELECTION__) == TIM_TS_TI2FP2) || ((__SELECTION__) == TIM_TS_ETRF) || ((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR4) || ((__SELECTION__) == TIM_TS_ITR5) || ((__SELECTION__) == TIM_TS_ITR6) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR9) || ((__SELECTION__) == TIM_TS_ITR10))) || (((INSTANCE) == TIM5) && (((__SELECTION__) == TIM_TS_TI1F_ED) || ((__SELECTION__) == TIM_TS_TI1FP1) || ((__SELECTION__) == TIM_TS_TI2FP2) || ((__SELECTION__) == TIM_TS_ETRF) || ((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_ITR5) || ((__SELECTION__) == TIM_TS_ITR6) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR9) || ((__SELECTION__) == TIM_TS_ITR10))) || (((INSTANCE) == TIM8) && (((__SELECTION__) == TIM_TS_TI1F_ED) || ((__SELECTION__) == TIM_TS_TI1FP1) || ((__SELECTION__) == TIM_TS_TI2FP2) || ((__SELECTION__) == TIM_TS_ETRF) || ((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_ITR4) || ((__SELECTION__) == TIM_TS_ITR6) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR9) || ((__SELECTION__) == TIM_TS_ITR10))) || (((INSTANCE) == TIM15) && (((__SELECTION__) == TIM_TS_TI1F_ED) || ((__SELECTION__) == TIM_TS_TI1FP1) || ((__SELECTION__) == TIM_TS_TI2FP2) || ((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_ITR4) || ((__SELECTION__) == TIM_TS_ITR5) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR9) || ((__SELECTION__) == TIM_TS_ITR10))) || (((INSTANCE) == TIM20) && (((__SELECTION__) == TIM_TS_TI1F_ED) || ((__SELECTION__) == TIM_TS_TI1FP1) || ((__SELECTION__) == TIM_TS_TI2FP2) || ((__SELECTION__) == TIM_TS_ETRF) || ((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_ITR4) || ((__SELECTION__) == TIM_TS_ITR5) || ((__SELECTION__) == TIM_TS_ITR6) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR10))))
# 987 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim_ex.h"

#define IS_TIM_INTERNAL_TRIGGEREVENT_INSTANCE(INSTANCE,__SELECTION__) ((((INSTANCE) == TIM1) && (((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_ITR4) || ((__SELECTION__) == TIM_TS_ITR5) || ((__SELECTION__) == TIM_TS_ITR6) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR9) || ((__SELECTION__) == TIM_TS_ITR10)|| ((__SELECTION__) == TIM_TS_NONE))) || (((INSTANCE) == TIM2) && (((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_ITR4) || ((__SELECTION__) == TIM_TS_ITR5) || ((__SELECTION__) == TIM_TS_ITR6) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR9) || ((__SELECTION__) == TIM_TS_ITR10)|| ((__SELECTION__) == TIM_TS_ITR11)|| ((__SELECTION__) == TIM_TS_NONE))) || (((INSTANCE) == TIM3) && (((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_ITR4) || ((__SELECTION__) == TIM_TS_ITR5) || ((__SELECTION__) == TIM_TS_ITR6) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR9) || ((__SELECTION__) == TIM_TS_ITR10)|| ((__SELECTION__) == TIM_TS_NONE))) || (((INSTANCE) == TIM4) && (((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR4) || ((__SELECTION__) == TIM_TS_ITR5) || ((__SELECTION__) == TIM_TS_ITR6) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR9) || ((__SELECTION__) == TIM_TS_ITR10)|| ((__SELECTION__) == TIM_TS_NONE))) || (((INSTANCE) == TIM5) && (((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_ITR5) || ((__SELECTION__) == TIM_TS_ITR6) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR9) || ((__SELECTION__) == TIM_TS_ITR10)|| ((__SELECTION__) == TIM_TS_NONE))) || (((INSTANCE) == TIM8) && (((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_ITR4) || ((__SELECTION__) == TIM_TS_ITR6) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR9) || ((__SELECTION__) == TIM_TS_ITR10)|| ((__SELECTION__) == TIM_TS_NONE))) || (((INSTANCE) == TIM15) && (((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_ITR4) || ((__SELECTION__) == TIM_TS_ITR5) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR9) || ((__SELECTION__) == TIM_TS_ITR10)|| ((__SELECTION__) == TIM_TS_NONE))) || (((INSTANCE) == TIM20) && (((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_ITR4) || ((__SELECTION__) == TIM_TS_ITR5) || ((__SELECTION__) == TIM_TS_ITR6) || ((__SELECTION__) == TIM_TS_ITR7) || ((__SELECTION__) == TIM_TS_ITR8) || ((__SELECTION__) == TIM_TS_ITR10)|| ((__SELECTION__) == TIM_TS_NONE))))
# 1093 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim_ex.h"

# 1907 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim_ex.h"

#define IS_TIM_OC_CHANNEL_MODE(__MODE__,__CHANNEL__) (IS_TIM_OC_MODE(__MODE__) && ((((__MODE__) == TIM_OCMODE_DIRECTION_OUTPUT) || ((__MODE__) == TIM_OCMODE_PULSE_ON_COMPARE)) ? (((__CHANNEL__) == TIM_CHANNEL_3) || ((__CHANNEL__) == TIM_CHANNEL_4)) : (1 == 1)))




#define IS_TIM_PULSEONCOMPARE_CHANNEL(__CHANNEL__) (((__CHANNEL__) == TIM_CHANNEL_3) || ((__CHANNEL__) == TIM_CHANNEL_4))



#define IS_TIM_PULSEONCOMPARE_INSTANCE(INSTANCE) IS_TIM_CC3_INSTANCE(INSTANCE)

#define IS_TIM_PULSEONCOMPARE_WIDTH(__WIDTH__) ((__WIDTH__) <= 0xFFU)

#define IS_TIM_PULSEONCOMPARE_WIDTHPRESCALER(__PRESCALER__) ((__PRESCALER__) <= 0x7U)

#define IS_TIM_SLAVE_PRELOAD_SOURCE(__SOURCE__) (((__SOURCE__) == TIM_SMS_PRELOAD_SOURCE_UPDATE) || ((__SOURCE__) == TIM_SMS_PRELOAD_SOURCE_INDEX))


#define IS_TIM_ENCODERINDEX_POLARITY(__POLARITY__) (((__POLARITY__) == TIM_ENCODERINDEX_POLARITY_INVERTED) || ((__POLARITY__) == TIM_ENCODERINDEX_POLARITY_NONINVERTED))


#define IS_TIM_ENCODERINDEX_PRESCALER(__PRESCALER__) (((__PRESCALER__) == TIM_ENCODERINDEX_PRESCALER_DIV1) || ((__PRESCALER__) == TIM_ENCODERINDEX_PRESCALER_DIV2) || ((__PRESCALER__) == TIM_ENCODERINDEX_PRESCALER_DIV4) || ((__PRESCALER__) == TIM_ENCODERINDEX_PRESCALER_DIV8))




#define IS_TIM_ENCODERINDEX_FILTER(__FILTER__) ((__FILTER__) <= 0xFUL)

#define IS_TIM_ENCODERINDEX_POSITION(__POSITION__) (((__POSITION__) == TIM_ENCODERINDEX_POSITION_00) || ((__POSITION__) == TIM_ENCODERINDEX_POSITION_01) || ((__POSITION__) == TIM_ENCODERINDEX_POSITION_10) || ((__POSITION__) == TIM_ENCODERINDEX_POSITION_11) || ((__POSITION__) == TIM_ENCODERINDEX_POSITION_0) || ((__POSITION__) == TIM_ENCODERINDEX_POSITION_1))






#define IS_TIM_ENCODERINDEX_DIRECTION(__DIRECTION__) (((__DIRECTION__) == TIM_ENCODERINDEX_DIRECTION_UP_DOWN) || ((__DIRECTION__) == TIM_ENCODERINDEX_DIRECTION_UP) || ((__DIRECTION__) == TIM_ENCODERINDEX_DIRECTION_DOWN))


/**
  * @}
  */
/* End of private macro ------------------------------------------------------*/

/* Exported functions --------------------------------------------------------*/
/** @addtogroup TIMEx_Exported_Functions TIM Extended Exported Functions
  * @{
  */

/** @addtogroup TIMEx_Exported_Functions_Group1 Extended Timer Hall Sensor functions
  *  @brief    Timer Hall Sensor functions
  * @{
  */
/*  Timer Hall Sensor functions  **********************************************/
HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, const TIM_HallSensor_InitTypeDef *sConfig);
HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim);

void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim);
void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim);

/* Blocking mode: Polling */
HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim);
/* Non-Blocking mode: Interrupt */
HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim);
/* Non-Blocking mode: DMA */
HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length);
HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim);
/**
  * @}
  */

/** @addtogroup TIMEx_Exported_Functions_Group2 Extended Timer Complementary Output Compare functions
  *  @brief   Timer Complementary Output Compare functions
  * @{
  */
/*  Timer Complementary Output Compare functions  *****************************/
/* Blocking mode: Polling */
HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);

/* Non-Blocking mode: Interrupt */
HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);

/* Non-Blocking mode: DMA */
HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, const uint32_t *pData,
                                          uint16_t Length);
HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
/**
  * @}
  */

/** @addtogroup TIMEx_Exported_Functions_Group3 Extended Timer Complementary PWM functions
  *  @brief    Timer Complementary PWM functions
  * @{
  */
/*  Timer Complementary PWM functions  ****************************************/
/* Blocking mode: Polling */
HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);

/* Non-Blocking mode: Interrupt */
HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
/* Non-Blocking mode: DMA */
HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, const uint32_t *pData,
                                           uint16_t Length);
HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
/**
  * @}
  */

/** @addtogroup TIMEx_Exported_Functions_Group4 Extended Timer Complementary One Pulse functions
  *  @brief    Timer Complementary One Pulse functions
  * @{
  */
/*  Timer Complementary One Pulse functions  **********************************/
/* Blocking mode: Polling */
HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel);

/* Non-Blocking mode: Interrupt */
HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
/**
  * @}
  */

/** @addtogroup TIMEx_Exported_Functions_Group5 Extended Peripheral Control functions
  *  @brief    Peripheral Control functions
  * @{
  */
/* Extended Control functions  ************************************************/
HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
                                              uint32_t  CommutationSource);
HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
                                                 uint32_t  CommutationSource);
HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
                                                  uint32_t  CommutationSource);
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        const TIM_MasterConfigTypeDef *sMasterConfig);
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
                                                const TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig);
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakInput(TIM_HandleTypeDef *htim, uint32_t BreakInput,
                                             const TIMEx_BreakInputConfigTypeDef *sBreakInputConfig);
HAL_StatusTypeDef HAL_TIMEx_GroupChannel5(TIM_HandleTypeDef *htim, uint32_t Channels);
HAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap);
HAL_StatusTypeDef  HAL_TIMEx_TISelection(TIM_HandleTypeDef *htim, uint32_t TISelection, uint32_t Channel);

HAL_StatusTypeDef HAL_TIMEx_DisarmBreakInput(TIM_HandleTypeDef *htim, uint32_t BreakInput);
HAL_StatusTypeDef HAL_TIMEx_ReArmBreakInput(const TIM_HandleTypeDef *htim, uint32_t BreakInput);
HAL_StatusTypeDef HAL_TIMEx_DitheringEnable(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIMEx_DitheringDisable(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIMEx_OC_ConfigPulseOnCompare(TIM_HandleTypeDef *htim, uint32_t PulseWidthPrescaler,
                                                    uint32_t PulseWidth);
HAL_StatusTypeDef HAL_TIMEx_ConfigSlaveModePreload(TIM_HandleTypeDef *htim, uint32_t Source);
HAL_StatusTypeDef HAL_TIMEx_EnableSlaveModePreload(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIMEx_DisableSlaveModePreload(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIMEx_EnableDeadTimePreload(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIMEx_DisableDeadTimePreload(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIMEx_ConfigDeadTime(TIM_HandleTypeDef *htim, uint32_t Deadtime);
HAL_StatusTypeDef HAL_TIMEx_ConfigAsymmetricalDeadTime(TIM_HandleTypeDef *htim, uint32_t FallingDeadtime);
HAL_StatusTypeDef HAL_TIMEx_EnableAsymmetricalDeadTime(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIMEx_DisableAsymmetricalDeadTime(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIMEx_ConfigEncoderIndex(TIM_HandleTypeDef *htim,
                                               TIMEx_EncoderIndexConfigTypeDef *sEncoderIndexConfig);
HAL_StatusTypeDef HAL_TIMEx_EnableEncoderIndex(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIMEx_DisableEncoderIndex(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIMEx_EnableEncoderFirstIndex(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIMEx_DisableEncoderFirstIndex(TIM_HandleTypeDef *htim);
/**
  * @}
  */

/** @addtogroup TIMEx_Exported_Functions_Group6 Extended Callbacks functions
  * @brief    Extended Callbacks functions
  * @{
  */
/* Extended Callback **********************************************************/
void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim);
void HAL_TIMEx_CommutHalfCpltCallback(TIM_HandleTypeDef *htim);
void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim);
void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim);
void HAL_TIMEx_EncoderIndexCallback(TIM_HandleTypeDef *htim);
void HAL_TIMEx_DirectionChangeCallback(TIM_HandleTypeDef *htim);
void HAL_TIMEx_IndexErrorCallback(TIM_HandleTypeDef *htim);
void HAL_TIMEx_TransitionErrorCallback(TIM_HandleTypeDef *htim);
/**
  * @}
  */

/** @addtogroup TIMEx_Exported_Functions_Group7 Extended Peripheral State functions
  * @brief    Extended Peripheral State functions
  * @{
  */
/* Extended Peripheral State functions  ***************************************/
HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(const TIM_HandleTypeDef *htim);
HAL_TIM_ChannelStateTypeDef HAL_TIMEx_GetChannelNState(const TIM_HandleTypeDef *htim,  uint32_t ChannelN);
/**
  * @}
  */

/**
  * @}
  */
/* End of exported functions -------------------------------------------------*/

/* Private functions----------------------------------------------------------*/
/** @addtogroup TIMEx_Private_Functions TIM Extended Private Functions
  * @{
  */
void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma);
void TIMEx_DMACommutationHalfCplt(DMA_HandleTypeDef *hdma);
/**
  * @}
  */
/* End of private functions --------------------------------------------------*/

/**
  * @}
  */

/**
  * @}
  */






# 2337 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_tim.h" 2

/* Exported functions --------------------------------------------------------*/
/** @addtogroup TIM_Exported_Functions TIM Exported Functions
  * @{
  */

/** @addtogroup TIM_Exported_Functions_Group1 TIM Time Base functions
  *  @brief   Time Base functions
  * @{
  */
/* Time Base functions ********************************************************/
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim);
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim);
void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim);
/* Blocking mode: Polling */
HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim);
/* Non-Blocking mode: Interrupt */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim);
/* Non-Blocking mode: DMA */
HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, const uint32_t *pData, uint16_t Length);
HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim);
/**
  * @}
  */

/** @addtogroup TIM_Exported_Functions_Group2 TIM Output Compare functions
  *  @brief   TIM Output Compare functions
  * @{
  */
/* Timer Output Compare functions *********************************************/
HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim);
void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim);
void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim);
/* Blocking mode: Polling */
HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);
/* Non-Blocking mode: Interrupt */
HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
/* Non-Blocking mode: DMA */
HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, const uint32_t *pData,
                                       uint16_t Length);
HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
/**
  * @}
  */

/** @addtogroup TIM_Exported_Functions_Group3 TIM PWM functions
  *  @brief   TIM PWM functions
  * @{
  */
/* Timer PWM functions ********************************************************/
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim);
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim);
void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim);
/* Blocking mode: Polling */
HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);
/* Non-Blocking mode: Interrupt */
HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
/* Non-Blocking mode: DMA */
HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, const uint32_t *pData,
                                        uint16_t Length);
HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
/**
  * @}
  */

/** @addtogroup TIM_Exported_Functions_Group4 TIM Input Capture functions
  *  @brief   TIM Input Capture functions
  * @{
  */
/* Timer Input Capture functions **********************************************/
HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim);
HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim);
void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim);
void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim);
/* Blocking mode: Polling */
HAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);
/* Non-Blocking mode: Interrupt */
HAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
/* Non-Blocking mode: DMA */
HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length);
HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
/**
  * @}
  */

/** @addtogroup TIM_Exported_Functions_Group5 TIM One Pulse functions
  *  @brief   TIM One Pulse functions
  * @{
  */
/* Timer One Pulse functions **************************************************/
HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode);
HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim);
void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim);
void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim);
/* Blocking mode: Polling */
HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
/* Non-Blocking mode: Interrupt */
HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel);
/**
  * @}
  */

/** @addtogroup TIM_Exported_Functions_Group6 TIM Encoder functions
  *  @brief   TIM Encoder functions
  * @{
  */
/* Timer Encoder functions ****************************************************/
HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim, const TIM_Encoder_InitTypeDef *sConfig);
HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim);
void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim);
void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim);
/* Blocking mode: Polling */
HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel);
/* Non-Blocking mode: Interrupt */
HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
/* Non-Blocking mode: DMA */
HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1,
                                            uint32_t *pData2, uint16_t Length);
HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel);
/**
  * @}
  */

/** @addtogroup TIM_Exported_Functions_Group7 TIM IRQ handler management
  *  @brief   IRQ handler management
  * @{
  */
/* Interrupt Handler functions  ***********************************************/
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim);
/**
  * @}
  */

/** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions
  *  @brief   Peripheral Control functions
  * @{
  */
/* Control functions  *********************************************************/
HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, const TIM_OC_InitTypeDef *sConfig,
                                           uint32_t Channel);
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, const TIM_OC_InitTypeDef *sConfig,
                                            uint32_t Channel);
HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, const TIM_IC_InitTypeDef *sConfig,
                                           uint32_t Channel);
HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OnePulse_InitTypeDef *sConfig,
                                                 uint32_t OutputChannel,  uint32_t InputChannel);
HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,
                                           const TIM_ClearInputConfigTypeDef *sClearInputConfig,
                                           uint32_t Channel);
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, const TIM_ClockConfigTypeDef *sClockSourceConfig);
HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection);
HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, const TIM_SlaveConfigTypeDef *sSlaveConfig);
HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim, const TIM_SlaveConfigTypeDef *sSlaveConfig);
HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
                                              uint32_t BurstRequestSrc, const uint32_t  *BurstBuffer,
                                              uint32_t  BurstLength);
HAL_StatusTypeDef HAL_TIM_DMABurst_MultiWriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
                                                   uint32_t BurstRequestSrc, const uint32_t *BurstBuffer,
                                                   uint32_t BurstLength,  uint32_t DataLength);
HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc);
HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
                                             uint32_t BurstRequestSrc, uint32_t  *BurstBuffer, uint32_t  BurstLength);
HAL_StatusTypeDef HAL_TIM_DMABurst_MultiReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
                                                  uint32_t BurstRequestSrc, uint32_t  *BurstBuffer,
                                                  uint32_t  BurstLength, uint32_t  DataLength);
HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc);
HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource);
uint32_t HAL_TIM_ReadCapturedValue(const TIM_HandleTypeDef *htim, uint32_t Channel);
/**
  * @}
  */

/** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
  *  @brief   TIM Callbacks functions
  * @{
  */
/* Callback in non blocking modes (Interrupt and DMA) *************************/
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);
void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim);
void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim);
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim);
void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim);
void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim);
void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim);
void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim);
void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim);
void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim);

/* Callbacks Register/UnRegister functions  ***********************************/






/**
  * @}
  */

/** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions
  *  @brief  Peripheral State functions
  * @{
  */
/* Peripheral State functions  ************************************************/
HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(const TIM_HandleTypeDef *htim);
HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(const TIM_HandleTypeDef *htim);
HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(const TIM_HandleTypeDef *htim);
HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(const TIM_HandleTypeDef *htim);
HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(const TIM_HandleTypeDef *htim);
HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(const TIM_HandleTypeDef *htim);

/* Peripheral Channel state functions  ************************************************/
HAL_TIM_ActiveChannel HAL_TIM_GetActiveChannel(const TIM_HandleTypeDef *htim);
HAL_TIM_ChannelStateTypeDef HAL_TIM_GetChannelState(const TIM_HandleTypeDef *htim,  uint32_t Channel);
HAL_TIM_DMABurstStateTypeDef HAL_TIM_DMABurstState(const TIM_HandleTypeDef *htim);
/**
  * @}
  */

/**
  * @}
  */
/* End of exported functions -------------------------------------------------*/

/* Private functions----------------------------------------------------------*/
/** @defgroup TIM_Private_Functions TIM Private Functions
  * @{
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure);
void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection, uint32_t TIM_ICFilter);
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config);
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter);

void TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma);
void TIM_DMAError(DMA_HandleTypeDef *hdma);
void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma);
void TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma);
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState);





/**
  * @}
  */
/* End of private functions --------------------------------------------------*/

/**
  * @}
  */

/**
  * @}
  */





# 345 "Core/Inc/stm32g4xx_hal_conf.h" 2



# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_uart.h
  * @author  MCD Application Team
  * @brief   Header file of UART HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_UART_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup UART
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/** @defgroup UART_Exported_Types UART Exported Types
  * @{
  */

/**
  * @brief UART Init Structure definition
  */
typedef struct
{
  uint32_t BaudRate;                /*!< This member configures the UART communication baud rate.
                                         The baud rate register is computed using the following formula:
                                         LPUART:
                                         =======
                                         Baud Rate Register = ((256 * lpuart_ker_ckpres) / ((huart->Init.BaudRate)))
                                         where lpuart_ker_ck_pres is the UART input clock divided by a prescaler
                                         UART:
                                         =====
                                         - If oversampling is 16 or in LIN mode,
                                            Baud Rate Register = ((uart_ker_ckpres) / ((huart->Init.BaudRate)))
                                         - If oversampling is 8,
                                            Baud Rate Register[15:4] = ((2 * uart_ker_ckpres) /
                                            ((huart->Init.BaudRate)))[15:4]
                                            Baud Rate Register[3] =  0
                                            Baud Rate Register[2:0] =  (((2 * uart_ker_ckpres) /
                                            ((huart->Init.BaudRate)))[3:0]) >> 1
                                         where uart_ker_ck_pres is the UART input clock divided by a prescaler */

  uint32_t WordLength;              /*!< Specifies the number of data bits transmitted or received in a frame.
                                         This parameter can be a value of @ref UARTEx_Word_Length. */

  uint32_t StopBits;                /*!< Specifies the number of stop bits transmitted.
                                         This parameter can be a value of @ref UART_Stop_Bits. */

  uint32_t Parity;                  /*!< Specifies the parity mode.
                                         This parameter can be a value of @ref UART_Parity
                                         @note When parity is enabled, the computed parity is inserted
                                               at the MSB position of the transmitted data (9th bit when
                                               the word length is set to 9 data bits; 8th bit when the
                                               word length is set to 8 data bits). */

  uint32_t Mode;                    /*!< Specifies whether the Receive or Transmit mode is enabled or disabled.
                                         This parameter can be a value of @ref UART_Mode. */

  uint32_t HwFlowCtl;               /*!< Specifies whether the hardware flow control mode is enabled
                                         or disabled.
                                         This parameter can be a value of @ref UART_Hardware_Flow_Control. */

  uint32_t OverSampling;            /*!< Specifies whether the Over sampling 8 is enabled or disabled,
                                         to achieve higher speed (up to f_PCLK/8).
                                         This parameter can be a value of @ref UART_Over_Sampling. */

  uint32_t OneBitSampling;          /*!< Specifies whether a single sample or three samples' majority vote is selected.
                                         Selecting the single sample method increases the receiver tolerance to clock
                                         deviations. This parameter can be a value of @ref UART_OneBit_Sampling. */

  uint32_t ClockPrescaler;          /*!< Specifies the prescaler value used to divide the UART clock source.
                                         This parameter can be a value of @ref UART_ClockPrescaler. */

} UART_InitTypeDef;

/**
  * @brief  UART Advanced Features initialization structure definition
  */
typedef struct
{
  uint32_t AdvFeatureInit;        /*!< Specifies which advanced UART features is initialized. Several
                                       Advanced Features may be initialized at the same time .
                                       This parameter can be a value of
                                       @ref UART_Advanced_Features_Initialization_Type. */

  uint32_t TxPinLevelInvert;      /*!< Specifies whether the TX pin active level is inverted.
                                       This parameter can be a value of @ref UART_Tx_Inv. */

  uint32_t RxPinLevelInvert;      /*!< Specifies whether the RX pin active level is inverted.
                                       This parameter can be a value of @ref UART_Rx_Inv. */

  uint32_t DataInvert;            /*!< Specifies whether data are inverted (positive/direct logic
                                       vs negative/inverted logic).
                                       This parameter can be a value of @ref UART_Data_Inv. */

  uint32_t Swap;                  /*!< Specifies whether TX and RX pins are swapped.
                                       This parameter can be a value of @ref UART_Rx_Tx_Swap. */

  uint32_t OverrunDisable;        /*!< Specifies whether the reception overrun detection is disabled.
                                       This parameter can be a value of @ref UART_Overrun_Disable. */

  uint32_t DMADisableonRxError;   /*!< Specifies whether the DMA is disabled in case of reception error.
                                       This parameter can be a value of @ref UART_DMA_Disable_on_Rx_Error. */

  uint32_t AutoBaudRateEnable;    /*!< Specifies whether auto Baud rate detection is enabled.
                                       This parameter can be a value of @ref UART_AutoBaudRate_Enable. */

  uint32_t AutoBaudRateMode;      /*!< If auto Baud rate detection is enabled, specifies how the rate
                                       detection is carried out.
                                       This parameter can be a value of @ref UART_AutoBaud_Rate_Mode. */

  uint32_t MSBFirst;              /*!< Specifies whether MSB is sent first on UART line.
                                       This parameter can be a value of @ref UART_MSB_First. */
} UART_AdvFeatureInitTypeDef;

/**
  * @brief HAL UART State definition
  * @note  HAL UART State value is a combination of 2 different substates:
  *        gState and RxState (see @ref UART_State_Definition).
  *        - gState contains UART state information related to global Handle management
  *          and also information related to Tx operations.
  *          gState value coding follow below described bitmap :
  *          b7-b6  Error information
  *             00 : No Error
  *             01 : (Not Used)
  *             10 : Timeout
  *             11 : Error
  *          b5     Peripheral initialization status
  *             0  : Reset (Peripheral not initialized)
  *             1  : Init done (Peripheral initialized. HAL UART Init function already called)
  *          b4-b3  (not used)
  *             xx : Should be set to 00
  *          b2     Intrinsic process state
  *             0  : Ready
  *             1  : Busy (Peripheral busy with some configuration or internal operations)
  *          b1     (not used)
  *             x  : Should be set to 0
  *          b0     Tx state
  *             0  : Ready (no Tx operation ongoing)
  *             1  : Busy (Tx operation ongoing)
  *        - RxState contains information related to Rx operations.
  *          RxState value coding follow below described bitmap :
  *          b7-b6  (not used)
  *             xx : Should be set to 00
  *          b5     Peripheral initialization status
  *             0  : Reset (Peripheral not initialized)
  *             1  : Init done (Peripheral initialized)
  *          b4-b2  (not used)
  *            xxx : Should be set to 000
  *          b1     Rx state
  *             0  : Ready (no Rx operation ongoing)
  *             1  : Busy (Rx operation ongoing)
  *          b0     (not used)
  *             x  : Should be set to 0.
  */
typedef uint32_t HAL_UART_StateTypeDef;

/**
  * @brief UART clock sources definition
  */
typedef enum
{
  UART_CLOCKSOURCE_PCLK1      = 0x00U,    /*!< PCLK1 clock source  */
  UART_CLOCKSOURCE_PCLK2      = 0x01U,    /*!< PCLK2 clock source  */
  UART_CLOCKSOURCE_HSI        = 0x02U,    /*!< HSI clock source    */
  UART_CLOCKSOURCE_SYSCLK     = 0x04U,    /*!< SYSCLK clock source */
  UART_CLOCKSOURCE_LSE        = 0x08U,    /*!< LSE clock source       */
  UART_CLOCKSOURCE_UNDEFINED  = 0x10U     /*!< Undefined clock source */
} UART_ClockSourceTypeDef;

/**
  * @brief HAL UART Reception type definition
  * @note  HAL UART Reception type value aims to identify which type of Reception is ongoing.
  *        This parameter can be a value of @ref UART_Reception_Type_Values :
  *           HAL_UART_RECEPTION_STANDARD         = 0x00U,
  *           HAL_UART_RECEPTION_TOIDLE           = 0x01U,
  *           HAL_UART_RECEPTION_TORTO            = 0x02U,
  *           HAL_UART_RECEPTION_TOCHARMATCH      = 0x03U,
  */
typedef uint32_t HAL_UART_RxTypeTypeDef;

/**
  * @brief HAL UART Rx Event type definition
  * @note  HAL UART Rx Event type value aims to identify which type of Event has occurred
  *        leading to call of the RxEvent callback.
  *        This parameter can be a value of @ref UART_RxEvent_Type_Values :
  *           HAL_UART_RXEVENT_TC                 = 0x00U,
  *           HAL_UART_RXEVENT_HT                 = 0x01U,
  *           HAL_UART_RXEVENT_IDLE               = 0x02U,
  */
typedef uint32_t HAL_UART_RxEventTypeTypeDef;

/**
  * @brief  UART handle Structure definition
  */
typedef struct __UART_HandleTypeDef
{
  USART_TypeDef            *Instance;                /*!< UART registers base address        */

  UART_InitTypeDef         Init;                     /*!< UART communication parameters      */

  UART_AdvFeatureInitTypeDef AdvancedInit;           /*!< UART Advanced Features initialization parameters */

  const uint8_t            *pTxBuffPtr;              /*!< Pointer to UART Tx transfer Buffer */

  uint16_t                 TxXferSize;               /*!< UART Tx Transfer size              */

  __IO uint16_t            TxXferCount;              /*!< UART Tx Transfer Counter           */

  uint8_t                  *pRxBuffPtr;              /*!< Pointer to UART Rx transfer Buffer */

  uint16_t                 RxXferSize;               /*!< UART Rx Transfer size              */

  __IO uint16_t            RxXferCount;              /*!< UART Rx Transfer Counter           */

  uint16_t                 Mask;                     /*!< UART Rx RDR register mask          */

  uint32_t                 FifoMode;                 /*!< Specifies if the FIFO mode is being used.
                                                          This parameter can be a value of @ref UARTEx_FIFO_mode. */

  uint16_t                 NbRxDataToProcess;        /*!< Number of data to process during RX ISR execution */

  uint16_t                 NbTxDataToProcess;        /*!< Number of data to process during TX ISR execution */

  __IO HAL_UART_RxTypeTypeDef ReceptionType;         /*!< Type of ongoing reception          */

  __IO HAL_UART_RxEventTypeTypeDef RxEventType;      /*!< Type of Rx Event                   */

  void (*RxISR)(struct __UART_HandleTypeDef *huart); /*!< Function pointer on Rx IRQ handler */

  void (*TxISR)(struct __UART_HandleTypeDef *huart); /*!< Function pointer on Tx IRQ handler */

  DMA_HandleTypeDef        *hdmatx;                  /*!< UART Tx DMA Handle parameters      */

  DMA_HandleTypeDef        *hdmarx;                  /*!< UART Rx DMA Handle parameters      */

  HAL_LockTypeDef           Lock;                    /*!< Locking object                     */

  __IO HAL_UART_StateTypeDef    gState;              /*!< UART state information related to global Handle management
                                                          and also related to Tx operations. This parameter
                                                          can be a value of @ref HAL_UART_StateTypeDef */

  __IO HAL_UART_StateTypeDef    RxState;             /*!< UART state information related to Rx operations. This
                                                          parameter can be a value of @ref HAL_UART_StateTypeDef */

  __IO uint32_t                 ErrorCode;           /*!< UART Error code                    */

# 288 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart.h"

} UART_HandleTypeDef;

# 322 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart.h"

/**
  * @}
  */

/* Exported constants --------------------------------------------------------*/
/** @defgroup UART_Exported_Constants UART Exported Constants
  * @{
  */

/** @defgroup UART_State_Definition UART State Code Definition
  * @{
  */
#define HAL_UART_STATE_RESET 0x00000000U

#define HAL_UART_STATE_READY 0x00000020U

#define HAL_UART_STATE_BUSY 0x00000024U

#define HAL_UART_STATE_BUSY_TX 0x00000021U

#define HAL_UART_STATE_BUSY_RX 0x00000022U

#define HAL_UART_STATE_BUSY_TX_RX 0x00000023U


#define HAL_UART_STATE_TIMEOUT 0x000000A0U

#define HAL_UART_STATE_ERROR 0x000000E0U

/**
  * @}
  */

/** @defgroup UART_Error_Definition   UART Error Definition
  * @{
  */
#define HAL_UART_ERROR_NONE (0x00000000U)
#define HAL_UART_ERROR_PE (0x00000001U)
#define HAL_UART_ERROR_NE (0x00000002U)
#define HAL_UART_ERROR_FE (0x00000004U)
#define HAL_UART_ERROR_ORE (0x00000008U)
#define HAL_UART_ERROR_DMA (0x00000010U)
#define HAL_UART_ERROR_RTO (0x00000020U)




/**
  * @}
  */

/** @defgroup UART_Stop_Bits   UART Number of Stop Bits
  * @{
  */
#define UART_STOPBITS_0_5 USART_CR2_STOP_0
#define UART_STOPBITS_1 0x00000000U
#define UART_STOPBITS_1_5 (USART_CR2_STOP_0 | USART_CR2_STOP_1)
#define UART_STOPBITS_2 USART_CR2_STOP_1
/**
  * @}
  */

/** @defgroup UART_Parity  UART Parity
  * @{
  */
#define UART_PARITY_NONE 0x00000000U
#define UART_PARITY_EVEN USART_CR1_PCE
#define UART_PARITY_ODD (USART_CR1_PCE | USART_CR1_PS)
/**
  * @}
  */

/** @defgroup UART_Hardware_Flow_Control UART Hardware Flow Control
  * @{
  */
#define UART_HWCONTROL_NONE 0x00000000U
#define UART_HWCONTROL_RTS USART_CR3_RTSE
#define UART_HWCONTROL_CTS USART_CR3_CTSE
#define UART_HWCONTROL_RTS_CTS (USART_CR3_RTSE | USART_CR3_CTSE)
/**
  * @}
  */

/** @defgroup UART_Mode UART Transfer Mode
  * @{
  */
#define UART_MODE_RX USART_CR1_RE
#define UART_MODE_TX USART_CR1_TE
#define UART_MODE_TX_RX (USART_CR1_TE |USART_CR1_RE)
/**
  * @}
  */

/** @defgroup UART_State  UART State
  * @{
  */
#define UART_STATE_DISABLE 0x00000000U
#define UART_STATE_ENABLE USART_CR1_UE
/**
  * @}
  */

/** @defgroup UART_Over_Sampling UART Over Sampling
  * @{
  */
#define UART_OVERSAMPLING_16 0x00000000U
#define UART_OVERSAMPLING_8 USART_CR1_OVER8
/**
  * @}
  */

/** @defgroup UART_OneBit_Sampling UART One Bit Sampling Method
  * @{
  */
#define UART_ONE_BIT_SAMPLE_DISABLE 0x00000000U
#define UART_ONE_BIT_SAMPLE_ENABLE USART_CR3_ONEBIT
/**
  * @}
  */

/** @defgroup UART_ClockPrescaler  UART Clock Prescaler
  * @{
  */
#define UART_PRESCALER_DIV1 0x00000000U
#define UART_PRESCALER_DIV2 0x00000001U
#define UART_PRESCALER_DIV4 0x00000002U
#define UART_PRESCALER_DIV6 0x00000003U
#define UART_PRESCALER_DIV8 0x00000004U
#define UART_PRESCALER_DIV10 0x00000005U
#define UART_PRESCALER_DIV12 0x00000006U
#define UART_PRESCALER_DIV16 0x00000007U
#define UART_PRESCALER_DIV32 0x00000008U
#define UART_PRESCALER_DIV64 0x00000009U
#define UART_PRESCALER_DIV128 0x0000000AU
#define UART_PRESCALER_DIV256 0x0000000BU
/**
  * @}
  */

/** @defgroup UART_AutoBaud_Rate_Mode    UART Advanced Feature AutoBaud Rate Mode
  * @{
  */
#define UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT 0x00000000U

#define UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE USART_CR2_ABRMODE_0

#define UART_ADVFEATURE_AUTOBAUDRATE_ON0X7FFRAME USART_CR2_ABRMODE_1

#define UART_ADVFEATURE_AUTOBAUDRATE_ON0X55FRAME USART_CR2_ABRMODE

/**
  * @}
  */

/** @defgroup UART_Receiver_Timeout UART Receiver Timeout
  * @{
  */
#define UART_RECEIVER_TIMEOUT_DISABLE 0x00000000U
#define UART_RECEIVER_TIMEOUT_ENABLE USART_CR2_RTOEN
/**
  * @}
  */

/** @defgroup UART_LIN    UART Local Interconnection Network mode
  * @{
  */
#define UART_LIN_DISABLE 0x00000000U
#define UART_LIN_ENABLE USART_CR2_LINEN
/**
  * @}
  */

/** @defgroup UART_LIN_Break_Detection  UART LIN Break Detection
  * @{
  */
#define UART_LINBREAKDETECTLENGTH_10B 0x00000000U
#define UART_LINBREAKDETECTLENGTH_11B USART_CR2_LBDL
/**
  * @}
  */

/** @defgroup UART_DMA_Tx    UART DMA Tx
  * @{
  */
#define UART_DMA_TX_DISABLE 0x00000000U
#define UART_DMA_TX_ENABLE USART_CR3_DMAT
/**
  * @}
  */

/** @defgroup UART_DMA_Rx   UART DMA Rx
  * @{
  */
#define UART_DMA_RX_DISABLE 0x00000000U
#define UART_DMA_RX_ENABLE USART_CR3_DMAR
/**
  * @}
  */

/** @defgroup UART_Half_Duplex_Selection  UART Half Duplex Selection
  * @{
  */
#define UART_HALF_DUPLEX_DISABLE 0x00000000U
#define UART_HALF_DUPLEX_ENABLE USART_CR3_HDSEL
/**
  * @}
  */

/** @defgroup UART_WakeUp_Methods   UART WakeUp Methods
  * @{
  */
#define UART_WAKEUPMETHOD_IDLELINE 0x00000000U
#define UART_WAKEUPMETHOD_ADDRESSMARK USART_CR1_WAKE
/**
  * @}
  */

/** @defgroup UART_Request_Parameters UART Request Parameters
  * @{
  */
#define UART_AUTOBAUD_REQUEST USART_RQR_ABRRQ
#define UART_SENDBREAK_REQUEST USART_RQR_SBKRQ
#define UART_MUTE_MODE_REQUEST USART_RQR_MMRQ
#define UART_RXDATA_FLUSH_REQUEST USART_RQR_RXFRQ
#define UART_TXDATA_FLUSH_REQUEST USART_RQR_TXFRQ
/**
  * @}
  */

/** @defgroup UART_Advanced_Features_Initialization_Type  UART Advanced Feature Initialization Type
  * @{
  */
#define UART_ADVFEATURE_NO_INIT 0x00000000U
#define UART_ADVFEATURE_TXINVERT_INIT 0x00000001U
#define UART_ADVFEATURE_RXINVERT_INIT 0x00000002U
#define UART_ADVFEATURE_DATAINVERT_INIT 0x00000004U
#define UART_ADVFEATURE_SWAP_INIT 0x00000008U
#define UART_ADVFEATURE_RXOVERRUNDISABLE_INIT 0x00000010U
#define UART_ADVFEATURE_DMADISABLEONERROR_INIT 0x00000020U
#define UART_ADVFEATURE_AUTOBAUDRATE_INIT 0x00000040U
#define UART_ADVFEATURE_MSBFIRST_INIT 0x00000080U
/**
  * @}
  */

/** @defgroup UART_Tx_Inv UART Advanced Feature TX Pin Active Level Inversion
  * @{
  */
#define UART_ADVFEATURE_TXINV_DISABLE 0x00000000U
#define UART_ADVFEATURE_TXINV_ENABLE USART_CR2_TXINV
/**
  * @}
  */

/** @defgroup UART_Rx_Inv UART Advanced Feature RX Pin Active Level Inversion
  * @{
  */
#define UART_ADVFEATURE_RXINV_DISABLE 0x00000000U
#define UART_ADVFEATURE_RXINV_ENABLE USART_CR2_RXINV
/**
  * @}
  */

/** @defgroup UART_Data_Inv  UART Advanced Feature Binary Data Inversion
  * @{
  */
#define UART_ADVFEATURE_DATAINV_DISABLE 0x00000000U
#define UART_ADVFEATURE_DATAINV_ENABLE USART_CR2_DATAINV
/**
  * @}
  */

/** @defgroup UART_Rx_Tx_Swap UART Advanced Feature RX TX Pins Swap
  * @{
  */
#define UART_ADVFEATURE_SWAP_DISABLE 0x00000000U
#define UART_ADVFEATURE_SWAP_ENABLE USART_CR2_SWAP
/**
  * @}
  */

/** @defgroup UART_Overrun_Disable  UART Advanced Feature Overrun Disable
  * @{
  */
#define UART_ADVFEATURE_OVERRUN_ENABLE 0x00000000U
#define UART_ADVFEATURE_OVERRUN_DISABLE USART_CR3_OVRDIS
/**
  * @}
  */

/** @defgroup UART_AutoBaudRate_Enable  UART Advanced Feature Auto BaudRate Enable
  * @{
  */
#define UART_ADVFEATURE_AUTOBAUDRATE_DISABLE 0x00000000U
#define UART_ADVFEATURE_AUTOBAUDRATE_ENABLE USART_CR2_ABREN
/**
  * @}
  */

/** @defgroup UART_DMA_Disable_on_Rx_Error   UART Advanced Feature DMA Disable On Rx Error
  * @{
  */
#define UART_ADVFEATURE_DMA_ENABLEONRXERROR 0x00000000U
#define UART_ADVFEATURE_DMA_DISABLEONRXERROR USART_CR3_DDRE
/**
  * @}
  */

/** @defgroup UART_MSB_First   UART Advanced Feature MSB First
  * @{
  */
#define UART_ADVFEATURE_MSBFIRST_DISABLE 0x00000000U

#define UART_ADVFEATURE_MSBFIRST_ENABLE USART_CR2_MSBFIRST

/**
  * @}
  */

/** @defgroup UART_Stop_Mode_Enable   UART Advanced Feature Stop Mode Enable
  * @{
  */
#define UART_ADVFEATURE_STOPMODE_DISABLE 0x00000000U
#define UART_ADVFEATURE_STOPMODE_ENABLE USART_CR1_UESM
/**
  * @}
  */

/** @defgroup UART_Mute_Mode   UART Advanced Feature Mute Mode Enable
  * @{
  */
#define UART_ADVFEATURE_MUTEMODE_DISABLE 0x00000000U
#define UART_ADVFEATURE_MUTEMODE_ENABLE USART_CR1_MME
/**
  * @}
  */

/** @defgroup UART_CR2_ADDRESS_LSB_POS    UART Address-matching LSB Position In CR2 Register
  * @{
  */
#define UART_CR2_ADDRESS_LSB_POS 24U
/**
  * @}
  */

/** @defgroup UART_WakeUp_from_Stop_Selection   UART WakeUp From Stop Selection
  * @{
  */
#define UART_WAKEUP_ON_ADDRESS 0x00000000U
#define UART_WAKEUP_ON_STARTBIT USART_CR3_WUS_1
#define UART_WAKEUP_ON_READDATA_NONEMPTY USART_CR3_WUS

/**
  * @}
  */

/** @defgroup UART_DriverEnable_Polarity      UART DriverEnable Polarity
  * @{
  */
#define UART_DE_POLARITY_HIGH 0x00000000U
#define UART_DE_POLARITY_LOW USART_CR3_DEP
/**
  * @}
  */

/** @defgroup UART_CR1_DEAT_ADDRESS_LSB_POS    UART Driver Enable Assertion Time LSB Position In CR1 Register
  * @{
  */
#define UART_CR1_DEAT_ADDRESS_LSB_POS 21U

/**
  * @}
  */

/** @defgroup UART_CR1_DEDT_ADDRESS_LSB_POS    UART Driver Enable DeAssertion Time LSB Position In CR1 Register
  * @{
  */
#define UART_CR1_DEDT_ADDRESS_LSB_POS 16U

/**
  * @}
  */

/** @defgroup UART_Interruption_Mask    UART Interruptions Flag Mask
  * @{
  */
#define UART_IT_MASK 0x001FU
/**
  * @}
  */

/** @defgroup UART_TimeOut_Value    UART polling-based communications time-out value
  * @{
  */
#define HAL_UART_TIMEOUT_VALUE 0x1FFFFFFU
/**
  * @}
  */

/** @defgroup UART_Flags     UART Status Flags
  *        Elements values convention: 0xXXXX
  *           - 0xXXXX  : Flag mask in the ISR register
  * @{
  */
#define UART_FLAG_TXFT USART_ISR_TXFT
#define UART_FLAG_RXFT USART_ISR_RXFT
#define UART_FLAG_RXFF USART_ISR_RXFF
#define UART_FLAG_TXFE USART_ISR_TXFE
#define UART_FLAG_REACK USART_ISR_REACK
#define UART_FLAG_TEACK USART_ISR_TEACK
#define UART_FLAG_WUF USART_ISR_WUF
#define UART_FLAG_RWU USART_ISR_RWU
#define UART_FLAG_SBKF USART_ISR_SBKF
#define UART_FLAG_CMF USART_ISR_CMF
#define UART_FLAG_BUSY USART_ISR_BUSY
#define UART_FLAG_ABRF USART_ISR_ABRF
#define UART_FLAG_ABRE USART_ISR_ABRE
#define UART_FLAG_RTOF USART_ISR_RTOF
#define UART_FLAG_CTS USART_ISR_CTS
#define UART_FLAG_CTSIF USART_ISR_CTSIF
#define UART_FLAG_LBDF USART_ISR_LBDF
#define UART_FLAG_TXE USART_ISR_TXE_TXFNF
#define UART_FLAG_TXFNF USART_ISR_TXE_TXFNF
#define UART_FLAG_TC USART_ISR_TC
#define UART_FLAG_RXNE USART_ISR_RXNE_RXFNE
#define UART_FLAG_RXFNE USART_ISR_RXNE_RXFNE
#define UART_FLAG_IDLE USART_ISR_IDLE
#define UART_FLAG_ORE USART_ISR_ORE
#define UART_FLAG_NE USART_ISR_NE
#define UART_FLAG_FE USART_ISR_FE
#define UART_FLAG_PE USART_ISR_PE
/**
  * @}
  */

/** @defgroup UART_Interrupt_definition   UART Interrupts Definition
  *        Elements values convention: 000ZZZZZ0XXYYYYYb
  *           - YYYYY  : Interrupt source position in the XX register (5bits)
  *           - XX  : Interrupt source register (2bits)
  *                 - 01: CR1 register
  *                 - 10: CR2 register
  *                 - 11: CR3 register
  *           - ZZZZZ  : Flag position in the ISR register(5bits)
  *        Elements values convention: 000000000XXYYYYYb
  *           - YYYYY  : Interrupt source position in the XX register (5bits)
  *           - XX  : Interrupt source register (2bits)
  *                 - 01: CR1 register
  *                 - 10: CR2 register
  *                 - 11: CR3 register
  *        Elements values convention: 0000ZZZZ00000000b
  *           - ZZZZ  : Flag position in the ISR register(4bits)
  * @{
  */
#define UART_IT_PE 0x0028U
#define UART_IT_TXE 0x0727U
#define UART_IT_TXFNF 0x0727U
#define UART_IT_TC 0x0626U
#define UART_IT_RXNE 0x0525U
#define UART_IT_RXFNE 0x0525U
#define UART_IT_IDLE 0x0424U
#define UART_IT_LBD 0x0846U
#define UART_IT_CTS 0x096AU
#define UART_IT_CM 0x112EU
#define UART_IT_WUF 0x1476U
#define UART_IT_RXFF 0x183FU
#define UART_IT_TXFE 0x173EU
#define UART_IT_RXFT 0x1A7CU
#define UART_IT_TXFT 0x1B77U
#define UART_IT_RTO 0x0B3AU

#define UART_IT_ERR 0x0060U

#define UART_IT_ORE 0x0300U
#define UART_IT_NE 0x0200U
#define UART_IT_FE 0x0100U
/**
  * @}
  */

/** @defgroup UART_IT_CLEAR_Flags  UART Interruption Clear Flags
  * @{
  */
#define UART_CLEAR_PEF USART_ICR_PECF
#define UART_CLEAR_FEF USART_ICR_FECF
#define UART_CLEAR_NEF USART_ICR_NECF
#define UART_CLEAR_OREF USART_ICR_ORECF
#define UART_CLEAR_IDLEF USART_ICR_IDLECF
#define UART_CLEAR_TXFECF USART_ICR_TXFECF
#define UART_CLEAR_TCF USART_ICR_TCCF
#define UART_CLEAR_LBDF USART_ICR_LBDCF
#define UART_CLEAR_CTSF USART_ICR_CTSCF
#define UART_CLEAR_CMF USART_ICR_CMCF
#define UART_CLEAR_WUF USART_ICR_WUCF
#define UART_CLEAR_RTOF USART_ICR_RTOCF
/**
  * @}
  */

/** @defgroup UART_Reception_Type_Values  UART Reception type values
  * @{
  */
#define HAL_UART_RECEPTION_STANDARD (0x00000000U)
#define HAL_UART_RECEPTION_TOIDLE (0x00000001U)
#define HAL_UART_RECEPTION_TORTO (0x00000002U)
#define HAL_UART_RECEPTION_TOCHARMATCH (0x00000003U)
/**
  * @}
  */

/** @defgroup UART_RxEvent_Type_Values  UART RxEvent type values
  * @{
  */
#define HAL_UART_RXEVENT_TC (0x00000000U)
#define HAL_UART_RXEVENT_HT (0x00000001U)
#define HAL_UART_RXEVENT_IDLE (0x00000002U)
/**
  * @}
  */

/**
  * @}
  */

/* Exported macros -----------------------------------------------------------*/
/** @defgroup UART_Exported_Macros UART Exported Macros
  * @{
  */

/** @brief  Reset UART handle states.
  * @param  __HANDLE__ UART handle.
  * @retval None
  */
# 863 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart.h"
#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__) do{ (__HANDLE__)->gState = HAL_UART_STATE_RESET; (__HANDLE__)->RxState = HAL_UART_STATE_RESET; } while(0U)





/** @brief  Flush the UART Data registers.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_FLUSH_DRREGISTER(__HANDLE__) do{ SET_BIT((__HANDLE__)->Instance->RQR, UART_RXDATA_FLUSH_REQUEST); SET_BIT((__HANDLE__)->Instance->RQR, UART_TXDATA_FLUSH_REQUEST); } while(0U)





/** @brief  Clear the specified UART pending flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __FLAG__ specifies the flag to check.
  *          This parameter can be any combination of the following values:
  *            @arg @ref UART_CLEAR_PEF      Parity Error Clear Flag
  *            @arg @ref UART_CLEAR_FEF      Framing Error Clear Flag
  *            @arg @ref UART_CLEAR_NEF      Noise detected Clear Flag
  *            @arg @ref UART_CLEAR_OREF     Overrun Error Clear Flag
  *            @arg @ref UART_CLEAR_IDLEF    IDLE line detected Clear Flag
  *            @arg @ref UART_CLEAR_TXFECF   TXFIFO empty clear Flag
  *            @arg @ref UART_CLEAR_TCF      Transmission Complete Clear Flag
  *            @arg @ref UART_CLEAR_RTOF     Receiver Timeout clear flag
  *            @arg @ref UART_CLEAR_LBDF     LIN Break Detection Clear Flag
  *            @arg @ref UART_CLEAR_CTSF     CTS Interrupt Clear Flag
  *            @arg @ref UART_CLEAR_CMF      Character Match Clear Flag
  *            @arg @ref UART_CLEAR_WUF      Wake Up from stop mode Clear Flag
  * @retval None
  */
#define __HAL_UART_CLEAR_FLAG(__HANDLE__,__FLAG__) ((__HANDLE__)->Instance->ICR = (__FLAG__))

/** @brief  Clear the UART PE pending flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_CLEAR_PEFLAG(__HANDLE__) __HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_PEF)

/** @brief  Clear the UART FE pending flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_CLEAR_FEFLAG(__HANDLE__) __HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_FEF)

/** @brief  Clear the UART NE pending flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_CLEAR_NEFLAG(__HANDLE__) __HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_NEF)

/** @brief  Clear the UART ORE pending flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_CLEAR_OREFLAG(__HANDLE__) __HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_OREF)

/** @brief  Clear the UART IDLE pending flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_CLEAR_IDLEFLAG(__HANDLE__) __HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_IDLEF)

/** @brief  Clear the UART TX FIFO empty clear flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_CLEAR_TXFECF(__HANDLE__) __HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_TXFECF)

/** @brief  Check whether the specified UART flag is set or not.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __FLAG__ specifies the flag to check.
  *        This parameter can be one of the following values:
  *            @arg @ref UART_FLAG_TXFT  TXFIFO threshold flag
  *            @arg @ref UART_FLAG_RXFT  RXFIFO threshold flag
  *            @arg @ref UART_FLAG_RXFF  RXFIFO Full flag
  *            @arg @ref UART_FLAG_TXFE  TXFIFO Empty flag
  *            @arg @ref UART_FLAG_REACK Receive enable acknowledge flag
  *            @arg @ref UART_FLAG_TEACK Transmit enable acknowledge flag
  *            @arg @ref UART_FLAG_WUF   Wake up from stop mode flag
  *            @arg @ref UART_FLAG_RWU   Receiver wake up flag (if the UART in mute mode)
  *            @arg @ref UART_FLAG_SBKF  Send Break flag
  *            @arg @ref UART_FLAG_CMF   Character match flag
  *            @arg @ref UART_FLAG_BUSY  Busy flag
  *            @arg @ref UART_FLAG_ABRF  Auto Baud rate detection flag
  *            @arg @ref UART_FLAG_ABRE  Auto Baud rate detection error flag
  *            @arg @ref UART_FLAG_CTS   CTS Change flag
  *            @arg @ref UART_FLAG_LBDF  LIN Break detection flag
  *            @arg @ref UART_FLAG_TXE   Transmit data register empty flag
  *            @arg @ref UART_FLAG_TXFNF UART TXFIFO not full flag
  *            @arg @ref UART_FLAG_TC    Transmission Complete flag
  *            @arg @ref UART_FLAG_RXNE  Receive data register not empty flag
  *            @arg @ref UART_FLAG_RXFNE UART RXFIFO not empty flag
  *            @arg @ref UART_FLAG_RTOF  Receiver Timeout flag
  *            @arg @ref UART_FLAG_IDLE  Idle Line detection flag
  *            @arg @ref UART_FLAG_ORE   Overrun Error flag
  *            @arg @ref UART_FLAG_NE    Noise Error flag
  *            @arg @ref UART_FLAG_FE    Framing Error flag
  *            @arg @ref UART_FLAG_PE    Parity Error flag
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  */
#define __HAL_UART_GET_FLAG(__HANDLE__,__FLAG__) (((__HANDLE__)->Instance->ISR & (__FLAG__)) == (__FLAG__))

/** @brief  Enable the specified UART interrupt.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __INTERRUPT__ specifies the UART interrupt source to enable.
  *          This parameter can be one of the following values:
  *            @arg @ref UART_IT_RXFF  RXFIFO Full interrupt
  *            @arg @ref UART_IT_TXFE  TXFIFO Empty interrupt
  *            @arg @ref UART_IT_RXFT  RXFIFO threshold interrupt
  *            @arg @ref UART_IT_TXFT  TXFIFO threshold interrupt
  *            @arg @ref UART_IT_WUF   Wakeup from stop mode interrupt
  *            @arg @ref UART_IT_CM    Character match interrupt
  *            @arg @ref UART_IT_CTS   CTS change interrupt
  *            @arg @ref UART_IT_LBD   LIN Break detection interrupt
  *            @arg @ref UART_IT_TXE   Transmit Data Register empty interrupt
  *            @arg @ref UART_IT_TXFNF TX FIFO not full interrupt
  *            @arg @ref UART_IT_TC    Transmission complete interrupt
  *            @arg @ref UART_IT_RXNE  Receive Data register not empty interrupt
  *            @arg @ref UART_IT_RXFNE RXFIFO not empty interrupt
  *            @arg @ref UART_IT_RTO   Receive Timeout interrupt
  *            @arg @ref UART_IT_IDLE  Idle line detection interrupt
  *            @arg @ref UART_IT_PE    Parity Error interrupt
  *            @arg @ref UART_IT_ERR   Error interrupt (frame error, noise error, overrun error)
  * @retval None
  */
#define __HAL_UART_ENABLE_IT(__HANDLE__,__INTERRUPT__) ( ((((uint8_t)(__INTERRUPT__)) >> 5U) == 1U)? ((__HANDLE__)->Instance->CR1 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))): ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2U)? ((__HANDLE__)->Instance->CR2 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))): ((__HANDLE__)->Instance->CR3 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))))
# 1001 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart.h"

/** @brief  Disable the specified UART interrupt.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __INTERRUPT__ specifies the UART interrupt source to disable.
  *          This parameter can be one of the following values:
  *            @arg @ref UART_IT_RXFF  RXFIFO Full interrupt
  *            @arg @ref UART_IT_TXFE  TXFIFO Empty interrupt
  *            @arg @ref UART_IT_RXFT  RXFIFO threshold interrupt
  *            @arg @ref UART_IT_TXFT  TXFIFO threshold interrupt
  *            @arg @ref UART_IT_WUF   Wakeup from stop mode interrupt
  *            @arg @ref UART_IT_CM    Character match interrupt
  *            @arg @ref UART_IT_CTS   CTS change interrupt
  *            @arg @ref UART_IT_LBD   LIN Break detection interrupt
  *            @arg @ref UART_IT_TXE   Transmit Data Register empty interrupt
  *            @arg @ref UART_IT_TXFNF TX FIFO not full interrupt
  *            @arg @ref UART_IT_TC    Transmission complete interrupt
  *            @arg @ref UART_IT_RXNE  Receive Data register not empty interrupt
  *            @arg @ref UART_IT_RXFNE RXFIFO not empty interrupt
  *            @arg @ref UART_IT_RTO   Receive Timeout interrupt
  *            @arg @ref UART_IT_IDLE  Idle line detection interrupt
  *            @arg @ref UART_IT_PE    Parity Error interrupt
  *            @arg @ref UART_IT_ERR   Error interrupt (Frame error, noise error, overrun error)
  * @retval None
  */
#define __HAL_UART_DISABLE_IT(__HANDLE__,__INTERRUPT__) ( ((((uint8_t)(__INTERRUPT__)) >> 5U) == 1U)? ((__HANDLE__)->Instance->CR1 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))): ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2U)? ((__HANDLE__)->Instance->CR2 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))): ((__HANDLE__)->Instance->CR3 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))))
# 1034 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart.h"

/** @brief  Check whether the specified UART interrupt has occurred or not.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __INTERRUPT__ specifies the UART interrupt to check.
  *          This parameter can be one of the following values:
  *            @arg @ref UART_IT_RXFF  RXFIFO Full interrupt
  *            @arg @ref UART_IT_TXFE  TXFIFO Empty interrupt
  *            @arg @ref UART_IT_RXFT  RXFIFO threshold interrupt
  *            @arg @ref UART_IT_TXFT  TXFIFO threshold interrupt
  *            @arg @ref UART_IT_WUF   Wakeup from stop mode interrupt
  *            @arg @ref UART_IT_CM    Character match interrupt
  *            @arg @ref UART_IT_CTS   CTS change interrupt
  *            @arg @ref UART_IT_LBD   LIN Break detection interrupt
  *            @arg @ref UART_IT_TXE   Transmit Data Register empty interrupt
  *            @arg @ref UART_IT_TXFNF TX FIFO not full interrupt
  *            @arg @ref UART_IT_TC    Transmission complete interrupt
  *            @arg @ref UART_IT_RXNE  Receive Data register not empty interrupt
  *            @arg @ref UART_IT_RXFNE RXFIFO not empty interrupt
  *            @arg @ref UART_IT_RTO   Receive Timeout interrupt
  *            @arg @ref UART_IT_IDLE  Idle line detection interrupt
  *            @arg @ref UART_IT_PE    Parity Error interrupt
  *            @arg @ref UART_IT_ERR   Error interrupt (Frame error, noise error, overrun error)
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  */
#define __HAL_UART_GET_IT(__HANDLE__,__INTERRUPT__) ((((__HANDLE__)->Instance->ISR & (1U << ((__INTERRUPT__)>> 8U))) != RESET) ? SET : RESET)


/** @brief  Check whether the specified UART interrupt source is enabled or not.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __INTERRUPT__ specifies the UART interrupt source to check.
  *          This parameter can be one of the following values:
  *            @arg @ref UART_IT_RXFF  RXFIFO Full interrupt
  *            @arg @ref UART_IT_TXFE  TXFIFO Empty interrupt
  *            @arg @ref UART_IT_RXFT  RXFIFO threshold interrupt
  *            @arg @ref UART_IT_TXFT  TXFIFO threshold interrupt
  *            @arg @ref UART_IT_WUF   Wakeup from stop mode interrupt
  *            @arg @ref UART_IT_CM    Character match interrupt
  *            @arg @ref UART_IT_CTS   CTS change interrupt
  *            @arg @ref UART_IT_LBD   LIN Break detection interrupt
  *            @arg @ref UART_IT_TXE   Transmit Data Register empty interrupt
  *            @arg @ref UART_IT_TXFNF TX FIFO not full interrupt
  *            @arg @ref UART_IT_TC    Transmission complete interrupt
  *            @arg @ref UART_IT_RXNE  Receive Data register not empty interrupt
  *            @arg @ref UART_IT_RXFNE RXFIFO not empty interrupt
  *            @arg @ref UART_IT_RTO   Receive Timeout interrupt
  *            @arg @ref UART_IT_IDLE  Idle line detection interrupt
  *            @arg @ref UART_IT_PE    Parity Error interrupt
  *            @arg @ref UART_IT_ERR   Error interrupt (Frame error, noise error, overrun error)
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  */
#define __HAL_UART_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__) ((((((((uint8_t)(__INTERRUPT__)) >> 5U) == 1U) ? (__HANDLE__)->Instance->CR1 : (((((uint8_t)(__INTERRUPT__)) >> 5U) == 2U) ? (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & (1U << (((uint16_t)(__INTERRUPT__)) & UART_IT_MASK))) != RESET) ? SET : RESET)







/** @brief  Clear the specified UART ISR flag, in setting the proper ICR register flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __IT_CLEAR__ specifies the interrupt clear register flag that needs to be set
  *                       to clear the corresponding interrupt
  *          This parameter can be one of the following values:
  *            @arg @ref UART_CLEAR_PEF    Parity Error Clear Flag
  *            @arg @ref UART_CLEAR_FEF    Framing Error Clear Flag
  *            @arg @ref UART_CLEAR_NEF    Noise detected Clear Flag
  *            @arg @ref UART_CLEAR_OREF   Overrun Error Clear Flag
  *            @arg @ref UART_CLEAR_IDLEF  IDLE line detected Clear Flag
  *            @arg @ref UART_CLEAR_RTOF   Receiver timeout clear flag
  *            @arg @ref UART_CLEAR_TXFECF TXFIFO empty Clear Flag
  *            @arg @ref UART_CLEAR_TCF    Transmission Complete Clear Flag
  *            @arg @ref UART_CLEAR_LBDF   LIN Break Detection Clear Flag
  *            @arg @ref UART_CLEAR_CTSF   CTS Interrupt Clear Flag
  *            @arg @ref UART_CLEAR_CMF    Character Match Clear Flag
  *            @arg @ref UART_CLEAR_WUF    Wake Up from stop mode Clear Flag
  * @retval None
  */
#define __HAL_UART_CLEAR_IT(__HANDLE__,__IT_CLEAR__) ((__HANDLE__)->Instance->ICR = (uint32_t)(__IT_CLEAR__))

/** @brief  Set a specific UART request flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __REQ__ specifies the request flag to set
  *          This parameter can be one of the following values:
  *            @arg @ref UART_AUTOBAUD_REQUEST Auto-Baud Rate Request
  *            @arg @ref UART_SENDBREAK_REQUEST Send Break Request
  *            @arg @ref UART_MUTE_MODE_REQUEST Mute Mode Request
  *            @arg @ref UART_RXDATA_FLUSH_REQUEST Receive Data flush Request
  *            @arg @ref UART_TXDATA_FLUSH_REQUEST Transmit data flush Request
  * @retval None
  */
#define __HAL_UART_SEND_REQ(__HANDLE__,__REQ__) ((__HANDLE__)->Instance->RQR |= (uint16_t)(__REQ__))

/** @brief  Enable the UART one bit sample method.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_ONE_BIT_SAMPLE_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR3|= USART_CR3_ONEBIT)

/** @brief  Disable the UART one bit sample method.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_ONE_BIT_SAMPLE_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR3 &= ~USART_CR3_ONEBIT)

/** @brief  Enable UART.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR1 |= USART_CR1_UE)

/** @brief  Disable UART.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR1 &= ~USART_CR1_UE)

/** @brief  Enable CTS flow control.
  * @note   This macro allows to enable CTS hardware flow control for a given UART instance,
  *         without need to call HAL_UART_Init() function.
  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
  * @note   As macro is expected to be used for modifying CTS Hw flow control feature activation, without need
  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
  *           - macro could only be called when corresponding UART instance is disabled
  *             (i.e. __HAL_UART_DISABLE(__HANDLE__)) and should be followed by an Enable
  *              macro (i.e. __HAL_UART_ENABLE(__HANDLE__)).
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_HWCONTROL_CTS_ENABLE(__HANDLE__) do{ ATOMIC_SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE); (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_CTSE; } while(0U)





/** @brief  Disable CTS flow control.
  * @note   This macro allows to disable CTS hardware flow control for a given UART instance,
  *         without need to call HAL_UART_Init() function.
  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
  * @note   As macro is expected to be used for modifying CTS Hw flow control feature activation, without need
  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
  *           - macro could only be called when corresponding UART instance is disabled
  *             (i.e. __HAL_UART_DISABLE(__HANDLE__)) and should be followed by an Enable
  *              macro (i.e. __HAL_UART_ENABLE(__HANDLE__)).
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_HWCONTROL_CTS_DISABLE(__HANDLE__) do{ ATOMIC_CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE); (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_CTSE); } while(0U)





/** @brief  Enable RTS flow control.
  * @note   This macro allows to enable RTS hardware flow control for a given UART instance,
  *         without need to call HAL_UART_Init() function.
  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
  * @note   As macro is expected to be used for modifying RTS Hw flow control feature activation, without need
  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
  *           - macro could only be called when corresponding UART instance is disabled
  *             (i.e. __HAL_UART_DISABLE(__HANDLE__)) and should be followed by an Enable
  *              macro (i.e. __HAL_UART_ENABLE(__HANDLE__)).
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_HWCONTROL_RTS_ENABLE(__HANDLE__) do{ ATOMIC_SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE); (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_RTSE; } while(0U)





/** @brief  Disable RTS flow control.
  * @note   This macro allows to disable RTS hardware flow control for a given UART instance,
  *         without need to call HAL_UART_Init() function.
  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
  * @note   As macro is expected to be used for modifying RTS Hw flow control feature activation, without need
  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
  *           - macro could only be called when corresponding UART instance is disabled
  *             (i.e. __HAL_UART_DISABLE(__HANDLE__)) and should be followed by an Enable
  *              macro (i.e. __HAL_UART_ENABLE(__HANDLE__)).
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  */
#define __HAL_UART_HWCONTROL_RTS_DISABLE(__HANDLE__) do{ ATOMIC_CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE); (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_RTSE); } while(0U)




/**
  * @}
  */

/* Private macros --------------------------------------------------------*/
/** @defgroup UART_Private_Macros   UART Private Macros
  * @{
  */
/** @brief  Get UART clock division factor from clock prescaler value.
  * @param  __CLOCKPRESCALER__ UART prescaler value.
  * @retval UART clock division factor
  */
#define UART_GET_DIV_FACTOR(__CLOCKPRESCALER__) (((__CLOCKPRESCALER__) == UART_PRESCALER_DIV1) ? 1U : ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV2) ? 2U : ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV4) ? 4U : ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV6) ? 6U : ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV8) ? 8U : ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV10) ? 10U : ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV12) ? 12U : ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV16) ? 16U : ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV32) ? 32U : ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV64) ? 64U : ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV128) ? 128U : 256U)
# 1249 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart.h"

/** @brief  BRR division operation to set BRR register with LPUART.
  * @param  __PCLK__ LPUART clock.
  * @param  __BAUD__ Baud rate set by the user.
  * @param  __CLOCKPRESCALER__ UART prescaler value.
  * @retval Division result
  */
#define UART_DIV_LPUART(__PCLK__,__BAUD__,__CLOCKPRESCALER__) ((uint32_t)((((((uint64_t)(__PCLK__))/(UARTPrescTable[(__CLOCKPRESCALER__)]))*256U)+ (uint32_t)((__BAUD__)/2U)) / (__BAUD__)) )




/** @brief  BRR division operation to set BRR register in 8-bit oversampling mode.
  * @param  __PCLK__ UART clock.
  * @param  __BAUD__ Baud rate set by the user.
  * @param  __CLOCKPRESCALER__ UART prescaler value.
  * @retval Division result
  */
#define UART_DIV_SAMPLING8(__PCLK__,__BAUD__,__CLOCKPRESCALER__) (((((__PCLK__)/UARTPrescTable[(__CLOCKPRESCALER__)])*2U) + ((__BAUD__)/2U)) / (__BAUD__))


/** @brief  BRR division operation to set BRR register in 16-bit oversampling mode.
  * @param  __PCLK__ UART clock.
  * @param  __BAUD__ Baud rate set by the user.
  * @param  __CLOCKPRESCALER__ UART prescaler value.
  * @retval Division result
  */
#define UART_DIV_SAMPLING16(__PCLK__,__BAUD__,__CLOCKPRESCALER__) ((((__PCLK__)/UARTPrescTable[(__CLOCKPRESCALER__)]) + ((__BAUD__)/2U)) / (__BAUD__))


/** @brief  Check whether or not UART instance is Low Power UART.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval SET (instance is LPUART) or RESET (instance isn't LPUART)
  */
#define UART_INSTANCE_LOWPOWER(__HANDLE__) (IS_LPUART_INSTANCE((__HANDLE__)->Instance))

/** @brief  Check UART Baud rate.
  * @param  __BAUDRATE__ Baudrate specified by the user.
  *         The maximum Baud Rate is derived from the maximum clock on G4 (i.e. 150 MHz)
  *         divided by the smallest oversampling used on the USART (i.e. 8)
  * @retval SET (__BAUDRATE__ is valid) or RESET (__BAUDRATE__ is invalid)
  */
#define IS_UART_BAUDRATE(__BAUDRATE__) ((__BAUDRATE__) < 18750001U)

/** @brief  Check UART assertion time.
  * @param  __TIME__ 5-bit value assertion time.
  * @retval Test result (TRUE or FALSE).
  */
#define IS_UART_ASSERTIONTIME(__TIME__) ((__TIME__) <= 0x1FU)

/** @brief  Check UART deassertion time.
  * @param  __TIME__ 5-bit value deassertion time.
  * @retval Test result (TRUE or FALSE).
  */
#define IS_UART_DEASSERTIONTIME(__TIME__) ((__TIME__) <= 0x1FU)

/**
  * @brief Ensure that UART frame number of stop bits is valid.
  * @param __STOPBITS__ UART frame number of stop bits.
  * @retval SET (__STOPBITS__ is valid) or RESET (__STOPBITS__ is invalid)
  */
#define IS_UART_STOPBITS(__STOPBITS__) (((__STOPBITS__) == UART_STOPBITS_0_5) || ((__STOPBITS__) == UART_STOPBITS_1) || ((__STOPBITS__) == UART_STOPBITS_1_5) || ((__STOPBITS__) == UART_STOPBITS_2))




/**
  * @brief Ensure that LPUART frame number of stop bits is valid.
  * @param __STOPBITS__ LPUART frame number of stop bits.
  * @retval SET (__STOPBITS__ is valid) or RESET (__STOPBITS__ is invalid)
  */
#define IS_LPUART_STOPBITS(__STOPBITS__) (((__STOPBITS__) == UART_STOPBITS_1) || ((__STOPBITS__) == UART_STOPBITS_2))


/**
  * @brief Ensure that UART frame parity is valid.
  * @param __PARITY__ UART frame parity.
  * @retval SET (__PARITY__ is valid) or RESET (__PARITY__ is invalid)
  */
#define IS_UART_PARITY(__PARITY__) (((__PARITY__) == UART_PARITY_NONE) || ((__PARITY__) == UART_PARITY_EVEN) || ((__PARITY__) == UART_PARITY_ODD))



/**
  * @brief Ensure that UART hardware flow control is valid.
  * @param __CONTROL__ UART hardware flow control.
  * @retval SET (__CONTROL__ is valid) or RESET (__CONTROL__ is invalid)
  */
#define IS_UART_HARDWARE_FLOW_CONTROL(__CONTROL__) (((__CONTROL__) == UART_HWCONTROL_NONE) || ((__CONTROL__) == UART_HWCONTROL_RTS) || ((__CONTROL__) == UART_HWCONTROL_CTS) || ((__CONTROL__) == UART_HWCONTROL_RTS_CTS))





/**
  * @brief Ensure that UART communication mode is valid.
  * @param __MODE__ UART communication mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_UART_MODE(__MODE__) ((((__MODE__) & (~((uint32_t)(UART_MODE_TX_RX)))) == 0x00U) && ((__MODE__) != 0x00U))

/**
  * @brief Ensure that UART state is valid.
  * @param __STATE__ UART state.
  * @retval SET (__STATE__ is valid) or RESET (__STATE__ is invalid)
  */
#define IS_UART_STATE(__STATE__) (((__STATE__) == UART_STATE_DISABLE) || ((__STATE__) == UART_STATE_ENABLE))


/**
  * @brief Ensure that UART oversampling is valid.
  * @param __SAMPLING__ UART oversampling.
  * @retval SET (__SAMPLING__ is valid) or RESET (__SAMPLING__ is invalid)
  */
#define IS_UART_OVERSAMPLING(__SAMPLING__) (((__SAMPLING__) == UART_OVERSAMPLING_16) || ((__SAMPLING__) == UART_OVERSAMPLING_8))


/**
  * @brief Ensure that UART frame sampling is valid.
  * @param __ONEBIT__ UART frame sampling.
  * @retval SET (__ONEBIT__ is valid) or RESET (__ONEBIT__ is invalid)
  */
#define IS_UART_ONE_BIT_SAMPLE(__ONEBIT__) (((__ONEBIT__) == UART_ONE_BIT_SAMPLE_DISABLE) || ((__ONEBIT__) == UART_ONE_BIT_SAMPLE_ENABLE))


/**
  * @brief Ensure that UART auto Baud rate detection mode is valid.
  * @param __MODE__ UART auto Baud rate detection mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  */
#define IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(__MODE__) (((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT) || ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE) || ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ON0X7FFRAME) || ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ON0X55FRAME))




/**
  * @brief Ensure that UART receiver timeout setting is valid.
  * @param __TIMEOUT__ UART receiver timeout setting.
  * @retval SET (__TIMEOUT__ is valid) or RESET (__TIMEOUT__ is invalid)
  */
#define IS_UART_RECEIVER_TIMEOUT(__TIMEOUT__) (((__TIMEOUT__) == UART_RECEIVER_TIMEOUT_DISABLE) || ((__TIMEOUT__) == UART_RECEIVER_TIMEOUT_ENABLE))


/** @brief  Check the receiver timeout value.
  * @note   The maximum UART receiver timeout value is 0xFFFFFF.
  * @param  __TIMEOUTVALUE__ receiver timeout value.
  * @retval Test result (TRUE or FALSE)
  */
#define IS_UART_RECEIVER_TIMEOUT_VALUE(__TIMEOUTVALUE__) ((__TIMEOUTVALUE__) <= 0xFFFFFFU)

/**
  * @brief Ensure that UART LIN state is valid.
  * @param __LIN__ UART LIN state.
  * @retval SET (__LIN__ is valid) or RESET (__LIN__ is invalid)
  */
#define IS_UART_LIN(__LIN__) (((__LIN__) == UART_LIN_DISABLE) || ((__LIN__) == UART_LIN_ENABLE))


/**
  * @brief Ensure that UART LIN break detection length is valid.
  * @param __LENGTH__ UART LIN break detection length.
  * @retval SET (__LENGTH__ is valid) or RESET (__LENGTH__ is invalid)
  */
#define IS_UART_LIN_BREAK_DETECT_LENGTH(__LENGTH__) (((__LENGTH__) == UART_LINBREAKDETECTLENGTH_10B) || ((__LENGTH__) == UART_LINBREAKDETECTLENGTH_11B))


/**
  * @brief Ensure that UART DMA TX state is valid.
  * @param __DMATX__ UART DMA TX state.
  * @retval SET (__DMATX__ is valid) or RESET (__DMATX__ is invalid)
  */
#define IS_UART_DMA_TX(__DMATX__) (((__DMATX__) == UART_DMA_TX_DISABLE) || ((__DMATX__) == UART_DMA_TX_ENABLE))


/**
  * @brief Ensure that UART DMA RX state is valid.
  * @param __DMARX__ UART DMA RX state.
  * @retval SET (__DMARX__ is valid) or RESET (__DMARX__ is invalid)
  */
#define IS_UART_DMA_RX(__DMARX__) (((__DMARX__) == UART_DMA_RX_DISABLE) || ((__DMARX__) == UART_DMA_RX_ENABLE))


/**
  * @brief Ensure that UART half-duplex state is valid.
  * @param __HDSEL__ UART half-duplex state.
  * @retval SET (__HDSEL__ is valid) or RESET (__HDSEL__ is invalid)
  */
#define IS_UART_HALF_DUPLEX(__HDSEL__) (((__HDSEL__) == UART_HALF_DUPLEX_DISABLE) || ((__HDSEL__) == UART_HALF_DUPLEX_ENABLE))


/**
  * @brief Ensure that UART wake-up method is valid.
  * @param __WAKEUP__ UART wake-up method .
  * @retval SET (__WAKEUP__ is valid) or RESET (__WAKEUP__ is invalid)
  */
#define IS_UART_WAKEUPMETHOD(__WAKEUP__) (((__WAKEUP__) == UART_WAKEUPMETHOD_IDLELINE) || ((__WAKEUP__) == UART_WAKEUPMETHOD_ADDRESSMARK))


/**
  * @brief Ensure that UART request parameter is valid.
  * @param __PARAM__ UART request parameter.
  * @retval SET (__PARAM__ is valid) or RESET (__PARAM__ is invalid)
  */
#define IS_UART_REQUEST_PARAMETER(__PARAM__) (((__PARAM__) == UART_AUTOBAUD_REQUEST) || ((__PARAM__) == UART_SENDBREAK_REQUEST) || ((__PARAM__) == UART_MUTE_MODE_REQUEST) || ((__PARAM__) == UART_RXDATA_FLUSH_REQUEST) || ((__PARAM__) == UART_TXDATA_FLUSH_REQUEST))





/**
  * @brief Ensure that UART advanced features initialization is valid.
  * @param __INIT__ UART advanced features initialization.
  * @retval SET (__INIT__ is valid) or RESET (__INIT__ is invalid)
  */
#define IS_UART_ADVFEATURE_INIT(__INIT__) ((__INIT__) <= (UART_ADVFEATURE_NO_INIT | UART_ADVFEATURE_TXINVERT_INIT | UART_ADVFEATURE_RXINVERT_INIT | UART_ADVFEATURE_DATAINVERT_INIT | UART_ADVFEATURE_SWAP_INIT | UART_ADVFEATURE_RXOVERRUNDISABLE_INIT | UART_ADVFEATURE_DMADISABLEONERROR_INIT | UART_ADVFEATURE_AUTOBAUDRATE_INIT | UART_ADVFEATURE_MSBFIRST_INIT))
# 1472 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart.h"

/**
  * @brief Ensure that UART frame TX inversion setting is valid.
  * @param __TXINV__ UART frame TX inversion setting.
  * @retval SET (__TXINV__ is valid) or RESET (__TXINV__ is invalid)
  */
#define IS_UART_ADVFEATURE_TXINV(__TXINV__) (((__TXINV__) == UART_ADVFEATURE_TXINV_DISABLE) || ((__TXINV__) == UART_ADVFEATURE_TXINV_ENABLE))


/**
  * @brief Ensure that UART frame RX inversion setting is valid.
  * @param __RXINV__ UART frame RX inversion setting.
  * @retval SET (__RXINV__ is valid) or RESET (__RXINV__ is invalid)
  */
#define IS_UART_ADVFEATURE_RXINV(__RXINV__) (((__RXINV__) == UART_ADVFEATURE_RXINV_DISABLE) || ((__RXINV__) == UART_ADVFEATURE_RXINV_ENABLE))


/**
  * @brief Ensure that UART frame data inversion setting is valid.
  * @param __DATAINV__ UART frame data inversion setting.
  * @retval SET (__DATAINV__ is valid) or RESET (__DATAINV__ is invalid)
  */
#define IS_UART_ADVFEATURE_DATAINV(__DATAINV__) (((__DATAINV__) == UART_ADVFEATURE_DATAINV_DISABLE) || ((__DATAINV__) == UART_ADVFEATURE_DATAINV_ENABLE))


/**
  * @brief Ensure that UART frame RX/TX pins swap setting is valid.
  * @param __SWAP__ UART frame RX/TX pins swap setting.
  * @retval SET (__SWAP__ is valid) or RESET (__SWAP__ is invalid)
  */
#define IS_UART_ADVFEATURE_SWAP(__SWAP__) (((__SWAP__) == UART_ADVFEATURE_SWAP_DISABLE) || ((__SWAP__) == UART_ADVFEATURE_SWAP_ENABLE))


/**
  * @brief Ensure that UART frame overrun setting is valid.
  * @param __OVERRUN__ UART frame overrun setting.
  * @retval SET (__OVERRUN__ is valid) or RESET (__OVERRUN__ is invalid)
  */
#define IS_UART_OVERRUN(__OVERRUN__) (((__OVERRUN__) == UART_ADVFEATURE_OVERRUN_ENABLE) || ((__OVERRUN__) == UART_ADVFEATURE_OVERRUN_DISABLE))


/**
  * @brief Ensure that UART auto Baud rate state is valid.
  * @param __AUTOBAUDRATE__ UART auto Baud rate state.
  * @retval SET (__AUTOBAUDRATE__ is valid) or RESET (__AUTOBAUDRATE__ is invalid)
  */
#define IS_UART_ADVFEATURE_AUTOBAUDRATE(__AUTOBAUDRATE__) (((__AUTOBAUDRATE__) == UART_ADVFEATURE_AUTOBAUDRATE_DISABLE) || ((__AUTOBAUDRATE__) == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE))



/**
  * @brief Ensure that UART DMA enabling or disabling on error setting is valid.
  * @param __DMA__ UART DMA enabling or disabling on error setting.
  * @retval SET (__DMA__ is valid) or RESET (__DMA__ is invalid)
  */
#define IS_UART_ADVFEATURE_DMAONRXERROR(__DMA__) (((__DMA__) == UART_ADVFEATURE_DMA_ENABLEONRXERROR) || ((__DMA__) == UART_ADVFEATURE_DMA_DISABLEONRXERROR))


/**
  * @brief Ensure that UART frame MSB first setting is valid.
  * @param __MSBFIRST__ UART frame MSB first setting.
  * @retval SET (__MSBFIRST__ is valid) or RESET (__MSBFIRST__ is invalid)
  */
#define IS_UART_ADVFEATURE_MSBFIRST(__MSBFIRST__) (((__MSBFIRST__) == UART_ADVFEATURE_MSBFIRST_DISABLE) || ((__MSBFIRST__) == UART_ADVFEATURE_MSBFIRST_ENABLE))


/**
  * @brief Ensure that UART stop mode state is valid.
  * @param __STOPMODE__ UART stop mode state.
  * @retval SET (__STOPMODE__ is valid) or RESET (__STOPMODE__ is invalid)
  */
#define IS_UART_ADVFEATURE_STOPMODE(__STOPMODE__) (((__STOPMODE__) == UART_ADVFEATURE_STOPMODE_DISABLE) || ((__STOPMODE__) == UART_ADVFEATURE_STOPMODE_ENABLE))


/**
  * @brief Ensure that UART mute mode state is valid.
  * @param __MUTE__ UART mute mode state.
  * @retval SET (__MUTE__ is valid) or RESET (__MUTE__ is invalid)
  */
#define IS_UART_MUTE_MODE(__MUTE__) (((__MUTE__) == UART_ADVFEATURE_MUTEMODE_DISABLE) || ((__MUTE__) == UART_ADVFEATURE_MUTEMODE_ENABLE))


/**
  * @brief Ensure that UART wake-up selection is valid.
  * @param __WAKE__ UART wake-up selection.
  * @retval SET (__WAKE__ is valid) or RESET (__WAKE__ is invalid)
  */
#define IS_UART_WAKEUP_SELECTION(__WAKE__) (((__WAKE__) == UART_WAKEUP_ON_ADDRESS) || ((__WAKE__) == UART_WAKEUP_ON_STARTBIT) || ((__WAKE__) == UART_WAKEUP_ON_READDATA_NONEMPTY))



/**
  * @brief Ensure that UART driver enable polarity is valid.
  * @param __POLARITY__ UART driver enable polarity.
  * @retval SET (__POLARITY__ is valid) or RESET (__POLARITY__ is invalid)
  */
#define IS_UART_DE_POLARITY(__POLARITY__) (((__POLARITY__) == UART_DE_POLARITY_HIGH) || ((__POLARITY__) == UART_DE_POLARITY_LOW))


/**
  * @brief Ensure that UART Prescaler is valid.
  * @param __CLOCKPRESCALER__ UART Prescaler value.
  * @retval SET (__CLOCKPRESCALER__ is valid) or RESET (__CLOCKPRESCALER__ is invalid)
  */
#define IS_UART_PRESCALER(__CLOCKPRESCALER__) (((__CLOCKPRESCALER__) == UART_PRESCALER_DIV1) || ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV2) || ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV4) || ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV6) || ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV8) || ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV10) || ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV12) || ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV16) || ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV32) || ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV64) || ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV128) || ((__CLOCKPRESCALER__) == UART_PRESCALER_DIV256))
# 1588 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart.h"

/**
  * @}
  */

/* Include UART HAL Extended module */
# 1 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart_ex.h" 1
/**
  ******************************************************************************
  * @file    stm32g4xx_hal_uart_ex.h
  * @author  MCD Application Team
  * @brief   Header file of UART HAL Extended module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2019 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/

#define STM32G4xx_HAL_UART_EX_H 





/* Includes ------------------------------------------------------------------*/


/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup UARTEx
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/** @defgroup UARTEx_Exported_Types UARTEx Exported Types
  * @{
  */

/**
  * @brief  UART wake up from stop mode parameters
  */
typedef struct
{
  uint32_t WakeUpEvent;        /*!< Specifies which event will activate the Wakeup from Stop mode flag (WUF).
                                    This parameter can be a value of @ref UART_WakeUp_from_Stop_Selection.
                                    If set to UART_WAKEUP_ON_ADDRESS, the two other fields below must
                                    be filled up. */

  uint16_t AddressLength;      /*!< Specifies whether the address is 4 or 7-bit long.
                                    This parameter can be a value of @ref UARTEx_WakeUp_Address_Length.  */

  uint8_t Address;             /*!< UART/USART node address (7-bit long max). */
} UART_WakeUpTypeDef;

/**
  * @}
  */

/* Exported constants --------------------------------------------------------*/
/** @defgroup UARTEx_Exported_Constants UARTEx Exported Constants
  * @{
  */

/** @defgroup UARTEx_Word_Length UARTEx Word Length
  * @{
  */
#define UART_WORDLENGTH_7B USART_CR1_M1
#define UART_WORDLENGTH_8B 0x00000000U
#define UART_WORDLENGTH_9B USART_CR1_M0
/**
  * @}
  */

/** @defgroup UARTEx_WakeUp_Address_Length UARTEx WakeUp Address Length
  * @{
  */
#define UART_ADDRESS_DETECT_4B 0x00000000U
#define UART_ADDRESS_DETECT_7B USART_CR2_ADDM7
/**
  * @}
  */

/** @defgroup UARTEx_FIFO_mode UARTEx FIFO mode
  * @brief    UART FIFO mode
  * @{
  */
#define UART_FIFOMODE_DISABLE 0x00000000U
#define UART_FIFOMODE_ENABLE USART_CR1_FIFOEN
/**
  * @}
  */

/** @defgroup UARTEx_TXFIFO_threshold_level UARTEx TXFIFO threshold level
  * @brief    UART TXFIFO threshold level
  * @{
  */
#define UART_TXFIFO_THRESHOLD_1_8 0x00000000U
#define UART_TXFIFO_THRESHOLD_1_4 USART_CR3_TXFTCFG_0
#define UART_TXFIFO_THRESHOLD_1_2 USART_CR3_TXFTCFG_1
#define UART_TXFIFO_THRESHOLD_3_4 (USART_CR3_TXFTCFG_0|USART_CR3_TXFTCFG_1)
#define UART_TXFIFO_THRESHOLD_7_8 USART_CR3_TXFTCFG_2
#define UART_TXFIFO_THRESHOLD_8_8 (USART_CR3_TXFTCFG_2|USART_CR3_TXFTCFG_0)
/**
  * @}
  */

/** @defgroup UARTEx_RXFIFO_threshold_level UARTEx RXFIFO threshold level
  * @brief    UART RXFIFO threshold level
  * @{
  */
#define UART_RXFIFO_THRESHOLD_1_8 0x00000000U
#define UART_RXFIFO_THRESHOLD_1_4 USART_CR3_RXFTCFG_0
#define UART_RXFIFO_THRESHOLD_1_2 USART_CR3_RXFTCFG_1
#define UART_RXFIFO_THRESHOLD_3_4 (USART_CR3_RXFTCFG_0|USART_CR3_RXFTCFG_1)
#define UART_RXFIFO_THRESHOLD_7_8 USART_CR3_RXFTCFG_2
#define UART_RXFIFO_THRESHOLD_8_8 (USART_CR3_RXFTCFG_2|USART_CR3_RXFTCFG_0)
/**
  * @}
  */

/**
  * @}
  */

/* Exported macros -----------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
/** @addtogroup UARTEx_Exported_Functions
  * @{
  */

/** @addtogroup UARTEx_Exported_Functions_Group1
  * @{
  */

/* Initialization and de-initialization functions  ****************************/
HAL_StatusTypeDef HAL_RS485Ex_Init(UART_HandleTypeDef *huart, uint32_t Polarity, uint32_t AssertionTime,
                                   uint32_t DeassertionTime);

/**
  * @}
  */

/** @addtogroup UARTEx_Exported_Functions_Group2
  * @{
  */

void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart);

void HAL_UARTEx_RxFifoFullCallback(UART_HandleTypeDef *huart);
void HAL_UARTEx_TxFifoEmptyCallback(UART_HandleTypeDef *huart);

/**
  * @}
  */

/** @addtogroup UARTEx_Exported_Functions_Group3
  * @{
  */

/* Peripheral Control functions  **********************************************/
HAL_StatusTypeDef HAL_UARTEx_StopModeWakeUpSourceConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection);
HAL_StatusTypeDef HAL_UARTEx_EnableStopMode(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_UARTEx_DisableStopMode(UART_HandleTypeDef *huart);

HAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t AddressLength);

HAL_StatusTypeDef HAL_UARTEx_EnableFifoMode(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_UARTEx_DisableFifoMode(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold);
HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold);

HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint16_t *RxLen,
                                           uint32_t Timeout);
HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
HAL_StatusTypeDef HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);

HAL_UART_RxEventTypeTypeDef HAL_UARTEx_GetRxEventType(const UART_HandleTypeDef *huart);


/**
  * @}
  */

/**
  * @}
  */

/* Private macros ------------------------------------------------------------*/
/** @defgroup UARTEx_Private_Macros UARTEx Private Macros
  * @{
  */

/** @brief  Report the UART clock source.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __CLOCKSOURCE__ output variable.
  * @retval UART clocking source, written in __CLOCKSOURCE__.
  */

#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__) do { if((__HANDLE__)->Instance == USART1) { switch(__HAL_RCC_GET_USART1_SOURCE()) { case RCC_USART1CLKSOURCE_PCLK2: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK2; break; case RCC_USART1CLKSOURCE_HSI: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI; break; case RCC_USART1CLKSOURCE_SYSCLK: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK; break; case RCC_USART1CLKSOURCE_LSE: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE; break; default: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; break; } } else if((__HANDLE__)->Instance == USART2) { switch(__HAL_RCC_GET_USART2_SOURCE()) { case RCC_USART2CLKSOURCE_PCLK1: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1; break; case RCC_USART2CLKSOURCE_HSI: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI; break; case RCC_USART2CLKSOURCE_SYSCLK: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK; break; case RCC_USART2CLKSOURCE_LSE: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE; break; default: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; break; } } else if((__HANDLE__)->Instance == USART3) { switch(__HAL_RCC_GET_USART3_SOURCE()) { case RCC_USART3CLKSOURCE_PCLK1: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1; break; case RCC_USART3CLKSOURCE_HSI: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI; break; case RCC_USART3CLKSOURCE_SYSCLK: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK; break; case RCC_USART3CLKSOURCE_LSE: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE; break; default: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; break; } } else if((__HANDLE__)->Instance == UART4) { switch(__HAL_RCC_GET_UART4_SOURCE()) { case RCC_UART4CLKSOURCE_PCLK1: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1; break; case RCC_UART4CLKSOURCE_HSI: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI; break; case RCC_UART4CLKSOURCE_SYSCLK: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK; break; case RCC_UART4CLKSOURCE_LSE: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE; break; default: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; break; } } else if((__HANDLE__)->Instance == UART5) { switch(__HAL_RCC_GET_UART5_SOURCE()) { case RCC_UART5CLKSOURCE_PCLK1: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1; break; case RCC_UART5CLKSOURCE_HSI: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI; break; case RCC_UART5CLKSOURCE_SYSCLK: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK; break; case RCC_UART5CLKSOURCE_LSE: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE; break; default: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; break; } } else if((__HANDLE__)->Instance == LPUART1) { switch(__HAL_RCC_GET_LPUART1_SOURCE()) { case RCC_LPUART1CLKSOURCE_PCLK1: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1; break; case RCC_LPUART1CLKSOURCE_HSI: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI; break; case RCC_LPUART1CLKSOURCE_SYSCLK: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK; break; case RCC_LPUART1CLKSOURCE_LSE: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE; break; default: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; break; } } else { (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; } } while(0U)
# 336 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart_ex.h"
# 818 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart_ex.h"

/** @brief  Report the UART mask to apply to retrieve the received data
  *         according to the word length and to the parity bits activation.
  * @note   If PCE = 1, the parity bit is not included in the data extracted
  *         by the reception API().
  *         This masking operation is not carried out in the case of
  *         DMA transfers.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None, the mask to apply to UART RDR register is stored in (__HANDLE__)->Mask field.
  */
#define UART_MASK_COMPUTATION(__HANDLE__) do { if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_9B) { if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE) { (__HANDLE__)->Mask = 0x01FFU ; } else { (__HANDLE__)->Mask = 0x00FFU ; } } else if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_8B) { if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE) { (__HANDLE__)->Mask = 0x00FFU ; } else { (__HANDLE__)->Mask = 0x007FU ; } } else if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_7B) { if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE) { (__HANDLE__)->Mask = 0x007FU ; } else { (__HANDLE__)->Mask = 0x003FU ; } } else { (__HANDLE__)->Mask = 0x0000U; } } while(0U)
# 868 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart_ex.h"

/**
  * @brief Ensure that UART frame length is valid.
  * @param __LENGTH__ UART frame length.
  * @retval SET (__LENGTH__ is valid) or RESET (__LENGTH__ is invalid)
  */
#define IS_UART_WORD_LENGTH(__LENGTH__) (((__LENGTH__) == UART_WORDLENGTH_7B) || ((__LENGTH__) == UART_WORDLENGTH_8B) || ((__LENGTH__) == UART_WORDLENGTH_9B))



/**
  * @brief Ensure that UART wake-up address length is valid.
  * @param __ADDRESS__ UART wake-up address length.
  * @retval SET (__ADDRESS__ is valid) or RESET (__ADDRESS__ is invalid)
  */
#define IS_UART_ADDRESSLENGTH_DETECT(__ADDRESS__) (((__ADDRESS__) == UART_ADDRESS_DETECT_4B) || ((__ADDRESS__) == UART_ADDRESS_DETECT_7B))


/**
  * @brief Ensure that UART TXFIFO threshold level is valid.
  * @param __THRESHOLD__ UART TXFIFO threshold level.
  * @retval SET (__THRESHOLD__ is valid) or RESET (__THRESHOLD__ is invalid)
  */
#define IS_UART_TXFIFO_THRESHOLD(__THRESHOLD__) (((__THRESHOLD__) == UART_TXFIFO_THRESHOLD_1_8) || ((__THRESHOLD__) == UART_TXFIFO_THRESHOLD_1_4) || ((__THRESHOLD__) == UART_TXFIFO_THRESHOLD_1_2) || ((__THRESHOLD__) == UART_TXFIFO_THRESHOLD_3_4) || ((__THRESHOLD__) == UART_TXFIFO_THRESHOLD_7_8) || ((__THRESHOLD__) == UART_TXFIFO_THRESHOLD_8_8))






/**
  * @brief Ensure that UART RXFIFO threshold level is valid.
  * @param __THRESHOLD__ UART RXFIFO threshold level.
  * @retval SET (__THRESHOLD__ is valid) or RESET (__THRESHOLD__ is invalid)
  */
#define IS_UART_RXFIFO_THRESHOLD(__THRESHOLD__) (((__THRESHOLD__) == UART_RXFIFO_THRESHOLD_1_8) || ((__THRESHOLD__) == UART_RXFIFO_THRESHOLD_1_4) || ((__THRESHOLD__) == UART_RXFIFO_THRESHOLD_1_2) || ((__THRESHOLD__) == UART_RXFIFO_THRESHOLD_3_4) || ((__THRESHOLD__) == UART_RXFIFO_THRESHOLD_7_8) || ((__THRESHOLD__) == UART_RXFIFO_THRESHOLD_8_8))






/**
  * @}
  */

/* Private functions ---------------------------------------------------------*/

/**
  * @}
  */

/**
  * @}
  */







# 1595 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart.h" 2

/* Exported functions --------------------------------------------------------*/
/** @addtogroup UART_Exported_Functions UART Exported Functions
  * @{
  */

/** @addtogroup UART_Exported_Functions_Group1 Initialization and de-initialization functions
  * @{
  */

/* Initialization and de-initialization functions  ****************************/
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength);
HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod);
HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart);
void HAL_UART_MspInit(UART_HandleTypeDef *huart);
void HAL_UART_MspDeInit(UART_HandleTypeDef *huart);

/* Callbacks Register/UnRegister functions  ***********************************/
# 1623 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal_uart.h"

/**
  * @}
  */

/** @addtogroup UART_Exported_Functions_Group2 IO operation functions
  * @{
  */

/* IO operation functions *****************************************************/
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout);
HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout);
HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size);
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size);
HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart);
/* Transfer Abort functions */
HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart);

void HAL_UART_IRQHandler(UART_HandleTypeDef *huart);
void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart);
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);
void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart);
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart);
void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart);
void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart);
void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart);

void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size);

/**
  * @}
  */

/** @addtogroup UART_Exported_Functions_Group3 Peripheral Control functions
  * @{
  */

/* Peripheral Control functions  ************************************************/
void HAL_UART_ReceiverTimeout_Config(UART_HandleTypeDef *huart, uint32_t TimeoutValue);
HAL_StatusTypeDef HAL_UART_EnableReceiverTimeout(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_UART_DisableReceiverTimeout(UART_HandleTypeDef *huart);

HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart);
void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart);
HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart);

/**
  * @}
  */

/** @addtogroup UART_Exported_Functions_Group4 Peripheral State and Error functions
  * @{
  */

/* Peripheral State and Errors functions  **************************************************/
HAL_UART_StateTypeDef HAL_UART_GetState(const UART_HandleTypeDef *huart);
uint32_t              HAL_UART_GetError(const UART_HandleTypeDef *huart);

/**
  * @}
  */

/**
  * @}
  */

/* Private functions -----------------------------------------------------------*/
/** @addtogroup UART_Private_Functions UART Private Functions
  * @{
  */



HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart);
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart);
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout);
void              UART_AdvFeatureConfig(UART_HandleTypeDef *huart);
HAL_StatusTypeDef UART_Start_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
HAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);

/**
  * @}
  */

/* Private variables -----------------------------------------------------------*/
/** @defgroup UART_Private_variables UART Private variables
  * @{
  */
/* Prescaler Table used in BRR computation macros.
   Declared as extern here to allow use of private UART macros, outside of HAL UART functions */
extern const uint16_t UARTPrescTable[12];
/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */







# 349 "Core/Inc/stm32g4xx_hal_conf.h" 2










/* Exported macro ------------------------------------------------------------*/
# 373 "Core/Inc/stm32g4xx_hal_conf.h"
#define assert_param(expr) ((void)0U)






# 30 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal.h" 2

/** @addtogroup STM32G4xx_HAL_Driver
  * @{
  */

/** @addtogroup HAL HAL
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/

/** @defgroup HAL_Exported_Constants HAL Exported Constants
  * @{
  */

/** @defgroup HAL_TICK_FREQ Tick Frequency
  * @{
  */
#define HAL_TICK_FREQ_10HZ 100U
#define HAL_TICK_FREQ_100HZ 10U
#define HAL_TICK_FREQ_1KHZ 1U
#define HAL_TICK_FREQ_DEFAULT HAL_TICK_FREQ_1KHZ

/**
  * @}
  */

/** @defgroup SYSCFG_Exported_Constants SYSCFG Exported Constants
  * @{
  */

/** @defgroup SYSCFG_BootMode Boot Mode
  * @{
  */
#define SYSCFG_BOOT_MAINFLASH 0x00000000U
#define SYSCFG_BOOT_SYSTEMFLASH SYSCFG_MEMMEMRMP_MODE_0


#define SYSCFG_BOOT_FMC SYSCFG_MEMMEMRMP_MODE_1


#define SYSCFG_BOOT_SRAM (SYSCFG_MEMMEMRMP_MODE_1 | SYSCFG_MEMMEMRMP_MODE_0)


#define SYSCFG_BOOT_QUADSPI (SYSCFG_MEMMEMRMP_MODE_2 | SYSCFG_MEMMEMRMP_MODE_1)


/**
  * @}
  */

/** @defgroup SYSCFG_FPU_Interrupts FPU Interrupts
  * @{
  */
#define SYSCFG_IT_FPU_IOC SYSCFG_CFGR1_FPU_IE_0
#define SYSCFG_IT_FPU_DZC SYSCFG_CFGR1_FPU_IE_1
#define SYSCFG_IT_FPU_UFC SYSCFG_CFGR1_FPU_IE_2
#define SYSCFG_IT_FPU_OFC SYSCFG_CFGR1_FPU_IE_3
#define SYSCFG_IT_FPU_IDC SYSCFG_CFGR1_FPU_IE_4
#define SYSCFG_IT_FPU_IXC SYSCFG_CFGR1_FPU_IE_5

/**
  * @}
  */

/** @defgroup SYSCFG_CCMSRAMWRP CCM Write protection
  * @{
  */
#define SYSCFG_CCMSRAMWRP_PAGE0 SYSCFG_SWPR_PAGE0
#define SYSCFG_CCMSRAMWRP_PAGE1 SYSCFG_SWPR_PAGE1
#define SYSCFG_CCMSRAMWRP_PAGE2 SYSCFG_SWPR_PAGE2
#define SYSCFG_CCMSRAMWRP_PAGE3 SYSCFG_SWPR_PAGE3
#define SYSCFG_CCMSRAMWRP_PAGE4 SYSCFG_SWPR_PAGE4
#define SYSCFG_CCMSRAMWRP_PAGE5 SYSCFG_SWPR_PAGE5
#define SYSCFG_CCMSRAMWRP_PAGE6 SYSCFG_SWPR_PAGE6
#define SYSCFG_CCMSRAMWRP_PAGE7 SYSCFG_SWPR_PAGE7
#define SYSCFG_CCMSRAMWRP_PAGE8 SYSCFG_SWPR_PAGE8
#define SYSCFG_CCMSRAMWRP_PAGE9 SYSCFG_SWPR_PAGE9
#define SYSCFG_CCMSRAMWRP_PAGE10 SYSCFG_SWPR_PAGE10
#define SYSCFG_CCMSRAMWRP_PAGE11 SYSCFG_SWPR_PAGE11
#define SYSCFG_CCMSRAMWRP_PAGE12 SYSCFG_SWPR_PAGE12
#define SYSCFG_CCMSRAMWRP_PAGE13 SYSCFG_SWPR_PAGE13
#define SYSCFG_CCMSRAMWRP_PAGE14 SYSCFG_SWPR_PAGE14
#define SYSCFG_CCMSRAMWRP_PAGE15 SYSCFG_SWPR_PAGE15
#define SYSCFG_CCMSRAMWRP_PAGE16 SYSCFG_SWPR_PAGE16
#define SYSCFG_CCMSRAMWRP_PAGE17 SYSCFG_SWPR_PAGE17
#define SYSCFG_CCMSRAMWRP_PAGE18 SYSCFG_SWPR_PAGE18
#define SYSCFG_CCMSRAMWRP_PAGE19 SYSCFG_SWPR_PAGE19
#define SYSCFG_CCMSRAMWRP_PAGE20 SYSCFG_SWPR_PAGE20
#define SYSCFG_CCMSRAMWRP_PAGE21 SYSCFG_SWPR_PAGE21
#define SYSCFG_CCMSRAMWRP_PAGE22 SYSCFG_SWPR_PAGE22
#define SYSCFG_CCMSRAMWRP_PAGE23 SYSCFG_SWPR_PAGE23
#define SYSCFG_CCMSRAMWRP_PAGE24 SYSCFG_SWPR_PAGE24
#define SYSCFG_CCMSRAMWRP_PAGE25 SYSCFG_SWPR_PAGE25
#define SYSCFG_CCMSRAMWRP_PAGE26 SYSCFG_SWPR_PAGE26
#define SYSCFG_CCMSRAMWRP_PAGE27 SYSCFG_SWPR_PAGE27
#define SYSCFG_CCMSRAMWRP_PAGE28 SYSCFG_SWPR_PAGE28
#define SYSCFG_CCMSRAMWRP_PAGE29 SYSCFG_SWPR_PAGE29
#define SYSCFG_CCMSRAMWRP_PAGE30 SYSCFG_SWPR_PAGE30
#define SYSCFG_CCMSRAMWRP_PAGE31 SYSCFG_SWPR_PAGE31

/**
  * @}
  */


/** @defgroup SYSCFG_VREFBUF_VoltageScale VREFBUF Voltage Scale
  * @{
  */
#define SYSCFG_VREFBUF_VOLTAGE_SCALE0 0x00000000U
#define SYSCFG_VREFBUF_VOLTAGE_SCALE1 VREFBUF_CSR_VRS_0
#define SYSCFG_VREFBUF_VOLTAGE_SCALE2 VREFBUF_CSR_VRS_1

/**
  * @}
  */

/** @defgroup SYSCFG_VREFBUF_HighImpedance VREFBUF High Impedance
  * @{
  */
#define SYSCFG_VREFBUF_HIGH_IMPEDANCE_DISABLE 0x00000000U
#define SYSCFG_VREFBUF_HIGH_IMPEDANCE_ENABLE VREFBUF_CSR_HIZ

/**
  * @}
  */


/** @defgroup SYSCFG_flags_definition Flags
  * @{
  */

#define SYSCFG_FLAG_SRAM_PE SYSCFG_CFGR2_SPF
#define SYSCFG_FLAG_CCMSRAM_BUSY SYSCFG_SCSR_CCMBSY

/**
  * @}
  */

/** @defgroup SYSCFG_FastModePlus_GPIO Fast-mode Plus on GPIO
  * @{
  */

/** @brief  Fast-mode Plus driving capability on a specific GPIO
  */
#define SYSCFG_FASTMODEPLUS_PB6 SYSCFG_CFGR1_I2C_PB6_FMP
#define SYSCFG_FASTMODEPLUS_PB7 SYSCFG_CFGR1_I2C_PB7_FMP

#define SYSCFG_FASTMODEPLUS_PB8 SYSCFG_CFGR1_I2C_PB8_FMP


#define SYSCFG_FASTMODEPLUS_PB9 SYSCFG_CFGR1_I2C_PB9_FMP


/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/* Exported macros -----------------------------------------------------------*/

/** @defgroup DBGMCU_Exported_Macros DBGMCU Exported Macros
  * @{
  */

/** @brief  Freeze/Unfreeze Peripherals in Debug mode
  */

#define __HAL_DBGMCU_FREEZE_TIM2() SET_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_TIM2_STOP)
#define __HAL_DBGMCU_UNFREEZE_TIM2() CLEAR_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_TIM2_STOP)



#define __HAL_DBGMCU_FREEZE_TIM3() SET_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_TIM3_STOP)
#define __HAL_DBGMCU_UNFREEZE_TIM3() CLEAR_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_TIM3_STOP)



#define __HAL_DBGMCU_FREEZE_TIM4() SET_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_TIM4_STOP)
#define __HAL_DBGMCU_UNFREEZE_TIM4() CLEAR_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_TIM4_STOP)



#define __HAL_DBGMCU_FREEZE_TIM5() SET_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_TIM5_STOP)
#define __HAL_DBGMCU_UNFREEZE_TIM5() CLEAR_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_TIM5_STOP)



#define __HAL_DBGMCU_FREEZE_TIM6() SET_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_TIM6_STOP)
#define __HAL_DBGMCU_UNFREEZE_TIM6() CLEAR_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_TIM6_STOP)



#define __HAL_DBGMCU_FREEZE_TIM7() SET_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_TIM7_STOP)
#define __HAL_DBGMCU_UNFREEZE_TIM7() CLEAR_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_TIM7_STOP)



#define __HAL_DBGMCU_FREEZE_RTC() SET_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_RTC_STOP)
#define __HAL_DBGMCU_UNFREEZE_RTC() CLEAR_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_RTC_STOP)



#define __HAL_DBGMCU_FREEZE_WWDG() SET_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_WWDG_STOP)
#define __HAL_DBGMCU_UNFREEZE_WWDG() CLEAR_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_WWDG_STOP)



#define __HAL_DBGMCU_FREEZE_IWDG() SET_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_IWDG_STOP)
#define __HAL_DBGMCU_UNFREEZE_IWDG() CLEAR_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_IWDG_STOP)



#define __HAL_DBGMCU_FREEZE_I2C1_TIMEOUT() SET_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_I2C1_STOP)
#define __HAL_DBGMCU_UNFREEZE_I2C1_TIMEOUT() CLEAR_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_I2C1_STOP)



#define __HAL_DBGMCU_FREEZE_I2C2_TIMEOUT() SET_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_I2C2_STOP)
#define __HAL_DBGMCU_UNFREEZE_I2C2_TIMEOUT() CLEAR_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_I2C2_STOP)



#define __HAL_DBGMCU_FREEZE_I2C3_TIMEOUT() SET_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_I2C3_STOP)
#define __HAL_DBGMCU_UNFREEZE_I2C3_TIMEOUT() CLEAR_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_I2C3_STOP)



#define __HAL_DBGMCU_FREEZE_LPTIM1() SET_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_LPTIM1_STOP)
#define __HAL_DBGMCU_UNFREEZE_LPTIM1() CLEAR_BIT(DBGMCU->APB1FZR1, DBGMCU_APB1FZR1_DBG_LPTIM1_STOP)



#define __HAL_DBGMCU_FREEZE_I2C4_TIMEOUT() SET_BIT(DBGMCU->APB1FZR2, DBGMCU_APB1FZR2_DBG_I2C4_STOP)
#define __HAL_DBGMCU_UNFREEZE_I2C4_TIMEOUT() CLEAR_BIT(DBGMCU->APB1FZR2, DBGMCU_APB1FZR2_DBG_I2C4_STOP)



#define __HAL_DBGMCU_FREEZE_TIM1() SET_BIT(DBGMCU->APB2FZ, DBGMCU_APB2FZ_DBG_TIM1_STOP)
#define __HAL_DBGMCU_UNFREEZE_TIM1() CLEAR_BIT(DBGMCU->APB2FZ, DBGMCU_APB2FZ_DBG_TIM1_STOP)



#define __HAL_DBGMCU_FREEZE_TIM8() SET_BIT(DBGMCU->APB2FZ, DBGMCU_APB2FZ_DBG_TIM8_STOP)
#define __HAL_DBGMCU_UNFREEZE_TIM8() CLEAR_BIT(DBGMCU->APB2FZ, DBGMCU_APB2FZ_DBG_TIM8_STOP)



#define __HAL_DBGMCU_FREEZE_TIM15() SET_BIT(DBGMCU->APB2FZ, DBGMCU_APB2FZ_DBG_TIM15_STOP)
#define __HAL_DBGMCU_UNFREEZE_TIM15() CLEAR_BIT(DBGMCU->APB2FZ, DBGMCU_APB2FZ_DBG_TIM15_STOP)



#define __HAL_DBGMCU_FREEZE_TIM16() SET_BIT(DBGMCU->APB2FZ, DBGMCU_APB2FZ_DBG_TIM16_STOP)
#define __HAL_DBGMCU_UNFREEZE_TIM16() CLEAR_BIT(DBGMCU->APB2FZ, DBGMCU_APB2FZ_DBG_TIM16_STOP)



#define __HAL_DBGMCU_FREEZE_TIM17() SET_BIT(DBGMCU->APB2FZ, DBGMCU_APB2FZ_DBG_TIM17_STOP)
#define __HAL_DBGMCU_UNFREEZE_TIM17() CLEAR_BIT(DBGMCU->APB2FZ, DBGMCU_APB2FZ_DBG_TIM17_STOP)



#define __HAL_DBGMCU_FREEZE_TIM20() SET_BIT(DBGMCU->APB2FZ, DBGMCU_APB2FZ_DBG_TIM20_STOP)
#define __HAL_DBGMCU_UNFREEZE_TIM20() CLEAR_BIT(DBGMCU->APB2FZ, DBGMCU_APB2FZ_DBG_TIM20_STOP)







/**
  * @}
  */

/** @defgroup SYSCFG_Exported_Macros SYSCFG Exported Macros
  * @{
  */

/** @brief  Main Flash memory mapped at 0x00000000.
  */
#define __HAL_SYSCFG_REMAPMEMORY_FLASH() CLEAR_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_MEM_MODE)

/** @brief  System Flash memory mapped at 0x00000000.
  */
#define __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH() MODIFY_REG(SYSCFG->MEMRMP, SYSCFG_MEMRMP_MEM_MODE, SYSCFG_MEMRMP_MEM_MODE_0)

/** @brief  Embedded SRAM mapped at 0x00000000.
  */
#define __HAL_SYSCFG_REMAPMEMORY_SRAM() MODIFY_REG(SYSCFG->MEMRMP, SYSCFG_MEMRMP_MEM_MODE, (SYSCFG_MEMRMP_MEM_MODE_1|SYSCFG_MEMRMP_MEM_MODE_0))


/** @brief  FMC Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000.
  */
#define __HAL_SYSCFG_REMAPMEMORY_FMC() MODIFY_REG(SYSCFG->MEMRMP, SYSCFG_MEMRMP_MEM_MODE, SYSCFG_MEMRMP_MEM_MODE_1)



/** @brief  QUADSPI mapped at 0x00000000.
  */
#define __HAL_SYSCFG_REMAPMEMORY_QUADSPI() MODIFY_REG(SYSCFG->MEMRMP, SYSCFG_MEMRMP_MEM_MODE, (SYSCFG_MEMRMP_MEM_MODE_2|SYSCFG_MEMRMP_MEM_MODE_1))


/**
  * @brief  Return the boot mode as configured by user.
  * @retval The boot mode as configured by user. The returned value can be one
  *         of the following values:
  *           @arg @ref SYSCFG_BOOT_MAINFLASH
  *           @arg @ref SYSCFG_BOOT_SYSTEMFLASH
  *           @arg @ref SYSCFG_BOOT_FMC (*)
  *           @arg @ref SYSCFG_BOOT_QUADSPI (*)
  *           @arg @ref SYSCFG_BOOT_SRAM
  * @note   (*) availability depends on devices
  */
#define __HAL_SYSCFG_GET_BOOT_MODE() READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_MEM_MODE)

/** @brief  CCMSRAM page write protection enable macro
  * @param __CCMSRAMWRP__: This parameter can be a value of @ref SYSCFG_CCMSRAMWRP
  * @note   write protection can only be disabled by a system reset
  * @retval None
  */
/* Legacy define */
#define __HAL_SYSCFG_CCMSRAM_WRP_1_31_ENABLE __HAL_SYSCFG_CCMSRAM_WRP_0_31_ENABLE
#define __HAL_SYSCFG_CCMSRAM_WRP_0_31_ENABLE(__CCMSRAMWRP__) do {assert_param(IS_SYSCFG_CCMSRAMWRP_PAGE((__CCMSRAMWRP__))); SET_BIT(SYSCFG->SWPR,(__CCMSRAMWRP__)); }while(0)



/** @brief  CCMSRAM page write protection unlock prior to erase
  * @note   Writing a wrong key reactivates the write protection
  */
#define __HAL_SYSCFG_CCMSRAM_WRP_UNLOCK() do {SYSCFG->SKR = 0xCA; SYSCFG->SKR = 0x53; }while(0)



/** @brief  CCMSRAM erase
  * @note   __SYSCFG_GET_FLAG(SYSCFG_FLAG_CCMSRAM_BUSY) may be used to check end of erase
  */
#define __HAL_SYSCFG_CCMSRAM_ERASE() SET_BIT(SYSCFG->SCSR, SYSCFG_SCSR_CCMER)

/** @brief  Floating Point Unit interrupt enable/disable macros
  * @param __INTERRUPT__: This parameter can be a value of @ref SYSCFG_FPU_Interrupts
  */
#define __HAL_SYSCFG_FPU_INTERRUPT_ENABLE(__INTERRUPT__) do {assert_param(IS_SYSCFG_FPU_INTERRUPT((__INTERRUPT__))); SET_BIT(SYSCFG->CFGR1, (__INTERRUPT__)); }while(0)



#define __HAL_SYSCFG_FPU_INTERRUPT_DISABLE(__INTERRUPT__) do {assert_param(IS_SYSCFG_FPU_INTERRUPT((__INTERRUPT__))); CLEAR_BIT(SYSCFG->CFGR1, (__INTERRUPT__)); }while(0)



/** @brief  SYSCFG Break ECC lock.
  *         Enable and lock the connection of Flash ECC error connection to TIM1/8/15/16/17 Break input.
  * @note   The selected configuration is locked and can be unlocked only by system reset.
  */
#define __HAL_SYSCFG_BREAK_ECC_LOCK() SET_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_ECCL)

/** @brief  SYSCFG Break Cortex-M4 Lockup lock.
  *         Enable and lock the connection of Cortex-M4 LOCKUP (Hardfault) output to TIM1/8/15/16/17 Break input.
  * @note   The selected configuration is locked and can be unlocked only by system reset.
  */
#define __HAL_SYSCFG_BREAK_LOCKUP_LOCK() SET_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_CLL)

/** @brief  SYSCFG Break PVD lock.
  *         Enable and lock the PVD connection to Timer1/8/15/16/17 Break input, as well as the PVDE and PLS[2:0] in the PWR_CR2 register.
  * @note   The selected configuration is locked and can be unlocked only by system reset.
  */
#define __HAL_SYSCFG_BREAK_PVD_LOCK() SET_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_PVDL)

/** @brief  SYSCFG Break SRAM parity lock.
  *         Enable and lock the SRAM parity error (first 32kB of SRAM1 + CCM SRAM) signal connection to TIM1/8/15/16/17 Break input.
  * @note   The selected configuration is locked and can be unlocked by system reset.
  */
#define __HAL_SYSCFG_BREAK_SRAMPARITY_LOCK() SET_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_SPL)

/** @brief  Check SYSCFG flag is set or not.
  * @param  __FLAG__: specifies the flag to check.
  *         This parameter can be one of the following values:
  *            @arg @ref SYSCFG_FLAG_SRAM_PE   SRAM Parity Error Flag
  *            @arg @ref SYSCFG_FLAG_CCMSRAM_BUSY CCMSRAM Erase Ongoing
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  */
#define __HAL_SYSCFG_GET_FLAG(__FLAG__) ((((((__FLAG__) == SYSCFG_SCSR_CCMBSY)? SYSCFG->SCSR : SYSCFG->CFGR2) & (__FLAG__))!= 0U) ? 1U : 0U)


/** @brief  Set the SPF bit to clear the SRAM Parity Error Flag.
  */
#define __HAL_SYSCFG_CLEAR_FLAG() SET_BIT(SYSCFG->CFGR2, SYSCFG_CFGR2_SPF)

/** @brief  Fast-mode Plus driving capability enable/disable macros
  * @param __FASTMODEPLUS__: This parameter can be a value of :
  *     @arg @ref SYSCFG_FASTMODEPLUS_PB6 Fast-mode Plus driving capability activation on PB6
  *     @arg @ref SYSCFG_FASTMODEPLUS_PB7 Fast-mode Plus driving capability activation on PB7
  *     @arg @ref SYSCFG_FASTMODEPLUS_PB8 Fast-mode Plus driving capability activation on PB8
  *     @arg @ref SYSCFG_FASTMODEPLUS_PB9 Fast-mode Plus driving capability activation on PB9
  */
#define __HAL_SYSCFG_FASTMODEPLUS_ENABLE(__FASTMODEPLUS__) do {assert_param(IS_SYSCFG_FASTMODEPLUS((__FASTMODEPLUS__))); SET_BIT(SYSCFG->CFGR1, (__FASTMODEPLUS__)); }while(0)



#define __HAL_SYSCFG_FASTMODEPLUS_DISABLE(__FASTMODEPLUS__) do {assert_param(IS_SYSCFG_FASTMODEPLUS((__FASTMODEPLUS__))); CLEAR_BIT(SYSCFG->CFGR1, (__FASTMODEPLUS__)); }while(0)



/**
  * @}
  */

/* Private macros ------------------------------------------------------------*/
/** @defgroup SYSCFG_Private_Macros SYSCFG Private Macros
  * @{
  */

#define IS_SYSCFG_FPU_INTERRUPT(__INTERRUPT__) ((((__INTERRUPT__) & SYSCFG_IT_FPU_IOC) == SYSCFG_IT_FPU_IOC) || (((__INTERRUPT__) & SYSCFG_IT_FPU_DZC) == SYSCFG_IT_FPU_DZC) || (((__INTERRUPT__) & SYSCFG_IT_FPU_UFC) == SYSCFG_IT_FPU_UFC) || (((__INTERRUPT__) & SYSCFG_IT_FPU_OFC) == SYSCFG_IT_FPU_OFC) || (((__INTERRUPT__) & SYSCFG_IT_FPU_IDC) == SYSCFG_IT_FPU_IDC) || (((__INTERRUPT__) & SYSCFG_IT_FPU_IXC) == SYSCFG_IT_FPU_IXC))






#define IS_SYSCFG_BREAK_CONFIG(__CONFIG__) (((__CONFIG__) == SYSCFG_BREAK_ECC) || ((__CONFIG__) == SYSCFG_BREAK_PVD) || ((__CONFIG__) == SYSCFG_BREAK_SRAMPARITY) || ((__CONFIG__) == SYSCFG_BREAK_LOCKUP))





#define IS_SYSCFG_CCMSRAMWRP_PAGE(__PAGE__) ((__PAGE__) > 0U)









#define IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(__SCALE__) (((__SCALE__) == SYSCFG_VREFBUF_VOLTAGE_SCALE0) || ((__SCALE__) == SYSCFG_VREFBUF_VOLTAGE_SCALE1) || ((__SCALE__) == SYSCFG_VREFBUF_VOLTAGE_SCALE2))



#define IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(__VALUE__) (((__VALUE__) == SYSCFG_VREFBUF_HIGH_IMPEDANCE_DISABLE) || ((__VALUE__) == SYSCFG_VREFBUF_HIGH_IMPEDANCE_ENABLE))


#define IS_SYSCFG_VREFBUF_TRIMMING(__VALUE__) (((__VALUE__) > 0U) && ((__VALUE__) <= VREFBUF_CCR_TRIM))



#define IS_SYSCFG_FASTMODEPLUS(__PIN__) ((((__PIN__) & SYSCFG_FASTMODEPLUS_PB6) == SYSCFG_FASTMODEPLUS_PB6) || (((__PIN__) & SYSCFG_FASTMODEPLUS_PB7) == SYSCFG_FASTMODEPLUS_PB7) || (((__PIN__) & SYSCFG_FASTMODEPLUS_PB8) == SYSCFG_FASTMODEPLUS_PB8) || (((__PIN__) & SYSCFG_FASTMODEPLUS_PB9) == SYSCFG_FASTMODEPLUS_PB9))



# 501 "Drivers/STM32G4xx_HAL_Driver/Inc/stm32g4xx_hal.h"
/**
  * @}
  */

/** @defgroup HAL_Private_Macros HAL Private Macros
  * @{
  */
#define IS_TICKFREQ(FREQ) (((FREQ) == HAL_TICK_FREQ_10HZ) || ((FREQ) == HAL_TICK_FREQ_100HZ) || ((FREQ) == HAL_TICK_FREQ_1KHZ))


/**
  * @}
  */

/* Exported functions --------------------------------------------------------*/

/** @addtogroup HAL_Exported_Functions
  * @{
  */

/** @addtogroup HAL_Exported_Functions_Group1
  * @{
  */
/* Initialization and Configuration functions  ******************************/
HAL_StatusTypeDef HAL_Init(void);
HAL_StatusTypeDef HAL_DeInit(void);
void HAL_MspInit(void);
void HAL_MspDeInit(void);
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority);

/**
  * @}
  */

/** @addtogroup HAL_Exported_Functions_Group2 HAL Control functions
  * @{
  */

/* Peripheral Control functions  ************************************************/
void HAL_IncTick(void);
void HAL_Delay(uint32_t Delay);
uint32_t HAL_GetTick(void);
uint32_t HAL_GetTickPrio(void);
HAL_StatusTypeDef HAL_SetTickFreq(uint32_t Freq);
uint32_t HAL_GetTickFreq(void);
void HAL_SuspendTick(void);
void HAL_ResumeTick(void);
uint32_t HAL_GetHalVersion(void);
uint32_t HAL_GetREVID(void);
uint32_t HAL_GetDEVID(void);
uint32_t HAL_GetUIDw0(void);
uint32_t HAL_GetUIDw1(void);
uint32_t HAL_GetUIDw2(void);

/**
  * @}
  */

/** @addtogroup HAL_Exported_Functions_Group3
  * @{
  */

/* DBGMCU Peripheral Control functions  *****************************************/
void HAL_DBGMCU_EnableDBGSleepMode(void);
void HAL_DBGMCU_DisableDBGSleepMode(void);
void HAL_DBGMCU_EnableDBGStopMode(void);
void HAL_DBGMCU_DisableDBGStopMode(void);
void HAL_DBGMCU_EnableDBGStandbyMode(void);
void HAL_DBGMCU_DisableDBGStandbyMode(void);

/**
  * @}
  */

/* Exported variables ---------------------------------------------------------*/
/** @addtogroup HAL_Exported_Variables
  * @{
  */
extern __IO uint32_t uwTick;
extern uint32_t uwTickPrio;
extern uint32_t uwTickFreq;
/**
  * @}
  */

/** @addtogroup HAL_Exported_Functions_Group4
  * @{
  */

/* SYSCFG Control functions  ****************************************************/
void HAL_SYSCFG_CCMSRAMErase(void);
void HAL_SYSCFG_EnableMemorySwappingBank(void);
void HAL_SYSCFG_DisableMemorySwappingBank(void);


void HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling);
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode);
void HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue);
HAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void);
void HAL_SYSCFG_DisableVREFBUF(void);


void HAL_SYSCFG_EnableIOSwitchBooster(void);
void HAL_SYSCFG_DisableIOSwitchBooster(void);
void HAL_SYSCFG_EnableIOSwitchVDD(void);
void HAL_SYSCFG_DisableIOSwitchVDD(void);
void HAL_SYSCFG_CCMSRAM_WriteProtectionEnable(uint32_t Page);

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */







# 31 "Core/Inc/main.h" 2

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Exported types ------------------------------------------------------------*/
/* USER CODE BEGIN ET */

/* USER CODE END ET */

/* Exported constants --------------------------------------------------------*/
/* USER CODE BEGIN EC */

/* USER CODE END EC */

/* Exported macro ------------------------------------------------------------*/
/* USER CODE BEGIN EM */

/* USER CODE END EM */

void HAL_TIM_MspPostInit(TIM_HandleTypeDef *htim);

/* Exported functions prototypes ---------------------------------------------*/
void Error_Handler(void);

/* USER CODE BEGIN EFP */

/* USER CODE END EFP */

/* Private defines -----------------------------------------------------------*/
#define LED1_Pin GPIO_PIN_14
#define LED1_GPIO_Port GPIOC
#define LED2_Pin GPIO_PIN_15
#define LED2_GPIO_Port GPIOC
#define H1_Pin GPIO_PIN_4
#define H1_GPIO_Port GPIOA
#define H2_Pin GPIO_PIN_5
#define H2_GPIO_Port GPIOA
#define H3_Pin GPIO_PIN_6
#define H3_GPIO_Port GPIOA
#define H4_Pin GPIO_PIN_7
#define H4_GPIO_Port GPIOA
#define RELAY_GATE_Pin GPIO_PIN_10
#define RELAY_GATE_GPIO_Port GPIOA
#define H5_Pin GPIO_PIN_4
#define H5_GPIO_Port GPIOB
#define H6_Pin GPIO_PIN_5
#define H6_GPIO_Port GPIOB
#define H7_Pin GPIO_PIN_6
#define H7_GPIO_Port GPIOB
#define H8_Pin GPIO_PIN_7
#define H8_GPIO_Port GPIOB
#define USER_BTN_Pin GPIO_PIN_9
#define USER_BTN_GPIO_Port GPIOB

/* USER CODE BEGIN Private defines */

/* USER CODE END Private defines */





# 14 "Core/Inc/pid.h" 2
# 1 "Core/Inc/config.h" 1
/*
 * config.h
 *
 *  Created on: Oct 16, 2025
 *      Author: ordum
 */


#define INC_CONFIG_H_ 



// General
#define CONTROL_DT_MS 1U
#define CAN_TOGGLE_MS 250U


// ADC
#define ADC_CHANNEL_COUNT 5


// ADC to physical conversion
// ADC reference, gain, shunt value, divider etc.    
#define ADC_RESOLUTION 4095.0f
#define VREF_VOLTS 3.3f




// Limits for diagnostics (physical units)
#define VBUS_MIN 0.0f
#define VBUS_MAX 1500.0f


#define I_MAX 1900.0f


// PWM
#define PWM_MIN_DUTY 0U
#define PWM_MAX_DUTY(arr) (arr)


// CAN
#define CAN_SEND_PERIOD_MS CAN_TOGGLE_MS


// System states
typedef enum {
STATE_INIT = 0,
STATE_PRECHARGE = 1,
STATE_IDLE = 2,
STATE_CHARGE = 3,
STATE_DISCHARGE = 4
} SystemState_t;

typedef enum {
	STATE_DISABLE = 0,
	STATE_ENABLE = 1
} PWMState_t;


// Error bitmask
#define ERR_NONE 0x00
#define ERR_OVERVOLTAGE 0x01
#define ERR_UNDERVOLTAGE 0x02
#define ERR_OVERCURRENT 0x04
#define ERR_IGBT_DRIVER 0x08


//   ADC ->  
#define ADC_TO_CURRENT_COEFF_IN 0.80586f
#define ADC_TO_CURRENT_COEFF_OUT 0.80586f
#define ADC_TO_CURRENT_COEFF_CHOKE 0.80586f
#define ADC_TO_VOLTAGE_COEFF_IN 0.85959f
#define ADC_TO_VOLTAGE_COEFF_OUT 0.85959f

#define CURRENT_OFFSET 1500.0f
#define VOLTAGE_OFFSET 1600.0f

# 15 "Core/Inc/pid.h" 2

// -------------------------------
//   -
// -------------------------------
typedef struct {
    float kp;
    float ki;
    float dt;
    float integral;
    float outMin;
    float outMax;
    unsigned int output;
} PIController_t;

/*
 *
 *
 *           
                         -            
             

                     
   r(t) ( + )   e(t)      
                               
                                              
                                      
                                        Kp + Ki * e(t)
                                      
                                               
                                               
                                            
            y(t) 
                                             

                                             */


// -------------------------------
//   
// -------------------------------
typedef struct {
    PIController_t voltageLoop;  //    
    PIController_t currentLoop;  //    
} PI2Controller_t;

/*
 *               
                                        
                 

       r(t)  (+)  e1(t) 
                                   u1(t) = Kp1*e1 + Ki1e1 
                                   
                                             
                                             
                                         
                                          y1(t)  
                                         
                                             
                            
                            
                        (+)  e2(t) 
                                          u2(t) = Kp2*e2 + Ki2e2 
                                          
                                                    
                                                    
                                                 
                  y2(t)  
                                                   

 *
*/




// -------------------------------
//   -
// -------------------------------
void piInit(PIController_t* pi, float kp, float ki, float dt, float outMin, float outMax);
unsigned int piUpdate(PIController_t* pi, float setpoint, float measurement);
void piReset(PIController_t* pi);

// -------------------------------
//   -
// -------------------------------
void pi2Init(PI2Controller_t* pi2,
             float kp_v, float ki_v,
             float kp_i, float ki_i,
             float dt, float inMin, float inMax,
			 float outMin, float outMax);

unsigned int pi2Update(PI2Controller_t* pi2,
                float voltageSet, float voltageMeas,
                float currentMeas);

void pi2Reset(PI2Controller_t* pi2);

# 7 "test/test_diag.c" 2
//#include "types.h"
# 1 "build/test/mocks/test_diag/mock_stm32g4xx_hal.h" 1
/* AUTOGENERATED FILE. DO NOT EDIT. */

#define _MOCK_STM32G4XX_HAL_H 




/* Ignore the following warnings, since we are copying code */


#pragma GCC diagnostic push


#pragma GCC diagnostic ignored "-Wpragmas"

#pragma GCC diagnostic ignored "-Wunknown-pragmas"
#pragma GCC diagnostic ignored "-Wduplicate-decl-specifier"






void mock_stm32g4xx_hal_Init(void);
void mock_stm32g4xx_hal_Destroy(void);
void mock_stm32g4xx_hal_Verify(void);




#define HAL_Init_Ignore() TEST_FAIL_MESSAGE("HAL_Init requires _IgnoreAndReturn");
#define HAL_Init_IgnoreAndReturn(cmock_retval) HAL_Init_CMockIgnoreAndReturn(__LINE__, cmock_retval)
void HAL_Init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, HAL_StatusTypeDef cmock_to_return);
#define HAL_Init_StopIgnore() HAL_Init_CMockStopIgnore()
void HAL_Init_CMockStopIgnore(void);
#define HAL_Init_Expect() TEST_FAIL_MESSAGE("HAL_Init requires _ExpectAndReturn");
#define HAL_Init_ExpectAndReturn(cmock_retval) HAL_Init_CMockExpectAndReturn(__LINE__, cmock_retval)
void HAL_Init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, HAL_StatusTypeDef cmock_to_return);
typedef HAL_StatusTypeDef (* CMOCK_HAL_Init_CALLBACK)(int cmock_num_calls);
void HAL_Init_AddCallback(CMOCK_HAL_Init_CALLBACK Callback);
void HAL_Init_Stub(CMOCK_HAL_Init_CALLBACK Callback);
#define HAL_Init_StubWithCallback HAL_Init_Stub
#define HAL_DeInit_Ignore() TEST_FAIL_MESSAGE("HAL_DeInit requires _IgnoreAndReturn");
#define HAL_DeInit_IgnoreAndReturn(cmock_retval) HAL_DeInit_CMockIgnoreAndReturn(__LINE__, cmock_retval)
void HAL_DeInit_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, HAL_StatusTypeDef cmock_to_return);
#define HAL_DeInit_StopIgnore() HAL_DeInit_CMockStopIgnore()
void HAL_DeInit_CMockStopIgnore(void);
#define HAL_DeInit_Expect() TEST_FAIL_MESSAGE("HAL_DeInit requires _ExpectAndReturn");
#define HAL_DeInit_ExpectAndReturn(cmock_retval) HAL_DeInit_CMockExpectAndReturn(__LINE__, cmock_retval)
void HAL_DeInit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, HAL_StatusTypeDef cmock_to_return);
typedef HAL_StatusTypeDef (* CMOCK_HAL_DeInit_CALLBACK)(int cmock_num_calls);
void HAL_DeInit_AddCallback(CMOCK_HAL_DeInit_CALLBACK Callback);
void HAL_DeInit_Stub(CMOCK_HAL_DeInit_CALLBACK Callback);
#define HAL_DeInit_StubWithCallback HAL_DeInit_Stub
#define HAL_MspInit_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_MspInit requires _Ignore (not AndReturn)");
#define HAL_MspInit_Ignore() HAL_MspInit_CMockIgnore()
void HAL_MspInit_CMockIgnore(void);
#define HAL_MspInit_StopIgnore() HAL_MspInit_CMockStopIgnore()
void HAL_MspInit_CMockStopIgnore(void);
#define HAL_MspInit_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_MspInit requires _Expect (not AndReturn)");
#define HAL_MspInit_Expect() HAL_MspInit_CMockExpect(__LINE__)
void HAL_MspInit_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_MspInit_CALLBACK)(int cmock_num_calls);
void HAL_MspInit_AddCallback(CMOCK_HAL_MspInit_CALLBACK Callback);
void HAL_MspInit_Stub(CMOCK_HAL_MspInit_CALLBACK Callback);
#define HAL_MspInit_StubWithCallback HAL_MspInit_Stub
#define HAL_MspDeInit_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_MspDeInit requires _Ignore (not AndReturn)");
#define HAL_MspDeInit_Ignore() HAL_MspDeInit_CMockIgnore()
void HAL_MspDeInit_CMockIgnore(void);
#define HAL_MspDeInit_StopIgnore() HAL_MspDeInit_CMockStopIgnore()
void HAL_MspDeInit_CMockStopIgnore(void);
#define HAL_MspDeInit_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_MspDeInit requires _Expect (not AndReturn)");
#define HAL_MspDeInit_Expect() HAL_MspDeInit_CMockExpect(__LINE__)
void HAL_MspDeInit_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_MspDeInit_CALLBACK)(int cmock_num_calls);
void HAL_MspDeInit_AddCallback(CMOCK_HAL_MspDeInit_CALLBACK Callback);
void HAL_MspDeInit_Stub(CMOCK_HAL_MspDeInit_CALLBACK Callback);
#define HAL_MspDeInit_StubWithCallback HAL_MspDeInit_Stub
#define HAL_InitTick_Ignore() TEST_FAIL_MESSAGE("HAL_InitTick requires _IgnoreAndReturn");
#define HAL_InitTick_IgnoreAndReturn(cmock_retval) HAL_InitTick_CMockIgnoreAndReturn(__LINE__, cmock_retval)
void HAL_InitTick_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, HAL_StatusTypeDef cmock_to_return);
#define HAL_InitTick_StopIgnore() HAL_InitTick_CMockStopIgnore()
void HAL_InitTick_CMockStopIgnore(void);
#define HAL_InitTick_Expect(TickPriority) TEST_FAIL_MESSAGE("HAL_InitTick requires _ExpectAndReturn");
#define HAL_InitTick_ExpectAndReturn(TickPriority,cmock_retval) HAL_InitTick_CMockExpectAndReturn(__LINE__, TickPriority, cmock_retval)
void HAL_InitTick_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t TickPriority, HAL_StatusTypeDef cmock_to_return);
typedef HAL_StatusTypeDef (* CMOCK_HAL_InitTick_CALLBACK)(uint32_t TickPriority, int cmock_num_calls);
void HAL_InitTick_AddCallback(CMOCK_HAL_InitTick_CALLBACK Callback);
void HAL_InitTick_Stub(CMOCK_HAL_InitTick_CALLBACK Callback);
#define HAL_InitTick_StubWithCallback HAL_InitTick_Stub
#define HAL_IncTick_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_IncTick requires _Ignore (not AndReturn)");
#define HAL_IncTick_Ignore() HAL_IncTick_CMockIgnore()
void HAL_IncTick_CMockIgnore(void);
#define HAL_IncTick_StopIgnore() HAL_IncTick_CMockStopIgnore()
void HAL_IncTick_CMockStopIgnore(void);
#define HAL_IncTick_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_IncTick requires _Expect (not AndReturn)");
#define HAL_IncTick_Expect() HAL_IncTick_CMockExpect(__LINE__)
void HAL_IncTick_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_IncTick_CALLBACK)(int cmock_num_calls);
void HAL_IncTick_AddCallback(CMOCK_HAL_IncTick_CALLBACK Callback);
void HAL_IncTick_Stub(CMOCK_HAL_IncTick_CALLBACK Callback);
#define HAL_IncTick_StubWithCallback HAL_IncTick_Stub
#define HAL_Delay_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_Delay requires _Ignore (not AndReturn)");
#define HAL_Delay_Ignore() HAL_Delay_CMockIgnore()
void HAL_Delay_CMockIgnore(void);
#define HAL_Delay_StopIgnore() HAL_Delay_CMockStopIgnore()
void HAL_Delay_CMockStopIgnore(void);
#define HAL_Delay_ExpectAndReturn(Delay,cmock_retval) TEST_FAIL_MESSAGE("HAL_Delay requires _Expect (not AndReturn)");
#define HAL_Delay_Expect(Delay) HAL_Delay_CMockExpect(__LINE__, Delay)
void HAL_Delay_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t Delay);
typedef void (* CMOCK_HAL_Delay_CALLBACK)(uint32_t Delay, int cmock_num_calls);
void HAL_Delay_AddCallback(CMOCK_HAL_Delay_CALLBACK Callback);
void HAL_Delay_Stub(CMOCK_HAL_Delay_CALLBACK Callback);
#define HAL_Delay_StubWithCallback HAL_Delay_Stub
#define HAL_GetTick_Ignore() TEST_FAIL_MESSAGE("HAL_GetTick requires _IgnoreAndReturn");
#define HAL_GetTick_IgnoreAndReturn(cmock_retval) HAL_GetTick_CMockIgnoreAndReturn(__LINE__, cmock_retval)
void HAL_GetTick_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
#define HAL_GetTick_StopIgnore() HAL_GetTick_CMockStopIgnore()
void HAL_GetTick_CMockStopIgnore(void);
#define HAL_GetTick_Expect() TEST_FAIL_MESSAGE("HAL_GetTick requires _ExpectAndReturn");
#define HAL_GetTick_ExpectAndReturn(cmock_retval) HAL_GetTick_CMockExpectAndReturn(__LINE__, cmock_retval)
void HAL_GetTick_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
typedef uint32_t (* CMOCK_HAL_GetTick_CALLBACK)(int cmock_num_calls);
void HAL_GetTick_AddCallback(CMOCK_HAL_GetTick_CALLBACK Callback);
void HAL_GetTick_Stub(CMOCK_HAL_GetTick_CALLBACK Callback);
#define HAL_GetTick_StubWithCallback HAL_GetTick_Stub
#define HAL_GetTickPrio_Ignore() TEST_FAIL_MESSAGE("HAL_GetTickPrio requires _IgnoreAndReturn");
#define HAL_GetTickPrio_IgnoreAndReturn(cmock_retval) HAL_GetTickPrio_CMockIgnoreAndReturn(__LINE__, cmock_retval)
void HAL_GetTickPrio_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
#define HAL_GetTickPrio_StopIgnore() HAL_GetTickPrio_CMockStopIgnore()
void HAL_GetTickPrio_CMockStopIgnore(void);
#define HAL_GetTickPrio_Expect() TEST_FAIL_MESSAGE("HAL_GetTickPrio requires _ExpectAndReturn");
#define HAL_GetTickPrio_ExpectAndReturn(cmock_retval) HAL_GetTickPrio_CMockExpectAndReturn(__LINE__, cmock_retval)
void HAL_GetTickPrio_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
typedef uint32_t (* CMOCK_HAL_GetTickPrio_CALLBACK)(int cmock_num_calls);
void HAL_GetTickPrio_AddCallback(CMOCK_HAL_GetTickPrio_CALLBACK Callback);
void HAL_GetTickPrio_Stub(CMOCK_HAL_GetTickPrio_CALLBACK Callback);
#define HAL_GetTickPrio_StubWithCallback HAL_GetTickPrio_Stub
#define HAL_SetTickFreq_Ignore() TEST_FAIL_MESSAGE("HAL_SetTickFreq requires _IgnoreAndReturn");
#define HAL_SetTickFreq_IgnoreAndReturn(cmock_retval) HAL_SetTickFreq_CMockIgnoreAndReturn(__LINE__, cmock_retval)
void HAL_SetTickFreq_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, HAL_StatusTypeDef cmock_to_return);
#define HAL_SetTickFreq_StopIgnore() HAL_SetTickFreq_CMockStopIgnore()
void HAL_SetTickFreq_CMockStopIgnore(void);
#define HAL_SetTickFreq_Expect(Freq) TEST_FAIL_MESSAGE("HAL_SetTickFreq requires _ExpectAndReturn");
#define HAL_SetTickFreq_ExpectAndReturn(Freq,cmock_retval) HAL_SetTickFreq_CMockExpectAndReturn(__LINE__, Freq, cmock_retval)
void HAL_SetTickFreq_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t Freq, HAL_StatusTypeDef cmock_to_return);
typedef HAL_StatusTypeDef (* CMOCK_HAL_SetTickFreq_CALLBACK)(uint32_t Freq, int cmock_num_calls);
void HAL_SetTickFreq_AddCallback(CMOCK_HAL_SetTickFreq_CALLBACK Callback);
void HAL_SetTickFreq_Stub(CMOCK_HAL_SetTickFreq_CALLBACK Callback);
#define HAL_SetTickFreq_StubWithCallback HAL_SetTickFreq_Stub
#define HAL_GetTickFreq_Ignore() TEST_FAIL_MESSAGE("HAL_GetTickFreq requires _IgnoreAndReturn");
#define HAL_GetTickFreq_IgnoreAndReturn(cmock_retval) HAL_GetTickFreq_CMockIgnoreAndReturn(__LINE__, cmock_retval)
void HAL_GetTickFreq_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
#define HAL_GetTickFreq_StopIgnore() HAL_GetTickFreq_CMockStopIgnore()
void HAL_GetTickFreq_CMockStopIgnore(void);
#define HAL_GetTickFreq_Expect() TEST_FAIL_MESSAGE("HAL_GetTickFreq requires _ExpectAndReturn");
#define HAL_GetTickFreq_ExpectAndReturn(cmock_retval) HAL_GetTickFreq_CMockExpectAndReturn(__LINE__, cmock_retval)
void HAL_GetTickFreq_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
typedef uint32_t (* CMOCK_HAL_GetTickFreq_CALLBACK)(int cmock_num_calls);
void HAL_GetTickFreq_AddCallback(CMOCK_HAL_GetTickFreq_CALLBACK Callback);
void HAL_GetTickFreq_Stub(CMOCK_HAL_GetTickFreq_CALLBACK Callback);
#define HAL_GetTickFreq_StubWithCallback HAL_GetTickFreq_Stub
#define HAL_SuspendTick_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SuspendTick requires _Ignore (not AndReturn)");
#define HAL_SuspendTick_Ignore() HAL_SuspendTick_CMockIgnore()
void HAL_SuspendTick_CMockIgnore(void);
#define HAL_SuspendTick_StopIgnore() HAL_SuspendTick_CMockStopIgnore()
void HAL_SuspendTick_CMockStopIgnore(void);
#define HAL_SuspendTick_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SuspendTick requires _Expect (not AndReturn)");
#define HAL_SuspendTick_Expect() HAL_SuspendTick_CMockExpect(__LINE__)
void HAL_SuspendTick_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_SuspendTick_CALLBACK)(int cmock_num_calls);
void HAL_SuspendTick_AddCallback(CMOCK_HAL_SuspendTick_CALLBACK Callback);
void HAL_SuspendTick_Stub(CMOCK_HAL_SuspendTick_CALLBACK Callback);
#define HAL_SuspendTick_StubWithCallback HAL_SuspendTick_Stub
#define HAL_ResumeTick_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_ResumeTick requires _Ignore (not AndReturn)");
#define HAL_ResumeTick_Ignore() HAL_ResumeTick_CMockIgnore()
void HAL_ResumeTick_CMockIgnore(void);
#define HAL_ResumeTick_StopIgnore() HAL_ResumeTick_CMockStopIgnore()
void HAL_ResumeTick_CMockStopIgnore(void);
#define HAL_ResumeTick_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_ResumeTick requires _Expect (not AndReturn)");
#define HAL_ResumeTick_Expect() HAL_ResumeTick_CMockExpect(__LINE__)
void HAL_ResumeTick_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_ResumeTick_CALLBACK)(int cmock_num_calls);
void HAL_ResumeTick_AddCallback(CMOCK_HAL_ResumeTick_CALLBACK Callback);
void HAL_ResumeTick_Stub(CMOCK_HAL_ResumeTick_CALLBACK Callback);
#define HAL_ResumeTick_StubWithCallback HAL_ResumeTick_Stub
#define HAL_GetHalVersion_Ignore() TEST_FAIL_MESSAGE("HAL_GetHalVersion requires _IgnoreAndReturn");
#define HAL_GetHalVersion_IgnoreAndReturn(cmock_retval) HAL_GetHalVersion_CMockIgnoreAndReturn(__LINE__, cmock_retval)
void HAL_GetHalVersion_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
#define HAL_GetHalVersion_StopIgnore() HAL_GetHalVersion_CMockStopIgnore()
void HAL_GetHalVersion_CMockStopIgnore(void);
#define HAL_GetHalVersion_Expect() TEST_FAIL_MESSAGE("HAL_GetHalVersion requires _ExpectAndReturn");
#define HAL_GetHalVersion_ExpectAndReturn(cmock_retval) HAL_GetHalVersion_CMockExpectAndReturn(__LINE__, cmock_retval)
void HAL_GetHalVersion_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
typedef uint32_t (* CMOCK_HAL_GetHalVersion_CALLBACK)(int cmock_num_calls);
void HAL_GetHalVersion_AddCallback(CMOCK_HAL_GetHalVersion_CALLBACK Callback);
void HAL_GetHalVersion_Stub(CMOCK_HAL_GetHalVersion_CALLBACK Callback);
#define HAL_GetHalVersion_StubWithCallback HAL_GetHalVersion_Stub
#define HAL_GetREVID_Ignore() TEST_FAIL_MESSAGE("HAL_GetREVID requires _IgnoreAndReturn");
#define HAL_GetREVID_IgnoreAndReturn(cmock_retval) HAL_GetREVID_CMockIgnoreAndReturn(__LINE__, cmock_retval)
void HAL_GetREVID_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
#define HAL_GetREVID_StopIgnore() HAL_GetREVID_CMockStopIgnore()
void HAL_GetREVID_CMockStopIgnore(void);
#define HAL_GetREVID_Expect() TEST_FAIL_MESSAGE("HAL_GetREVID requires _ExpectAndReturn");
#define HAL_GetREVID_ExpectAndReturn(cmock_retval) HAL_GetREVID_CMockExpectAndReturn(__LINE__, cmock_retval)
void HAL_GetREVID_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
typedef uint32_t (* CMOCK_HAL_GetREVID_CALLBACK)(int cmock_num_calls);
void HAL_GetREVID_AddCallback(CMOCK_HAL_GetREVID_CALLBACK Callback);
void HAL_GetREVID_Stub(CMOCK_HAL_GetREVID_CALLBACK Callback);
#define HAL_GetREVID_StubWithCallback HAL_GetREVID_Stub
#define HAL_GetDEVID_Ignore() TEST_FAIL_MESSAGE("HAL_GetDEVID requires _IgnoreAndReturn");
#define HAL_GetDEVID_IgnoreAndReturn(cmock_retval) HAL_GetDEVID_CMockIgnoreAndReturn(__LINE__, cmock_retval)
void HAL_GetDEVID_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
#define HAL_GetDEVID_StopIgnore() HAL_GetDEVID_CMockStopIgnore()
void HAL_GetDEVID_CMockStopIgnore(void);
#define HAL_GetDEVID_Expect() TEST_FAIL_MESSAGE("HAL_GetDEVID requires _ExpectAndReturn");
#define HAL_GetDEVID_ExpectAndReturn(cmock_retval) HAL_GetDEVID_CMockExpectAndReturn(__LINE__, cmock_retval)
void HAL_GetDEVID_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
typedef uint32_t (* CMOCK_HAL_GetDEVID_CALLBACK)(int cmock_num_calls);
void HAL_GetDEVID_AddCallback(CMOCK_HAL_GetDEVID_CALLBACK Callback);
void HAL_GetDEVID_Stub(CMOCK_HAL_GetDEVID_CALLBACK Callback);
#define HAL_GetDEVID_StubWithCallback HAL_GetDEVID_Stub
#define HAL_GetUIDw0_Ignore() TEST_FAIL_MESSAGE("HAL_GetUIDw0 requires _IgnoreAndReturn");
#define HAL_GetUIDw0_IgnoreAndReturn(cmock_retval) HAL_GetUIDw0_CMockIgnoreAndReturn(__LINE__, cmock_retval)
void HAL_GetUIDw0_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
#define HAL_GetUIDw0_StopIgnore() HAL_GetUIDw0_CMockStopIgnore()
void HAL_GetUIDw0_CMockStopIgnore(void);
#define HAL_GetUIDw0_Expect() TEST_FAIL_MESSAGE("HAL_GetUIDw0 requires _ExpectAndReturn");
#define HAL_GetUIDw0_ExpectAndReturn(cmock_retval) HAL_GetUIDw0_CMockExpectAndReturn(__LINE__, cmock_retval)
void HAL_GetUIDw0_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
typedef uint32_t (* CMOCK_HAL_GetUIDw0_CALLBACK)(int cmock_num_calls);
void HAL_GetUIDw0_AddCallback(CMOCK_HAL_GetUIDw0_CALLBACK Callback);
void HAL_GetUIDw0_Stub(CMOCK_HAL_GetUIDw0_CALLBACK Callback);
#define HAL_GetUIDw0_StubWithCallback HAL_GetUIDw0_Stub
#define HAL_GetUIDw1_Ignore() TEST_FAIL_MESSAGE("HAL_GetUIDw1 requires _IgnoreAndReturn");
#define HAL_GetUIDw1_IgnoreAndReturn(cmock_retval) HAL_GetUIDw1_CMockIgnoreAndReturn(__LINE__, cmock_retval)
void HAL_GetUIDw1_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
#define HAL_GetUIDw1_StopIgnore() HAL_GetUIDw1_CMockStopIgnore()
void HAL_GetUIDw1_CMockStopIgnore(void);
#define HAL_GetUIDw1_Expect() TEST_FAIL_MESSAGE("HAL_GetUIDw1 requires _ExpectAndReturn");
#define HAL_GetUIDw1_ExpectAndReturn(cmock_retval) HAL_GetUIDw1_CMockExpectAndReturn(__LINE__, cmock_retval)
void HAL_GetUIDw1_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
typedef uint32_t (* CMOCK_HAL_GetUIDw1_CALLBACK)(int cmock_num_calls);
void HAL_GetUIDw1_AddCallback(CMOCK_HAL_GetUIDw1_CALLBACK Callback);
void HAL_GetUIDw1_Stub(CMOCK_HAL_GetUIDw1_CALLBACK Callback);
#define HAL_GetUIDw1_StubWithCallback HAL_GetUIDw1_Stub
#define HAL_GetUIDw2_Ignore() TEST_FAIL_MESSAGE("HAL_GetUIDw2 requires _IgnoreAndReturn");
#define HAL_GetUIDw2_IgnoreAndReturn(cmock_retval) HAL_GetUIDw2_CMockIgnoreAndReturn(__LINE__, cmock_retval)
void HAL_GetUIDw2_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
#define HAL_GetUIDw2_StopIgnore() HAL_GetUIDw2_CMockStopIgnore()
void HAL_GetUIDw2_CMockStopIgnore(void);
#define HAL_GetUIDw2_Expect() TEST_FAIL_MESSAGE("HAL_GetUIDw2 requires _ExpectAndReturn");
#define HAL_GetUIDw2_ExpectAndReturn(cmock_retval) HAL_GetUIDw2_CMockExpectAndReturn(__LINE__, cmock_retval)
void HAL_GetUIDw2_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
typedef uint32_t (* CMOCK_HAL_GetUIDw2_CALLBACK)(int cmock_num_calls);
void HAL_GetUIDw2_AddCallback(CMOCK_HAL_GetUIDw2_CALLBACK Callback);
void HAL_GetUIDw2_Stub(CMOCK_HAL_GetUIDw2_CALLBACK Callback);
#define HAL_GetUIDw2_StubWithCallback HAL_GetUIDw2_Stub
#define HAL_DBGMCU_EnableDBGSleepMode_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_DBGMCU_EnableDBGSleepMode requires _Ignore (not AndReturn)");
#define HAL_DBGMCU_EnableDBGSleepMode_Ignore() HAL_DBGMCU_EnableDBGSleepMode_CMockIgnore()
void HAL_DBGMCU_EnableDBGSleepMode_CMockIgnore(void);
#define HAL_DBGMCU_EnableDBGSleepMode_StopIgnore() HAL_DBGMCU_EnableDBGSleepMode_CMockStopIgnore()
void HAL_DBGMCU_EnableDBGSleepMode_CMockStopIgnore(void);
#define HAL_DBGMCU_EnableDBGSleepMode_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_DBGMCU_EnableDBGSleepMode requires _Expect (not AndReturn)");
#define HAL_DBGMCU_EnableDBGSleepMode_Expect() HAL_DBGMCU_EnableDBGSleepMode_CMockExpect(__LINE__)
void HAL_DBGMCU_EnableDBGSleepMode_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_DBGMCU_EnableDBGSleepMode_CALLBACK)(int cmock_num_calls);
void HAL_DBGMCU_EnableDBGSleepMode_AddCallback(CMOCK_HAL_DBGMCU_EnableDBGSleepMode_CALLBACK Callback);
void HAL_DBGMCU_EnableDBGSleepMode_Stub(CMOCK_HAL_DBGMCU_EnableDBGSleepMode_CALLBACK Callback);
#define HAL_DBGMCU_EnableDBGSleepMode_StubWithCallback HAL_DBGMCU_EnableDBGSleepMode_Stub
#define HAL_DBGMCU_DisableDBGSleepMode_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_DBGMCU_DisableDBGSleepMode requires _Ignore (not AndReturn)");
#define HAL_DBGMCU_DisableDBGSleepMode_Ignore() HAL_DBGMCU_DisableDBGSleepMode_CMockIgnore()
void HAL_DBGMCU_DisableDBGSleepMode_CMockIgnore(void);
#define HAL_DBGMCU_DisableDBGSleepMode_StopIgnore() HAL_DBGMCU_DisableDBGSleepMode_CMockStopIgnore()
void HAL_DBGMCU_DisableDBGSleepMode_CMockStopIgnore(void);
#define HAL_DBGMCU_DisableDBGSleepMode_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_DBGMCU_DisableDBGSleepMode requires _Expect (not AndReturn)");
#define HAL_DBGMCU_DisableDBGSleepMode_Expect() HAL_DBGMCU_DisableDBGSleepMode_CMockExpect(__LINE__)
void HAL_DBGMCU_DisableDBGSleepMode_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_DBGMCU_DisableDBGSleepMode_CALLBACK)(int cmock_num_calls);
void HAL_DBGMCU_DisableDBGSleepMode_AddCallback(CMOCK_HAL_DBGMCU_DisableDBGSleepMode_CALLBACK Callback);
void HAL_DBGMCU_DisableDBGSleepMode_Stub(CMOCK_HAL_DBGMCU_DisableDBGSleepMode_CALLBACK Callback);
#define HAL_DBGMCU_DisableDBGSleepMode_StubWithCallback HAL_DBGMCU_DisableDBGSleepMode_Stub
#define HAL_DBGMCU_EnableDBGStopMode_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_DBGMCU_EnableDBGStopMode requires _Ignore (not AndReturn)");
#define HAL_DBGMCU_EnableDBGStopMode_Ignore() HAL_DBGMCU_EnableDBGStopMode_CMockIgnore()
void HAL_DBGMCU_EnableDBGStopMode_CMockIgnore(void);
#define HAL_DBGMCU_EnableDBGStopMode_StopIgnore() HAL_DBGMCU_EnableDBGStopMode_CMockStopIgnore()
void HAL_DBGMCU_EnableDBGStopMode_CMockStopIgnore(void);
#define HAL_DBGMCU_EnableDBGStopMode_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_DBGMCU_EnableDBGStopMode requires _Expect (not AndReturn)");
#define HAL_DBGMCU_EnableDBGStopMode_Expect() HAL_DBGMCU_EnableDBGStopMode_CMockExpect(__LINE__)
void HAL_DBGMCU_EnableDBGStopMode_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_DBGMCU_EnableDBGStopMode_CALLBACK)(int cmock_num_calls);
void HAL_DBGMCU_EnableDBGStopMode_AddCallback(CMOCK_HAL_DBGMCU_EnableDBGStopMode_CALLBACK Callback);
void HAL_DBGMCU_EnableDBGStopMode_Stub(CMOCK_HAL_DBGMCU_EnableDBGStopMode_CALLBACK Callback);
#define HAL_DBGMCU_EnableDBGStopMode_StubWithCallback HAL_DBGMCU_EnableDBGStopMode_Stub
#define HAL_DBGMCU_DisableDBGStopMode_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_DBGMCU_DisableDBGStopMode requires _Ignore (not AndReturn)");
#define HAL_DBGMCU_DisableDBGStopMode_Ignore() HAL_DBGMCU_DisableDBGStopMode_CMockIgnore()
void HAL_DBGMCU_DisableDBGStopMode_CMockIgnore(void);
#define HAL_DBGMCU_DisableDBGStopMode_StopIgnore() HAL_DBGMCU_DisableDBGStopMode_CMockStopIgnore()
void HAL_DBGMCU_DisableDBGStopMode_CMockStopIgnore(void);
#define HAL_DBGMCU_DisableDBGStopMode_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_DBGMCU_DisableDBGStopMode requires _Expect (not AndReturn)");
#define HAL_DBGMCU_DisableDBGStopMode_Expect() HAL_DBGMCU_DisableDBGStopMode_CMockExpect(__LINE__)
void HAL_DBGMCU_DisableDBGStopMode_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_DBGMCU_DisableDBGStopMode_CALLBACK)(int cmock_num_calls);
void HAL_DBGMCU_DisableDBGStopMode_AddCallback(CMOCK_HAL_DBGMCU_DisableDBGStopMode_CALLBACK Callback);
void HAL_DBGMCU_DisableDBGStopMode_Stub(CMOCK_HAL_DBGMCU_DisableDBGStopMode_CALLBACK Callback);
#define HAL_DBGMCU_DisableDBGStopMode_StubWithCallback HAL_DBGMCU_DisableDBGStopMode_Stub
#define HAL_DBGMCU_EnableDBGStandbyMode_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_DBGMCU_EnableDBGStandbyMode requires _Ignore (not AndReturn)");
#define HAL_DBGMCU_EnableDBGStandbyMode_Ignore() HAL_DBGMCU_EnableDBGStandbyMode_CMockIgnore()
void HAL_DBGMCU_EnableDBGStandbyMode_CMockIgnore(void);
#define HAL_DBGMCU_EnableDBGStandbyMode_StopIgnore() HAL_DBGMCU_EnableDBGStandbyMode_CMockStopIgnore()
void HAL_DBGMCU_EnableDBGStandbyMode_CMockStopIgnore(void);
#define HAL_DBGMCU_EnableDBGStandbyMode_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_DBGMCU_EnableDBGStandbyMode requires _Expect (not AndReturn)");
#define HAL_DBGMCU_EnableDBGStandbyMode_Expect() HAL_DBGMCU_EnableDBGStandbyMode_CMockExpect(__LINE__)
void HAL_DBGMCU_EnableDBGStandbyMode_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_DBGMCU_EnableDBGStandbyMode_CALLBACK)(int cmock_num_calls);
void HAL_DBGMCU_EnableDBGStandbyMode_AddCallback(CMOCK_HAL_DBGMCU_EnableDBGStandbyMode_CALLBACK Callback);
void HAL_DBGMCU_EnableDBGStandbyMode_Stub(CMOCK_HAL_DBGMCU_EnableDBGStandbyMode_CALLBACK Callback);
#define HAL_DBGMCU_EnableDBGStandbyMode_StubWithCallback HAL_DBGMCU_EnableDBGStandbyMode_Stub
#define HAL_DBGMCU_DisableDBGStandbyMode_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_DBGMCU_DisableDBGStandbyMode requires _Ignore (not AndReturn)");
#define HAL_DBGMCU_DisableDBGStandbyMode_Ignore() HAL_DBGMCU_DisableDBGStandbyMode_CMockIgnore()
void HAL_DBGMCU_DisableDBGStandbyMode_CMockIgnore(void);
#define HAL_DBGMCU_DisableDBGStandbyMode_StopIgnore() HAL_DBGMCU_DisableDBGStandbyMode_CMockStopIgnore()
void HAL_DBGMCU_DisableDBGStandbyMode_CMockStopIgnore(void);
#define HAL_DBGMCU_DisableDBGStandbyMode_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_DBGMCU_DisableDBGStandbyMode requires _Expect (not AndReturn)");
#define HAL_DBGMCU_DisableDBGStandbyMode_Expect() HAL_DBGMCU_DisableDBGStandbyMode_CMockExpect(__LINE__)
void HAL_DBGMCU_DisableDBGStandbyMode_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_DBGMCU_DisableDBGStandbyMode_CALLBACK)(int cmock_num_calls);
void HAL_DBGMCU_DisableDBGStandbyMode_AddCallback(CMOCK_HAL_DBGMCU_DisableDBGStandbyMode_CALLBACK Callback);
void HAL_DBGMCU_DisableDBGStandbyMode_Stub(CMOCK_HAL_DBGMCU_DisableDBGStandbyMode_CALLBACK Callback);
#define HAL_DBGMCU_DisableDBGStandbyMode_StubWithCallback HAL_DBGMCU_DisableDBGStandbyMode_Stub
#define HAL_SYSCFG_CCMSRAMErase_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_CCMSRAMErase requires _Ignore (not AndReturn)");
#define HAL_SYSCFG_CCMSRAMErase_Ignore() HAL_SYSCFG_CCMSRAMErase_CMockIgnore()
void HAL_SYSCFG_CCMSRAMErase_CMockIgnore(void);
#define HAL_SYSCFG_CCMSRAMErase_StopIgnore() HAL_SYSCFG_CCMSRAMErase_CMockStopIgnore()
void HAL_SYSCFG_CCMSRAMErase_CMockStopIgnore(void);
#define HAL_SYSCFG_CCMSRAMErase_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_CCMSRAMErase requires _Expect (not AndReturn)");
#define HAL_SYSCFG_CCMSRAMErase_Expect() HAL_SYSCFG_CCMSRAMErase_CMockExpect(__LINE__)
void HAL_SYSCFG_CCMSRAMErase_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_SYSCFG_CCMSRAMErase_CALLBACK)(int cmock_num_calls);
void HAL_SYSCFG_CCMSRAMErase_AddCallback(CMOCK_HAL_SYSCFG_CCMSRAMErase_CALLBACK Callback);
void HAL_SYSCFG_CCMSRAMErase_Stub(CMOCK_HAL_SYSCFG_CCMSRAMErase_CALLBACK Callback);
#define HAL_SYSCFG_CCMSRAMErase_StubWithCallback HAL_SYSCFG_CCMSRAMErase_Stub
#define HAL_SYSCFG_EnableMemorySwappingBank_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_EnableMemorySwappingBank requires _Ignore (not AndReturn)");
#define HAL_SYSCFG_EnableMemorySwappingBank_Ignore() HAL_SYSCFG_EnableMemorySwappingBank_CMockIgnore()
void HAL_SYSCFG_EnableMemorySwappingBank_CMockIgnore(void);
#define HAL_SYSCFG_EnableMemorySwappingBank_StopIgnore() HAL_SYSCFG_EnableMemorySwappingBank_CMockStopIgnore()
void HAL_SYSCFG_EnableMemorySwappingBank_CMockStopIgnore(void);
#define HAL_SYSCFG_EnableMemorySwappingBank_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_EnableMemorySwappingBank requires _Expect (not AndReturn)");
#define HAL_SYSCFG_EnableMemorySwappingBank_Expect() HAL_SYSCFG_EnableMemorySwappingBank_CMockExpect(__LINE__)
void HAL_SYSCFG_EnableMemorySwappingBank_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_SYSCFG_EnableMemorySwappingBank_CALLBACK)(int cmock_num_calls);
void HAL_SYSCFG_EnableMemorySwappingBank_AddCallback(CMOCK_HAL_SYSCFG_EnableMemorySwappingBank_CALLBACK Callback);
void HAL_SYSCFG_EnableMemorySwappingBank_Stub(CMOCK_HAL_SYSCFG_EnableMemorySwappingBank_CALLBACK Callback);
#define HAL_SYSCFG_EnableMemorySwappingBank_StubWithCallback HAL_SYSCFG_EnableMemorySwappingBank_Stub
#define HAL_SYSCFG_DisableMemorySwappingBank_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_DisableMemorySwappingBank requires _Ignore (not AndReturn)");
#define HAL_SYSCFG_DisableMemorySwappingBank_Ignore() HAL_SYSCFG_DisableMemorySwappingBank_CMockIgnore()
void HAL_SYSCFG_DisableMemorySwappingBank_CMockIgnore(void);
#define HAL_SYSCFG_DisableMemorySwappingBank_StopIgnore() HAL_SYSCFG_DisableMemorySwappingBank_CMockStopIgnore()
void HAL_SYSCFG_DisableMemorySwappingBank_CMockStopIgnore(void);
#define HAL_SYSCFG_DisableMemorySwappingBank_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_DisableMemorySwappingBank requires _Expect (not AndReturn)");
#define HAL_SYSCFG_DisableMemorySwappingBank_Expect() HAL_SYSCFG_DisableMemorySwappingBank_CMockExpect(__LINE__)
void HAL_SYSCFG_DisableMemorySwappingBank_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_SYSCFG_DisableMemorySwappingBank_CALLBACK)(int cmock_num_calls);
void HAL_SYSCFG_DisableMemorySwappingBank_AddCallback(CMOCK_HAL_SYSCFG_DisableMemorySwappingBank_CALLBACK Callback);
void HAL_SYSCFG_DisableMemorySwappingBank_Stub(CMOCK_HAL_SYSCFG_DisableMemorySwappingBank_CALLBACK Callback);
#define HAL_SYSCFG_DisableMemorySwappingBank_StubWithCallback HAL_SYSCFG_DisableMemorySwappingBank_Stub
#define HAL_SYSCFG_VREFBUF_VoltageScalingConfig_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_VREFBUF_VoltageScalingConfig requires _Ignore (not AndReturn)");
#define HAL_SYSCFG_VREFBUF_VoltageScalingConfig_Ignore() HAL_SYSCFG_VREFBUF_VoltageScalingConfig_CMockIgnore()
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig_CMockIgnore(void);
#define HAL_SYSCFG_VREFBUF_VoltageScalingConfig_StopIgnore() HAL_SYSCFG_VREFBUF_VoltageScalingConfig_CMockStopIgnore()
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig_CMockStopIgnore(void);
#define HAL_SYSCFG_VREFBUF_VoltageScalingConfig_ExpectAndReturn(VoltageScaling,cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_VREFBUF_VoltageScalingConfig requires _Expect (not AndReturn)");
#define HAL_SYSCFG_VREFBUF_VoltageScalingConfig_Expect(VoltageScaling) HAL_SYSCFG_VREFBUF_VoltageScalingConfig_CMockExpect(__LINE__, VoltageScaling)
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t VoltageScaling);
typedef void (* CMOCK_HAL_SYSCFG_VREFBUF_VoltageScalingConfig_CALLBACK)(uint32_t VoltageScaling, int cmock_num_calls);
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig_AddCallback(CMOCK_HAL_SYSCFG_VREFBUF_VoltageScalingConfig_CALLBACK Callback);
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig_Stub(CMOCK_HAL_SYSCFG_VREFBUF_VoltageScalingConfig_CALLBACK Callback);
#define HAL_SYSCFG_VREFBUF_VoltageScalingConfig_StubWithCallback HAL_SYSCFG_VREFBUF_VoltageScalingConfig_Stub
#define HAL_SYSCFG_VREFBUF_HighImpedanceConfig_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_VREFBUF_HighImpedanceConfig requires _Ignore (not AndReturn)");
#define HAL_SYSCFG_VREFBUF_HighImpedanceConfig_Ignore() HAL_SYSCFG_VREFBUF_HighImpedanceConfig_CMockIgnore()
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig_CMockIgnore(void);
#define HAL_SYSCFG_VREFBUF_HighImpedanceConfig_StopIgnore() HAL_SYSCFG_VREFBUF_HighImpedanceConfig_CMockStopIgnore()
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig_CMockStopIgnore(void);
#define HAL_SYSCFG_VREFBUF_HighImpedanceConfig_ExpectAndReturn(Mode,cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_VREFBUF_HighImpedanceConfig requires _Expect (not AndReturn)");
#define HAL_SYSCFG_VREFBUF_HighImpedanceConfig_Expect(Mode) HAL_SYSCFG_VREFBUF_HighImpedanceConfig_CMockExpect(__LINE__, Mode)
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t Mode);
typedef void (* CMOCK_HAL_SYSCFG_VREFBUF_HighImpedanceConfig_CALLBACK)(uint32_t Mode, int cmock_num_calls);
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig_AddCallback(CMOCK_HAL_SYSCFG_VREFBUF_HighImpedanceConfig_CALLBACK Callback);
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig_Stub(CMOCK_HAL_SYSCFG_VREFBUF_HighImpedanceConfig_CALLBACK Callback);
#define HAL_SYSCFG_VREFBUF_HighImpedanceConfig_StubWithCallback HAL_SYSCFG_VREFBUF_HighImpedanceConfig_Stub
#define HAL_SYSCFG_VREFBUF_TrimmingConfig_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_VREFBUF_TrimmingConfig requires _Ignore (not AndReturn)");
#define HAL_SYSCFG_VREFBUF_TrimmingConfig_Ignore() HAL_SYSCFG_VREFBUF_TrimmingConfig_CMockIgnore()
void HAL_SYSCFG_VREFBUF_TrimmingConfig_CMockIgnore(void);
#define HAL_SYSCFG_VREFBUF_TrimmingConfig_StopIgnore() HAL_SYSCFG_VREFBUF_TrimmingConfig_CMockStopIgnore()
void HAL_SYSCFG_VREFBUF_TrimmingConfig_CMockStopIgnore(void);
#define HAL_SYSCFG_VREFBUF_TrimmingConfig_ExpectAndReturn(TrimmingValue,cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_VREFBUF_TrimmingConfig requires _Expect (not AndReturn)");
#define HAL_SYSCFG_VREFBUF_TrimmingConfig_Expect(TrimmingValue) HAL_SYSCFG_VREFBUF_TrimmingConfig_CMockExpect(__LINE__, TrimmingValue)
void HAL_SYSCFG_VREFBUF_TrimmingConfig_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t TrimmingValue);
typedef void (* CMOCK_HAL_SYSCFG_VREFBUF_TrimmingConfig_CALLBACK)(uint32_t TrimmingValue, int cmock_num_calls);
void HAL_SYSCFG_VREFBUF_TrimmingConfig_AddCallback(CMOCK_HAL_SYSCFG_VREFBUF_TrimmingConfig_CALLBACK Callback);
void HAL_SYSCFG_VREFBUF_TrimmingConfig_Stub(CMOCK_HAL_SYSCFG_VREFBUF_TrimmingConfig_CALLBACK Callback);
#define HAL_SYSCFG_VREFBUF_TrimmingConfig_StubWithCallback HAL_SYSCFG_VREFBUF_TrimmingConfig_Stub
#define HAL_SYSCFG_EnableVREFBUF_Ignore() TEST_FAIL_MESSAGE("HAL_SYSCFG_EnableVREFBUF requires _IgnoreAndReturn");
#define HAL_SYSCFG_EnableVREFBUF_IgnoreAndReturn(cmock_retval) HAL_SYSCFG_EnableVREFBUF_CMockIgnoreAndReturn(__LINE__, cmock_retval)
void HAL_SYSCFG_EnableVREFBUF_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, HAL_StatusTypeDef cmock_to_return);
#define HAL_SYSCFG_EnableVREFBUF_StopIgnore() HAL_SYSCFG_EnableVREFBUF_CMockStopIgnore()
void HAL_SYSCFG_EnableVREFBUF_CMockStopIgnore(void);
#define HAL_SYSCFG_EnableVREFBUF_Expect() TEST_FAIL_MESSAGE("HAL_SYSCFG_EnableVREFBUF requires _ExpectAndReturn");
#define HAL_SYSCFG_EnableVREFBUF_ExpectAndReturn(cmock_retval) HAL_SYSCFG_EnableVREFBUF_CMockExpectAndReturn(__LINE__, cmock_retval)
void HAL_SYSCFG_EnableVREFBUF_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, HAL_StatusTypeDef cmock_to_return);
typedef HAL_StatusTypeDef (* CMOCK_HAL_SYSCFG_EnableVREFBUF_CALLBACK)(int cmock_num_calls);
void HAL_SYSCFG_EnableVREFBUF_AddCallback(CMOCK_HAL_SYSCFG_EnableVREFBUF_CALLBACK Callback);
void HAL_SYSCFG_EnableVREFBUF_Stub(CMOCK_HAL_SYSCFG_EnableVREFBUF_CALLBACK Callback);
#define HAL_SYSCFG_EnableVREFBUF_StubWithCallback HAL_SYSCFG_EnableVREFBUF_Stub
#define HAL_SYSCFG_DisableVREFBUF_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_DisableVREFBUF requires _Ignore (not AndReturn)");
#define HAL_SYSCFG_DisableVREFBUF_Ignore() HAL_SYSCFG_DisableVREFBUF_CMockIgnore()
void HAL_SYSCFG_DisableVREFBUF_CMockIgnore(void);
#define HAL_SYSCFG_DisableVREFBUF_StopIgnore() HAL_SYSCFG_DisableVREFBUF_CMockStopIgnore()
void HAL_SYSCFG_DisableVREFBUF_CMockStopIgnore(void);
#define HAL_SYSCFG_DisableVREFBUF_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_DisableVREFBUF requires _Expect (not AndReturn)");
#define HAL_SYSCFG_DisableVREFBUF_Expect() HAL_SYSCFG_DisableVREFBUF_CMockExpect(__LINE__)
void HAL_SYSCFG_DisableVREFBUF_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_SYSCFG_DisableVREFBUF_CALLBACK)(int cmock_num_calls);
void HAL_SYSCFG_DisableVREFBUF_AddCallback(CMOCK_HAL_SYSCFG_DisableVREFBUF_CALLBACK Callback);
void HAL_SYSCFG_DisableVREFBUF_Stub(CMOCK_HAL_SYSCFG_DisableVREFBUF_CALLBACK Callback);
#define HAL_SYSCFG_DisableVREFBUF_StubWithCallback HAL_SYSCFG_DisableVREFBUF_Stub
#define HAL_SYSCFG_EnableIOSwitchBooster_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_EnableIOSwitchBooster requires _Ignore (not AndReturn)");
#define HAL_SYSCFG_EnableIOSwitchBooster_Ignore() HAL_SYSCFG_EnableIOSwitchBooster_CMockIgnore()
void HAL_SYSCFG_EnableIOSwitchBooster_CMockIgnore(void);
#define HAL_SYSCFG_EnableIOSwitchBooster_StopIgnore() HAL_SYSCFG_EnableIOSwitchBooster_CMockStopIgnore()
void HAL_SYSCFG_EnableIOSwitchBooster_CMockStopIgnore(void);
#define HAL_SYSCFG_EnableIOSwitchBooster_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_EnableIOSwitchBooster requires _Expect (not AndReturn)");
#define HAL_SYSCFG_EnableIOSwitchBooster_Expect() HAL_SYSCFG_EnableIOSwitchBooster_CMockExpect(__LINE__)
void HAL_SYSCFG_EnableIOSwitchBooster_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_SYSCFG_EnableIOSwitchBooster_CALLBACK)(int cmock_num_calls);
void HAL_SYSCFG_EnableIOSwitchBooster_AddCallback(CMOCK_HAL_SYSCFG_EnableIOSwitchBooster_CALLBACK Callback);
void HAL_SYSCFG_EnableIOSwitchBooster_Stub(CMOCK_HAL_SYSCFG_EnableIOSwitchBooster_CALLBACK Callback);
#define HAL_SYSCFG_EnableIOSwitchBooster_StubWithCallback HAL_SYSCFG_EnableIOSwitchBooster_Stub
#define HAL_SYSCFG_DisableIOSwitchBooster_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_DisableIOSwitchBooster requires _Ignore (not AndReturn)");
#define HAL_SYSCFG_DisableIOSwitchBooster_Ignore() HAL_SYSCFG_DisableIOSwitchBooster_CMockIgnore()
void HAL_SYSCFG_DisableIOSwitchBooster_CMockIgnore(void);
#define HAL_SYSCFG_DisableIOSwitchBooster_StopIgnore() HAL_SYSCFG_DisableIOSwitchBooster_CMockStopIgnore()
void HAL_SYSCFG_DisableIOSwitchBooster_CMockStopIgnore(void);
#define HAL_SYSCFG_DisableIOSwitchBooster_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_DisableIOSwitchBooster requires _Expect (not AndReturn)");
#define HAL_SYSCFG_DisableIOSwitchBooster_Expect() HAL_SYSCFG_DisableIOSwitchBooster_CMockExpect(__LINE__)
void HAL_SYSCFG_DisableIOSwitchBooster_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_SYSCFG_DisableIOSwitchBooster_CALLBACK)(int cmock_num_calls);
void HAL_SYSCFG_DisableIOSwitchBooster_AddCallback(CMOCK_HAL_SYSCFG_DisableIOSwitchBooster_CALLBACK Callback);
void HAL_SYSCFG_DisableIOSwitchBooster_Stub(CMOCK_HAL_SYSCFG_DisableIOSwitchBooster_CALLBACK Callback);
#define HAL_SYSCFG_DisableIOSwitchBooster_StubWithCallback HAL_SYSCFG_DisableIOSwitchBooster_Stub
#define HAL_SYSCFG_EnableIOSwitchVDD_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_EnableIOSwitchVDD requires _Ignore (not AndReturn)");
#define HAL_SYSCFG_EnableIOSwitchVDD_Ignore() HAL_SYSCFG_EnableIOSwitchVDD_CMockIgnore()
void HAL_SYSCFG_EnableIOSwitchVDD_CMockIgnore(void);
#define HAL_SYSCFG_EnableIOSwitchVDD_StopIgnore() HAL_SYSCFG_EnableIOSwitchVDD_CMockStopIgnore()
void HAL_SYSCFG_EnableIOSwitchVDD_CMockStopIgnore(void);
#define HAL_SYSCFG_EnableIOSwitchVDD_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_EnableIOSwitchVDD requires _Expect (not AndReturn)");
#define HAL_SYSCFG_EnableIOSwitchVDD_Expect() HAL_SYSCFG_EnableIOSwitchVDD_CMockExpect(__LINE__)
void HAL_SYSCFG_EnableIOSwitchVDD_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_SYSCFG_EnableIOSwitchVDD_CALLBACK)(int cmock_num_calls);
void HAL_SYSCFG_EnableIOSwitchVDD_AddCallback(CMOCK_HAL_SYSCFG_EnableIOSwitchVDD_CALLBACK Callback);
void HAL_SYSCFG_EnableIOSwitchVDD_Stub(CMOCK_HAL_SYSCFG_EnableIOSwitchVDD_CALLBACK Callback);
#define HAL_SYSCFG_EnableIOSwitchVDD_StubWithCallback HAL_SYSCFG_EnableIOSwitchVDD_Stub
#define HAL_SYSCFG_DisableIOSwitchVDD_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_DisableIOSwitchVDD requires _Ignore (not AndReturn)");
#define HAL_SYSCFG_DisableIOSwitchVDD_Ignore() HAL_SYSCFG_DisableIOSwitchVDD_CMockIgnore()
void HAL_SYSCFG_DisableIOSwitchVDD_CMockIgnore(void);
#define HAL_SYSCFG_DisableIOSwitchVDD_StopIgnore() HAL_SYSCFG_DisableIOSwitchVDD_CMockStopIgnore()
void HAL_SYSCFG_DisableIOSwitchVDD_CMockStopIgnore(void);
#define HAL_SYSCFG_DisableIOSwitchVDD_ExpectAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_DisableIOSwitchVDD requires _Expect (not AndReturn)");
#define HAL_SYSCFG_DisableIOSwitchVDD_Expect() HAL_SYSCFG_DisableIOSwitchVDD_CMockExpect(__LINE__)
void HAL_SYSCFG_DisableIOSwitchVDD_CMockExpect(UNITY_LINE_TYPE cmock_line);
typedef void (* CMOCK_HAL_SYSCFG_DisableIOSwitchVDD_CALLBACK)(int cmock_num_calls);
void HAL_SYSCFG_DisableIOSwitchVDD_AddCallback(CMOCK_HAL_SYSCFG_DisableIOSwitchVDD_CALLBACK Callback);
void HAL_SYSCFG_DisableIOSwitchVDD_Stub(CMOCK_HAL_SYSCFG_DisableIOSwitchVDD_CALLBACK Callback);
#define HAL_SYSCFG_DisableIOSwitchVDD_StubWithCallback HAL_SYSCFG_DisableIOSwitchVDD_Stub
#define HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_IgnoreAndReturn(cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_CCMSRAM_WriteProtectionEnable requires _Ignore (not AndReturn)");
#define HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_Ignore() HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_CMockIgnore()
void HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_CMockIgnore(void);
#define HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_StopIgnore() HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_CMockStopIgnore()
void HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_CMockStopIgnore(void);
#define HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_ExpectAndReturn(Page,cmock_retval) TEST_FAIL_MESSAGE("HAL_SYSCFG_CCMSRAM_WriteProtectionEnable requires _Expect (not AndReturn)");
#define HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_Expect(Page) HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_CMockExpect(__LINE__, Page)
void HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t Page);
typedef void (* CMOCK_HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_CALLBACK)(uint32_t Page, int cmock_num_calls);
void HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_AddCallback(CMOCK_HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_CALLBACK Callback);
void HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_Stub(CMOCK_HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_CALLBACK Callback);
#define HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_StubWithCallback HAL_SYSCFG_CCMSRAM_WriteProtectionEnable_Stub







#pragma GCC diagnostic pop



# 9 "test/test_diag.c" 2
# 1 "Core/Inc/diag.h" 1
/*
 * diag.h
 *
 *  Created on: Oct 16, 2025
 *      Author: ordum
 */


#define INC_DIAG_H_ 





# 1 "Core/Inc/types.h" 1
/*
 * types.h
 *
 *  Created on: Oct 16, 2025
 *      Author: ordum
 */


#define INC_TYPES_H_ 





typedef struct {
int32_t currentIn;
int32_t currentOut;
int32_t currentChoke;
int32_t voltageIn;
int32_t voltageOut;
} SensorValues_t;



# 16 "Core/Inc/diag.h" 2


void diagInit(void);
uint8_t diagCheck(const SensorValues_t* s, uint32_t* errorMask);


# 10 "test/test_diag.c" 2
# 1 "Core/Inc/config.h" 1
/*
 * config.h
 *
 *  Created on: Oct 16, 2025
 *      Author: ordum
 */

# 11 "test/test_diag.c" 2
# 1 "Core/Inc/converter.h" 1
/*
 * converter.h
 *
 *  Created on: Oct 16, 2025
 *      Author: ordum
 */


#define INC_CONVERTER_H_ 







void converterInit(void);
void converterProcess(SystemState_t state);
SystemState_t ConverterGetState(void);


# 12 "test/test_diag.c" 2
# 1 "Core/Inc/pwmHandler.h" 1
/*
 * pwmHandler.h
 *
 *  Created on: Oct 16, 2025
 *      Author: ordum
 */


#define INC_PWMHANDLER_H_ 








void pwmHandlerInit(void);
void pwmHandlerProcess(uint8_t hasError, SystemState_t state);



# 13 "test/test_diag.c" 2
# 1 "Core/Inc/pwm.h" 1
/*
 * pwm.h
 *
 *  Created on: Oct 16, 2025
 *      Author: ordum
 */


#define INC_PWM_H_ 




void pwmInit(void);
void pwmSetDuty(uint32_t duty);
uint32_t pwmGetArr(void);
void pwmDisable(void);
void pwmEnable(void);

# 14 "test/test_diag.c" 2
# 1 "Core/Inc/sensor.h" 1
/*
 * sensor.h
 *
 *  Created on: Oct 16, 2025
 *      Author: ordum
 */


#define INC_SENSOR_H_ 





void sensorInit(void);
void sensorRead(void);
const SensorValues_t* sensorGetValues(void);

# 15 "test/test_diag.c" 2

PIController_t pi;
PI2Controller_t pi2;
SensorValues_t sensor;


extern SensorValues_t unitTestSensorValues;
extern uint32_t unitTestErrorMask;
extern uint8_t unitTestHasError;


extern uint32_t globalErrorMask;
extern SystemState_t currentState;
extern PWMState_t currentPWMState;

extern uint32_t rawValues[5];
extern SensorValues_t currentValues;


//void HAL_Delay(uint32_t ms) {}
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState) {}
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);


//   precharge.c
extern uint8_t prechargeDone;

void setUp(void) {
}
void tearDown(void) { }



void test_diagCheck_NoErrors_ShouldReturnZero(void) {

    sensor.currentIn = 0;
    sensor.currentOut = 0;
    sensor.currentChoke = 0;
    sensor.voltageIn = 0;
    sensor.voltageOut = 0;
	uint32_t errorMask;
    uint8_t result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(0, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_NONE, errorMask);
}


void test_diagCheck_Errors_CurChoke (void)
{

    sensor.currentIn = 0;
    sensor.currentOut = 0;
    sensor.currentChoke = I_MAX+1;
    sensor.voltageIn = 0;
    sensor.voltageOut = 0;
	uint32_t errorMask;
    uint8_t result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_OVERCURRENT, errorMask);


    sensor.currentIn = 0;
    sensor.currentOut = 0;
    sensor.currentChoke = -I_MAX-1;
    sensor.voltageIn = 0;
    sensor.voltageOut = 0;
    result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_OVERCURRENT, errorMask);
}


void test_diagCheck_Errors_CurOut (void)
{

    sensor.currentIn = 0;
    sensor.currentOut = I_MAX+1;
    sensor.currentChoke = 0;
    sensor.voltageIn = 0;
    sensor.voltageOut = 0;
	uint32_t errorMask;
    uint8_t result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_OVERCURRENT, errorMask);

    sensor.currentIn = 0;
    sensor.currentOut = -I_MAX-1;
    sensor.currentChoke = 0;
    sensor.voltageIn = 0;
    sensor.voltageOut = 0;
    result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_OVERCURRENT, errorMask);
}


void test_diagCheck_Errors_Cur_In (void)
{

    sensor.currentIn = I_MAX+1;
    sensor.currentOut = 0;
    sensor.currentChoke = 0;
    sensor.voltageIn = 0;
    sensor.voltageOut = 0;
	uint32_t errorMask;
    uint8_t result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_OVERCURRENT, errorMask);

    sensor.currentIn = -I_MAX-1;
    sensor.currentOut = 0;
    sensor.currentChoke = 0;
    sensor.voltageIn = 0;
    sensor.voltageOut = 0;
    result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_OVERCURRENT, errorMask);
}


void test_diagCheck_FirstErrors_ThenNoError (void)
{

    sensor.currentIn = I_MAX+1;
    sensor.currentOut = 0;
    sensor.currentChoke = 0;
    sensor.voltageIn = 0;
    sensor.voltageOut = 0;
	uint32_t errorMask;
    uint8_t result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_OVERCURRENT, errorMask);

    sensor.currentIn = 0;
    sensor.currentOut = 0;
    sensor.currentChoke = 0;
    sensor.voltageIn = 0;
    sensor.voltageOut = 0;
    result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(0, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_NONE, errorMask);
}

void test_diagCheck_FirstErrors_ThenNoError_ThenError (void)
{

    sensor.currentIn = I_MAX+1;
    sensor.currentOut = 0;
    sensor.currentChoke = 0;
    sensor.voltageIn = 0;
    sensor.voltageOut = 0;
	uint32_t errorMask;
    uint8_t result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_OVERCURRENT, errorMask);

    sensor.currentIn = 0;
    sensor.currentOut = 0;
    sensor.currentChoke = 0;
    sensor.voltageIn = 0;
    sensor.voltageOut = 0;
    result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(0, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_NONE, errorMask);

    sensor.currentIn = 0;
    sensor.currentOut = 0;
    sensor.currentChoke = I_MAX+1;
    sensor.voltageIn = 0;
    sensor.voltageOut = 0;
    result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_OVERCURRENT, errorMask);
}

void test_diagCheck_Errors_VolIn (void)
{

    sensor.currentIn = 0;
    sensor.currentOut = 0;
    sensor.currentChoke = 0;
    sensor.voltageIn = VBUS_MAX+1;
    sensor.voltageOut = 0;
	uint32_t errorMask;
    uint8_t result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_OVERVOLTAGE, errorMask);

    sensor.currentIn = 0;
    sensor.currentOut = 0;
    sensor.currentChoke = 0;
    sensor.voltageIn = VBUS_MIN-1;
    sensor.voltageOut = 0;
    result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_UNDERVOLTAGE, errorMask);
}


void test_diagCheck_Errors_VolOut (void)
{
    sensor.currentIn = 0;
    sensor.currentOut = 0;
    sensor.currentChoke = 0;
    sensor.voltageIn = 0;
    sensor.voltageOut = VBUS_MAX+1;
	uint32_t errorMask;
    uint8_t result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_OVERVOLTAGE, errorMask);

    sensor.currentIn = 0;
    sensor.currentOut = 0;
    sensor.currentChoke = 0;
    sensor.voltageIn = 0;
    sensor.voltageOut = VBUS_MIN-1;
    result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_UNDERVOLTAGE, errorMask);
}

void test_diagCheck_Errors_VolAndCur (void)
{
    sensor.currentIn = 0;
    sensor.currentOut = 0;
    sensor.currentChoke = I_MAX+1;
    sensor.voltageIn = 0;
    sensor.voltageOut = VBUS_MAX+1;
	uint32_t errorMask;
    uint8_t result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_OVERVOLTAGE | ERR_OVERCURRENT, errorMask);

    sensor.currentIn = -I_MAX-1;
    sensor.currentOut = 0;
    sensor.currentChoke = 0;
    sensor.voltageIn = 0;
    sensor.voltageOut = VBUS_MIN-1;
    result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_UNDERVOLTAGE | ERR_OVERCURRENT, errorMask);
}

void test_diagCheck_Errors_All (void)
{
    sensor.currentIn = -I_MAX-1;
    sensor.currentOut = I_MAX+1;
    sensor.currentChoke = I_MAX+1;
    sensor.voltageIn = VBUS_MIN-1;
    sensor.voltageOut = VBUS_MAX+1;
	uint32_t errorMask;
    uint8_t result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_OVERVOLTAGE | ERR_OVERCURRENT | ERR_UNDERVOLTAGE, errorMask);

    sensor.currentIn = -I_MAX-1;
    sensor.currentOut = -I_MAX-1;
    sensor.currentChoke = I_MAX+1;
    sensor.voltageIn = VBUS_MAX+1;
    sensor.voltageOut = VBUS_MIN-1;
    result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(1, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_OVERVOLTAGE | ERR_OVERCURRENT | ERR_UNDERVOLTAGE, errorMask);

    sensor.currentIn = 0;
    sensor.currentOut = 0;
    sensor.currentChoke = 0;
    sensor.voltageIn = 0;
    sensor.voltageOut = 0;
    result = diagCheck(&sensor, &errorMask);

    TEST_ASSERT_EQUAL_UINT8(0, result);
    TEST_ASSERT_EQUAL_UINT32(ERR_NONE, errorMask);
}

